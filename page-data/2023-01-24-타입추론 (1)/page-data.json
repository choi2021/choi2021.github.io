{"componentChunkName":"component---src-templates-post-jsx","path":"/2023-01-24-타입추론 (1)/","result":{"data":{"site":{"siteMetadata":{"title":"Troy DevLog"}},"markdownRemark":{"id":"c3a5ecab-ca1d-5597-a321-d4b866d72a4c","excerpt":"🙋‍♂️ 타입추론 타입추론은 타입스크립트가 우리가 작성한 코드에 대해서 자동으로 타입을 추론해주는 것을 의미한다. 위 person 예제를 보면서 타입 추론이 정확하게 작동하고 있는 것을 볼 수 있다. 타입 추론을 이용했을 때 더 정확하게 타입이 정해지거나, 굳이 명시적으로 타입을 정할 필요가 없을 때에는 타입 구문을 생략하는 게 가독성을 높여준다. 위 예제에서…","html":"<h1>🙋‍♂️ 타입추론</h1>\n<p>타입추론은 타입스크립트가 우리가 작성한 코드에 대해서 자동으로 타입을 추론해주는 것을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'so'</span><span class=\"token punctuation\">,</span>\n  born<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    where<span class=\"token operator\">:</span> <span class=\"token string\">'asd'</span><span class=\"token punctuation\">,</span>\n    when<span class=\"token operator\">:</span> <span class=\"token string\">'1233'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  died<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    where<span class=\"token operator\">:</span> <span class=\"token string\">'asi'</span><span class=\"token punctuation\">,</span>\n    when<span class=\"token operator\">:</span> <span class=\"token string\">'nov,201'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 타입스크립트로 추론된 타입 </span>\n<span class=\"token keyword\">const</span> person<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    born<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        where<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n        when<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    died<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        where<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n        when<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 person 예제를 보면서 타입 추론이 정확하게 작동하고 있는 것을 볼 수 있다. 타입 추론을 이용했을 때 더 정확하게 타입이 정해지거나, 굳이 명시적으로 타입을 정할 필요가 없을 때에는 타입 구문을 생략하는 게 가독성을 높여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Product</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  price<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 명시적으로 타입을 다 정한 경우</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">logProduct</span><span class=\"token punctuation\">(</span>product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> product<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> product<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> price<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">logProduct</span><span class=\"token punctuation\">(</span>product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> price <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> product<span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 예제에서 <code class=\"language-text\">Product</code> interface에서 타입을 이미 정의했기 때문에 굳이 함수 내부에서 정의할 필요가 없었다.</p>\n<p>그러면 항상 타입 추론에 맡기면 되는 걸까?</p>\n<p>앞서 정리했던 타입시스템을 통해 배웠던 <strong>객체 리터럴</strong>과 <strong>함수의 인자와 반환값</strong>은 명시적으로 타입을 정의해 줄 필요가 있다.</p>\n<p>먼저 객체 리터럴의 경우 명시적으로 타입을 정의하면 <code class=\"language-text\">잉여 속성 체크</code>가 동작해 작성된 타입과 비교해 오타나 오류를 잡는데 도움을 줄 수 있다.</p>\n<p>함수의 경우 반환 값을 통해 오류를 막을 수 있다. 다음 예제를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> cache<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>ticker<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getQuote</span><span class=\"token punctuation\">(</span>ticker<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ticker <span class=\"token keyword\">in</span> cache<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>ticker<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Promise&lt;number>가 아니라 에러</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://quotes.example.com/?q=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>ticker<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>quote<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      cache<span class=\"token punctuation\">[</span>ticker<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> quote<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> quote<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 이미 존재하는 값의 경우 cache 데이터를 가져오고 cache된 값이 없다면 새로 요청하는 함수다. 하지만 cache값이 없을 때 <code class=\"language-text\">number</code>로 반환되기 때문에 에러를 던져주는 것을 볼 수 있다.</p>\n<p>이처럼 반환 타입을 명시함으로써 코드 자체적으로 인자를 넣었을 때 결과 값을 예측해 문서로써 역할을 할 수 있으며,  기존의 명명된 타입을 그대로 이용할 수 있는 장점도 가진다. 아래 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vector2D</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Vector2D<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Vector2D<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> a<span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span> b<span class=\"token punctuation\">.</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {x:number y:number}</span>\n<span class=\"token punctuation\">}</span> \n\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Vector2D<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> Vector2D<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Vector2D <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> a<span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span> b<span class=\"token punctuation\">.</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>반환값 타입도 동일하게 <code class=\"language-text\">Vector 2D</code>를 예상했지만 다른 타입으로 반환 값이 추론되는 것을 볼 수 있다. </p>\n<p>정리해보면 명시적 타입이 필요한 경우는 객체리터럴을 선언해 잉여속성체크가 필요하거나, 함수의 인자와 반환값에 필요하며, 대부분의 경우 타입 추론에 맡겨도 된다고 한다.</p>\n<h2>📦 다른 타입에 다른 변수 쓰기</h2>\n<p>자바스크립트는 동적 타입 언어이기 때문에 같은 변수에 다른 타입을 할당할 수 있지만 타입스크립트에서는 할당할 수 없다. 이 경우에 다른 타입을 할당하기 위해서 유니온 타입으로 타입을 더 좁힐 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token string\">'12-34-56'</span><span class=\"token punctuation\">;</span>\nid<span class=\"token operator\">=</span><span class=\"token number\">123</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 이러한 경우에 오히려 string과 number의 공통 메소드만 제공해주는 등 사용하기 더 어려워진다. 차라리 <strong>별도로 변수를 나누는 것</strong>이 나은 방법이다. </p>\n<h2>🎈 타입 넓히기</h2>\n<p>타입스크립트가 타입을 추론할 때는 할당된 값을 통해 할당 가능한 값들의 집합을 유추한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vector3</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  z<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getComponent</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">:</span> Vector3<span class=\"token punctuation\">,</span> axis<span class=\"token operator\">:</span> <span class=\"token string\">'x'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'y'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> vector<span class=\"token punctuation\">[</span>axis<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">let</span> vec <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> z<span class=\"token operator\">:</span> <span class=\"token number\">30</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">getComponent</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Argument of type 'string' is not assignable to parameter of type '\"x\" | \"y\" | \"z\"'</span></code></pre></div>\n<p>위 예제에서 <code class=\"language-text\">let x= 'x'</code>로 선언되어 x변수에는 할당할 수 있는 타입을 고려해 string타입으로 추론했다. 그렇기 때문에 정확히 <code class=\"language-text\">\"x\" | \"y\" | \"z\"</code>가 필요한 <code class=\"language-text\">getComponent</code>함수의 인자로 전달 시 타입 에러가 발생했다.</p>\n<p>이러한 문제를 해결하기 위해서는 간단하게 <code class=\"language-text\">let</code>대신 <code class=\"language-text\">const</code>로 수정할 수 있다. <code class=\"language-text\">const</code>로 선언하면 <code class=\"language-text\">x</code>의 타입이 <code class=\"language-text\">'x'</code>가 되어 타입이 더 좁혀지기 때문에 앞서 발생한 에러를 막을 수 있다. </p>\n<p>하지만 <code class=\"language-text\">const</code>로 선언하는 방법은 객체와 배열에서는 여전히 문제가 된다. 배열의 경우의 <code class=\"language-text\">const x= [1,2,3]</code>라고 했을 때 <code class=\"language-text\">number[]</code>로 봐야할 지 <code class=\"language-text\">[number,number,number]</code>로 해야할 지 타입추론만으로는 어렵다.  </p>\n<p>이러한 문제점을 해결하기 위해서는 먼저 명시적 타입을 전달해 주는 방법이 있다. 정확히 내가 원하는 타입으로 정해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number[]</span>\n<span class=\"token keyword\">const</span> arr2<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>두 번째로는 <code class=\"language-text\">as const</code> 타입 단언을 통해 최대한 좁은 타입으로 추론하는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// readonly [1,2,3] </span></code></pre></div>\n<h2>🙏 타입 좁히기</h2>\n<h4>null 체크/ undefined 체크</h4>\n<p>타입 좁히기를 내가 가장 많이 썼던 경우는 <code class=\"language-text\">null</code> 체크 또는 <code class=\"language-text\">undefined</code> 체크였던 것 같다. 책에서도 대표적인 예시로 null 체크를 보여준다. </p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// HTMLElement | null</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>el<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unable to find #foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nel<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">\"Party Time\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">blink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 예제에서 <code class=\"language-text\">el</code>값이 null이 될 수 있기 때문에 조건문으로 분기 처리를 해준 것을 볼 수 있다. </p>\n<h4>instanceof와 내장 함수</h4>\n<p><code class=\"language-text\">instanceof</code>와 내장 함수를 이용해 타입을 좁힐 수 있다.  <code class=\"language-text\">instanceof</code>를 이용 시에 중요했던 점은 런타임 연산자로 prototype chain에 해당 타겟이 있는지 확인하고 값을 확인하는 것을 이해하고 사용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> search<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> RegExp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>search <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    search<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>search<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> terms<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> termList <span class=\"token operator\">=</span> <span class=\"token builtin\">Array</span><span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>terms<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> terms <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>terms<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  termList\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>속성체크와 discriminated Union Type</h4>\n<p>또 다른 타입을 좁히는 방법으로 객체 타입의 경우 속성 체크를 이용해 좁힐 수 있고, 공통의 속성의 다른 값을 가지게 하는 <code class=\"language-text\">discriminated union</code> 구별된 유니온 타입을 이용할 수 있다. 실제 사용 경험은 속성 체크와 discriminated Union Type은 union Type으로 전달한 props를 분기 처리하기 위해 많이 사용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token punctuation\">{</span>\n  b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">pickAB</span><span class=\"token punctuation\">(</span>ab<span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token operator\">|</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span> <span class=\"token keyword\">in</span> ab<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ab<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    ab<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  ab<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">UploadEvent</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'upload'</span><span class=\"token punctuation\">;</span>\n  filename<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  contents<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">DownloadEvent</span> <span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'download'</span><span class=\"token punctuation\">;</span>\n  filename<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AppEvent</span> <span class=\"token operator\">=</span> UploadEvent <span class=\"token operator\">|</span> DownloadEvent<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">handleEvent</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> AppEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'download'</span><span class=\"token operator\">:</span>\n      e<span class=\"token punctuation\">;</span> <span class=\"token comment\">// DownloadEvent</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'upload'</span><span class=\"token operator\">:</span> \n      e<span class=\"token punctuation\">;</span> <span class=\"token comment\">// UploadEvent</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>사용자 정의 타입 가드</h4>\n<p>타입을 좁히기 위한 마지막 방법으로 함수를 이용해 내가 원하는 타입으로 좁혀줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isInputElement</span><span class=\"token punctuation\">(</span>el<span class=\"token operator\">:</span> HTMLElement<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> el <span class=\"token keyword\">is</span> HTMLInputElement <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'value'</span> <span class=\"token keyword\">in</span> el<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getElementContent</span><span class=\"token punctuation\">(</span>el<span class=\"token operator\">:</span> HTMLElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isInputElement</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    el<span class=\"token punctuation\">;</span> <span class=\"token comment\">// HTMLInputElement</span>\n    <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  el<span class=\"token punctuation\">;</span> <span class=\"token comment\">// HTMLElement</span>\n  <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>한꺼번에 객체 생성하기</h2>\n<p>객체를 생성할 때 주의할 점은 동적으로 속성을 추가하기 보다 필요한 속성들을 한번에 생성해야 타입추론의 이점을 이용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> pt <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\npt<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Property 'x' does not exist on type '{}'.</span>\npt<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Property 'y' does not exist on type '{}'.</span></code></pre></div>\n<p>위 예제에서는 처음 pt가 <code class=\"language-text\">{}</code>로 추론되기 때문에 에러가 발생했다. 이러한 원칙은 기존 객체 내용을 이용해 새로운 객체를 만들 때에도 동일하게 적용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> pt <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Pythagoras'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> namedPoint <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>namedPoint<span class=\"token punctuation\">,</span> pt<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnamedPoint<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Property 'name' does not exist on type '{}'.</span></code></pre></div>\n<p>위 예제는 <code class=\"language-text\">namedPoint</code>는 동일하게 <code class=\"language-text\">{}</code>를 기준으로 추론이 되어 <code class=\"language-text\">Object.assign()</code>메소드를 이용해서 속성을 추가해도 에러가 발생되었다. 이점을 해결하기 위해서는 <code class=\"language-text\">spread operator</code>를 이용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> namedPoint <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>pt<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// const namedPoint: {name: string; x: number; y: number;}</span>\nnamedPoint<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span></code></pre></div>\n<h2>정리하며</h2>\n<p>타입 추론은 엄청나게 편한 부분이지만, 더 정확하고 내가 원하는 타입으로 사용하기 위해서는 명시적으로 사용하거나 <code class=\"language-text\">as const</code>를 사용할 수 있다는 점을 알 수 있었다.  </p>","frontmatter":{"title":"TS study: 타입 추론(1)","date":"January 24, 2023","tags":["typescript"],"series":"Typescript"},"fields":{"slug":"/2023-01-24-타입추론 (1)/","readingTime":{"minutes":11.14}}},"seriesList":{"edges":[{"node":{"id":"450c65d9-1adb-5355-86a6-38e29edf10f5","fields":{"slug":"/2023-01-02-타입스크립트란/"},"frontmatter":{"title":"TS study: 타입스크립트란"}}},{"node":{"id":"30f66428-af72-5c78-bf83-6adedb7f226b","fields":{"slug":"/2023-01-07-타입시스템-1/"},"frontmatter":{"title":"TS study: 타입시스템 (1)"}}},{"node":{"id":"8a0f9e55-e3e4-5418-a3a4-72acabfe070a","fields":{"slug":"/2023-01-10-타입시스템-2/"},"frontmatter":{"title":"TS study: 타입 시스템 (2)"}}},{"node":{"id":"34de2078-05c8-5c18-ad6f-b50da3d61695","fields":{"slug":"/2023-01-16-타입시스템-3/"},"frontmatter":{"title":"TS study: 타입 시스템 (3)"}}},{"node":{"id":"c3a5ecab-ca1d-5597-a321-d4b866d72a4c","fields":{"slug":"/2023-01-24-타입추론 (1)/"},"frontmatter":{"title":"TS study: 타입 추론(1)"}}},{"node":{"id":"526d83da-deee-5851-bd4d-6ed71de266f8","fields":{"slug":"/2023-10-16-the_Basics/"},"frontmatter":{"title":"Typescript: The Basics"}}},{"node":{"id":"b8ceb0c1-25a0-51d0-ab4e-86977a6e3643","fields":{"slug":"/2023-10-18-Narrowing/"},"frontmatter":{"title":"Typescript: Narrowing"}}},{"node":{"id":"dcf311da-09d1-555a-8978-5c8cbd09f3e4","fields":{"slug":"/2023-10-17-Everyday-Types/"},"frontmatter":{"title":"Typescript: EveryDay Types"}}},{"node":{"id":"8fe67159-cfd9-54bf-b268-55dd2267c9b3","fields":{"slug":"/2023-10-23-MoreOnFunctions/"},"frontmatter":{"title":"Typescript: More On Functions"}}},{"node":{"id":"9655a307-90e6-5c82-b302-c3a78bf59193","fields":{"slug":"/2023-10-31-Object-Types/"},"frontmatter":{"title":"Typescript: Object Types"}}},{"node":{"id":"888c4fe2-471c-5bb5-9d97-5ae433bbe9c8","fields":{"slug":"/2023-11-07-Generics/"},"frontmatter":{"title":"Typescript: Generics"}}},{"node":{"id":"afbe0b5e-070e-5dd2-9c94-200338d5851d","fields":{"slug":"/2023-11-16-keyof,typeof, indexed Access Types/"},"frontmatter":{"title":"Typescript: Keyof, TypeOf, Indexed"}}},{"node":{"id":"dab6e2de-2654-5d7c-be1b-8f852db76d25","fields":{"slug":"/2023-12-19-conditional-types/"},"frontmatter":{"title":"Typescript: Conditional Types"}}}]},"previous":{"fields":{"slug":"/2022-12-20-리액트-성능보장/"},"frontmatter":{"title":"React study: 리액트가 성능을 보장하는 방법"}},"next":{"fields":{"slug":"/2023-02-03-useState,useEffect, useRef, memo/"},"frontmatter":{"title":"React Study: useState, useEffect, useRef, memo"}}},"pageContext":{"id":"c3a5ecab-ca1d-5597-a321-d4b866d72a4c","series":"Typescript","previousPostId":"2cd6faf4-d340-58ee-a4bc-c4b16bc21c42","nextPostId":"717eb8fb-45a2-5fef-aaa9-c5c5eceb792a"}},"staticQueryHashes":[],"slicesMap":{}}