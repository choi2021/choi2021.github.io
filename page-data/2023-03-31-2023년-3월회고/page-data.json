{"componentChunkName":"component---src-templates-post-jsx","path":"/2023-03-31-2023년-3월회고/","result":{"data":{"site":{"siteMetadata":{"title":"Troy DevLog"}},"markdownRemark":{"id":"543681af-5db3-518d-b19e-7668efdda7fc","excerpt":"회사에 입사하고 일한 지 한 달이 되었다. 입사일 기준으로 하면 한 달을 넘었지만 3월에 운 좋게 포상휴가를 받아서, 이참에 지금까지 일하면서 배울 수 있었던 부분들을 정리하면 좋겠다고 생각되었다. 회사의 코드에 적응하고, 스쿼드로 함께 일하는 법을 배우고, 챕터의 코드 리뷰를 주고 받으면서 하루 하루 배워나가는 게 너무 많았다. 취업을 준비하면서 단순히…","html":"<p>회사에 입사하고 일한 지 한 달이 되었다. 입사일 기준으로 하면 한 달을 넘었지만 3월에 운 좋게 포상휴가를 받아서, 이참에 지금까지 일하면서 배울 수 있었던 부분들을 정리하면 좋겠다고 생각되었다. 회사의 코드에 적응하고, 스쿼드로 함께 일하는 법을 배우고, 챕터의 코드 리뷰를 주고 받으면서 하루 하루 배워나가는 게 너무 많았다. 취업을 준비하면서 단순히 공부할 때는 보지 못했던 것과 중요하다 듣기만 했던 부분들에 대해 정리해보고 다음 한 달은 좀 더 개발자다울 수 있기를 바라며 회고를 써보려 한다.    </p>\n<h3>😂 Git, 너 좋은 녀석이었구나</h3>\n<p>혼자서 개인 프로젝트만 하다가 회사에 들어가 누군가와 함께  협업한다는 것은 생각보다 큰 두려움으로 다가왔다. 내가 작성한 코드나 내가 잘못해서 누군가의 작업을 망치지는 않을까라는 막연한 두려움이 있었다. 온보딩 기간 동안 여러 도움을 받고, 스쿼드 업무를 하면서 모바일 챕터의 브랜치 전략에 대해 이해하고 어떻게 작업하면 될지 조금씩 감을 잡아가고 있다.    </p>\n<h4>우리는 변형된 Git flow 전략</h4>\n<p>숨고 모바일 챕터에서 사용하는 협업 전략은 변형된 <code class=\"language-text\">Git flow</code>전략으로 기존의 git flow전략을 우리팀의 배포 전략에 맞게 변형해서 사용하고 있다. 이에 대한 내용은 우리팀 테크 리더인 Jimmy가 작성해주신 글을 참고해 정리해 보고자 한다.</p>\n<p>기존 <strong>Git flow</strong>전략의 경우 Production에 해당하는 <code class=\"language-text\">Main 또는 Master 브랜치</code>, 개발을 위한 <code class=\"language-text\">Develop 브랜치</code> 두 가지로 크게 나뉘는 전략이다. 두 가지 주요 브랜치에 하위 브랜치로  Develop 브랜치에서 여러 개발자가 함께 일하기 위해 각자가 맡은 기능 개발을 위한 <code class=\"language-text\">feature 브랜치</code>, Production에 내보내기 전 QA나 Test를 위한 <code class=\"language-text\">release 브랜치</code>, 배포한 후에 급한 버그를 수정하기 위한 <code class=\"language-text\">hotfix 브랜치</code> 하위 브랜치들이 있다.</p>\n<p>[기존 Git Flow 전략]</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=913\" alt=\"Git flow workflow - Feature Branches\"></p>\n<p>우리 모바일 팀은 스쿼드 별로 작업한 내용을 반영할 수 있게 하기 위해서 기존 Git flow 전략에서 develop 브랜치를 스쿼드 별 develop 브랜치로 <code class=\"language-text\">squad/스쿼드</code> 브랜치를 추가해 사용하고 있다. 각 스쿼드 별로 develop 브랜치를 구분함으로써 특정 스쿼드의 작업의 배포를 연기해야 하는 경우 해당 squad의 배포 내용만을 제외할 수 있는 장점을 갖게 되었다. </p>\n<p>이러한 배포 전략에 대해서는 어느정도 이해했지만 한주간 돌아가는 배포 사이클 전체에 대해서 이해하는 데에는 좀 더 오래걸렸다. 그이유는 과정마다 <code class=\"language-text\">테스트</code>가 중간 중간에 함께 들어있기 때문이었다. 숨고의 배포 사이클에는 내가 만든 feature에 대해서 테스트 빌드 버전을 통해 PO분과 디자이너 분께서 봐주시는 <code class=\"language-text\">스쿼드 내부 디자인 QA</code>, 배포에 나가기 위한 release 버전을 다양한 테스트 기기를 통해서 QA분께서 봐주시는 <code class=\"language-text\">통합 QA</code>과정이 있다. 이러한 QA를 통해 발견된 버그나 에러 등은 다시 해당 스텝의 브랜치에서 <code class=\"language-text\">bugfix</code>브랜치를 만들어 작업을 하게 된다.  </p>\n<p>앞서 설명한 변형된 Git flow 전략과 QA과정을 함께 정리해 다음과 같이 배포 사이클을 나타낼 수 있다.  Jimmy가 작성해주신 글의 그림을 참고해서 좀 더 간단하게 만들어 보았다. 그림에 설명을 스텝별로 덧붙여보면 다음과 같다.</p>\n<ol>\n<li>스쿼드 별 브랜치에 feature 브랜치을 만들어 작업하고 스쿼드 브랜치로 병합한다. 이때 챕터 내의 <strong>코드리뷰</strong>를 거친다.</li>\n<li>스쿼드 브랜치에서 목표 배포 날짜에 맞는 <code class=\"language-text\">release/스쿼드명/날짜 브랜치</code>를 만든다. </li>\n<li>만들어진 브랜치를 App center를 이용해 앱을 빌드하는데 이때 버전을 <code class=\"language-text\">Test 빌드</code>버전이라고 부르고 배포 일자의 전 주 수요일까지 이과정을 완료해야 배포에 포함될 수 있다.</li>\n<li>해당 앱 버전을 다운받아 PO와 디자이너 분들께서 디자인 QA를 진행한다. QA과정에서 수정할 부분이 발생하면 <code class=\"language-text\">release/스쿼드명/날짜 브랜치</code>에서 bugfix 브랜치를 만들어 다시 작업하고 병합한다.</li>\n<li>디자인 QA를 거치고 통합 QA를 위해 <code class=\"language-text\">release/날짜 브랜치</code>로 <code class=\"language-text\">release/스쿼드명/날짜 브랜치</code>를 병합한다.</li>\n<li><code class=\"language-text\">release/날짜</code>브랜치로 병합된 버전의 앱을 빌드하고, 이때 버전을 <code class=\"language-text\">Staging 빌드</code>버전이라 부른다. 배포 일자의 전 주 금요일까지 이 과정을 완료한다.</li>\n<li>병합 후에는 배포 주 월요일 화요일에는 통합 QA를 진행하는데 QA과정에서 수정할 부분이 발생하면 <code class=\"language-text\">release/날짜 브랜치</code>에서 bugfix 브랜치를 만들어 다시 작업한다. </li>\n<li>이과정이 완료되면 배포일자에 작업한 내용이 배포된다.</li>\n</ol>\n<p>[모바일 팀의 배포 사이클을 정리한 그림 ]</p>\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8ac8f594224be66496652b802e05ea48/aaf92/Main.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3VQmP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAT8hX//aAAwDAQACAAMAAAAQow//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAACAgMAAAAAAAAAAAAAAAABEQAxECFh/9oACAEBAAE/EGAwGeKWbQgS1Fn/2Q=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Main' title='' src='/static/8ac8f594224be66496652b802e05ea48/a22ce/Main.jpg' srcset='/static/8ac8f594224be66496652b802e05ea48/0b705/Main.jpg 170w,\n/static/8ac8f594224be66496652b802e05ea48/31389/Main.jpg 340w,\n/static/8ac8f594224be66496652b802e05ea48/a22ce/Main.jpg 680w,\n/static/8ac8f594224be66496652b802e05ea48/29373/Main.jpg 1020w,\n/static/8ac8f594224be66496652b802e05ea48/232dc/Main.jpg 1360w,\n/static/8ac8f594224be66496652b802e05ea48/aaf92/Main.jpg 1920w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n<p>부족한 그림과 설명이지만 내가 한달동안 이해한 배포 사이클을 정리해보았다. 여기에 비정기배포나 hotfix가 나가야하는 경우는 아직 겪어보지 않아 따로 정리하지 않았다.</p>\n<h4>Git에서는 폴더명을 함부로 바꾸면 안돼...</h4>\n<p>고수 회원가입 부분을 작업하는 과정에서 폴더명의 대소문자를 변경했다. 처음에는 아무 생각 없이 작업했지만 이부분 때문에 Git이 기존에 추적하고 있던 파일들의 경로명이 달라져 에러가 나기 시작했다. 이럴 때 해결방법으로 몇 가지를 찾아보았는데 가장 좋은 방법은 <strong>git 명령어</strong>를 이용해서 폴더명을 변경하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">mv</span> oldName newName</code></pre></div>\n<p>명령어를 이용하지 않고 그냥 폴더명만 변경해버리면 버전이 없는 파일로 기존 파일이 변경되면서 충돌이 발생했다. 단순히 대소문자가 변경되었기 때문에 git뿐 아니라 tsc에서도 에러가 발생하는 것을 볼 수 있었다. </p>\n<p>아무것도 몰랐던 나는 이미 엎질러지고 해결법을 찾아야했는데 그 방법으로는 먼저 시도했던 방법은 git의 설정을 변경하는 것이었다. git 자체는 대소문자를 구분하지 않기 때문에 git config의 설정에 구분할 수 있게 추가해줘야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> config core.ignorecase <span class=\"token boolean\">false</span></code></pre></div>\n<p>커밋을 정상적으로 했지만 여전히 에러가 발생했기 때문에 <strong>git의 캐싱된 파일들에서 기존 파일을 삭제하는 방법</strong>을 추가적으로 진행했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-r</span> <span class=\"token parameter variable\">--cached</span> filename</code></pre></div>\n<p>덕분에 git자체는 병합에러 없이 정상적으로 처리가 되었지만 이번에는 tsc에서 에러가 발생하기 시작했다.</p>\n<p>[당시 발생했던 tsc 에러]\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/33e74668772b33b1a2ce983316e7b2bf/23a6b/image-20230402155550414.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFUlEQVR42pWQyVLDMBBE/R8cIC5sYse7ZCvejSMvoaASlv//labtpIDKjcMr9UxJPT0yMlGiKXqoZkAgS4RpdWHR/8BPcgzHMwzbjRDJArLoEKUl4qyCUA0cX8ByIljuL/YV6wZ7F+PB8lC2AwzTCeHECpGq4UYZHOKJHLaX4N72sHnyV8xtgM2Vv3qt6XFnbqHqHkbARs40OY1Usv9hT9OSQwomLphchikUB0vek4FcdUqdXe8mnoA+zDBya4eJjc/nCadG470bqWec2xEf/Ywv/bL2Bz7UNFk40EizXnoNV14oHl3MrYYRc62OSU7TG440e10MqNeaQ0aa6apHw3+uaFDG2eVcknJVwe8Q3DLgyn3d4xtQHcJy2Vxt+AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='image 20230402155550414' title='' src='/static/33e74668772b33b1a2ce983316e7b2bf/ca1dc/image-20230402155550414.png' srcset='/static/33e74668772b33b1a2ce983316e7b2bf/e7570/image-20230402155550414.png 170w,\n/static/33e74668772b33b1a2ce983316e7b2bf/f46e7/image-20230402155550414.png 340w,\n/static/33e74668772b33b1a2ce983316e7b2bf/ca1dc/image-20230402155550414.png 680w,\n/static/33e74668772b33b1a2ce983316e7b2bf/02d09/image-20230402155550414.png 1020w,\n/static/33e74668772b33b1a2ce983316e7b2bf/9d567/image-20230402155550414.png 1360w,\n/static/33e74668772b33b1a2ce983316e7b2bf/23a6b/image-20230402155550414.png 1766w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>tsc 에러가 더 어려웠던 것은 나와 유사한 에러를 경험한 사람을 찾을 수가 없었기 때문이었다. 그나마 찾아낸 방법은 tsconfig.json에 옵션을 추가하는 방법이었는데 이렇게 해도 해결이 되지 않았다. </p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"forceConsistentCasingInFileNames\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>막막했지만 기존 파일의 경로로 tsc가 돌아가서 생기는 에러인 것 같아 코드내용이 동일한 임시파일을 만들어 경로를 돌려서 커밋했더니 다행히 tsc가 정상작동했다. </p>\n<p>이후에 Jessie가 감사하게 알려준 방법은 마지막에 시도했던 방법처럼 임시파일로 점진적으로 바꾼 후에 다시 변경하는 방법으로 하면 옵션을 추가하거나 하지 않아도 되었다. 다음에 이런 일이 일어났을 때 기억하고 좀 더 빨리 해결할 수 있기를... </p>\n<p>이외에도 여러 작업을 동시에 하기 위해서 현재 작업하던 내용을 저장하기 위해서 <code class=\"language-text\">stash</code>를 자주 사용하는 등의 혼자 작업할 때보다 훨씬 다양한 명령어와 상황에서 작업하고 있다. 앞으로 익숙해져서 두려워하고 어려워하기 보다는 정말 좋은 도구로써 사용할 수 있게 노력할 필요를 느꼈던 한달이었다.</p>\n<h3>😎 코드 리뷰와 지속적 통합</h3>\n<p>팀으로 일하면서 아마 가장 많이 배울 수 있었던 포인트들은 대부분 <strong>코드 리뷰</strong>를 통해서 얻을 수 있었다. 간단한 건 기존 컨벤션에 대해서 알려주시는 부분이나 컴포넌트의 default로 설정되어있어 전달하지 않아도 되는 props에 대해서 알려주시는 부분부터 어려운 부분은 어떤 게 더 좋은 방식일지 내가 고민하고 있는 방식의 trade-off에 대해 같이 고민해주셨다.</p>\n<h4>코드 컨벤션</h4>\n<p>이번에 배울 수 있었던 우리팀의 컨벤션에 대해 몇가지 정리해보면 다음과 같다.</p>\n<h5>이벤트 핸들러 함수 네이밍</h5>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 컨벤션 적용 전</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleArrowPress</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        navigation<span class=\"token punctuation\">.</span><span class=\"token function\">navigate</span><span class=\"token punctuation\">(</span>ScreenKeyEnum<span class=\"token punctuation\">.</span>Store<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">location</span><span class=\"token operator\">:</span> <span class=\"token string\">'pro_main'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 컨벤션 적용 후</span>\n\n <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handlePressArrow</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        navigation<span class=\"token punctuation\">.</span><span class=\"token function\">navigate</span><span class=\"token punctuation\">(</span>ScreenKeyEnum<span class=\"token punctuation\">.</span>Store<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">location</span><span class=\"token operator\">:</span> <span class=\"token string\">'pro_main'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이벤트 핸들러 함수를 네이밍 할 때  <strong>handle+동사+타겟</strong> 로 컨벤션으로 작성한다.</p>\n<h5>클래스 컴포넌트 내의 Render함수 방식 지양하기</h5>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token operator\">...</span> \n <span class=\"token function\">renderSignupWithSearch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactElement <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n              ...\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>코드중에 레거시로써 클래스 컴포넌트로 작성되어 있는 부분들이 있다. 클래스 컴포넌트는 <code class=\"language-text\">render()</code>메소드를 이용해서 렌더링할 부분을 작성하는데, 내부에서만 사용할 것 같아 <code class=\"language-text\">renderSignupWithSearch</code>라는 메소드로 만들었지만 이러한 방식을 <strong>render 함수</strong>방식으로 우리팀 내의 안티 패턴으로 지정했다. 컴포넌트로 분리해서 사용하는 것이 컨벤션이다. </p>\n<h4>고민했던 Screen간의 상태변화</h4>\n<p>이번 달에 혼자 스쿼드 업무를 담당하면서 가장 어려웠던 부분은 <code class=\"language-text\">스크린간의 상태변화</code>였다. A 스크린의 상태를 B 스크린에서 변화시키기 위해 set함수를 전달해야 했는데 우리가 사용하고 있는 <code class=\"language-text\">React Navigation</code>은 함수를 param으로 전달하는 것을 지양한다. 그 이유는 스크린 간에 param이 전달될 때 <strong>Serialize</strong>되기 때문인데 이로인해 참조관계가 깨져버릴 수 있어 이벤트를 이용하기를 추천한다. 이부분에 대해서는 챕터 위클리 미팅에서도 논의된 부분으로 고민했던 부분에 대해 공유했다. 논의에서 이야기 되었던 대안으로 <strong>Global Event bus</strong>와 <strong>전역상태</strong>에 대해 이야기했다.</p>\n<p>[React Navigation 공식 문서]</p>\n<p><img src=\"https://user-images.githubusercontent.com/80830981/227853570-6cd5ef75-44ed-42ae-bce9-d959d611ce74.png\" alt=\"image\"></p>\n<p><strong>Global event bus</strong>를 이용하면 param으로 전달하려 해 변경하려 했던 로직을 event로 등록하고 필요한 스크린에서 사용하는 event를 발생시킴으로써 스크린 간 상태 변경에 사용할 수 있었다. Global event bus의 단점으로는 <code class=\"language-text\">언제 event listener를 삭제해야하는 지에 대한 시점 문제</code>가 제기 되었고, 기존의 함수로 전달되던 모든 방식을 다 이벤트 버스로 바꾸는 것은 너무 많은 이벤트가 등록될 것 같다는 의견이 제시 되었다.</p>\n<p><strong>전역상태</strong>방식은 내가 제시한 방식으로 스크린 간의 상태를 변경이 필요하다면 사용하는 게 맞지 않을까라는 고민이 되었다고 이야기 했다. 여기에 대해서 내가 합류하기 이전의 논의에서 고민했던 이야기들을 들을 수 있었는데, 모바일 특성상 같은 스크린이 stack으로 쌓이게 될 경우의 영향을 전역상태 변경으로 영향을 받는 화면이 많아지고, redux의 많은 보일러플레이트 문제도 있었다고 말씀해주셨다.</p>\n<ul>\n<li>결론은, 상태와 관련이 없는 경우에는 함수를 param으로 전달하는 방식을 유지하고, 상태 변경이 필요할 시에는 global event bus를 이용하는 것으로 이야기가 되었다.</li>\n</ul>\n<p>이렇게 더 좋은 방향을 고민하고 얻는 장점과 잃을 수 있는 단점에 대해 같이 고민하고 의논할 수 있는 팀이라는 점이 너무 좋았던 부분이었다.</p>\n<h4>내가 놓쳤던 리뷰 반영과 호되게 배운 CI</h4>\n<p>내가 만든 가장 큰 사고(?) 였던 부분에 대해 이야기 해보려 한다. 기간이 긴 큰 작업을 혼자 맡게 된 것에 대한 부담 때문이었을까 기존의 작업한 부분을 수정하기 보다 기능 개발에만 너무 몰두해 7개의 PR들이 받은 리뷰를 수정하지 않은 채 병합되지 못하고 브랜치에 남아만 있게 되었다. </p>\n<p> 이것의 큰 문제점은 앞서 정리한 배포 사이클에서 master는 매주 변경되고 변경된 내용들은 squad 브랜치로 당겨오게 된다. 이때 이전에 작업한 브랜치들은 변경 전 스쿼드 브랜치를 바라보고 있기 때문에 conflict이 날 수 밖에 없다. 연쇄적으로 이어지는 PR이었기 때문에 변경사항 또한 계속해서 이어졌고 기존에 예상하지 못한 conflict을 해결하는 작업으로 인해 기한 내에 병합하지 못하게 되었다. 결국 스쿼드 일정이 나로 인해 밀리게 되버렸고 내가 한 작업이 나가지 못하게 되었다.</p>\n<p><strong>왜 CI(Continuous Integration)가 중요한 지</strong> 배울 수 있었고, 리뷰를 받고 다시 응답하는 과정이 얼마나 중요한 것인지 배울 수 있었다.</p>\n<h4>let 지양과 즉시실행 함수 활용하기</h4>\n<p>마지막으로 기억에 남는 부분은 let을 지양하고 즉시 실행 함수를 활용하는 부분이었다. 여러가지 조건에 맞게 다른 값을 반환해줘야할 때 단순히 let을 이용해 선언한 변수에 조건에 맞는 값을 대입해 마지막에 return하려 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token constant\">BASE_POSTION</span> <span class=\"token operator\">=</span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getBottomPosition</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> Location<span class=\"token punctuation\">,</span> buttonHeight<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> keyboardHeight<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> position <span class=\"token operator\">=</span> <span class=\"token constant\">BASE_POSTION</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">===</span> ScreenKeyEnum<span class=\"token punctuation\">.</span>SignUpSearchService <span class=\"token operator\">&amp;&amp;</span> keyboardHeight <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        position <span class=\"token operator\">=</span> keyboardHeight<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">===</span> ScreenKeyEnum<span class=\"token punctuation\">.</span>SignupGosu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        position <span class=\"token operator\">=</span> buttonHeight<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> position<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>let을 지양하고 내가 필요한 부분이 단 한번만 조건에 맞게 값을 받으면 되는 것이기 때문에 <code class=\"language-text\">즉시실행함수</code>를 사용할 수 있다. 리뷰를 통해 개선한 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"> <span class=\"token keyword\">const</span> bottomPosition <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token constant\">BASE_POSTION</span> <span class=\"token operator\">=</span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">===</span> ScreenKeyEnum<span class=\"token punctuation\">.</span>SignUpSearchService <span class=\"token operator\">&amp;&amp;</span> keyboardHeight <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> keyboardHeight<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">===</span> ScreenKeyEnum<span class=\"token punctuation\">.</span>SignupGosu<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> buttonHeight<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">BASE_POSTION</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n\t <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">View</span></span> <span class=\"token attr-name\">style</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> bottom<span class=\"token operator\">:</span> bottomPosition<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"> ... </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">View</span></span><span class=\"token punctuation\">></span></span>  \t\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>즉시 실행함수를 사용함으로써 함수 내에서만 사용한 변수들이 선언되어 불필요한 전역변수를 줄일 수 있고, 실제 사용할 때도 함수로 사용하는 것이 아니라 값으로 사용할 수 있었다. IIFE는 클로저와 함께 사용될 수 있는 부분으로 함수형 프로그래밍에 대해 더 공부하면서 적용하면 좋을 것 같다고 생각되었다.</p>\n<h3>😉 마치며</h3>\n<p>이번 한달 동안 많은 내용을 배울 수 있었다. 아직 소화하지 못해서 적지 못한 내용 중에는 <strong>명령형과 선언형으로 코드를 작성하는 방법의 차이</strong>, class component에서 <strong>set함수에 콜백함수를 전달하는 것을 대체하는 방법</strong>이 있다. 이부분들에 대해서 4월 한달 동안 또 고민하면서 더 나은 코드를 작성하고, 내가 하는 리뷰가 우리 팀에 또 도움이 될 수 있게 역량을 키워나가야겠다.</p>\n<p>[참고]</p>\n<ul>\n<li><a href=\"https://medium.com/@jimmy_58380/%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EB%A7%A4%EC%A3%BC-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-%EA%B7%9C%EC%B9%99-%EC%A0%95%ED%95%98%EA%B8%B0-2fd03c65484\">Jimmy Lee 블로그</a></li>\n</ul>","frontmatter":{"title":"🐤 2023년 3월 회고","date":"March 31, 2023","tags":["회고","리액트 네이티브"],"series":null},"fields":{"slug":"/2023-03-31-2023년-3월회고/","readingTime":{"minutes":21.595}}},"seriesList":{"edges":[{"node":{"id":"db12bfaf-9b68-5456-b2d3-bf7af6db01f6","fields":{"slug":"/2022-09-06-BEM과-자료형/"},"frontmatter":{"title":"BEM과 자바스크립트의 자료형"}}},{"node":{"id":"11c1a396-7281-552a-9589-6f14d399473b","fields":{"slug":"/2022-09-07-자바스크립트의-타입과연산자/"},"frontmatter":{"title":"자바스크립트의 타입과 연산자"}}},{"node":{"id":"1b75d916-f93f-54a4-bcb0-ee6a88e1e807","fields":{"slug":"/2022-09-07-자바스트립트의-두가지-복사방법/"},"frontmatter":{"title":"자바스크립트의 두가지 복사 방법"}}},{"node":{"id":"3b564afa-9e11-5817-9130-4e2a191f4dff","fields":{"slug":"/2022-09-10-intersection-observer /"},"frontmatter":{"title":"Intersection observer"}}},{"node":{"id":"ac0c72d8-87ec-5038-8d94-316c5fcc3d62","fields":{"slug":"/2022-09-12-브라우저API/"},"frontmatter":{"title":"Browser API"}}},{"node":{"id":"362a634b-e650-5526-851e-d5fbd908dab8","fields":{"slug":"/2022-09-13-함수/"},"frontmatter":{"title":"함수"}}},{"node":{"id":"fa488a20-ff1a-5d21-a871-7cd7a1943bb7","fields":{"slug":"/2022-09-14-객체/"},"frontmatter":{"title":"객체"}}},{"node":{"id":"93e28849-ee68-5f54-a013-82287b705626","fields":{"slug":"/2022-09-17-빌트인객체/"},"frontmatter":{"title":"빌트인 객체"}}},{"node":{"id":"792817ac-87f4-5be2-a7aa-360f10d5c8b4","fields":{"slug":"/2022-09-19-array/"},"frontmatter":{"title":"Array"}}},{"node":{"id":"b9665749-4456-51bc-8980-7b1df634660e","fields":{"slug":"/2022-09-22-iteration/"},"frontmatter":{"title":"Iteration"}}},{"node":{"id":"b36e6692-59b2-579e-a86a-a032da431840","fields":{"slug":"/2022-09-24-Map과Set/"},"frontmatter":{"title":"Map과 Set"}}},{"node":{"id":"483fabc0-6bc7-5db7-9654-84987635add6","fields":{"slug":"/2022-10-06-HTTP란/"},"frontmatter":{"title":"HTTP 정리"}}},{"node":{"id":"197d4909-e862-5b9a-8676-b53e027e5379","fields":{"slug":"/2022-10-18-Node-JS-기초/"},"frontmatter":{"title":"Node js:NodeJS 이용한 서버 만들기"}}},{"node":{"id":"bd10a339-6c06-5837-862e-192c45081282","fields":{"slug":"/2022-10-19-Express-기초/"},"frontmatter":{"title":"NodeJS: express"}}},{"node":{"id":"8195c683-dc7e-58d3-b7b6-c5a1e78b6522","fields":{"slug":"/2022-11-18-CSR과-SSR/"},"frontmatter":{"title":"CSR과 SSR 그리고 Universal Rendering"}}},{"node":{"id":"f05c2eb8-16da-5e6e-a906-bbdffa05ace6","fields":{"slug":"/2022-11-20-스코프-실행컨테스트-클로저/"},"frontmatter":{"title":"스코프,실행컨텍스트,클로저"}}},{"node":{"id":"24ec8ed8-dfae-5619-8c64-df914805c0eb","fields":{"slug":"/2022-11-24-Critical-Rendering-Path/"},"frontmatter":{"title":"💻 Critical Rendering Path"}}},{"node":{"id":"c32a9017-54df-5eb4-98cd-5eba4b9ae41c","fields":{"slug":"/2022-11-27-비동기와-프로미스/"},"frontmatter":{"title":"비동기와 프로미스"}}},{"node":{"id":"364cb56c-45fc-52dc-8311-0f61a88dfdfe","fields":{"slug":"/2022-11-30-지스트-청원-서비스-회고/"},"frontmatter":{"title":"지스트 청원서비스 회고"}}},{"node":{"id":"40c2d20c-04f0-5876-aee6-be5b43bce78a","fields":{"slug":"/2022-12-02-제너레이터와-async-await/"},"frontmatter":{"title":"제너레이터와 Async-Await"}}},{"node":{"id":"4ed9db58-39c3-5f21-ad1e-59be0b94e988","fields":{"slug":"/2022-12-03-모으잡-리팩토링/"},"frontmatter":{"title":"모으잡-check box 수정, react-query 커스텀 훅, 크롤링 이슈"}}},{"node":{"id":"937a4bc1-5318-52a9-b6fd-61188127ce23","fields":{"slug":"/2022-12-05-호이스팅/"},"frontmatter":{"title":"호이스팅"}}},{"node":{"id":"09bdd07c-e41f-573e-bd66-71c526ab83f8","fields":{"slug":"/2022-12-09-쿠키-session-jwt/"},"frontmatter":{"title":"Cookie,Session과 JWT"}}},{"node":{"id":"b552cf79-29a8-5e87-a162-c03661121fb6","fields":{"slug":"/2022-12-09-this/"},"frontmatter":{"title":"this"}}},{"node":{"id":"05a00e19-f52a-5596-a97e-4f7390b20119","fields":{"slug":"/2022-12-10-http와https/"},"frontmatter":{"title":"http와 https"}}},{"node":{"id":"b91bff56-be62-5318-b6f1-dc3ddc789d08","fields":{"slug":"/2022-12-12-생성자함수-프로토타입/"},"frontmatter":{"title":"생성자 함수, 프로토타입"}}},{"node":{"id":"3b7d6329-680d-5db9-8ee6-cb15da44b6a8","fields":{"slug":"/2022-12-30-이벤트/"},"frontmatter":{"title":"이벤트"}}},{"node":{"id":"a94c02b8-45b0-5fac-b129-cf99c64a8f24","fields":{"slug":"/2022-12-23-class/"},"frontmatter":{"title":"클래스"}}},{"node":{"id":"8dd5dd72-0262-582e-8a1d-33fd6b2245f3","fields":{"slug":"/2023-01-23-Vite와-번들러/"},"frontmatter":{"title":"Vite는 왜 빠를까, 번들러에 대한 정리"}}},{"node":{"id":"d1dc9a50-2824-5859-826f-ceb445994e93","fields":{"slug":"/2023-01-23-리액트의-기본원리/"},"frontmatter":{"title":"React study: 리액트의 기본 원리"}}},{"node":{"id":"2cd6faf4-d340-58ee-a4bc-c4b16bc21c42","fields":{"slug":"/2022-12-20-리액트-성능보장/"},"frontmatter":{"title":"React study: 리액트가 성능을 보장하는 방법"}}},{"node":{"id":"717eb8fb-45a2-5fef-aaa9-c5c5eceb792a","fields":{"slug":"/2023-02-03-useState,useEffect, useRef, memo/"},"frontmatter":{"title":"React Study: useState, useEffect, useRef, memo"}}},{"node":{"id":"26ed4c76-848a-56e4-ae68-7e879e23bf77","fields":{"slug":"/2023-02-17-취업준비-회고/"},"frontmatter":{"title":"신입으로 시작하며 작성하는 취준 회고"}}},{"node":{"id":"166ce257-9146-51aa-a470-57c257844c07","fields":{"slug":"/2023-02-21-google.com-입력했을때-일어나는-일/"},"frontmatter":{"title":"google.com를 브라우저에 검색했을 때 일어나는 일"}}},{"node":{"id":"aaa88fe5-37a4-5ff4-9de2-959da89dcd86","fields":{"slug":"/2023-03-01-CDN/"},"frontmatter":{"title":"CDN은 뭘까?"}}},{"node":{"id":"f2fa5329-7ce4-5a65-9e28-0e4b1d188a6c","fields":{"slug":"/2023-03-05-디자인패턴/"},"frontmatter":{"title":"MVC, MVVM, Flux패턴 그리고 Service와 Repository 패턴"}}},{"node":{"id":"543681af-5db3-518d-b19e-7668efdda7fc","fields":{"slug":"/2023-03-31-2023년-3월회고/"},"frontmatter":{"title":"🐤 2023년 3월 회고"}}},{"node":{"id":"eecd0175-5be8-556d-a36a-756d4af0700b","fields":{"slug":"/2023-05-06-2023년-4월회고/"},"frontmatter":{"title":"😎 2023년 4월 회고"}}},{"node":{"id":"055d38ec-e2c0-5a63-aa95-fbc147365d29","fields":{"slug":"/2023-06-05-2023년-5월회고/"},"frontmatter":{"title":"☀︎ 2023년 5월 회고"}}},{"node":{"id":"32156a84-756c-50c3-bd9f-77b3dc2e7547","fields":{"slug":"/2023-07-06-2023년-6월회고/"},"frontmatter":{"title":"☼ 2023년 6월 회고"}}},{"node":{"id":"5438a45e-764a-5e14-b5ba-b71f4ba8be23","fields":{"slug":"/2023-08-09-2023년-7월회고/"},"frontmatter":{"title":"☂︎ 2023년 7월 회고"}}},{"node":{"id":"7a788f0b-75af-5eac-b509-fd0d3f119d98","fields":{"slug":"/2023-09-09-2023년-8월회고/"},"frontmatter":{"title":"😊 2023년 8월 회고"}}},{"node":{"id":"d47fe7ea-21c5-5c88-b64e-e34021957c29","fields":{"slug":"/2023-10-03-2023년-9월회고/"},"frontmatter":{"title":"🚅 2023년 9월 회고"}}},{"node":{"id":"4268b04a-703c-5bd0-8081-e900ee0ce15c","fields":{"slug":"/2023-11-01-2023년-10월회고/"},"frontmatter":{"title":"🧐 2023년 10월 회고"}}},{"node":{"id":"01c028b9-d56c-52a8-8719-eb5cbcf6ea70","fields":{"slug":"/2023-12-02-2023년-11월회고/"},"frontmatter":{"title":"😃 2023년 11월 회고"}}},{"node":{"id":"e696cf5b-451a-5fe0-a2cb-100a22d3d356","fields":{"slug":"/2023-12-31-2023년-12월회고/"},"frontmatter":{"title":"🌟 2023년 12월 회고"}}},{"node":{"id":"b0eb4259-0e5c-53fd-9fdc-cd5e53336653","fields":{"slug":"/2024-02-07-2024년-1월회고/"},"frontmatter":{"title":"🐥 2024년 1월회고"}}}]},"previous":{"fields":{"slug":"/2023-03-05-디자인패턴/"},"frontmatter":{"title":"MVC, MVVM, Flux패턴 그리고 Service와 Repository 패턴"}},"next":{"fields":{"slug":"/2023-05-06-2023년-4월회고/"},"frontmatter":{"title":"😎 2023년 4월 회고"}}},"pageContext":{"id":"543681af-5db3-518d-b19e-7668efdda7fc","series":null,"previousPostId":"f2fa5329-7ce4-5a65-9e28-0e4b1d188a6c","nextPostId":"eecd0175-5be8-556d-a36a-756d4af0700b"}},"staticQueryHashes":[],"slicesMap":{}}