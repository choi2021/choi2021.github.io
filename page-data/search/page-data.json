{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"2025년이 시작되고, 새로운 업무와 새로운 환경이 시작되었다. 토스에 11월에 입사하면서 이제 3개월이 되는 달로, 바쁘게 일했던 11월, 12월을 지나 1월은 상대적으로 이번 한해를 준비하는 작업들을 진행하는 달이었다. 12월 말의 off-week 기간과 글을 쓰는 현재 설날의 긴 연휴로 인해 3개월이란 시간이 상대적으로 더 빠르게 느껴졌지만, 한달간…","fields":{"slug":"/2025-01-27/"},"frontmatter":{"date":"January 27, 2025","title":"2025년 1월 회고","tags":["회고","toss"]},"rawMarkdownBody":"\n2025년이 시작되고, 새로운 업무와 새로운 환경이 시작되었다. 토스에 11월에 입사하면서 이제 3개월이 되는 달로, 바쁘게 일했던 11월, 12월을 지나 1월은 상대적으로 이번 한해를 준비하는 작업들을 진행하는 달이었다.\n\n12월 말의 off-week 기간과 글을 쓰는 현재 설날의 긴 연휴로 인해 3개월이란 시간이 상대적으로 더 빠르게 느껴졌지만, 한달간의 업무를 정리해보고 12월에 세웠던 목표를 이루었는지 다음달에는 어떤 목표로 나아갈 지 생각해보려 한다.\n\n## 새롭게 담당하게 된 퍼널 개선 업무\n\n1월이 되면서 조직 개편이 있었고, 기존 토스 코어내 세금 사일로에서 토스 인컴의 퍼널 개선 사일로로 이동하게 되었다. 이에 따라 일하는 사무실도 변경되었고, 담당하는 업무도 변경되게 되었다.\n\n기존 메이트분이 담당하시던 퍼널 관련 업무들을 이제 내가 담당하게 되어 현재 진행중인, 앞으로 내가 할 업무들에 대해 다운로드받게 되었다.\n\n메이트 분께서 다운로드를 해주시는 내용을 들으면서, 부분부분 코드나 기술적인 건 이해가 되지만, 큰 흐름과 도메인과 관련된 부분을 이해하는데 많은 어려움이 있었다. 세금이란 도메인에 어려운 용어들이 혼재되어 있고, 관련 법률사항들이 예외케이스들이 하나하나 코드에 녹아들어있다보니 완전히 이해하는데 오랜시간이 걸렸다. `나는 내 담당 제품에 대해 너무 모르고 일해왔구나` 체감하게 되었다.\n\n이러한 부족한 도메인 지식은 문제가 있을때 어떻게 풀어나갈 지에 대해 어려움으로 이어졌다. 예를 들어 특정 공제 내용이 잘못 적용되어 신고되는 케이스가 있다는 내용을 전달받아도 해당 공제 관련 구현에서 각 변수들의 의미는 뭔지부터 시작해 어떤게 기존에 문제가 되는지 파악도 어려웠다.\n\n팀원분들이 내가 어려워하는 것을 이해해주셔서 디자이너분과 백엔드 개발자분이 필요한 업무에 대해 정리해주시고 문제를 뾰족하게 만들어주셨지만 이대로는 안되겠다는 생각이 많이 들었다.\n\n메이트 분께서 다운로드를 해주시면서 담당했던 제품중에서 가장 길고 복잡한 퍼널 제품중 하나라고 말씀해주신 만큼, 퍼널을 다루는 것에 있어서 깊이가 필요하다고 생각해 자주 사용하는 새로운 `useFunnel` 라이브러리 버전으로 정리를 하면서 내부구현을 이해하고 활용해보려 했다. 아직 글을 작성하는 중이지만 조만간 정리 글을 작성해보려 한다.\n\n두번째로 내가 모르는 도메인 관련 지식을 모르는 상태로 계속해서 두게 되면, 그때 계속해서 물어서만 일하게 되면 팀원분들의 추가적인 리소스가 드는 것 뿐 아니라 내 자신의 업무주도성이 떨어지겠다는 걱정이 많이 들었다.\n\n2월부터는 이러한 도메인 내용들 또한 마주할 때마다 관련 법률과 용어들을 정리하고 이해하는 시간을 가지면서 업무를 진행해나가려 한다. 그리고 이러한 도메인 내용을 바탕으로 내가 기여할 수 있는 부분을 제안하는 것을 액션아이템으로 삼아보려 한다.\n\n## 토스 생활: alignment week\n\n토스에는 한해를 시작하면서 `alignment week`라는 이름의 행사가 있다. 이 행사는 토스 내 모든 팀들이 과거 한해를 돌아보고, 새로운 한해를 시작하면서 목표를 세우고 이를 이루기 위해 모두 모여 이야기하는 시간을 가지는 행사다.\n\n[2023년 토스 얼라이먼트 위크](https://blog.toss.im/article/alignmentweek23-1)\n\n![2023년 토스 얼라이먼트 위크 참고 사진](https://static.toss-internal.com/ipd-tcs/toss_core/live/8bd24766-ba31-4e56-a9c0-e07c3ae7ac60)\n\n다른 팀의 발표를 듣고, 우리 팀의 PM분이 발표하는 시간에 응원도 하면서 정말 많은 팀에서 다양한 문제를 풀기위해 애쓰고 있고, 토스에는 일에 열정이 가득한 사람들이 많다는 것과, 앞으로가 더 기대됨을 느낄 수 있었다.\n\n내년에 더 큰 성과를 우리팀의 발표로 할 수 있도록 기여해보고 싶다.\n\n## 새로운 환경과 사람들\n\n팀의 소속이 변경되면서 인컴분들과 함께 사무실을 사용하게 되었고, 새로운 사람들과 함께하게 되었다.\n\n기존 사일로분들이 메이트분을 제외하고 함께 옮겨지게 되었고, 간간히 함께 일했던 분들이 계셨지만 새롭게 합류한 분들이 많았다.\n\n새롭게 합류하신 분 중에는 프론트엔드 개발자분도 계셔서 오시기전, 노션으로 기존 개발 환경, 진행중인 업무 등에 대해 정리한 문서를 작성했다. 이후에 합류 이후에 해당 문서를 전달드리고 그것을 바탕으로 함께 팀내 프론트엔드 온보딩 문서로 발전시키기도 했다. 코어에서 2년 넘게 일하셨던 분이다 보니 정리를 굉장히 잘하시고, 프로젝트의 필요한 부분을 히스토리로 남겨두는 것을 잘하셨다.\n\n기존 메이트분의 장점은 반복업무에 대해서 굉장히 효율화 잘하시는 분이셨다. Raycast나 Shell Script, snippet을 자체적으로 만드셔서 반복된 업무에 대해 템플릿을 만들어 사용하는 것을 많이 배울 수 있었는데, 이분의 장점을 또 찾고 배워나가는 것을 기대하고 있다.\n\n뿐만 아니라 새로운 동료분들과 이야기하면서 각자 새로운 환경에 대한 목표가 있는게 좋았고, 이분들의 장점을 찾아보고 배워나가는 것을 기대하고 있다. 함께 더 좋은 제품, 더 좋은 팀을 만들어나가기를 바래본다.\n\n## 사내 라이브러리 개발\n\n사내 라이브러리를 1월 중순까지 거의 10개 정도의 PR을 올렸고 길드 내 첫 마일스톤으로 잡았던 작업량을 달성할 수 있었다.\n\n현재 남겨두고 있는 부분은 해당 라이브러리를 오픈소스로 공개하기 전 문서 작업들과 사내에서 마이그레이션 진행시 편리하게 옮길 수 있도록 codemod를 만드는 작업이 남았다. 나는 이중 codemod를 만드는 작업을 담당하게 되었고 설 연휴 동안 작업을 진행해볼 예정이다.\n\n12월 말부터 거의 하루에 한개정도 작업을 했던 게 실제로 오픈하기 까지 얼마 남지 않은 것 같아 기대도 되고, 뿌듯하기도 했다. 계속해서 관심을 가지고 사용하시는 분들과 소통도 하면서 적극적으로 계속해서 기여해나가는 것을 목표로 하려한다.\n\n## 토스 얼라이먼트 위크\n\n## 이전 한달과 다음 한달의 목표\n\n이전 한달의 목표들은 아래와 같았다.\n\n- [] 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기 (제시까지는 못함)\n- [x] 토스 프론트엔드 라이브러리 분석하기\n- [x] 사내 라이브러리에 기여하기\n\n### 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기\n\n숨은 환급액 찾기 서비스를 이용하면서 진입시 로딩시간이 길다는 생각이 들어 실제 유저가 겪고 있는 시간이 얼마나 되는지 측정작업을 먼저 진행했다. 기존에 코어 서비스들은 측정이 되고 있었지만 인컴 제품은 계열사가 달라 따로 데이터를 쌓기위한 작업이 필요했다.\n\n별도 작업을 하더라도 아직 데이터 인프라가 완성되지 않아 세부 데이터까지 수집해서 보기 어려운 상황이었다.\n\n그러면 포기해야하나 할때 백엔드 엔지니어분께서 아이디어를 주셔서 간단하게 추세를 보는 방법에 대해 제안해주셨다.\n제시해주신 형식에 맞게 데이터를 쌓고 그라파나라는 툴을 이용해서 대시보드를 간략하게 만드는 것까지 현재 진행할 수 있었다.\n\n2월에는 어떤 퍼널에서 오랜시간이 걸리고 있고, 이탈을 하고 있는지 확인하며 퍼널간 전환율 개선 작업으로 진행할 수 있도록 제안해보려 한다.\n\n### 토스 프론트엔드 라이브러리 분석하기와 사내 라이브러리 기여하기\n\n`토스 프론트엔드 라이브러리 분석하기`를 위해 개발하는 과정에서 마주하는 다양한 유틸들의 내부 구조들을 분석하고 정리해보고 있다.\n\n이번달은 사내 라이브러리에 기여하면서 리액트 관련 기존 구현들을 분석하고 테스트 케이스, 문서를 보완하는 작업을 진행했다.\n\n추가로 퍼널 개선 업무를 맡으면서 기존의 작성했던 [이전 버전 useFunnel](https://choi2021.github.io/2024-09-17-useFunnel-%EB%B6%84%EC%84%9D%ED%95%B4%EB%B3%B4%EA%B8%B0/)에 이어 [새로운 버전의 useFunnel 라이브러리](https://use-funnel.slash.page/ko/docs/use-funnel)를 분석하고 정리해보고 있다. 정리하는 글까지 올리는 것을 1월 중으로 완료했다.\n\n![useFunnel 라이브러리 공식문서](./useFunnel.png)\n\n얼마나 많은 고민이 담긴 패키지인지 분석하면서 느낄 수 있었다.\n\n### 다음 한달의 목표\n\n다음 한달의 목표는 이전 한달의 목표 달성 현황과 작업을 하면서 느꼈던 느낀점을 바탕으로 4가지로 정해보았다.\n\n- 숨은 환급액 찾기 제품 내 퍼널 개선 필요 지점 제안하고 개선하기\n- 세금 관련 공제 내용 정리하기\n- 사내 라이브러리 기여하기\n- 데이터 패칭 관련 라이브러리 분석하기\n\n욕심이 많아 다 잘하고 싶어 계속 늘어가는 것 같지만, 더 좋은 개발자, 더 좋은 동료가 되기 위해 계속해서 발전해나가는 것을 목표로 하려 한다.\n\n블로그를 작성하는 것을 팀원분들께 들킨(?) 이후로 한달 회고 언제 올라오냐고 감사하게 관심을 가져주신다.\n\n내가 작성한 글을 누군가 읽고 있으니 더 책임감을 가지고 액션아이템들을 이루어나가기를 바라본다.\n"},{"excerpt":"useFunnel 라이브러리는 2023 토스 Slash의 퍼널: 쏟아지는 페이지 한 방에 관리하기 발표에서 복잡한 퍼널간 상태관리를 위한 라이브러리 useFunnel을 소개되었고, 토스 프론트엔드 액셀러레이터 과정의 2주차 주제였던 라는 주제를 진행하고 분석하는 글을 작성했다.  개인적으로 새롭게 정리하게 된 이유는 기존 패키지과 달리 다양한 장점을 가지…","fields":{"slug":"/2025-01-19-useFunnel-분석/"},"frontmatter":{"date":"January 19, 2025","title":"new useFunnel 분석해보기","tags":["frontend","open-source","toss","react"]},"rawMarkdownBody":"\nuseFunnel 라이브러리는 2023 토스 Slash의 [퍼널: 쏟아지는 페이지 한 방에 관리하기 발표](https://www.youtube.com/watch?v=NwLWX2RNVcw&t=50s)에서 복잡한 퍼널간 상태관리를 위한 라이브러리 useFunnel을 소개되었고, 토스 프론트엔드 액셀러레이터 과정의 2주차 주제였던 `퍼널간 상태 관리하기`라는 주제를 진행하고 [분석하는 글](https://choi2021.github.io/2024-09-17-useFunnel-%EB%B6%84%EC%84%9D%ED%95%B4%EB%B3%B4%EA%B8%B0/)을 작성했다.\n\n![작성했던 이전글](useFunnel-previous-cover.png)\n\n개인적으로 새롭게 정리하게 된 이유는 기존 패키지과 달리 다양한 장점을 가지고 있고, 훨씬 다양한 유즈케이스를 관리하기 위해 새롭게 만들어져 오픈소스로 공개되어 분석해보고 싶었고, 1월부터 굉장히 복잡한 퍼널을 관리가 필요한 제품을 담당하게 되면서 퍼널에 대한 이해도를 높일 필요가 있다고 느꼈다.\n\n그러면 새로운 useFunnel 패키지에 대해 알아보고 분석해보자.\n\n## 새로운 useFunnel은 어떤 문제를 해결하기 위한걸까?\n\n기존 패키지가 있지만 새롭게 만들게 된 이유는 무엇일까? 새로운 패키지를 만들어주신 선영님과 민우님께서 사내 블로그에 올려주신 글을 통해 알아보자.\n\n- [@use-funnel 개발기 #1: 왜 기존 라이브러리를 두고 새로 만들었나?](https://toss.tech/article/use-funnel-1)\n\n- [@use-funnel 개발기 #2: 기존 라이브러리를 어떻게 뜯어 고칠 것인가?](https://toss.tech/article/use-funnel-2)\n\n### 먼저 기존 라이브러리의 문제점\n\n당시 선영님께서 담당하게 되신 서비스인 주택 담보 대출 비교 서비스는 굉장히 복잡한 퍼널 관리가 필요했고, 기존 사용중인 두가지 퍼널 관리 방식을 통해 구현되어 있었다.\n\n첫번째는 기존 use-funnel 패키지로 직관적이고 익숙하지만 퍼널과정에서 수집하게 되는 데이터 관리를 별도로 해야하는 문제점이 있었다.\n\n```tsx\ninterface FormState {\n  purpose: Purpose;\n  address: string;\n  income: number;\n}\n\nfunction Funnel() {\n  const [formState, setFormState] = useState<Partial<FormState>>({});\n  const [Funnel, setStep] = useFunnel([FunnelName.대출목적선택, FunnelName.담보물선택, FunnelName.연소득입력], {\n    initialStep: FunnelName.대출목적선택,\n    stepQueryKey: 'mortgage-loan-funnel',\n  });\n\n  return (\n    <Funnel>\n      <Funnel.Step name={FunnelName.대출목적선택}>\n        <대출목적선택\n          onNext={purpose =>\n            setFormState(prev => ({ ...prev, purpose }));\n          }}\n        />\n      </Funnel.Step>\n      <Funnel.Step name={FunnelName.담보물선택}>\n        <담보물선택\n          onNext={(address) => {\n            setFormState(prev => ({ ...prev, address }));\n          }}\n        />\n      </Funnel.Step>\n      <Funnel.Step name={FunnelName.연소득입력}>\n        <연소득입력\n          onNext={(income) => {\n            setFormState(prev => ({ ...prev, income }));\n          }}\n        />\n      </Funnel.Step>\n    </Funnel>\n  );\n};\n```\n\n두번째로는 XState 상태관리 도구를 이용하는 방식으로 퍼널과 상태를 함께 관리하지만 복잡하면서도 상태관리와 렌더링하는 컴포넌트 코드가 분리되어 있는 문제점이 있었다.\n\n```tsx\nfunction createFunnelMachine() {\n  return (\n    createMachine<Partial<Context>, Event, StateType>({\n\t\t  id: \"mortgage-loan-funnel\",\n\t\t  initial: \"대출목적선택\",\n\t\t  states: {\n\t\t\t\t대출목적선택: {\n\t\t\t\t\tentry: [assign(context => 대출목적선택State검증(context))],\n\t\t\t\t\ton: {\n\t\t\t\t\t\t대출목적선택완료: [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t    target: \"담보물선택\",\n\t\t\t\t\t\t    actions: [assign()],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t담보물선택: {\n\t\t\t\t\tentry: [assign(context => 담보물선택State검증(context))],\n\t\t\t\t\ton: {\n\t\t\t\t\t\t담보물선택완료: [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t    target: \"연소득입력\",\n\t\t\t\t\t\t    actions: [assign()],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t연소득입력: {\n\t\t\t\t\tentry: [assign(context => 연소득입력State검증(context))],\n\t\t\t\t\ton: {\n\t\t\t\t\t\t연소득입력완료: [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t    target: \"입력완료\",\n\t\t\t\t\t\t    actions: [assign()],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t입력완료: {\n\t\t\t\t  entry: [assign(context => 입력완료State검증(context))],\n\t\t\t\t}\n\t\t  }\n    })\n  );\n}\n\nfunction Funnel() {\n  const [funnelMachine] = useState(() => createFunnelMachine());\n  // useMachineRouter는 dispatch 시점에 적절한 다음 퍼널로 라우트시켜주는 기능을 구현한 hook이에요\n  // 내부적으로 XState의 useMachine을 사용해요\n  const [render, state] = useMachineRouter(funnelMachine);\n\n  return (\n    <>\n      {render({\n        대출목적선택: ({ dispatch }) => (\n          <대출목적선택\n\t          onNext={purpose =>\n\t            dispatch({ type: \"대출목적선택완료\", payload: { purpose }})\n\t          }}\n\t        />\n        ),\n        담보물선택: ({ dispatch }) => (\n          <담보물선택\n\t          onNext={address =>\n\t            dispatch({ type: \"담보물선택완료\", payload: { address }})\n\t          }}\n\t        />\n        ),\n        연소득입력: ({ dispatch }) => (\n          <연소득입력\n\t          onNext={income =>\n\t            dispatch({ type: \"연소득입력완료\", payload: { income }})\n\t          }}\n\t        />\n        ),\n        입력완료: ({ context }) => (\n          <입력완료 context={context} />\n        )\n      })}\n    </>\n  );\n}\n```\n\n둘다 공통적으로 뒤로가기와 앞으로 가기를 할 때, 수집한 데이터를 관리하는데 어려움이 존재하게 된다. 예를 들어 A->B->C 에서 B로 돌아가게 되면 A에서 수집한 데이터 외의 B에서 이미 수집한 데이터가 존재하게 된다.\n\n![뒤로가기 데이터 관리 문제](simple-funnel.png)\n\n이부분을 읽으면서 `이미 선택한 데이터를 다시 선택하지 않아도 되게 해줄 수 있기 위해 이미 선택한 정보는 뒤로가기시에도 보관하는 게 좋지 않을까` 생각이 들었지만 아래와 같은 상황이라면 달라진다.\n\n![복잡한 퍼널에서의 뒤로가기 데이터 관리 문제](complicated-funnel.png)\n\n위 사진처럼 A → B → C → B(뒤로가기) → A(뒤로가기) → D → E로 이동한다면 했을때 선택한적 없어야하는 B의 값을 D, E 퍼널에서 갖게 되면서 별도로 원하는 데이터를 정제하는 과정이 필요하게 된다.\n\n이렇게 퍼널이 복잡해질수록 각 스텝에서 보유해야하는 데이터를 한정시켜주는게 데이터의 흐름을 이해하는데 조금 더 직관적이고 좋을 것 같다는 생각이 들었고 문제상황을 공감할 수 있었다.\n\n## 기존 useFunnel의 또다른 문제점\n\n기존의 useFunnel 패키지의 또다른 문제점은 `Next와의 강한 결합`이었다. 다른 라우팅 라이브러리와 환경(React Router DOM, react native 환경) 에서는 각자 자체적으로 구현해야 한다는 점이 있었고,\n퍼널에서 수집한 데이터의 타입이 `자동적으로 추론이 되지 않기 때문에` A퍼널에서 필수적으로 받아야하는 데이터가 B 퍼널에서 여전히 optional로 추론되기도 해 타입을 좁히는 코드가 별도로 필요했다.\n\n이 두가지 문제점을 추가로 개선한 버전이 바로 `새로운 useFunnel` 패키지였다. 그러면 이제 실제 코드를 보면서 분석해보자.\n\n## 코드 분석\n\nuse-funnel 패키지를 다운받아서 내부 구조를 보게 되면 아래와 같은 구조를 확인할 수 있다.\n\n![use-funnel 패키지 구조](use-funnel-structure.png)\n\n위와 같은 프로젝트 구조를 통해 core 폴더는 라이브러리, 프레임워크와 상관없이 동일하게 적용되는 핵심로직을 가지고 있고, 라우팅 라이브러리/프레임워크 폴더들은 각각의 사용방법에 맞게 구체적인 구현이 되어있을 것으로 예상할 수 있다.\n\n이렇게 공통 코어 로직과 구체적인 구현을 분리하는 구조를 통해 특정 라우팅 라이브러리/프레임워크와의 강결합을 끊고 라이브러리의 유연성을 가지게 되었다.\n\n그러면 이제 핵심적이고 중요한 코어 폴더의 코드를 살펴보자.\n\n### Core 패키지\n\n코어 패키지는 모든 패키지에서 공통적으로 사용되는 핵심 로직이 구현되어 있는 패키지이다.\n\n![core 폴더 구조](core-structure.png)\n\n코어 패키지의 index.ts 파일을 살펴보면 다음과 같은 코드를 확인할 수 있다.\n\n```ts\n// index.ts\nexport { AnyFunnelState } from \"./core.js\"\nexport * from \"./stepBuilder.js\"\nexport { CreateFunnelStepType } from \"./typeUtil.js\"\nexport * from \"./useFunnel.js\"\n```\n\nstepBuilder 등 추가적인 기능들을 제공하고 있지만, 이중 개인적으로 중요하다고 생각하는 핵심 `useFunnel.tsx` 파일을 살펴보면서 필요한 타입, 유틸 함수들을 하나씩 분석해보려 한다.\n\n처음 코드를 봤을 때 굉장히 복잡한 타입 정의에 압도를 당하는 느낌이어서 부분 부분 따라가며 이해하는 것이 좋다고 생각이 들어 쪼개서 분석해보았다.\n\n#### UseFunnelOptions\n\n`UseFunnelOptions` 타입은 퍼널의 옵션을 정의하는 타입이다.\n\n```ts\n// core.ts\nexport interface FunnelState<TName extends string, TContext = never> {\n  step: TName\n  context: TContext\n}\n\nexport type AnyContext = Record<string, any>\nexport type AnyStepContextMap = Record<string, AnyContext>\n\nexport type FunnelStateByContextMap<TStepContextMap extends AnyStepContextMap> =\n  {\n    [key in keyof TStepContextMap & string]: FunnelState<\n      key,\n      TStepContextMap[key]\n    >\n  }[keyof TStepContextMap & string]\n\n// useFunnel.tsx\nexport interface UseFunnelOptions<TStepContextMap extends AnyStepContextMap> {\n  id: string\n  initial: FunnelStateByContextMap<TStepContextMap>\n  steps?: {\n    [TStepName in keyof TStepContextMap]: FunnelStepOption<\n      TStepContextMap[TStepName]\n    >\n  }\n}\n```\n\nUseFunnelOptions 타입은 라우팅 패키지별로 사용할 `createUseFunnel` 함수에 전달할 옵션을 정의하는 타입이다. initial 옵션을 정의할 때 `FunnelStateByContextMap` 타입을 사용하고 있는데,\n사용처에서 정의한 context 구조를 통해 스텝별 퍼널의 상태를 타입으로 정의하고 있다.\n\n```ts\n// core.ts\nexport interface FunnelState<TName extends string, TContext = never> {\n  step: TName\n  context: TContext\n}\n```\n\n`funnelState`는 퍼널의 상태를 정의하는 타입이다. 퍼널의 상태는 퍼널의 스텝과 퍼널에서 사용할 데이터를 정의하는 context로 구성되어 있다.\n\n```ts\n// core.ts\nexport type FunnelStateByContextMap<TStepContextMap extends AnyStepContextMap> =\n  {\n    [key in keyof TStepContextMap & string]: FunnelState<\n      key,\n      TStepContextMap[key]\n    >\n  }[keyof TStepContextMap & string]\n```\n\n`FunnelStateByContextMap` 타입은 스텝별 퍼널 상태를 정의하는 타입으로 키는 문자열로 좁혀져 있는데 퍼널의 퍼널의 스텝은 `브라우저 히스토리`와 관련이 깊다보니 key가 될 수 있는 `string | number | symbol` 타입에서 string으로 좁히도록 되어있지 않을까 생각해볼 수 있었다.\n\n실제로 사용하는 코드를 보면 아래와 같다.\n\n```tsx\ntype EmailInput = {}\n\ntype PasswordInput = {\n  email: string\n}\n\ntype OtherInput = {\n  email: string\n  password: string\n}\n\nconst funnel = useFunnel<{\n  이메일입력: EmailInput\n  비밀번호입력: PasswordInput\n  그외정보입력: OtherInput\n}>({\n  id: \"my-funnel-app\",\n  initial: {\n    step: \"이메일입력\",\n    context: {},\n  },\n})\n```\n\n그러면 위 예제에서 전달될 타입들을 살펴보면 다음과 같다.\n\n```ts\ntype TStepContextMap = {\n  이메일입력: EmailInput\n  비밀번호입력: PasswordInput\n  그외정보입력: OtherInput\n}\n\ntype FunnelStateByContextMap = {\n  이메일입력: FunnelState<\"이메일입력\", EmailInput>\n  비밀번호입력: FunnelState<\"비밀번호입력\", PasswordInput>\n  그외정보입력: FunnelState<\"그외정보입력\", OtherInput>\n}\n\ntype UseFunnelOptions = {\n  id: string\n  initial: {\n    step: keyof TStepContextMap\n    context: TStepContextMap[keyof TStepContextMap]\n  }\n  steps?: {\n    [TStepName in keyof TStepContextMap]: FunnelStepOption<\n      TStepContextMap[TStepName]\n    >\n  }\n}\n```\n\n기본적인 옵션 외에 steps는 퍼널의 타입을 커스텀하게 정의할 수 있는 옵션으로 옵셔널한 옵션이다. 이때 step별로 조금 더 세부적인 타입이나 런타임 에러를 체크할 수 있는 옵션을 정의할 수 있다.\n\n```ts\n// stepBuilder.ts\nexport type FunnelStepGuardOption<TContext> = {\n  guard: (data: unknown) => data is TContext\n}\n\nexport type FunnelStepParseOption<TContext> = {\n  parse: (data: unknown) => TContext\n}\n\nexport type FunnelStepOption<TContext> =\n  | FunnelStepGuardOption<TContext>\n  | FunnelStepParseOption<TContext>\n```\n\n`FunnelStepGuardOption`은 전달 받은 데이터가 특정 타입인지 검증하는 옵션이고, `FunnelStepParseOption`은 전달 받은 데이터를 특정 타입으로 변환하는 옵션이다.\n\n`FunnelStepOption`은 두 옵션을 합치는 union 타입으로 정의되어 있는데 steps 옵션으로 두가지 방식을 다 사용할 수 있게 제공하고 있다.\n\n그러면 실제 사용 예제를 살펴보자.\n\n```tsx\nimport { useFunnel } from \"@use-funnel/next\"\n\ntype FormState = {\n  email?: string\n  password?: string\n  other?: unknown\n}\n\nfunction 이메일입력_guard(data: unknown): data is FormState {\n  return true\n}\n\nfunction 비밀번호입력_parse(data: unknown): FormState & { email: string } {\n  if (\n    !(\n      data != null &&\n      typeof data === \"object\" &&\n      \"email\" in data &&\n      typeof data[\"email\"] === \"string\"\n    )\n  ) {\n    throw new Error(\"비밀번호입력 데이터가 아닙니다.\")\n  }\n  return { ...data, email: data.email }\n}\n\nfunction 그외정보입력_parse(\n  data: unknown\n): FormState & { email: string; password: string; other: unknown } {\n  const parseData = 비밀번호입력_parse(data)\n  if (!(\"password\" in parseData && typeof parseData.password === \"string\")) {\n    throw new Error(\"비밀번호가 없습니다\")\n  }\n  return { ...parseData, password: parseData.password, other: parseData.other }\n}\n\nfunction MyFunnelApp() {\n  const funnel = useFunnel({\n    id: \"step-by-step\",\n    initial: {\n      step: \"이메일입력\",\n      context: {},\n    },\n    steps: {\n      이메일입력: { guard: 이메일입력_guard },\n      비밀번호입력: { parse: 비밀번호입력_parse },\n      그외정보입력: { parse: 그외정보입력_parse },\n    },\n  })\n\n  funnel.step === \"이메일입력\" && typeof funnel.context.email // \"string\" | \"undefined\"\n  funnel.step === \"비밀번호입력\" && typeof funnel.context.email // \"string\"\n\n  funnel.step === \"비밀번호입력\" && typeof funnel.context.password // \"string\" | \"undefined\"\n  funnel.step === \"그외정보입력\" && typeof funnel.context.password // \"string\"\n  // ...\n}\n```\n\n위 코드는 공식 문서의 예제를 이용한 것으로 steps에 실제 런타임 에러를 체크할 수 있는 옵션을 정의하고 타입이 안전하게 추론되는 것을 확인할 수 있다.\n\n#### UseFunnelResults\n\n타입적으로 가장 복잡한 UseFunnelResults는 `createUseFunnel` 함수의 반환 타입이다. 해당 타입을 이해하기 위해 위와 같이 구성하는 타입들을 하나하나씩 살펴보며 이해해보자.\n\n```ts\n// core.ts\nexport type AnyStepContextMap = Record<string, AnyContext>\n\nexport type RouteOption = Partial<Record<string, any>>\n\nexport interface FunnelState<TName extends string, TContext = never> {\n  step: TName\n  context: TContext\n}\n\nexport type AnyFunnelState = FunnelState<string, AnyContext>\n\nexport type GetFunnelStateByName<\n  TFunnelState extends AnyFunnelState,\n  TName extends TFunnelState[\"step\"]\n> = Extract<TFunnelState, { step: TName }>\n```\n\n`AnyStepContextMap`은 퍼널의 스텝별 데이터를 정의하는 타입이고, `RouteOption`은 퍼널의 라우트 옵션을 정의하는 타입으로 key를 문자열로 가지는 객체이다.\n\n`FunnelState` 타입은 퍼널의 상태를 정의하는 타입으로 퍼널의 상태는 퍼널의 스텝과 퍼널에서 사용할 데이터를 정의하는 context로 구성되어 있다.\n\n`GetFunnelStateByName` 타입은 FunnelState 타입에서 특정 스텝의 이름을 이용해 특정 퍼널의 상태를 추출하는 타입이다.\n\n예로 퍼널의 상태가 다음과 같이 정의되어 있다고 가정해보자.\n\n```ts\ntype StepContextMap = {\n  이메일입력: {\n    email?: string\n  }\n  비밀번호입력: {\n    email: string\n    password?: string\n  }\n}\n```\n\n여기에 특정 스텝의 상태를 추출하면 다음과 같은 타입이 된다.\n\n```ts\ntype 이메일입력State = GetFunnelStateByName<StepContextMap, \"이메일입력\">\n// {\n//   step: '이메일입력';\n//   context: { email?: string; }\n// }\n```\n\n이제 다음으로 히스토리 관리 메소드들, 트랜지션 함수를 정의하는 타입들을 살펴보자.\n\n```ts\n// router.ts\nexport interface FunnelRouterTransitionOption {\n  renderComponent?: {\n    overlay: boolean\n  }\n}\n\ntype TransitionFnArguments<\n  TName extends PropertyKey,\n  TContext,\n  TRouteOption extends RouteOption\n> = Partial<TContext> extends TContext\n  ? [\n      target: TName,\n      context?: TContext,\n      option?: FunnelRouterTransitionOption & TRouteOption\n    ]\n  : [\n      target: TName,\n      context: TContext,\n      option?: FunnelRouterTransitionOption & TRouteOption\n    ]\n```\n\n`FunnelRouterTransitionOption` 타입은 퍼널의 라우트 옵션을 정의하는 타입으로 Overlay 형식의 컴포넌트도 퍼널의 스텝으로 관리하기 위해 정의되어 있다.\n\n`TransitionFnArguments` 타입은 트랜지션 함수의 인자를 정의하는 타입으로 트랜지션 함수의 인자는 특정 스텝의 이름, 스텝의 데이터, 라우트 옵션으로 구성되어 있다.\n\n다음으로 step별로 required, optional 속성을 정의하는 util 타입을 살펴보자.\n\n```ts\n// typeUtils.ts\n\nexport type Prettify<T> = Omit<T, never>\n\nexport type RequiredCompareKeys<TBase, TResult> =\n  | keyof TResult\n  | keyof TBase extends infer K\n  ? K extends keyof TResult\n    ? K extends keyof TBase\n      ? TBase[K] extends TResult[K]\n        ? never\n        : K\n      : undefined extends TResult[K]\n      ? never\n      : K\n    : never\n  : never\n\nexport type OptionalCompareKeys<TBase, TResult> =\n  | keyof TBase\n  | keyof TResult extends infer K\n  ? K extends keyof TResult\n    ? K extends keyof TBase\n      ? TBase[K] extends TResult[K]\n        ? K\n        : never\n      : undefined extends TResult[K]\n      ? K\n      : never\n    : K extends keyof TBase\n    ? K\n    : never\n  : never\n```\n\n`Prettify` 타입은 객체의 속성으로 never인 타입을 제외해 타입을 읽기 쉽게 만들어주는 타입이다.\n\n`RequiredCompareKeys` 타입은 두가지 타입의 속성 중 **필수 속성으로 변경/추가**된 속성을 배열로 반환하고,`OptionalCompareKeys` 타입은 두가지 타입의 속성 중 **선택 속성으로 변경된 속성과 공통으로 가지고 있는 속성**을 배열로 반환한다.\n\n예시로 step별로 아래와 같은 타입이 있다고 가정해보자.\n\n```ts\ntype StepContextMap = {\n  이메일입력: {\n    email?: string\n  }\n  비밀번호입력: {\n    email: string\n    password?: string\n  }\n}\n```\n\n그러면 이제 두가지 타입의 속성을 합치면 RequiredCompareKeys와 OptionalCompareKeys 타입을 사용해 필수 속성과 선택 속성을 추출할 수 있다.\n\n```ts\n// 비밀번호입력 스텝에서:\ntype Required = RequiredCompareKeys<\n  StepContextMap[\"이메일입력\"],\n  StepContextMap[\"비밀번호입력\"]\n> // \"email\"\n\ntype Optional = OptionalCompareKeys<\n  StepContextMap[\"이메일입력\"],\n  StepContextMap[\"비밀번호입력\"]\n> // \"password\"\n```\n\nTransitionFn에서는 두가지 타입의 속성을 합치는 타입을 사용해 트랜지션 함수의 인자를 정의하고 있다.\n\n```ts\n// typeUtils.ts\n\nexport type CompareMergeContext<TBase, TResult> = Prettify<\n  {\n    [K in RequiredCompareKeys<TBase, TResult>]: K extends keyof TResult\n      ? TResult[K]\n      : K extends keyof TBase\n      ? TBase[K]\n      : never\n  } & {\n    [K in OptionalCompareKeys<TBase, TResult>]?: K extends keyof TBase\n      ? TBase[K]\n      : K extends keyof TResult\n      ? TResult[K]\n      : never\n  }\n>\n\n//FunnelRender.tsx\n\ntype TransitionFn<\n  TState extends AnyFunnelState,\n  TNextState extends AnyFunnelState,\n  TRouteOption extends RouteOption\n> = <TName extends TNextState[\"step\"]>(\n  ...args:\n    | TransitionFnArguments<\n        TName,\n        CompareMergeContext<\n          TState[\"context\"],\n          GetFunnelStateByName<TNextState, TName>[\"context\"]\n        >,\n        TRouteOption\n      >\n    | [\n        target: TName,\n        callback: (\n          prev: TState[\"context\"]\n        ) => GetFunnelStateByName<TNextState, TName>[\"context\"],\n        option?: FunnelRouterTransitionOption & TRouteOption\n      ]\n) => Promise<GetFunnelStateByName<TNextState, TName>>\n```\n\n`CompareMergeContext` 타입은 두가지 타입의 속성을 합치는 타입으로 필수 속성으로 변경된 값과 기존에 있거나 새롭게 추가된 선택 속성을 추출해 합치는 타입이다.\n\n`TransitionFn` 타입은 트랜지션 함수를 정의하는 타입으로 인자는 두가지 인터페이스를 사용해 정의하고 있고 반환 타입은 특정 스텝의 상태를 Promise로 반환하는 타입이다. 제네릭을 보면 현재 `TState`와 `TNextState`는 트랜지션 함수의 현재 상태와 다음 상태를 정의하고 있고 `TRouteOption`는 트랜지션 함수의 라우트 옵션을 전달받는다.\n\n인자의 첫번째 방식은 `TransitionFnArguments` 타입을 사용해 특정 스텝의 이름, 스텝의 context, 라우트 옵션으로 구성된다.\nContext를 전달할 때 타입적으로 다음 스텝으로 퍼널 전환할 때 타입적으로 안전하게 context를 전달하게 하기 위해 `CompareMergeContext` 타입을 사용해 정의하고 있다. 비교대상은 `TState[context]` 타입와 `GetFunnelStateByName` 타입을 사용한 다음 스텝의 context로 정의된다.\n\n두번째 방식은 특정 스텝의 이름, 콜백 함수, 라우트 옵션으로 구성된다. 콜백 함수는 이전 스텝의 context를 받아 다음 스텝의 context를 반환하는 함수이다.\n\n이제 히스토리 타입을 보자.\n\n```ts\nexport type FunnelTransition<\n  TStepContextMap extends AnyStepContextMap,\n  TStepKey extends keyof TStepContextMap & string,\n  TRouteOption extends RouteOption\n> = TransitionFn<\n  FunnelState<TStepKey, TStepContextMap[TStepKey]>,\n  {\n    [NextStepKey in keyof TStepContextMap & string]: FunnelState<\n      NextStepKey,\n      TStepContextMap[NextStepKey]\n    >\n  }[keyof TStepContextMap & string],\n  TRouteOption\n>\n\nexport interface FunnelHistory<\n  TStepContextMap extends AnyStepContextMap,\n  TStepKey extends keyof TStepContextMap & string,\n  TRouteOption extends RouteOption\n> {\n  push: FunnelTransition<TStepContextMap, TStepKey, TRouteOption>\n  replace: FunnelTransition<TStepContextMap, TStepKey, TRouteOption>\n  go: (index: number) => void | Promise<void>\n  back: () => void | Promise<void>\n}\n```\n\n`FunnelTransition` 타입은 퍼널의 전환 함수(트랜지션 함수)를 정의하는 타입으로 퍼널의 전환 함수는 퍼널의 상태, 다음 상태, 라우트 옵션으로 구성된다.\n\n`FunnelHistory` 타입은 퍼널의 히스토리를 정의하는 타입으로 퍼널의 히스토리는 퍼널의 상태, 다음 상태, 라우트 옵션을 전달받아 트랜지션 함수를 정의하고 있다.\n우리가 자주보던 `window.history` API와 유사하게 `push`, `replace`, `go`, `back` 메소드를 정의하고 있다. 각 메소드는 FunnelTransition 타입을 통해 정의되어 있다.\n\n공식문서의 예시로 보면 다음과 같다.\n\n```tsx\ndeclare function 이메일입력(props: {\n  onNext: (email: string) => void\n}): JSX.Element\ndeclare function 비밀번호입력(props: {\n  email: string\n  onNext: (password: string) => void\n}): JSX.Element\n\nswitch (funnel.step) {\n  case \"이메일입력\":\n    return (\n      <이메일입력\n        onNext={email => funnel.history.push(\"비밀번호입력\", { email })}\n      />\n    )\n  case \"비밀번호입력\":\n    return (\n      <비밀번호입력\n        email={funnel.context.email} // optional -> required\n        onNext={password =>\n          funnel.history.push(\"그외정보입력\", prev => ({ ...prev, password }))\n        }\n      />\n    )\n}\n```\n\n이메일입력에서 onNext를 보게되면 email 데이터는 필수값으로 전달되고, 비밀번호 입력에서 context.email은 이메일입력에서 입력한 값이 있기 때문에 필수값으로 전달된다.\n\n다음으로 FunnelStep 타입을 보자.\n\n```ts\n// FunnelRender.tsx\n\nexport type FunnelStep<\n  TStepContextMap,  // 전체 스텝 컨텍스트 맵\n  TStepKey,        // 현재 스텝 키\n  TRouteOption     // 라우팅 옵션\n> = {\n  step: TStepKey;                              // 현재 스텝 이름\n  context: TStepContextMap[TStepKey];          // 현재 스텝의 컨텍스트\n  history:FunnelHistory<TStepContextMap, TStepKey, TRouteOption>         // 히스토리 조작 메서드들\n  index: number;                               // 현재 스텝의 인덱스\n  historySteps: FunnelState<...>[];           // 전체 히스토리 스텝들\n};\n\nexport type FunnelStepByContextMap<TStepContextMap extends AnyStepContextMap, TRouteOption extends RouteOption> = {\n  [TStepKey in keyof TStepContextMap & string]: FunnelStep<TStepContextMap, TStepKey, TRouteOption>;\n}[keyof TStepContextMap & string];\n\nexport type FunnelRenderReady<\n  TStepContextMap extends AnyStepContextMap,\n  TRouteOption extends RouteOption,\n> = FunnelStepByContextMap<TStepContextMap, TRouteOption>;\n```\n\n`FunnelStep`은 앞서 정리해온 타입들을 이용해 퍼널 스텝을 정의하는 타입이다. 퍼널 스텝은 `step`, `context`, `history`, `index`, `historySteps`로 구성된다.\n\n`FunnelStepByContextMap` 타입은 contextMap의 키값들을 키로, 값은 퍼널 스텝으로 가지는 객체에서 각 스텝별 FunnelStep 타입을 생성하는 유틸리티 타입을 반환하는 util 타입이다.\n\n`FunnelRenderReady` 타입은 퍼널의 스텝을 정의하는 타입으로 퍼널의 스텝은 퍼널의 상태, 라우트 옵션을 전달받아 퍼널의 스텝을 정의하고 있다.\n\n```ts\n// FunnelRender.tsx\nexport type FunnelRenderOverlayHandler = {\n  close: () => void\n}\n\nexport type RenderResult<\n  TStepContextMap extends AnyStepContextMap,\n  TStepKey extends keyof TStepContextMap & string,\n  TRouteOption extends RouteOption\n> =\n  | {\n      type: \"render\"\n      render: (\n        step: FunnelStep<TStepContextMap, TStepKey, TRouteOption>\n      ) => React.ReactNode\n    }\n  | {\n      type: \"overlay\"\n      render: (\n        step: FunnelStep<TStepContextMap, TStepKey, TRouteOption> &\n          FunnelRenderOverlayHandler\n      ) => React.ReactNode\n    }\n\nexport interface FunnelRenderComponentProps<\n  TStepContextMap extends AnyStepContextMap,\n  TRouteOption extends RouteOption\n> {\n  funnel: FunnelRenderReady<TStepContextMap, TRouteOption>\n  steps: {\n    [TStepKey in keyof TStepContextMap & string]:\n      | RenderResult<TStepContextMap, TStepKey, TRouteOption>\n      | ((\n          step: FunnelStep<TStepContextMap, TStepKey, TRouteOption>\n        ) => React.ReactNode)\n  }\n}\n```\n\n`FunnelRenderOverlayHandler`는 overlay 형식의 컴포넌트를 렌더링할때 사용하는 타입으로 오버레이가 닫힐 때를 위해 close 메소드를 정의하고 있다.\n\n`RenderResult` 타입은 퍼널 타입별로 렌더링함수의 타입을 정의하는 것으로 `render`, `overlay` 두가지 타입을 정의함으로서 이후에 퍼널 타입별로 렌더링함수를 정의할 때 타입적으로 안전하게 정의할 수 있다.\n\n`FunnelRenderComponentProps` 타입은 RenderComponent의 prop을 정의하는 타입으로 퍼널의 렌더 컴포넌트는 퍼널의 스텝을 전달받아 렌더 함수를 정의하고 있다.\n\n```ts\n// useFunnel.tsx\nexport type UseFunnelResults<\n  TStepContextMap extends AnyStepContextMap,\n  TRouteOption extends RouteOption\n> = {\n  Render: ((\n    props: FunnelRenderComponentProps<TStepContextMap, TRouteOption>[\"steps\"]\n  ) => JSX.Element) & {\n    with: typeof renderWith\n    overlay: typeof overlayRenderWith\n  }\n} & FunnelStepByContextMap<TStepContextMap, TRouteOption>\n```\n\n`UseFunnelResults` 타입은 앞서 소개한 타입들을 이용해 훅으로 반환되는 타입으로 `Render` 메소드는 `FunnelRenderComponentProps` 타입으로 prop을 전달받아 컴포넌트를 반환하고,\n`FunnelStepByContextMap` 타입으로 퍼널의 스텝을 반환하게 된다.\n\n실제 useFunnel훅을 사용하는 예제를 보면 다음과 같다.\n\n```tsx\ndeclare function 이메일입력(props: {\n  onNext: (email: string) => void\n}): JSX.Element\n\ndeclare function 비밀번호입력(props: {\n  email: string\n  onNext: (password: string) => void\n}): JSX.Element\n\ndeclare function 그외정보입력(): JSX.Element\n\ntype SignupFunnel = {\n  이메일입력: 이메일입력\n  비밀번호입력: 비밀번호입력\n  그외정보입력: 그외정보입력\n}\n\n// switch문을 사용한 구현\nfunction MyFunnelApp() {\n  const funnel = useFunnel<SignupFunnel>({\n    id: \"my-funnel-app\",\n    initial: {\n      step: \"이메일입력\",\n      context: {},\n    },\n  })\n\n  switch (funnel.step) {\n    case \"이메일입력\":\n      return (\n        <이메일입력\n          onNext={email => funnel.history.push(\"비밀번호입력\", { email })}\n        />\n      )\n\n    case \"비밀번호입력\":\n      return (\n        <비밀번호입력\n          email={funnel.context.email}\n          onNext={password => funnel.history.push(\"그외정보입력\", { password })}\n        />\n      )\n\n    case \"그외정보입력\":\n      return <그외정보입력 />\n  }\n}\n\n// Render 컴포넌트를 사용한 구현\nfunction MyFunnelApp() {\n  const funnel = useFunnel<SignupFunnel>({\n    id: \"my-funnel-app\",\n    initial: {\n      step: \"이메일입력\",\n      context: {},\n    },\n  })\n\n  return (\n    <funnel.Render\n      이메일입력={({ history }) => (\n        <이메일입력 onNext={email => history.push(\"비밀번호입력\", { email })} />\n      )}\n      비밀번호입력={({ context, history }) => (\n        <비밀번호입력\n          email={context.email}\n          onNext={password => history.push(\"그외정보입력\", { password })}\n        />\n      )}\n      그외정보입력={() => <그외정보입력 />}\n    />\n  )\n}\n```\n\n예제를 보면 퍼널 컴포넌트를 만들때 Switch문을 이용해서 각 스텝별로 컴포넌트를 렌더링할 수 있게 할 수 있고, `Render` 컴포넌트를 이용해서 각 스텝별로 컴포넌트를 렌더링할 수 있게 할 수 있다.\n\n그러면 이제 드디어 열심히 정리한 타입들을 이용해 이제 UseFunnel 타입을 만들 수 있다.\n\n```ts\nexport interface UseFunnel<TRouteOption extends RouteOption> {\n  <\n    _TStepContextMap extends AnyStepContextMap,\n    TStepKeys extends keyof _TStepContextMap = keyof _TStepContextMap,\n    TStepContext extends _TStepContextMap[TStepKeys] = _TStepContextMap[TStepKeys],\n    TStepContextMap extends string extends keyof _TStepContextMap\n      ? Record<TStepKeys, TStepContext>\n      : _TStepContextMap = string extends keyof _TStepContextMap\n      ? Record<TStepKeys, TStepContext>\n      : _TStepContextMap\n  >(\n    options: UseFunnelOptions<TStepContextMap>\n  ): UseFunnelResults<TStepContextMap, TRouteOption>\n}\n```\n\n대부분의 타입에 대한 분석은 끝났으니 실 구현부를 보자.\n\n#### FunnelRender\n\nfunnelRender는 Render컴포넌트에 해당되는 컴포넌트에 해당하게 된다.\n\n```tsx\nexport function useUpdatableRef<T>(value: T) {\n  const ref = useRef(value)\n  ref.current = value\n  return ref\n}\n\nfunction useOverwriteFunnelHistoryTransitionArgument<\n  TStepContextMap extends AnyStepContextMap,\n  TStepKey extends keyof TStepContextMap & string,\n  TRouteOption extends RouteOption\n>(\n  history: FunnelHistory<TStepContextMap, TStepKey, TRouteOption>,\n  callback: (\n    step: TStepKey,\n    context?: TStepContextMap[TStepKey],\n    option?: FunnelRouterTransitionOption\n  ) => FunnelRouterTransitionOption\n): FunnelHistory<TStepContextMap, TStepKey, TRouteOption> {\n  const callbackRef = useUpdatableRef(callback)\n\n  return useMemo(() => {\n    return {\n      ...history,\n      push(...args) {\n        const [step, context, option] = args\n        const newOption = callbackRef.current(\n          step as unknown as TStepKey,\n          context as TStepContextMap[TStepKey],\n          option\n        )\n        return (history.push as any)(step, context, newOption)\n      },\n      replace(...args) {\n        const [step, context, option] = args\n        const newOption = callbackRef.current(\n          step as unknown as TStepKey,\n          context as TStepContextMap[TStepKey],\n          option\n        )\n        return (history.replace as any)(step, context, newOption)\n      },\n    }\n  }, [history])\n}\n\nexport function FunnelRender<\n  TStepContextMap extends AnyStepContextMap,\n  TRouteOption extends RouteOption\n>(props: FunnelRenderComponentProps<TStepContextMap, TRouteOption>) {\n  //...\n  const funnelRenderHistory = useOverwriteFunnelHistoryTransitionArgument(\n    funnel.history,\n    (step, _, transitionOption) => {\n      const targetStep = steps[step]\n      const isOverlay =\n        typeof targetStep === \"object\" && targetStep.type === \"overlay\"\n      const newTransitionOption: FunnelRouterTransitionOption = {\n        ...transitionOption,\n        renderComponent: {\n          overlay: isOverlay,\n        },\n      }\n      return newTransitionOption\n    }\n  )\n  //...\n}\n```\n\n`useUpdatableRef` 훅은 컴포넌트가 리렌더링됨에 따라 최신 값을 유지하기 위해 사용되는 훅이다.\n\n`useOverwriteFunnelHistoryTransitionArgument`는 overlay 타입의 스텝을 관리하기 위해 사용되는 훅으로 ovelay 타입인지 체크하고 새로운 트랜지션 옵션을 반환하는 훅이다.\n\n```tsx\nconst { funnel, steps } = props\nconst render = steps[funnel.step]\nlet renderEntires: Array<[keyof TStepContextMap, React.ReactNode]> = []\n\nconst funnelRenderHistory = useOverwriteFunnelHistoryTransitionArgument(\n  funnel.history,\n  (step, _, transitionOption) => {\n    const targetStep = steps[step]\n    const isOverlay =\n      typeof targetStep === \"object\" && targetStep.type === \"overlay\"\n    const newTransitionOption: FunnelRouterTransitionOption = {\n      ...transitionOption,\n      renderComponent: {\n        overlay: isOverlay,\n      },\n    }\n    return newTransitionOption\n  }\n)\n```\n\nprops로 전달받은 steps를 통해 전체 퍼널 스텝 객체를 받고, 현재 스텝을 `funnel.step`으로 받아 현재 스텝에 해당하는 컴포넌트를 받는다.\n`funnelRenderHistory`는 overlay 타입인지 체크하고 새로운 트랜지션 옵션을 반환한다.\n\n`renderEntires`는 현재 스텝과 현재 스텝의 컴포넌트를 배열로 저장하는 변수다.\n\n```tsx\nconst funnelRenderStep = useMemo(() => {\n  return {\n    ...funnel,\n    history: funnelRenderHistory,\n  }\n}, [funnel, funnelRenderHistory])\n\nif (typeof render === \"function\") {\n  renderEntires.push([funnelRenderStep.step, render(funnelRenderStep)])\n} else if (render.type === \"render\") {\n  renderEntires.push([funnelRenderStep.step, render.render(funnelRenderStep)])\n} else if (render.type === \"overlay\") {\n  const beforeSteps = funnelRenderStep.historySteps.slice(\n    0,\n    funnelRenderStep.index\n  )\n  for (const step of beforeSteps.slice().reverse()) {\n    const stepRender = steps[step.step]\n    // NOTE: cannot use history in overlay render before steps\n    if (typeof stepRender === \"function\") {\n      renderEntires.push([\n        step.step,\n        stepRender({\n          ...funnelRenderStep,\n          ...step,\n          history: overlayBeforeHistory,\n        }),\n      ])\n      break\n    } else {\n      renderEntires.push([\n        step.step,\n        stepRender.render({\n          ...funnelRenderStep,\n          ...step,\n          history: overlayBeforeHistory,\n          close: neverUseHistory,\n        }),\n      ])\n      if (stepRender.type === \"render\") {\n        break\n      }\n    }\n  }\n  renderEntires = renderEntires.slice().reverse()\n  renderEntires.push([\n    funnelRenderStep.step,\n    render.render({\n      ...funnelRenderStep,\n      close: funnelRenderHistory.back,\n    }),\n  ])\n}\n```\n\n`funnelRenderStep`은 현재 스텝과 현재 스텝의 히스토리를 합쳐서 반환하는 객체다.\nrenderEntires에 현재 스텝과 현재 스텝의 컴포넌트를 배열로 저장하는데 이때 `render`의 타입에 따라 다르게 저장한다.\n\n- `((step: FunnelStep<TStepContextMap, TStepKey, TRouteOption>) => React.ReactNode)`\n  `render`의 타입이 함수일 경우로 render에 현재 스텝을 전달해 현재 스텝의 컴포넌트를 함께 저장한다.\n\n- `RenderResult`의 타입이 render인 경우\n  `render.render(funnelRenderStep)`을 호출해 현재 스텝의 컴포넌트를 저장한다.\n\n- `RenderResult`의 타입이 overlay인 경우\n  overlay인 경우에는 백그라운드에 이전 스텝의 컴포넌트가 함께 렌더링되어야 하기때문에 조금 복잡한 로직을 통해 이전 스텝의 컴포넌트를 함께 저장한다. 아래에서 조금 더 자세히 보자.\n\n```tsx\nfunction neverUseHistory(): never {\n  throw new Error(\"Cannot use history in overlay render before steps.\")\n}\n\nconst overlayBeforeHistory: FunnelHistory<any, any, any> = {\n  push: neverUseHistory,\n  replace: neverUseHistory,\n  go: neverUseHistory,\n  back: neverUseHistory,\n}\n\nconst beforeSteps = funnelRenderStep.historySteps.slice(\n  0,\n  funnelRenderStep.index\n)\n\nfor (const step of beforeSteps.slice().reverse()) {\n  const stepRender = steps[step.step]\n\n  if (typeof stepRender === \"function\") {\n    renderEntires.push([\n      step.step,\n      stepRender({\n        ...funnelRenderStep,\n        ...step,\n        history: overlayBeforeHistory,\n      }),\n    ])\n    break\n  } else {\n    renderEntires.push([\n      step.step,\n      stepRender.render({\n        ...funnelRenderStep,\n        ...step,\n        history: overlayBeforeHistory,\n        close: neverUseHistory,\n      }),\n    ])\n\n    if (stepRender.type === \"render\") {\n      break\n    }\n  }\n}\n\nrenderEntires = renderEntires.slice().reverse()\n\nrenderEntires.push([\n  funnelRenderStep.step,\n  render.render({\n    ...funnelRenderStep,\n    close: funnelRenderHistory.back,\n  }),\n])\n```\n\ntype이 overlay인 경우 `overlayBeforeHistory`를 정의해 이전 스텝의 잘못된 history 변경을 방지한다. overlay가 직전 스텝인 경우에는 다시 이전 스텝이 필요하기 때문에,\nrender일때만 break한다. 마지막에 현재의 overlay스텝을 entries에 추가하고, overlay close 메소드를 통해 뒤로가기 메소드를 전달한다.\n\n```tsx\nreturn (\n  <Fragment>\n    {renderEntires.map(([step, element]) => (\n      <Fragment key={step.toString()}>{element}</Fragment>\n    ))}\n  </Fragment>\n)\n```\n\n마지막으로 renderEntires를 이용해 정의된 요소들을 렌더링해 반환한다.\n\n```tsx\n// 전체 코드\n\nfunction neverUseHistory(): never {\n  throw new Error(\"Cannot use history in overlay render before steps.\")\n}\n\nconst overlayBeforeHistory: FunnelHistory<any, any, any> = {\n  push: neverUseHistory,\n  replace: neverUseHistory,\n  go: neverUseHistory,\n  back: neverUseHistory,\n}\n\nexport function FunnelRender<\n  TStepContextMap extends AnyStepContextMap,\n  TRouteOption extends RouteOption\n>(props: FunnelRenderComponentProps<TStepContextMap, TRouteOption>) {\n  const { funnel, steps } = props\n  const render = steps[funnel.step]\n  let renderEntires: Array<[keyof TStepContextMap, React.ReactNode]> = []\n\n  const funnelRenderHistory = useOverwriteFunnelHistoryTransitionArgument(\n    funnel.history,\n    (step, _, transitionOption) => {\n      const targetStep = steps[step]\n      const isOverlay =\n        typeof targetStep === \"object\" && targetStep.type === \"overlay\"\n      const newTransitionOption: FunnelRouterTransitionOption = {\n        ...transitionOption,\n        renderComponent: {\n          overlay: isOverlay,\n        },\n      }\n      return newTransitionOption\n    }\n  )\n\n  const funnelRenderStep = useMemo(() => {\n    return {\n      ...funnel,\n      history: funnelRenderHistory,\n    }\n  }, [funnel, funnelRenderHistory])\n\n  if (typeof render === \"function\") {\n    renderEntires.push([funnelRenderStep.step, render(funnelRenderStep)])\n  } else if (render.type === \"render\") {\n    renderEntires.push([funnelRenderStep.step, render.render(funnelRenderStep)])\n  } else if (render.type === \"overlay\") {\n    const beforeSteps = funnelRenderStep.historySteps.slice(\n      0,\n      funnelRenderStep.index\n    )\n    for (const step of beforeSteps.slice().reverse()) {\n      const stepRender = steps[step.step]\n      // NOTE: cannot use history in overlay render before steps\n      if (typeof stepRender === \"function\") {\n        renderEntires.push([\n          step.step,\n          stepRender({\n            ...funnelRenderStep,\n            ...step,\n            history: overlayBeforeHistory,\n          }),\n        ])\n        break\n      } else {\n        renderEntires.push([\n          step.step,\n          stepRender.render({\n            ...funnelRenderStep,\n            ...step,\n            history: overlayBeforeHistory,\n            close: neverUseHistory,\n          }),\n        ])\n        if (stepRender.type === \"render\") {\n          break\n        }\n      }\n    }\n    renderEntires = renderEntires.slice().reverse()\n    renderEntires.push([\n      funnelRenderStep.step,\n      render.render({\n        ...funnelRenderStep,\n        close: funnelRenderHistory.back,\n      }),\n    ])\n  }\n\n  return (\n    <Fragment>\n      {renderEntires.map(([step, element]) => (\n        <Fragment key={step.toString()}>{element}</Fragment>\n      ))}\n    </Fragment>\n  )\n}\n\nfunction useOverwriteFunnelHistoryTransitionArgument<\n  TStepContextMap extends AnyStepContextMap,\n  TStepKey extends keyof TStepContextMap & string,\n  TRouteOption extends RouteOption\n>(\n  history: FunnelHistory<TStepContextMap, TStepKey, TRouteOption>,\n  callback: (\n    step: TStepKey,\n    context?: TStepContextMap[TStepKey],\n    option?: FunnelRouterTransitionOption\n  ) => FunnelRouterTransitionOption\n): FunnelHistory<TStepContextMap, TStepKey, TRouteOption> {\n  const callbackRef = useUpdatableRef(callback)\n\n  return useMemo(() => {\n    return {\n      ...history,\n      push(...args) {\n        const [step, context, option] = args\n        const newOption = callbackRef.current(\n          step as unknown as TStepKey,\n          context as TStepContextMap[TStepKey],\n          option\n        )\n        return (history.push as any)(step, context, newOption)\n      },\n      replace(...args) {\n        const [step, context, option] = args\n        const newOption = callbackRef.current(\n          step as unknown as TStepKey,\n          context as TStepContextMap[TStepKey],\n          option\n        )\n        return (history.replace as any)(step, context, newOption)\n      },\n    }\n  }, [history])\n}\n```\n\n#### createUseFunnel\n\n이제 코어 패키지의 찐 본채인 `createUseFunnel`을 분석해보자.\n\n```tsx\n\nexport interface FunnelRouterOption<TState extends AnyFunnelState> {\n  id: string;\n  initialState: TState;\n}\n\nexport interface FunnelRouterTransitionOption {\n  renderComponent?: {\n    overlay: boolean;\n  };\n}\n\nexport interface FunnelRouterResult<TRouteOption extends RouteOption> {\n  history: AnyFunnelState[];\n  currentIndex: number;\n  push: (state: AnyFunnelState, option?: FunnelRouterTransitionOption & TRouteOption) => void | Promise<void>;\n  replace: (state: AnyFunnelState, option?: FunnelRouterTransitionOption & TRouteOption) => void | Promise<void>;\n  go: (index: number) => void | Promise<void>;\n  cleanup: () => void;\n}\n\nexport interface FunnelRouter<TRouteOption extends RouteOption> {\n  (option: FunnelRouterOption<AnyFunnelState>): FunnelRouterResult<TRouteOption>;\n}\n\nexport function createUseFunnel<TRouteOption extends RouteOption>(\n  useFunnelRouter: FunnelRouter<TRouteOption>\n): UseFunnel<TRouteOption> {\n```\n\n`useFunnelRouter`는 패키지별로 전달할 Router로 `FunnelRouterOption`을 전달받아 `FunnelRouterResult`를 반환하는 함수다.\n**Core 패키지로 전달되는 Routing 패키지들의 인터페이스**가 된다.\n\n`FunnelRouterOption`에는 앞서 사용예시에서 전달하던 `id`와 `initialState`가 있고, `FunnelRouterResult`에는 `history`, `currentIndex`, `push`, `replace`, `go`, `cleanup` 있다.\n\n`createUseFunnel`은 한마디로 말하면 라우팅 패키지들(`useFunnelRouter`)을 전달받아 현재 상태를 관리하고, `UseFunnelResult`를 반환하는 함수다.\n\n```tsx\n return function useFunnel<\n    _TStepContextMap extends AnyStepContextMap,\n    TStepKeys extends keyof _TStepContextMap = keyof _TStepContextMap,\n    TStepContext extends _TStepContextMap[TStepKeys] = _TStepContextMap[TStepKeys],\n    TStepContextMap extends string extends keyof _TStepContextMap\n    ? Record<TStepKeys, TStepContext>\n    : _TStepContextMap = string extends keyof _TStepContextMap ? Record<TStepKeys, TStepContext> : _TStepContextMap,\n  >(options: UseFunnelOptions<TStepContextMap>): UseFunnelResults<TStepContextMap, TRouteOption> {\n    const optionsRef = useUpdatableRef(options);\n    const router = useFunnelRouter({\n      id: optionsRef.current.id,\n      initialState: optionsRef.current.initial,\n    });\n    const currentState = (router.history[router.currentIndex] ??\n      options.initial) as FunnelStateByContextMap<TStepContextMap>;\n    const currentStateRef = useUpdatableRef(currentState);\n```\n\n`createUseFunnel`은 `useFunnel`함수를 반환하는데 이때 앞서 전달했던 타입들이 제네릭으로 정의되게 된다.\n\n`optionsRef`는 최신 옵션값을 참조하게 되고, `router`에 해당 옵션을 전달해 라우팅 패키지들을 통해 퍼널 상태를 관리하게 된다.\n\n`currentState`는 현재상태를, 비어있다면 옵션의 `initialState`를 참조하게 되고, `currentStateRef`는 이러한 현재 상태를 참조해 항상 최신 상태를 참조하게 된다.\n\n```tsx\nconst cleanUpRef = useUpdatableRef(router.cleanup)\n\nuseEffect(() => {\n  return () => {\n    cleanUpRef.current()\n  }\n}, [])\n```\n\n`cleanUpRef`는 패키지별로 정의된 `cleanup` 메소드를 가져와서 unmount시 실행한다.\n\n```tsx\nconst parseStepContext = useCallback(\n  <TStep extends keyof TStepContextMap>(\n    step: TStep,\n    context: unknown\n  ): TStepContextMap[TStep] | null => {\n    const stepOption = optionsRef.current.steps?.[step]\n    if (stepOption == null) {\n      return context as TStepContextMap[TStep]\n    }\n    // 1. check parse function\n    if (funnelStepOptionIsParse(stepOption)) {\n      return stepOption.parse(context)\n    }\n    // 2. check guard function\n    if (funnelStepOptionIsGuard(stepOption)) {\n      return stepOption.guard(context) ? context : null\n    }\n    return null\n  },\n  [optionsRef]\n)\n```\n\n`parseStepContext`는 `steps` 옵션의 `guard`, `parse` 함수를 통해 현재 상태를 파싱하는 함수다.\n\n```tsx\nconst history: FunnelHistory<\n  TStepContextMap,\n  keyof TStepContextMap & string,\n  TRouteOption\n> = useMemo(() => {\n  const transition = (\n    step: keyof TStepContextMap,\n    assignContext?: object | ((prev: object) => object)\n  ) => {\n    const newContext =\n      typeof assignContext === \"function\"\n        ? assignContext(currentStateRef.current.context)\n        : {\n            ...currentStateRef.current.context,\n            ...assignContext,\n          }\n    const context = parseStepContext(step, newContext)\n    return context == null\n      ? optionsRef.current.initial\n      : ({\n          step,\n          context,\n        } as FunnelStateByContextMap<TStepContextMap>)\n  }\n  return {\n    push: async (...args) => {\n      const [step, assignContext, transitionOption] = args\n      const nextState = transition(step, assignContext)\n      await router.push(nextState, transitionOption)\n      return nextState as never\n    },\n    replace: async (...args) => {\n      const [step, assignContext, transitionOption] = args\n      const nextState = transition(step, assignContext)\n      await router.replace(nextState, transitionOption)\n      return nextState as never\n    },\n    go: router.go,\n    back: () => router.go(-1),\n  }\n}, [router.replace, router.push, router.go, optionsRef, parseStepContext])\n```\n\n`history`는 현재 상태를 파싱하고, 현재 상태를 전달해 다음 상태를 만들어 라우팅 패키지별로 정의된 `transition` 메소드에 정의한다.\n\n`currentStateRef`를 통해 최신 현재 상태를 참조하게 한 이유로 비동기로 호출되더라도 최신값을 조회할 수 있게 된다.\n\n`transition` 메소드에서는 `parseStepContext`를 통해 현재 상태를 파싱하게 된다.\n\n```tsx\nconst step: FunnelStep<\n  TStepContextMap,\n  keyof TStepContextMap & string,\n  TRouteOption\n> = useMemo(() => {\n  const validContext = parseStepContext(currentState.step, currentState.context)\n  return {\n    ...(validContext == null\n      ? optionsRef.current.initial\n      : {\n          step: currentState.step,\n          context: validContext,\n        }),\n    history,\n    index: router.currentIndex,\n    historySteps: router.history as FunnelStateByContextMap<TStepContextMap>[],\n  }\n}, [\n  currentState,\n  history,\n  router.history,\n  router.currentIndex,\n  parseStepContext,\n])\n```\n\n`step`은 현재 상태에 대한 context가 유효한지 확인하고, 유효하다면 현재 상태를 전달해 `UseFunnelResult`의 `step`, `context`, `history`, `index`, `historySteps`를 전달하는 변수다.\n\n```tsx\nexport function useStateSubscriberStore<T>(state: T) {\n  const stateRef = useUpdatableRef(state);\n\n  const stateStoreRef = useRef<Store<T>>({\n    listeners: [],\n    subscribe(listeners) {\n      this.listeners.push(listeners);\n      return () => {\n        this.listeners = this.listeners.filter((fn) => fn !== listeners);\n      };\n    },\n    getSnapshot() {\n      return stateRef.current;\n    },\n  });\n\n  useEffect(() => {\n    for (const listener of stateStoreRef.current.listeners) {\n      listener();\n    }\n  }, [state]);\n\n  return stateStoreRef;\n}\n\nexport function useStateStore<T>(subscriberRef: MutableRefObject<Store<T>>) {\n  const [state, setState] = useState(() => subscriberRef.current.getSnapshot());\n\n  useEffect(() => {\n    return subscriberRef.current.subscribe(() => {\n      setState(subscriberRef.current.getSnapshot());\n    });\n  }, [subscriberRef]);\n\n  return state;\n}\n\n\nconst currentStepStoreRef = useStateSubscriberStore(step);\n\nconst Render = useMemo(() => {\n  return Object.assign(\n    (props: FunnelRenderComponentProps<TStepContextMap, TRouteOption>['steps']) => {\n      const currentStep = useStateStore(currentStepStoreRef)\n      return <FunnelRender funnel={currentStep} steps={props} />\n      },\n      {\n        with: renderWith,\n        overlay: overlayRenderWith,\n      }\n    )\n  }, [currentStepStoreRef])\n\n  return {\n    ...step,\n    Render,\n  }\n}\n```\n\n`useStateSubscriberStore`는 `useSyncExternalStore`와 동일하게 state를 참조하고, 변경될때마다 리스너를 호출하는 함수다.\n\n`Render`는 현재 상태를 참조하고, 현재 상태를 전달해 `FunnelRender` 컴포넌트를 렌더링하는 함수다.\n이때 `Object.assign`을 통해 `FunnelRender` 컴포넌트에 `with`와 `overlay` 옵션을 할당하게 된다.\n\n```tsx\n// 전체 코드\nexport function createUseFunnel<TRouteOption extends RouteOption>(\n  useFunnelRouter: FunnelRouter<TRouteOption>\n): UseFunnel<TRouteOption> {\n  return function useFunnel<\n    _TStepContextMap extends AnyStepContextMap,\n    TStepKeys extends keyof _TStepContextMap = keyof _TStepContextMap,\n    TStepContext extends _TStepContextMap[TStepKeys] = _TStepContextMap[TStepKeys],\n    TStepContextMap extends string extends keyof _TStepContextMap\n      ? Record<TStepKeys, TStepContext>\n      : _TStepContextMap = string extends keyof _TStepContextMap\n      ? Record<TStepKeys, TStepContext>\n      : _TStepContextMap\n  >(\n    options: UseFunnelOptions<TStepContextMap>\n  ): UseFunnelResults<TStepContextMap, TRouteOption> {\n    const optionsRef = useUpdatableRef(options)\n    const router = useFunnelRouter({\n      id: optionsRef.current.id,\n      initialState: optionsRef.current.initial,\n    })\n    const currentState = (router.history[router.currentIndex] ??\n      options.initial) as FunnelStateByContextMap<TStepContextMap>\n    const currentStateRef = useUpdatableRef(currentState)\n\n    const cleanUpRef = useUpdatableRef(router.cleanup)\n\n    useEffect(() => {\n      return () => {\n        cleanUpRef.current()\n      }\n    }, [])\n\n    const parseStepContext = useCallback(\n      <TStep extends keyof TStepContextMap>(\n        step: TStep,\n        context: unknown\n      ): TStepContextMap[TStep] | null => {\n        const stepOption = optionsRef.current.steps?.[step]\n        if (stepOption == null) {\n          return context as TStepContextMap[TStep]\n        }\n        // 1. check parse function\n        if (funnelStepOptionIsParse(stepOption)) {\n          return stepOption.parse(context)\n        }\n        // 2. check guard function\n        if (funnelStepOptionIsGuard(stepOption)) {\n          return stepOption.guard(context) ? context : null\n        }\n        return null\n      },\n      [optionsRef]\n    )\n\n    const history: FunnelHistory<\n      TStepContextMap,\n      keyof TStepContextMap & string,\n      TRouteOption\n    > = useMemo(() => {\n      const transition = (\n        step: keyof TStepContextMap,\n        assignContext?: object | ((prev: object) => object)\n      ) => {\n        const newContext =\n          typeof assignContext === \"function\"\n            ? assignContext(currentStateRef.current.context)\n            : {\n                ...currentStateRef.current.context,\n                ...assignContext,\n              }\n        const context = parseStepContext(step, newContext)\n        return context == null\n          ? optionsRef.current.initial\n          : ({\n              step,\n              context,\n            } as FunnelStateByContextMap<TStepContextMap>)\n      }\n      return {\n        push: async (...args) => {\n          const [step, assignContext, transitionOption] = args\n          const nextState = transition(step, assignContext)\n          await router.push(nextState, transitionOption)\n          return nextState as never\n        },\n        replace: async (...args) => {\n          const [step, assignContext, transitionOption] = args\n          const nextState = transition(step, assignContext)\n          await router.replace(nextState, transitionOption)\n          return nextState as never\n        },\n        go: router.go,\n        back: () => router.go(-1),\n      }\n    }, [router.replace, router.push, router.go, optionsRef, parseStepContext])\n\n    const step: FunnelStep<\n      TStepContextMap,\n      keyof TStepContextMap & string,\n      TRouteOption\n    > = useMemo(() => {\n      const validContext = parseStepContext(\n        currentState.step,\n        currentState.context\n      )\n      return {\n        ...(validContext == null\n          ? optionsRef.current.initial\n          : {\n              step: currentState.step,\n              context: validContext,\n            }),\n        history,\n        index: router.currentIndex,\n        historySteps:\n          router.history as FunnelStateByContextMap<TStepContextMap>[],\n      }\n    }, [\n      currentState,\n      history,\n      router.history,\n      router.currentIndex,\n      parseStepContext,\n    ])\n\n    const currentStepStoreRef = useStateSubscriberStore(step)\n\n    const Render = useMemo(() => {\n      return Object.assign(\n        (\n          props: FunnelRenderComponentProps<\n            TStepContextMap,\n            TRouteOption\n          >[\"steps\"]\n        ) => {\n          const currentStep = useStateStore(currentStepStoreRef)\n          return <FunnelRender funnel={currentStep} steps={props} />\n        },\n        {\n          with: renderWith,\n          overlay: overlayRenderWith,\n        }\n      )\n    }, [currentStepStoreRef])\n\n    return {\n      ...step,\n      Render,\n    }\n  }\n}\n```\n\n분석을 하면서 실 구현부 보다 타입정의가 복잡하게 느껴졌다. 코어 라이브러리의 핵심은 현재 스텝, 옵션의 최신 상태를 참조하고, 다음 상태를 만들어 라우팅 패키지별로 정의된 transition 메소드에 전달하는 것으로 정리할 수 있다.\n\n그러면 마지막으로 라우팅 패키지로 많이 사용하는 next 패키지를 분석해보려 한다.\n\n### next 패키지 분석하기\n\nnext는 현재 15버전 기준 `App router`를 지원한다. 분석하려는 패키지는 `Page router`를 기준으로 작성하려 하고, 공식문서를 보면 `App Router`는 `Browser` 패키지를 이용할 것을 권장하고 있다.\n\n![설치하기의 app router 관련 안내](install.png)\n\n```tsx\nconst QS_KEY = \"funnel.\"\n\nconst STEP_KEY = \".step\"\nconst CONTEXT_KEY = \".context\"\nconst HISTORY_KEY = \".histories\"\n\nconst checkIsHistoryKey = (key: string) =>\n  key.startsWith(QS_KEY) && key.endsWith(HISTORY_KEY)\n```\n\n먼저 상단의 변수들을 보면 퍼널의 QueryString으로 사용될 키들이 정의되어 있다.\n`checkIsHistoryKey`는 해당 키가 히스토리 키인지 확인하는 함수다. 왜 별도로 히스토리 키를 체크하는 유틸함수가 있는지는 아래에서 설명하려 한다.\n\n```tsx\nexport const TestPagesRouterFunnel = () => {\n  const funnel = useFunnel<FunnelState>({\n    id: FUNNEL_ID,\n    initial: { step: \"start\", context: {} },\n  })\n\n  return (\n    <funnel.Render\n      start={({ history }) => (\n        <div>\n          <p>start</p>\n\n          <button onClick={() => history.push(\"middle\", { a: \"1\" })}>\n            next\n          </button>\n        </div>\n      )}\n      middle={({ history }) => (\n        <div>\n          <p>middle</p>\n          <button onClick={() => history.push(\"end\", { a: \"1\", b: \"2\" })}>\n            next\n          </button>\n        </div>\n      )}\n      end={() => (\n        <div>\n          <p>end</p>\n        </div>\n      )}\n    />\n  )\n}\n```\n\n위 예제를 실행해보면 `http://localhost:3101?funnel.test.step=end&funnel.test.context=%7B%22a%22%3A%221%22%2C%22b%22%3A%222%22%7D` 와 같은 형태로 생성되는 것을 확인할 수 있다.\n\n```tsx\ninterface NextPageRouteOption {\n  shallow?: boolean\n  locale?: string | false\n  scroll?: boolean\n}\n\nexport const useFunnel = createUseFunnel<NextPageRouteOption>(({ id, initialState }) => {\n```\n\n`NextPageRouteOption`은 [Next.js의 페이지 옵션 타입](https://nextjs.org/docs/pages/api-reference/functions/use-router#routerpush)으로 `shallow, locale, scroll` 옵션을 전달받는다.\n\nuseFunnel은 앞서 코어 패키지를 분석하면서 보았던 `createUseFunnel`에 next page router에 맞춰 생성된 함수를 전달한다.\n`FunnelRouter<TRouteOption>` 타입으로 전달되는데 앞서 코어 패키지를 분석하면서 `FunnelRouterOption`을 파라미터로 `FunnelRouterResult`를 반환한다.\n\n전달된 타입을 작성해보면 다음과 같다.\n\n```tsx\ninterface NextPageRouteOption {\n  shallow?: boolean\n  locale?: string | false\n  scroll?: boolean\n}\n\ninterface FunnelRouterResult<NextPageRouteOption> {\n  history: AnyFunnelState[]\n  currentIndex: number\n  push: (\n    state: AnyFunnelState,\n    option?: FunnelRouterTransitionOption & NextPageRouteOption\n  ) => void | Promise<void>\n  replace: (\n    state: AnyFunnelState,\n    option?: FunnelRouterTransitionOption & NextPageRouteOption\n  ) => void | Promise<void>\n  go: (index: number) => void | Promise<void>\n  cleanup: () => void\n}\n\nexport interface FunnelRouter<NextPageRouteOption> {\n  (\n    option: FunnelRouterOption<AnyFunnelState>\n  ): FunnelRouterResult<NextPageRouteOption>\n}\n\nexport function createUseFunnel<NextPageRouteOption>(\n  useFunnelRouter: FunnelRouter<NextPageRouteOption>\n): UseFunnel<NextPageRouteOption>\n```\n\n다른 라이브러리들에도 마찬가지로 RouterOption을 전달받을 것으로 예상할 수 있다.\n\n```tsx\nconst router = useRouter()\n\nconst currentContext = useMemo(() => {\n    try {\n      const currentStep = router.query?.[`${QS_KEY}${id}${STEP_KEY}`] as\n        | string\n        | undefined\n      const currentContext = router.query?.[`${QS_KEY}${id}${CONTEXT_KEY}`] as\n        | string\n        | undefined\n      return currentStep == null || currentContext == null\n        ? initialState\n        : { step: currentStep, context: JSON.parse(currentContext) }\n    } catch {\n      return initialState\n    }\n  }, [router.query, initialState])\n\n  const _beforeHistories = router.query?.[`${QS_KEY}${id}${HISTORY_KEY}`]\n  const beforeHistories = useMemo<(typeof initialState)[]>(() => {\n    try {\n      return _beforeHistories == null\n        ? []\n        : JSON.parse(_beforeHistories as string)\n    } catch {\n      return []\n    }\n    }, [_beforeHistories])\n\n  const currentIndex = beforeHistories.length\n}\n```\n\n`router`는 Next.js의 useRouter 훅을 통해 현재 라우터 객체를 참조하게 된다.\n\n`currentContext`는 앞서 정의한 queryString 키들을 통해 현재 상태를 참조하고, `beforeHistories`를 이용해 histories 상태들을 참조하게 된다.\n\n`currentIndex`는 현재 스텝의 인덱스를 의미한다.\n\n```tsx\nreturn useMemo(\n  () => ({\n    history: [...beforeHistories, currentContext],\n    currentIndex,\n    async push(state, { scroll, locale, shallow = true } = {}) {\n      const { pathname, query } = makePath(router)\n      const queryContext = {\n        [`${QS_KEY}${id}${STEP_KEY}`]: state.step,\n        [`${QS_KEY}${id}${CONTEXT_KEY}`]: JSON.stringify(state.context),\n      }\n\n      await router.push(\n        {\n          pathname,\n          query: {\n            ...query,\n            [`${QS_KEY}${id}${HISTORY_KEY}`]: JSON.stringify([\n              ...beforeHistories,\n              currentContext,\n            ]),\n            ...queryContext,\n          },\n        },\n        {\n          pathname,\n          query: { ...removeKeys(query, [checkIsHistoryKey]), ...queryContext },\n        },\n        {\n          shallow,\n          locale,\n          scroll,\n        }\n      )\n    },\n    async replace(state, { scroll, locale, shallow = true } = {}) {\n      const { pathname, query } = makePath(router)\n      const queryContext = {\n        [`${QS_KEY}${id}${STEP_KEY}`]: state.step,\n        [`${QS_KEY}${id}${CONTEXT_KEY}`]: JSON.stringify(state.context),\n      }\n\n      await router.replace(\n        {\n          pathname,\n          query: {\n            ...query,\n            ...queryContext,\n          },\n        },\n        {\n          pathname,\n          query: { ...removeKeys(query, [checkIsHistoryKey]), ...queryContext },\n        },\n        {\n          shallow,\n          locale,\n          scroll,\n        }\n      )\n    },\n    go: index => window.history.go(index),\n    async cleanup() {\n      const { pathname, query } = makePath(router)\n      const queryContext = {\n        [`${QS_KEY}${id}${STEP_KEY}`]: undefined,\n        [`${QS_KEY}${id}${CONTEXT_KEY}`]: undefined,\n      }\n\n      await router.replace(\n        {\n          pathname,\n          query: {\n            ...query,\n            ...queryContext,\n          },\n        },\n        {\n          pathname,\n          query: { ...removeKeys(query, [checkIsHistoryKey]), ...queryContext },\n        },\n        {\n          shallow: true,\n        }\n      )\n    },\n  }),\n  [id, router, currentIndex, beforeHistories, currentContext]\n)\n```\n\n각 메소드를 보게되면 `FunnelRouterResult`의 메소드에 맞춰 작성되어 있다.\n\n```tsx\n\n//utils.ts\nexport const removeKeys = (_value: Record<string, any>, conditions: (string | ((key: string) => boolean))[]) => {\n  const value = { ..._value };\n  const valueKeys = Object.keys(value);\n\n  conditions.forEach((condition) => {\n    if (typeof condition === 'string') {\n      delete value[condition];\n    } else {\n      valueKeys.forEach((key) => {\n        if (condition(key)) {\n          delete value[key];\n        }\n      });\n    }\n  });\n\n  return value;\n};\n\nexport const makePath = (router: Pick<NextRouter, 'asPath' | 'pathname' | 'query'>) => {\n  const { asPath, query: _query } = router;\n  const query = { ..._query };\n\n  const pathname = asPath.split('?')[0];\n\n  const pathVariables = [...router.pathname.matchAll(/\\[(.+?)\\]/g)].map((match) => match[1]); // 동적 라우트 변수를 추출\n\n  pathVariables.forEach((variable) => {\n    delete query[variable];\n  });\n\n  return { pathname, query };\n};\n\n// ...\nasync push(state, { scroll, locale, shallow = true } = {}) {\n      const { pathname, query } = makePath(router)\n      const queryContext = {\n        [`${QS_KEY}${id}${STEP_KEY}`]: state.step,\n        [`${QS_KEY}${id}${CONTEXT_KEY}`]: JSON.stringify(state.context),\n      }\n\n      await router.push(\n        {\n          pathname,\n          query: {\n            ...query,\n            [`${QS_KEY}${id}${HISTORY_KEY}`]: JSON.stringify([\n              ...beforeHistories,\n              currentContext,\n            ]),\n            ...queryContext,\n          },\n        },\n        {\n          pathname,\n          query: { ...removeKeys(query, [checkIsHistoryKey]), ...queryContext },\n        },\n        {\n          shallow,\n          locale,\n          scroll,\n        }\n      )\n    },\n    async replace(state, { scroll, locale, shallow = true } = {}) {\n      const { pathname, query } = makePath(router)\n      const queryContext = {\n        [`${QS_KEY}${id}${STEP_KEY}`]: state.step,\n        [`${QS_KEY}${id}${CONTEXT_KEY}`]: JSON.stringify(state.context),\n      }\n\n      await router.replace(\n        {\n          pathname,\n          query: {\n            ...query,\n            ...queryContext,\n          },\n        },\n        {\n          pathname,\n          query: { ...removeKeys(query, [checkIsHistoryKey]), ...queryContext },\n        },\n        {\n          shallow,\n          locale,\n          scroll,\n        }\n      )\n    },\n```\n\n`makePath`는 현재 라우터의 pathname과 query를 참조하고, `removeKeys`는 특정 조건에 따라 쿼리스트링에서 키를 제거하는 함수다.\n\n`makePath`를 통해 query를 추출할때 동적 라우트 변수가 있는 경우 해당 변수를 제거해, 보다 명확하게 funnel 관련 query만 관리하기 위한 것으로 보였다.\n\n`push, replace`를 보게되면 context를 `JSON.stringify`를 통해 문자열로 변환해 쿼리스트링에 전달하는 것을 확인할 수 있다.\n\n![next router push interface](push-interface.png)\n\n이때 `push`와 `replace`의 두번째 파라미터에는 `as`로 실제 path와 다르게 보여질 수 있게 할 수 있다.\n예시로 가져왔던 `http://localhost:3101?funnel.test.step=end&funnel.test.context=%7B%22a%22%3A%221%22%2C%22b%22%3A%222%22%7D`로 query상태를 조회하면 history가 감춰져 있는 것을 볼 수 있다.\n\n![query state](query-state.png)\n\nremoveKeys를 통해 history 키를 제거하는 것을 확인할 수 있다.\n\n`push`는 현재 상태에 새로운 step과 context를 전달하고, `replace`는 현재 상태에 히스토리 변화없이 새로운 step과 context를 전달한다.\n\n```tsx\n{\n  // 브라우저 히스토리 이동\n  go: (index) => window.history.go(index),\n\n  // 퍼널 상태 초기화\n  async cleanup() {\n    // 현재 경로 정보 가져오기\n    const { pathname, query } = makePath(router);\n\n    // 퍼널 관련 쿼리 파라미터 제거\n    const queryContext = {\n      [`${QS_KEY}${id}${STEP_KEY}`]: undefined,\n      [`${QS_KEY}${id}${CONTEXT_KEY}`]: undefined,\n    };\n\n    // 라우터 상태 업데이트\n    await router.replace(\n      {\n        pathname,\n        query: {\n          ...query,\n          ...queryContext,\n        },\n      },\n      {\n        pathname,\n        query: {\n          ...removeKeys(query, [checkIsHistoryKey]),\n          ...queryContext,\n        },\n      },\n      {\n        shallow: true,\n      }\n    );\n  },\n}\n```\n\n`go`는 `window.history.go(index)`를 통해 히스토리를 이동하고, `cleanup`은 퍼널 관련 쿼리 파라미터를 제거하고 히스토리를 초기화한다. 코어 로직에서 봤듯이 해당 컴포넌트가 unmount될때 호출되는 것을 확인할 수 있다.\n\n이렇게 별도의 패키지로 분리해 두었기 때문에 이후에 다른 라우팅 라이브러리가 나오더라도 쉽게 구현할 수 있는 확장성을 가지고 있다.\n\n### 정리\n\n`useFunnel`은 퍼널 상태를 관리하는 훅으로, 퍼널 상태를 초기화하고 히스토리를 이동하는 기능을 제공한다.\n구버전 `useFunnel`은 퍼널과 데이터를 따로 관리해야하는 점과 타입적으로 정확하게 추론하기 어려웠던 점이 있었고, next와 강한 결합으로 react-native, react-router-dom과 같은 라우터에서 사용할 수 없었다.\n\n이러한 문제점을 해결하기 위해 새로운 useFunnel이 등장하게 되었다. 보다 정확한 타입 추론과 여러가지 라우터를 지원할 수 있도록 개선되었고, 오버레이를 하나의 퍼널스텝으로도 사용할 수 있는 등 다양한 기능을 제공한다.\n\n내부 코드를 보면서 엄청난 타입 정의에 대해 놀랐다. 덕분에 타입스크립트도 함께 공부할 수 있었고, 앞으로 퍼널을 구현할 때 더 자신감을 가지고 사용할 수 있을 것 같다.\n\n위 예제는 next의 page router에 대한 구현만 작성했지만 이후에 React Native 환경, Next App router에 대해서 작업을 하면서 정리해가려 한다.\n"},{"excerpt":"2024년 12월은 토스에서 2번째 달로, 글을 작성하는 현재 off-week 기간으로 조금 빠르게 회고를 작성하고 있다. 다른 달보다 근무 일수는 적었지만, 처음 동료평가를 받아보고, 사업자 환급금 서비스, 연말정산 미리보기 서비스 등을 개발하며 많은 것을 배웠던 한달이었다.\n12월을 정리하며 토스 적응기 2달차에 대해 기록해보려 한다. 12월은 연말정…","fields":{"slug":"/2024-12-27-2024년-12월회고/"},"frontmatter":{"date":"December 27, 2024","title":"2024년 12월 회고, bye bye 2024","tags":["회고","toss"]},"rawMarkdownBody":"\n2024년 12월은 토스에서 2번째 달로, 글을 작성하는 현재 off-week 기간으로 조금 빠르게 회고를 작성하고 있다.\n\n다른 달보다 근무 일수는 적었지만, 처음 동료평가를 받아보고, 사업자 환급금 서비스, 연말정산 미리보기 서비스 등을 개발하며 많은 것을 배웠던 한달이었다.\n12월을 정리하며 토스 적응기 2달차에 대해 기록해보려 한다.\n\n## 12월은 연말정산의 달\n\n환급액 두배 이벤트 이후로 새롭게 진행한 서비스로 `연말정산 미리보기` 서비스를 개발해 빠르게 런칭하게 되었다.\n\n연말에 직장인과 사업자 모두가 궁금해하는 시즌성 서비스였기 때문에 기존의 기능들을 최대한 살려서 빠르게 런칭하는 것이 중요했고, 그과정에서 세금 도메인과 프로젝트 구조를 더 이해하게 되었다.\n\n코드를 보면서 사용자는 굉장히 편하게 느끼지만, 그 편안함을 위해 개발자들은 얼마나 많은 노력을 했는지 알 수 있었다. 다양한 유저별 상황과 조건에 맞게 제품을 만들고, 그안에서 속도를 내기 위해 노력한 흔적을 보며 많이 배울 수 있었다.\n\n제품을 만들면서 숨이 차오른다(?)는 느낌을 받았지만, 그러다 보니 하면 좋은 일들과 중요한 일들의 위계를 세우는 것이 중요하다는 것, 왜 토스에서 Focus on Impact라는 문화를 가지고 있는지 느낄 수 있었다.\n\n필수 기능들에 대해 빠르게 개발하고, 서비스를 런칭한 후에 추가 개선점들을 개선하는 빠른 이터레이션을 진행해 더 좋은 제품을 만들 수 있었다.\n\n이렇게 런칭한 제품은 [뉴스 기사](https://www.etnews.com/20241121000231)로 소개되었고 현재까지도 좋은 반응을 이끌어내고 있다.\n\n![연말정산 미리보기 기사](annualSettlement.png)\n\n첫달에 했던 환급액 두배 이벤트는 잘될 줄 알았지만 생각보다 반응이 미적지근했고, 반면 연말정산 미리보기는 개인적으로 이미 유사한 서비스들이 토스 내에도 있었기 때문에 큰 기대는 없었지만 좋은 반응을 받게 되면서, 두 달안에 토스 내의 성공과 실패(?)를 모두 경험하는 좋은 기회를 얻을 수 있었다.\n\n다음 달은 또 어떤 일들이 있을지 더 많은 것을 배워나갈 수 있기를 바라본다.\n\n## 토스에서의 첫 피드백\n\n토스로 이직 후 처음으로 동료평가를 받아보게 되었다. 토스의 회사 문화중 솔직한 피드백을 중요시한다고 알고 있었기 때문에, 살짝 두려움이 있었지만 매일같이 함께 일하는 사일로 팀원분들의 솔직한 피드백을 받아보며 좋은 경험을 할 수 있었다.\n\n![토스의 문화](toss-culture.png)\n\n토스의 피드백은 문화를 근거로 이야기하게 되는데 여기서 가장 많이 공통적으로 받았던 부분은 `Move with Urgency`와 `Learn proactively`였다.\n\n공통적인 설명은 한달 반이라는 기간 내에 빠르게 적응하고 제품을 만들어 팀에 기여했다는 점과 팀과 회사의 적응을 위한 점들을 먼저 물어보고 배워나갔던 점에 대해서 좋은 평가를 해주셨다.\n\n입사를 하고 적응을 하면서 현재 팀의 내 자리는 특수성이 있었다고 느껴졌다. 매출을 내고 있는 팀이기 때문에 기대를 받는 팀이라는 점, 세금이라는 다소 어려운 맥락을 가진 제품이라는 점 등 다른 팀에 대해 잘 모르지만 주변의 이야기를 들으면서 어느정도 차이가 있다고 느껴졌다.\n\n그렇기 때문에 적응기간을 줄이고 빠르게 팀에 기여하는 것이 중요하다고 느껴서 최대한 제품을 이해하기 위해 노력했고, 모르는 것이나 중간 중간 1대 1로 밥을 먹거나하면서 어떻게 하면 잘 적응할 수 있을지, 내가 더 잘하기 위해서 어떤 점을 신경쓰면 좋을지 등 질문을 적극적으로 했던 부분들이 긍정적으로 평가되었던 것 같다.\n\n앞으로 더 잘할 수 있으면 좋을 부분들은 내가 가진 판단을 통해 팀과 조직에 영향력이 있다면 적극적으로 제안하는 것과 주도적으로 의견을 내는 부분이었다.\n\n그래서 1월부터의 액션아이템으로 현재 우리 서비스에서 보완되면 좋겠다고 느끼는 점들을 적극적으로 제안해보려 한다.\n\n두려웠지만 잘 적응하고 좋은 팀과 좋은 제품을 만들어가고 있다는 것, 한명의 토스 사람으로서 좋은 팀원이 되고 있다는 것을 느낄 수 있었다.\n\n## 사업자 환급금 서비스\n\n토스는 플랫폼으로서 많은 회사들과 협업하는 경우가 많다. 예를 들어 금융상품에서는 한국투자증권 등의 금융회사들도 있고, 토스 인슈런스는 보험사들과도 긴밀하게 협력하는 등 다양한 회사들과 협업하게 된다.\n\n사업자 환급금은 내가 처음 맡은 제휴사 협력 서비스였다. 제휴사와 협업하면서 다른 회사의 제품을 어떻게 연결할지 우리가 해줘야할 부분과 제휴사에 요청해야할 부분 등 다양한 부분을 고려해 서비스를 만들어야 했다.\n\n서로 개발해온 방식과 테스트 환경 등이 다르다보니 생각보다 의사소통에 많은 시간이 소요되었고, 이런 부분들을 해결하며 서비스를 만들어나가는 것이 중요하다는 것을 느낄 수 있었다.\n\n또한, 사업자 환급 서비스는 긴 퍼널은 아니었지만, 누군가가 만들어둔 서비스를 기반으로 개발하는 게 아니라, 처음부터 개발하는 경험을 할 수 있었다.\n\n기존 개발 환경과 달리 SSR로 개발하면서 SSR에서 주의해야할 점들 (서버에서 실행 시 window가 없다는 점 등) 등을 배울 수 있었고, [이전 slash 영상](https://www.youtube.com/watch?v=IKyA8BKxpXc)과 다른 SSR로 개발된 서비스 코드들을 분석하면서 SSR에서의 데이터 패칭 방식등을 배울 수 있었다.\n\nSSR로 개발하면서 특히 좋았던 점은 서버에서 redirection 로직을 처리할 수 있다. CSR이었다면 유저에게 화면을 보여주고 리다이렉션이 이루어야 하기 때문에 잠시의 깜빡임과 로딩 시간이 필수적이지만, 서버에서 응답에 따라 바로 리다이렉션을 해주다보니 굉장한 장점으로 느껴졌다.\n\nSSR의 단점은 아니지만 내가 길러야 할 새로운 역량으로 서버를 모니터링하고 디버깅 능력이 필요해졌다.\n\n토스의 프론트 개발자로서 조금씩 더 성장해갈 수 있었던 시간으로 좋은 경험을 할 수 있었다.\n\n## 다음 한달의 목표\n\n이전 한달의 목표들은 아래와 같았다.\n\n- [ ] 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기\n- [x] 토스 프론트엔드 라이브러리 분석하기\n- [x] 사내 라이브러리에 기여하기\n\n이중 첫번째 부분은 아직 직접 작업에 대해 제시하고 작업해보지 못했다. off-week동안 조금 더 좋은 서비스가 되기 위해 필요한 부분들에 고민해보고 1월에는 꼭 직접 작업해보고 피드백을 받아보고 싶다.\n\n두번째, 세번째 목표는 함께 진행중에 있다. 사내 라이브러리 작업에 contributor로 참여하게 되어 진행하고 있고, 이과정에서 다양한 라이브러리 코드에 대해 분석이 필요해 자연스럽게 진행할 수 있었다.\n\n아직 진행하지 못했거나 진행중이기 때문에 다음 한달의 목표도 이전 한달과 동일하게 잡아보려 한다.\n\n- 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기\n- 사내 라이브러리 적극적으로 기여하기\n\n이중 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기의 작업할 부분으로 성능 분석과 에러 모니터링 등 운영상 제품의 안정성에 기여할 수 있을 만한 부분들을 고려하고 있다.\n\n생각만 하기보다 행동을 하는 한달이 되기를 다음 달에는 더 많은 것을 배워나갈 수 있기를 바란다.\n"},{"excerpt":"11월은 토스로 이직한 지 첫 달이었고, 새로운 사람들, 새로운 문화, 새로운 코드 등 모든 게 새로웠던 한달이었다. 아직 적응 중이지만 한달간 겪었던, 토스의 모습과 내가 배웠던 것들을 기록해보려 한다. 내가 경험한 토스 사람들 팀에 처음 배치되었을 때 놀랐던 부분은 팀원들이 굉장히 적극적으로 도와주려 하는 모습이었다. 메이트 분은 거의 매일같이 30분…","fields":{"slug":"/2024-12-01-2024년-11월회고/"},"frontmatter":{"date":"December 01, 2024","title":"2024년 11월 회고, welcome to 토스","tags":["회고"]},"rawMarkdownBody":"\n11월은 토스로 이직한 지 첫 달이었고, 새로운 사람들, 새로운 문화, 새로운 코드 등 모든 게 새로웠던 한달이었다.\n\n아직 적응 중이지만 한달간 겪었던, 토스의 모습과 내가 배웠던 것들을 기록해보려 한다.\n\n## 내가 경험한 토스 사람들\n\n팀에 처음 배치되었을 때 놀랐던 부분은 팀원들이 굉장히 적극적으로 도와주려 하는 모습이었다.\n\n메이트 분은 거의 매일같이 30분씩 어려움이 없는지 기술적, 문화적 어려움을 같이 해결해주시려 해주셨고, 팀원 분들 모두가 온보딩 과정에서 필요하거나 질문이 있을 때 빠르게 도와주시는 모습을 보며 감사했다.\n\n그와 함께 팀원 모두 자신이 하는 일에 대해 굉장히 몰입되어 있고, 왜 이일을 하는지 또는 진행하고 있는 일의 목적이 무엇인지에 대해 근본적인 질문을 누구에게 물어도 PM, 디자이너, 개발자 상관없이 명확하게 답해주는 모습을 보며 놀랐다.\n\n이전 회사에서 개발자로서 일하면서 '주어진 것을 잘 만드는 것'에 조금 더 많이 고민을 하며 일을 했지만, 토스는 일을 하면서 왜 이일을 하는지 또는 진행하고 있는 일의 목적이 무엇인지에 대해 근본적인 질문에 대해 서로를 설득할 수 있어야하고, 확실한 목적을 가지고 일을 하는 것 같았다.\n\n동시에 이러한 납득이 되고 난 후에는 빠르게 제품의 이터레이션을 돌리며, 유저의 피드백을 받아 제품을 발전시키는 문화를 경험할 수 있었다.\n\n그리고 팀의 빠른 속도를 위해서 서로가 병목이 되지 않게 필요한 부분에 대해서는 서스럼없이 도움을 요청하거나 의견을 묻다보니 일을 하면서 답답함이 없다는 점이 좋았다.\n\n이러한 속도를 보면서 아직 미숙한 내가 팀의 속도를 더디게 하지 않을까 걱정되기도 했지만, 다행히 팀원 분들이 나에게 많은 도움을 주시며 적응하는 데 도움을 주셨다.\n\n점점 더 팀의 속도에 기여할 수 있기를, 또한 토스팀의 중요한 문화인 DRI를 발휘해서 내가 생각하는 지금 제품에 필요한 부분에 대해 의견을 제시하고 책임지고 결정해보는 것을 다음 한달의 목표로 잡으려 한다.\n\n## 첫 서비스 개발 - 환급액 2배 이벤트\n\n내가 맡게된 서비스는 토스의 '숨은 환급액 찾기' 서비스로, 유저가 납부한 세금에 대해서 돌려받을 수 있는 환급액을 찾아주는 서비스이다.\n\n해당 서비스의 디자인들을 보고 제품을 분석하면서 놀랐던 부분은 압도당할 만큼 복잡한 퍼널이었다.\n\n![토스ㅣSLASH 23 - 퍼널: 쏟아지는 페이지 한 방에 관리하기 영상 내용중 일부](use-funnel.png)\n\n입사전에 slash 발표 영상을 봤을 때 발표자분이 엄청나게 복잡한 제품을 만드셔서 이렇게 디자인이 나왔구나 모두 이렇게 복잡하지는 않겠지 했지만, 내가 담당한 숨은 환급액 찾기 서비스 또한 만만치 않게 복잡한 퍼널이었다.\n\n세금이라는 복잡한 개념에 대해 유저들이 이해할 수 있도록 논리적으로 퍼널들이 나열되어있었고, 시간이 꽤 필요했지만 실제 사용해보면서 디자인과 전체 플로우에 대한 이해도를 높일 수 있었다.\n\n해당 제품에 가장 먼저 담당한 기능은 '환급액 2배 이벤트'였다. 게임 형식으로 뽑기를 진행하고 당첨시 2배 환급을 진행하는 이벤트로, 유저들의 인플로우를 늘리는 이벤트였다. 백엔드 개발자분께서 말씀해주신 것에 따르면\n팀 내에서 진행했던 이벤트 중에서 가장 복잡했던 이벤트였다고 한다.\n\n작업을 하면서 혹시 나로 인해서 기간이 많이 미뤄지지 않을까, 놓친 요구사항들로 인해서 장애가 나지 않을까 걱정했지만 다행히도 메이트분의 도움으로 계속해서 제품 이해도와 코드베이스를 높여갔고,\n팀원 모두가 함께 QA를 해주시면서 다행히 안정적으로 배포될 수 있었다.\n\n해당 이벤트가 배포되고 난 후에 또 놀랐던 점은 내가 작업한 이벤트가 [뉴스 기사](https://www.etnews.com/20241121000231)로 나오게 되었다는 점이었다.\n\n![환급액 2배 이벤트 기사](double-refund.png)\n\n이전 회사에서는 팀이 열심히 작업한 기능을 유저가 모르고 사용하지 않아, 데이터적으로 분석하거나 더 나은 제품을 만드는 데 피드백을 받기 어려웠는데 토스는 굉장히 적극적으로 유저들에게 제품을 알리고 피드백을 받아 제품을 발전시키는 문화를 가지고 있구나 생각이 들었다.\n\n토스는 정말 안타나 번트를 대는게 아니라 모두가 홈런을 치게 밀어준다는 문화를 경험할 수 있었다.\n\n## 프론트엔드 코드 베이스에 익숙해지기\n\n토스 프론트엔드 개발자로서 새로운 코드 베이스에 익숙해지기 위해서 우선 제품의 여러 코드를 보고 분석했다.\n\n다행히 토스의 디자인 시스템은 프론트엔드 멘토링 과정을 통해서 한달간 사용하다 보니 조금 더 자연스럽게 사용할 수 있었고, 다양한 라이브러리\n를 사용하는데 어려움이 있으면 여러 채널을 통해 질문할 수 있었다.\n\n특히 사내 문서가 잘 되어 있었고, 최근 [토스 기술 블로그](https://toss.tech/article/toss-frontend-ai-docs)에 소개된 `박씨`라는 봇이 있기 때문에 24시간 편하게 질문할 수 있어 좋았다.\n\n![토스 프론트엔드 개발자들이 더 이상 문서를 찾지 않는 이유중 일부](bot.png)\n\n또한 추가적인 노력으로 사내 문서의 히스토리를 보면서 어떤 주제들을 중요하게 생각하는지 찾아 이번 달은 [패키지 매니저](https://choi2021.github.io/2024-11-18-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%A7%A4%EB%8B%88%EC%A0%80/)에 대해 공부하고 정리하며 글을 작성했고, 사내 오픈소스인 [overlay kit](https://github.com/toss/overlay-kit)에 대해 [분석하는 글](https://choi2021.github.io/2024-11-24-overlay-kit-%EB%B6%84%EC%84%9D/)을 작성했다.\n\n앞으로도 하나씩 조금씩 더 깊이 있게 코드 베이스에 익숙해져 이후에는 기여하는 것까지를 목표로 하고 있다.\n\n## 다음 한달의 목표\n\n이번 한달은 사람, 문화, 건물 모든 것에 새롭게 적응해야 했지만, 다음 한달은 조금 더 여유를 갖고 제품에 대해 더 깊이 있게 이해하고 기여할 수 있기를 바라며 다음 한달의 목표를 정해보았다.\n\n- 숨은 환급액 찾기 제품 내 개선할 부분 제시하고 작업해보기\n- 토스 프론트엔드 라이브러리 분석하기\n- 사내 라이브러리에 기여하기\n\n현재 사일로 내에서 개선할 부분에 대해서 제시하고 직접 작업하고 유저에게 기술적 문제를 해결했을 때 어떤 피드백을 받을 수 있는지 경험해보고 싶고, 토스 프론트엔드 라이브러리를 분석하고 기여해보며 토스 프론트엔드 개발자로서 동료로서 성장할 수 있기를 바란다.\n"},{"excerpt":"overlay-kit은 토스의 오픈소스 프로젝트로 모바일 제품을 만들면서 자주 사용하는 바텀시트, 다이얼로그 컴포넌트를 으로 관리할 수 있도록 도와주는 패키지이다. 해당 패키지의 사용법과 내부 구현을 분석해보면서 어떤 문제를 해결하고자 만들어졌는지 알아보자. Overlay Kit이 해결하고 싶은 문제 모바일 제품을 만들면서 한정적인 화면 크기로 인해 추가…","fields":{"slug":"/2024-11-24-overlay-kit-분석/"},"frontmatter":{"date":"November 24, 2024","title":"Overlay Kit 분석","tags":["frontend","open-source","toss","react"]},"rawMarkdownBody":"\n[overlay-kit](https://overlay-kit.slash.page/ko/introduction.html)은 토스의 오픈소스 프로젝트로 모바일 제품을 만들면서 자주 사용하는 바텀시트, 다이얼로그 컴포넌트를 `선언적`으로 관리할 수 있도록 도와주는 패키지이다.\n\n해당 패키지의 사용법과 내부 구현을 분석해보면서 어떤 문제를 해결하고자 만들어졌는지 알아보자.\n\n## Overlay Kit이 해결하고 싶은 문제\n\n모바일 제품을 만들면서 한정적인 화면 크기로 인해 추가 정보를 받거나, 보여주기 위해 바텀시트와 다이얼로그와 같은 overlay 컴포넌트를 자주 사용하게 된다.\n\n이러한 overlay 컴포넌트를 사용하고 만드는 방법으로 가장 일반적인 방법은 `상태를 직접 관리하는 방식`으로 isOpen에 따라 컴포넌트를 보여주고 보여주지 않게 변경해 구현할 수 있다.\n\n```jsx\n// 패키지 데모의 state를 이용한 예시\nfunction DemoWithState() {\n  const [isOpen, setIsOpen] = useState(false)\n\n  return (\n    <div>\n      <p>Demo with useState</p>\n      <button onClick={() => setIsOpen(true)}>open modal</button>\n      <Modal isOpen={isOpen}>\n        <div\n          style={{\n            display: \"flex\",\n            flexDirection: \"column\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n          }}\n        >\n          <p>MODAL CONTENT</p>\n          <button onClick={() => setIsOpen(false)}>close modal</button>\n        </div>\n      </Modal>\n    </div>\n  )\n}\n```\n\n![state를 직접 관리하는 방식](demo-state.gif)\n\n문제 없이 잘 동작하는 코드이지만, 다음과 같은 문제점이 있다.\n\n1. overlay 컴포넌트가 늘어남에 따라 isOpen 상태에 대한 보일러 플레이트 코드가 많아진다.\n2. isOpen 상태의 선언(useState), 변경(onClick), 사용하는 곳(Modal)이 흩어져 있어 코드 가독성이 떨어져보인다.\n\n이러한 부분은 더 많은 overlay 컴포넌트를 관리해야할 때 더욱 문제가 되게 된다.\n\noverlay kit은 해당 문제들을 열고닫는 동작을 선언적으로 관리함으로서 해결한다. 아래는 overlay kit을 이용해 같은 요구사항을 구현한 예시이다.\n\n```jsx\nfunction DemoWithEsOverlay() {\n  return (\n    <div>\n      <p>Demo with overlay-kit</p>\n      <button\n        onClick={() => {\n          overlay.open(({ isOpen, close, unmount }) => {\n            return (\n              <Modal isOpen={isOpen} onExit={unmount}>\n                <div\n                  style={{\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    alignItems: \"center\",\n                    justifyContent: \"center\",\n                  }}\n                >\n                  <p>MODAL CONTENT</p>\n                  <button onClick={close}>close modal</button>\n                </div>\n              </Modal>\n            )\n          })\n        }}\n      >\n        open modal\n      </button>\n    </div>\n  )\n}\n```\n\n![overlay kit을 이용한 예시](demo-overlay.gif)\n\n앞선 예제와는 다르게 상태를 별도로 선언하지 않아도 되고, 상태의 선언과, 변경, 사용하는 곳이 하나로 관리되기 때문에 코드 가독성이 좋아진다.\n\n이제 해당 패키지의 내부 구현을 살펴보면서 어떻게 이러한 기능을 구현되어있는지 알아보자.\n\n## 패키지 분석하기\n\noverlay kit 패키지를 다운받아서 내부 구조를 보게 되면 아래와 같은 구조를 확인할 수 있다.\n\n![overlay kit 패키지 구조](overlay-kit-structure.png)\n\n생각보다 굉장히 간단하게 구성되어있는 것을 볼 수 있는데 하나하나 한번 살펴보자.\n\n### package.json\n\n가장 먼저 package.json보면 다음과 같은 내용이 있다.\n\n```json\n{\n  // ...\n  \"dependencies\": {\n    \"use-sync-external-store\": \"^1.2.2\"\n  },\n  // ...\n  \"peerDependencies\": {\n    \"react\": \"^16.8.0 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.0 || ^17.0.0 || ^18.0.0\"\n  }\n}\n```\n\n[공식문서](https://overlay-kit.slash.page/ko/installation.html)를 보면 react 16.8 버전부터 지원하고 있으며, 18버전부터 추가된 useSyncExternalStore를 지원하기 위해서 별도의 dependency로 추가하고 있는 것으로 볼 수 있다.\n\n![overlay kit 지원버전](overlay-kit-support-version.png)\n\nuseSyncExternalStore는 react 18에서 추가된 hook으로 javascript로 구현된 외부 상태를 구독할 수 있도록 도와주는 hook으로 제품을 개발할 때 사용하기 보다 JS 변수의 변화를 리액트의 렌더링으로 연결할 때, 특히 상태관리 라이브러리에서 내부적으로 사용되고 있다.\n\n```js\n// zustand의 useStore 구현부\nexport function useStore<TState, StateSlice>(\n  api: ReadonlyStoreApi<TState>,\n  selector: (state: TState) => StateSlice = identity as any,\n) {\n  const slice = React.useSyncExternalStore(\n    api.subscribe,\n    () => selector(api.getState()),\n    () => selector(api.getInitialState()),\n  )\n  return slice\n}\n```\n\nuseSyncExternalStore의 내부 구현을 살펴보면 다음과 같다.\n\n```js\n// useSyncExternalStore 내부 구현\nimport * as React from \"react\"\nimport is from \"shared/objectIs\"\n\nconst { useState, useEffect, useLayoutEffect } = React\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T\n): T {\n  const value = getSnapshot()\n  const [{ inst }, forceUpdate] = useState({ inst: { value, getSnapshot } })\n\n  useLayoutEffect(() => {\n    inst.value = value\n    inst.getSnapshot = getSnapshot\n\n    if (checkIfSnapshotChanged(inst)) {\n      forceUpdate({ inst })\n    }\n  }, [subscribe, value, getSnapshot])\n\n  useEffect(() => {\n    if (checkIfSnapshotChanged(inst)) {\n      forceUpdate({ inst })\n    }\n    const handleStoreChange = () => {\n      if (checkIfSnapshotChanged(inst)) {\n        forceUpdate({ inst })\n      }\n    }\n    return subscribe(handleStoreChange)\n  }, [subscribe])\n\n  return value\n}\n\nfunction checkIfSnapshotChanged<T>(inst: {\n  value: T,\n  getSnapshot: () => T,\n}): boolean {\n  const latestGetSnapshot = inst.getSnapshot\n  const prevValue = inst.value\n  try {\n    const nextValue = latestGetSnapshot()\n    return !is(prevValue, nextValue)\n  } catch (error) {\n    return true\n  }\n}\n```\n\nuseSyncExternalStore의 내부 구현을 분석해보면 `getSnapshot` 함수를 통해 외부 상태의 현재 값을 읽어오고 `subscribe` 함수를 통해 외부 상태의 변경을 구독하며, 외부 상태가 변경될 때마다 `getSnapshot`의 반환값을 이전 값과 비교하여 값이 변경되었다면 컴포넌트를 리렌더링하는 방식으로 동작한다.\n\n리액트에서 리렌더링을 발생시키기 위해서는 상태가 변경되어야 하기 때문에, 외부 상태의 변경을 구독하여 외부 상태가 변경될 때마다 컴포넌트를 리렌더링하는 방식으로 리액트와 javascript 상태가 연결되는 것을 알 수 있다.\n\n그러면 overlay kit에서는 어떻게 사용되고 있는지 살펴보자.\n\n### store.ts\n\nstore.ts 파일을 살펴보면 다음과 같은 내용이 있다.\n\n```typescript\nimport { type OverlayControllerComponent } from \"./provider\"\nimport { type OverlayReducerAction, overlayReducer } from \"./reducer\"\n\ntype OverlayId = string\n\nexport type OverlayItem = {\n  id: OverlayId\n  isOpen: boolean\n  controller: OverlayControllerComponent\n}\n\nexport type OverlayData = {\n  current: OverlayId | null\n  overlayOrderList: OverlayId[]\n  overlayData: Record<OverlayId, OverlayItem>\n}\n\nlet overlays: OverlayData = {\n  current: null,\n  overlayOrderList: [],\n  overlayData: {},\n}\n\nlet listeners: Array<() => void> = []\n\nfunction emitChangeListener() {\n  for (const listener of listeners) {\n    listener()\n  }\n}\n\nexport function dispatchOverlay(action: OverlayReducerAction) {\n  overlays = overlayReducer(overlays, action)\n  emitChangeListener()\n}\n\nexport const registerOverlaysStore = {\n  subscribe(listener: () => void) {\n    listeners = [...listeners, listener]\n\n    return () => {\n      listeners = listeners.filter(l => l !== listener)\n    }\n  },\n  getSnapshot() {\n    return overlays\n  },\n}\n```\n\n#### OverlayItem과 OverlayData 인터페이스\n\n```typescript\ntype OverlayId = string\n\nexport type OverlayItem = {\n  id: OverlayId\n  isOpen: boolean\n  controller: OverlayControllerComponent\n}\n\nexport type OverlayData = {\n  current: OverlayId | null\n  overlayOrderList: OverlayId[]\n  overlayData: Record<OverlayId, OverlayItem>\n}\n```\n\nOverlayItem은 id, isOpen, controller로 구성된다.\n\n- id: overlay 식별자\n- isOpen: overlay 열림/닫힘 상태\n- controller: overlay로 보여줄 컴포넌트\n\nOverlayData는 current, overlayOrderList, overlayData로 구성된다.\n\n- current: 현재 상위 노출되는 overlay id\n- overlayOrderList: 현재 메모리에 등록된 오버레이 목록\n- overlayData: id를 키로 사용하는 각 오버레이의 상세 데이터\n\n이러한 데이터 구조를 통해 오버레이 상태를 관리하고 있는 것을 알 수 있다.\n\n#### overlay 상태관리\n\n사용처에서 노출되지 않던 overlay 상태관리는 아래와 같이 구현되어있다.\n\n```typescript\nlet overlays: OverlayData = {\n  current: null,\n  overlayOrderList: [],\n  overlayData: {},\n}\nlet listeners: Array<() => void> = []\n\nfunction emitChangeListener() {\n  for (const listener of listeners) {\n    listener()\n  }\n}\n\nexport function dispatchOverlay(action: OverlayReducerAction) {\n  overlays = overlayReducer(overlays, action)\n  emitChangeListener()\n}\n\nexport const registerOverlaysStore = {\n  subscribe(listener: () => void) {\n    listeners = [...listeners, listener]\n\n    return () => {\n      listeners = listeners.filter(l => l !== listener)\n    }\n  },\n  getSnapshot() {\n    return overlays\n  },\n}\n```\n\n상태는 overlays 변수를 통해 관리되고 있고, 변수의 변경사항의 현재 값을 반환하는 getSnapshot 함수를 통해 현재 상태를 조회하고 달라질 때마다 useSyncExternalStore를 통해 리렌더링이 일어나게 된다.\n\nlisteners 변수에는 상태가 변경될 때마다 실행할 콜백 함수를 보관하는 배열로, 앞서 설명한 useSyncExternalStore 내부 구현의 useEffect에서 forceUpdate를 통해 리렌더링시키는 함수가 해당 배열에 추가된다.\n\n이후에 dispatchOverlay를 통해 등록된 콜백함수가 실행되면서 reducer를 통해 overlays 변수의 값이 변경되면(checkIfSnapshotChanged가 true) 이에 따라 리렌더링이 발생하게 된다.\n\n```jsx\n// useSyncExternalStore 내부 구현의 useEffect 일부\nuseEffect(() => {\n  if (checkIfSnapshotChanged(inst)) {\n    forceUpdate({ inst })\n  }\n  const handleStoreChange = () => {\n    if (checkIfSnapshotChanged(inst)) {\n      forceUpdate({ inst })\n    }\n  }\n  return subscribe(handleStoreChange)\n}, [subscribe])\n```\n\n### useSyncOverlayStore와 OverlayProvider\n\n이제 위에서 정의한 registerOverlaysStore를 통해 오버레이 상태를 관리하는 useSyncOverlayStore와 오버레이 컴포넌트를 렌더링하는 OverlayProvider를 살펴보자.\n\n```jsx\n// useSyncOverlayStore\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\"\nimport { registerOverlaysStore } from \"./store\"\n\nexport function useSyncOverlayStore() {\n  const { subscribe, getSnapshot } = registerOverlaysStore\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n}\n\n// OverlayProvider\nimport { type FC, useEffect, useRef, type PropsWithChildren } from \"react\"\nimport { OverlayContextProvider } from \"./context\"\nimport { dispatchOverlay } from \"./store\"\nimport { useSyncOverlayStore } from \"./use-sync-overlay-store\"\nimport { overlay } from \"../event\"\n\nexport function OverlayProvider({ children }: PropsWithChildren) {\n  const overlayState = useSyncOverlayStore()\n\n  useEffect(() => {\n    return () => {\n      dispatchOverlay({ type: \"REMOVE_ALL\" })\n    }\n  }, [])\n\n  return (\n    <OverlayContextProvider value={overlayState}>\n      {children}\n      {overlayState.overlayOrderList.map(item => {\n        const {\n          id: currentOverlayId,\n          isOpen,\n          controller: currentController,\n        } = overlayState.overlayData[item]\n\n        return (\n          <ContentOverlayController\n            key={currentOverlayId}\n            isOpen={isOpen}\n            current={overlayState.current}\n            overlayId={currentOverlayId}\n            onMounted={() => {\n              requestAnimationFrame(() => {\n                dispatchOverlay({ type: \"OPEN\", overlayId: currentOverlayId })\n              })\n            }}\n            onCloseModal={() => overlay.close(currentOverlayId)}\n            onExitModal={() => overlay.unmount(currentOverlayId)}\n            controller={currentController}\n          />\n        )\n      })}\n    </OverlayContextProvider>\n  )\n}\n\ntype OverlayControllerProps = {\n  overlayId: string\n  isOpen: boolean\n  close: () => void\n  unmount: () => void\n}\n\ntype OverlayAsyncControllerProps<T> = Omit<OverlayControllerProps, \"close\"> & {\n  close: (param: T) => void\n}\n\nexport type OverlayControllerComponent = FC<OverlayControllerProps>\nexport type OverlayAsyncControllerComponent<T> = FC<\n  OverlayAsyncControllerProps<T>\n>\n\ntype ContentOverlayControllerProps = {\n  isOpen: boolean\n  current: string | null\n  overlayId: string\n  onMounted: () => void\n  onCloseModal: () => void\n  onExitModal: () => void\n  controller: OverlayControllerComponent\n}\n\nfunction ContentOverlayController({\n  isOpen,\n  current,\n  overlayId,\n  onMounted,\n  onCloseModal,\n  onExitModal,\n  controller: Controller,\n}: ContentOverlayControllerProps) {\n  const prevCurrent = useRef(current)\n  const onMountedRef = useRef(onMounted)\n\n  /**\n   * @description Executes when closing and reopening an overlay without unmounting.\n   */\n  if (prevCurrent.current !== current) {\n    prevCurrent.current = current\n\n    if (current === overlayId) {\n      onMountedRef.current()\n    }\n  }\n\n  useEffect(() => {\n    onMountedRef.current()\n  }, [])\n\n  return (\n    <Controller\n      overlayId={overlayId}\n      isOpen={isOpen}\n      close={onCloseModal}\n      unmount={onExitModal}\n    />\n  )\n}\n```\n\nuseSyncOverlayStore는 registerOverlaysStore를 구독하고 현재 상태를 반환하는 함수로, 이를 통해 오버레이 상태를 구독할 수 있다.\n\n```jsx\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\"\nimport { registerOverlaysStore } from \"./store\"\n\nexport function useSyncOverlayStore() {\n  const { subscribe, getSnapshot } = registerOverlaysStore\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n}\n```\n\n이렇게 만들어진 useSyncOverlayStore는 OverlayProvider에서 사용되어 오버레이 상태를 구독하고 있는 것을 볼 수 있다.\n\nOverlayProvider는 오버레이 상태를 구독하고 있는 useSyncOverlayStore를 통해 현재 상태를 읽어와 오버레이 컴포넌트를 렌더링하는 역할을 한다. 내부 코드를 보면 unMount 또는 리렌더링이 일어날때 기존 오버레이들을 닫는 action을 발생시키고, 오버레이 목록을 순회하며 오버레이 컴포넌트를 렌더링하는데 children으로 전달받은 컴포넌트 밑에 렌더링함으로서 기존 페이지 컴포넌트 상위에 그려질 수 있게 한다.\n\n```jsx\nexport function OverlayProvider({ children }: PropsWithChildren) {\n  const overlayState = useSyncOverlayStore()\n\n  useEffect(() => {\n    return () => {\n      dispatchOverlay({ type: \"REMOVE_ALL\" })\n    }\n  }, [])\n\n  return (\n    <OverlayContextProvider value={overlayState}>\n      {children}\n      {overlayState.overlayOrderList.map(item => {\n        const {\n          id: currentOverlayId,\n          isOpen,\n          controller: currentController,\n        } = overlayState.overlayData[item]\n\n        return (\n          <ContentOverlayController\n            key={currentOverlayId}\n            isOpen={isOpen}\n            current={overlayState.current}\n            overlayId={currentOverlayId}\n            onMounted={() => {\n              requestAnimationFrame(() => {\n                dispatchOverlay({ type: \"OPEN\", overlayId: currentOverlayId })\n              })\n            }}\n            onCloseModal={() => overlay.close(currentOverlayId)}\n            onExitModal={() => overlay.unmount(currentOverlayId)}\n            controller={currentController}\n          />\n        )\n      })}\n    </OverlayContextProvider>\n  )\n}\n```\n\nContentOverlayController는 overlay 상태에 있는 오버레이 컴포넌트를 주입받아 렌더링하는데 오버레이 컴포넌트로 정의된 인터페이스의 isOpen, close, unmount를 overlayState에서 prop으로 전달받아 사용하게 된다.\n\n내부적으로 onMounted, onCloseModal, onExitModal로 정의된 이벤트 액션을 오버레이 컴포넌트에 전달하는 것을 볼 수 있다.\n\n이때 onMounted에는 requestAnimationFrame을 open 이벤트를 발생시키는데, 컴포넌트 내부에서는 ref를 활용해 불필요한 렌더링을 방지하면서 해당 이벤트를 처리하고 있다. requestAnimationFrame을 이용하기 때문에 브라우저의 렌더링 타이밍에 맞춰 최적화된 시점에 실행되게 구현되어 있다.\n\n추가적으로 OverlayAsyncControllerProps를 정의해 비동기로 처리할 수 있도록 하고 있다.\n\n```jsx\n\ntype OverlayControllerProps = {\n  overlayId: string\n  isOpen: boolean\n  close: () => void\n  unmount: () => void\n}\n\ntype OverlayAsyncControllerProps<T> = Omit<OverlayControllerProps, \"close\"> & {\n  close: (param: T) => void\n}\n\nexport type OverlayControllerComponent = FC<OverlayControllerProps>\nexport type OverlayAsyncControllerComponent<T> = FC<\n  OverlayAsyncControllerProps<T>\n>\n\ntype ContentOverlayControllerProps = {\n  isOpen: boolean\n  current: string | null\n  overlayId: string\n  onMounted: () => void\n  onCloseModal: () => void\n  onExitModal: () => void\n  controller: OverlayControllerComponent\n}\n\nfunction ContentOverlayController({\n  isOpen,\n  current,\n  overlayId,\n  onMounted,\n  onCloseModal,\n  onExitModal,\n  controller: Controller,\n}: ContentOverlayControllerProps) {\n  const prevCurrent = useRef(current)\n  const onMountedRef = useRef(onMounted)\n\n  /**\n   * @description Executes when closing and reopening an overlay without unmounting.\n   */\n  if (prevCurrent.current !== current) {\n    prevCurrent.current = current\n\n    if (current === overlayId) {\n      onMountedRef.current()\n    }\n  }\n\n  useEffect(() => {\n    onMountedRef.current()\n  }, [])\n\n  return (\n    <Controller\n      overlayId={overlayId}\n      isOpen={isOpen}\n      close={onCloseModal}\n      unmount={onExitModal}\n    />\n  )\n}\n```\n\n그러면 ContentOverlayController에 전달하는 이벤트들과 액션들에 대해 알아보자.\n\n### Reducer와 Event\n\n위 섹션에서 정리한 ContentOverlayController에 전달하던 액션들은 event.ts에 정의되어있다.\n\n앞서 useSyncStore로 연결한 이벤트를 모두 실행시키는 dispatchOverlay 함수를 통해서 open, close, unmount, closeAll, unmountAll, openAsync 함수들이 정의되어있다.\n\ndispatchOverlay 함수 내부에는 현재상태인 overlays와 액션을 받아 reducer를 통해 overlays 변수의 값을 변경하고, 변경된 값을 반환하고 변경된 상태를 구독하는 리스너들에게 알리는 emitChangeListener 함수를 호출하는 것을 볼 수 있다.\n\n```jsx\nexport function dispatchOverlay(action: OverlayReducerAction) {\n  overlays = overlayReducer(overlays, action)\n  emitChangeListener()\n}\n```\n\n#### Reducer.ts\n\nreducer를 보게되면 전달받은 상태와 액션에 따라 상태를 변경해 반환하는 것을 볼 수 있다. 이러한 패턴은 Redux에서 자주보는 Flux 패턴을 따르고 있는 것을 볼 수 있다.\n\n```jsx\nimport { type OverlayData, type OverlayItem } from './store';\n\nexport type OverlayReducerAction =\n  | { type: 'ADD'; overlay: OverlayItem }\n  | { type: 'OPEN'; overlayId: string }\n  | { type: 'CLOSE'; overlayId: string }\n  | { type: 'REMOVE'; overlayId: string }\n  | { type: 'CLOSE_ALL' }\n  | { type: 'REMOVE_ALL' };\n\nexport function overlayReducer(state: OverlayData, action: OverlayReducerAction): OverlayData {\n  switch (action.type) {\n    case 'ADD': {\n      const isExisted = state.overlayOrderList.includes(action.overlay.id);\n\n      if (isExisted && state.overlayData[action.overlay.id].isOpen === true) {\n        throw new Error(\"You can't open the multiple overlays with the same overlayId. Please set a different id.\");\n      }\n\n      return {\n        current: action.overlay.id,\n        overlayOrderList: [...state.overlayOrderList.filter((item) => item !== action.overlay.id), action.overlay.id],\n        overlayData: isExisted\n          ? state.overlayData\n          : {\n              ...state.overlayData,\n              [action.overlay.id]: action.overlay,\n            },\n      };\n    }\n    case 'OPEN': {\n      return {\n        ...state,\n        overlayData: {\n          ...state.overlayData,\n          [action.overlayId]: {\n            ...state.overlayData[action.overlayId],\n            isOpen: true,\n          },\n        },\n      };\n    }\n    case 'CLOSE': {\n      const openedOverlayOrderList = state.overlayOrderList.filter(\n        (orderedOverlayId) => state.overlayData[orderedOverlayId].isOpen === true\n      );\n      const targetIndexInOpenedList = openedOverlayOrderList.findIndex((item) => item === action.overlayId);\n\n      const currentOverlayId =\n        targetIndexInOpenedList === openedOverlayOrderList.length - 1\n          ? openedOverlayOrderList[targetIndexInOpenedList - 1] ?? null\n          : openedOverlayOrderList.at(-1) ?? null;\n\n      return {\n        ...state,\n        current: currentOverlayId,\n        overlayData: {\n          ...state.overlayData,\n          [action.overlayId]: {\n            ...state.overlayData[action.overlayId],\n            isOpen: false,\n          },\n        },\n      };\n    }\n    case 'REMOVE': {\n      const remainingOverlays = state.overlayOrderList.filter((item) => item !== action.overlayId);\n      if (state.overlayOrderList.length === remainingOverlays.length) {\n        return state;\n      }\n\n      const copiedOverlayData = { ...state.overlayData };\n      delete copiedOverlayData[action.overlayId];\n\n      const current = state.current\n        ? remainingOverlays.includes(state.current)\n          ? state.current\n          : null\n\n      return {\n        current,\n        overlayOrderList: remainingOverlays,\n        overlayData: copiedOverlayData,\n      };\n    }\n    case 'CLOSE_ALL': {\n      return {\n        ...state,\n        overlayData: Object.keys(state.overlayData).reduce(\n          (prev, curr) => ({\n            ...prev,\n            [curr]: {\n              ...state.overlayData[curr],\n              isOpen: false,\n            } satisfies OverlayItem,\n          }),\n          {} satisfies Record<string, OverlayItem>\n        ),\n      };\n    }\n    case 'REMOVE_ALL': {\n      return { current: null, overlayOrderList: [], overlayData: {} };\n    }\n  }\n}\n\n```\n\n#### Event.ts\n\nreducer에 전달한 action들을 직접 전달하는 이벤트 함수들은 event.ts에 정의되어있다. 내부적으로 dispatchOverlay를 통해 reducer에 전달하는 것을 볼 수 있다.\n\n```jsx\nimport { type OverlayAsyncControllerComponent, type OverlayControllerComponent } from './context/provider';\nimport { dispatchOverlay } from './context/store';\nimport { randomId } from './utils';\n\ntype OpenOverlayOptions = {\n  overlayId?: string;\n};\n\nfunction open(controller: OverlayControllerComponent, options?: OpenOverlayOptions) {\n  const overlayId = options?.overlayId ?? randomId();\n\n  dispatchOverlay({\n    type: 'ADD',\n    overlay: {\n      id: overlayId,\n      isOpen: false,\n      controller: controller,\n    },\n  });\n\n  return overlayId;\n}\n\nasync function openAsync<T>(controller: OverlayAsyncControllerComponent<T>, options?: OpenOverlayOptions) {\n  return new Promise<T>((resolve) => {\n    open((overlayProps, ...deprecatedLegacyContext) => {\n      /**\n       * @description close the overlay with resolve\n       */\n      const close = (param: T) => {\n        resolve(param as T);\n        overlayProps.close();\n      };\n      /**\n       * @description Passing overridden methods\n       */\n      const props = { ...overlayProps, close };\n      return controller(props, ...deprecatedLegacyContext);\n    }, options);\n  });\n}\n\nfunction close(overlayId: string) {\n  dispatchOverlay({ type: 'CLOSE', overlayId });\n}\nfunction unmount(overlayId: string) {\n  dispatchOverlay({ type: 'REMOVE', overlayId });\n}\nfunction closeAll() {\n  dispatchOverlay({ type: 'CLOSE_ALL' });\n}\nfunction unmountAll() {\n  dispatchOverlay({ type: 'REMOVE_ALL' });\n}\n\nexport const overlay = { open, close, unmount, closeAll, unmountAll, openAsync }\n```\n\n## 더 알아보기 섹션 이해해보기\n\n공식문서의 더 알아보기 섹션에는 4가지 추가 사용법을 제공하고 있다. 각각에 대해 앞서 봤던 동작원리를 이용해서 이해해보자.\n\n### 1. React 바깥에서 열기\n\nOverlay kit은 react 외부에서도 overlay를 열 수 있다.\n\n```jsx\nimport ky from \"ky\"\nimport { overlay } from \"overlay-kit\"\n\nconst api = ky.extend({\n  hooks: {\n    afterResponse: [\n      (_, __, response) => {\n        if (response.status >= 400) {\n          overlay.open(({ isOpen, close }) => (\n            <ErrorDialog open={isOpen} onClose={close} />\n          ))\n        }\n      },\n    ],\n  },\n})\n```\n\n이러한 구조가 가능한 이유는 overlay.open 메소드는 내부적으로 dispatchOverlay를 통해 reducer에 렌더링할 컴포넌트와 함께 액션으로 전달하고 있기 때문이다.\n\n```jsx\nfunction open(\n  controller: OverlayControllerComponent,\n  options?: OpenOverlayOptions\n) {\n  const overlayId = options?.overlayId ?? randomId()\n\n  dispatchOverlay({\n    type: \"ADD\",\n    overlay: {\n      id: overlayId,\n      isOpen: false,\n      controller: controller,\n    },\n  })\n\n  return overlayId\n}\n```\n\n이후에 렌더링 되는 곳은 OverlayProvider 내부에서 정의된 controller에 전달되기 때문에 react 외부에서도 동일하게 사용할 수 있다.\n\n```jsx\nexport function OverlayProvider({ children }: PropsWithChildren) {\n  const overlayState = useSyncOverlayStore()\n\n  useEffect(() => {\n    return () => {\n      dispatchOverlay({ type: \"REMOVE_ALL\" })\n    }\n  }, [])\n\n  return (\n    <OverlayContextProvider value={overlayState}>\n      {children}\n      {overlayState.overlayOrderList.map(item => {\n        // 오버레이 컴포넌트 렌더링\n      })}\n    </OverlayContextProvider>\n  )\n}\n```\n\n### 2. Custom ID 지정하기\n\noverlayId를 직접 지정해서 전달할 수 있다.\n\n```jsx\nfunction Demo() {\n  const openDialog = () => {\n    overlay.open(\n      ({ isOpen, close, unmount }) => {\n        return <Dialog open={isOpen} onClose={close} onExit={unmount} />\n      },\n      { overlayId: \"customId\" }\n    )\n  }\n\n  return <Button onClick={openDialog}>Open dialog</Button>\n}\n```\n\n직접 id를 지정할 수 있는 것은 open 메소드에 전달하는 옵션에 있는 overlayId 속성을 전달하고 있고 없을 경우에는 randomId 함수를 통해 랜덤한 id를 생성하고 있다.\n\n```jsx\nconst overlayId = options?.overlayId ?? randomId()\n```\n\n이렇게 정해진 id는 reducer에서 처리되는 OPEN 액션에 전달되어 오버레이 데이터에 저장된다.\n\n```jsx\n//...\ncase 'OPEN': {\n      return {\n        ...state,\n        overlayData: {\n          ...state.overlayData,\n          [action.overlayId]: {\n            ...state.overlayData[action.overlayId],\n            isOpen: true,\n          },\n        },\n      };\n    }\n```\n\n### 3. Promise와 함께 사용하기\n\noverlay kit은 비동기 처리를 위해 promise와 함께 사용할 수 있다.\n\n```tsx\nconst result = await new Promise<boolean>(resolve => {\n  overlay.open(({ isOpen, close }) => {\n    return (\n      <Dialog open={isOpen} onClose={() => close(false)}>\n        <DialogTitle>계속 진행하시겠어요?</DialogTitle>\n        <DialogActions>\n          <Button\n            onClick={() => {\n              resolve(true)\n              close()\n            }}\n          >\n            네\n          </Button>\n          <Button\n            onClick={() => {\n              resolve(false)\n              close()\n            }}\n          >\n            아니요\n          </Button>\n        </DialogActions>\n      </Dialog>\n    )\n  })\n})\n\nif (result) {\n  // 사용자가 \"네\"를 눌렀을 때의 처리\n} else {\n  // 사용자가 \"아니요\"를 눌렀을 때의 처리\n}\n```\n\n그이유도 1번과 동일하게 open 메소드가 실행되면서 데이터가 저장되고, 이후에 렌더링 되는 곳은 OverlayProvider 내부에서 정의된 controller에 전달되기 때문이다.\n\npromise를 사용할 때 주의할점은 꼭 resolve를 해줘야한다는 점인데, resolve를 하지 않으면 await에서 무한정 대기하게 되어 다음 코드로 진행할 수 없다. 추가로 promise가 메모리에서 해제되지 않아 메모리 누수가 발생할 수 있다.\n\n직접 promise에서 감싸는 방식 대신 openAsync 메소드를 사용하는 방법도 있다.\n\n```tsx\nconst result = await overlay.openAsync<boolean>(({ isOpen, close }) => {\n  const agree = () => close(true)\n  const cancel = () => close(false)\n\n  return (\n    <Dialog open={isOpen} onClose={cancel}>\n      <DialogTitle>계속 진행하시겠어요?</DialogTitle>\n      <DialogActions>\n        <Button onClick={agree}>네</Button>\n        <Button onClick={cancel}>아니요</Button>\n      </DialogActions>\n    </Dialog>\n  )\n})\n\nif (result) {\n  // 사용자가 \"네\"를 눌렀을 때의 처리\n} else {\n  // 사용자가 \"아니요\"를 눌렀을 때의 처리\n}\n```\n\nopenAsync 메소드는 자체적으로 close 메소드 내부에서 resolve를 호출하기 때문에 따로 resolve를 호출해줄 필요가 없어 실수를 줄일 수 있다.\n\n```jsx\nasync function openAsync<T>(\n  controller: OverlayAsyncControllerComponent<T>,\n  options?: OpenOverlayOptions\n) {\n  return new Promise<T>((resolve) => {\n    open((overlayProps, ...deprecatedLegacyContext) => {\n      /**\n       * @description close the overlay with resolve\n       */\n      const close = (param: T) => {\n        resolve(param as T);\n        overlayProps.close();\n      };\n      /**\n       * @description Passing overridden methods\n       */\n      const props = { ...overlayProps, close };\n      return controller(props, ...deprecatedLegacyContext);\n    }, options);\n  });\n}\n```\n\n### 4. 오버레이 애니메이션과 Unmount 처리\n\noverlay kit에서 close는 오버레이의 애니메이션을 위해서 메모리에서 완전히 제거하지 않고 렌더링만 제외시키는 역할을 한다. 이러한 이유로 오버레이 컴포넌트에서 unmount 메소드를 이용해야 메모리에서 완전히 제거할 수 있다.\n\n```jsx\nfunction Demo() {\n  const openDialog = () => {\n    overlay.open(({ isOpen, close, unmount }) => (\n      <Dialog open={isOpen} onClose={close} onExit={unmount} />\n    ))\n  }\n}\n```\n\n실제 reducer와 이벤트 함수들을 보면 실제로 해당 데이터를 지우는 것은 REMOVE 액션이다.\n\n```tsx\n// event.ts\nfunction close(overlayId: string) {\n  dispatchOverlay({ type: \"CLOSE\", overlayId })\n}\nfunction unmount(overlayId: string) {\n  dispatchOverlay({ type: \"REMOVE\", overlayId })\n}\n\n// reducer.ts\n//...\n    case 'CLOSE': {\n      const openedOverlayOrderList = state.overlayOrderList.filter(\n        (orderedOverlayId) => state.overlayData[orderedOverlayId].isOpen === true\n      );\n      const targetIndexInOpenedList = openedOverlayOrderList.findIndex((item) => item === action.overlayId);\n\n      const currentOverlayId =\n        targetIndexInOpenedList === openedOverlayOrderList.length - 1\n          ? openedOverlayOrderList[targetIndexInOpenedList - 1] ?? null\n          : openedOverlayOrderList.at(-1) ?? null;\n\n      return {\n        ...state,\n        current: currentOverlayId,\n        overlayData: {\n          ...state.overlayData,\n          [action.overlayId]: {\n            ...state.overlayData[action.overlayId],\n            isOpen: false,\n          },\n        },\n      };\n    }\n    case 'REMOVE': {\n      const remainingOverlays = state.overlayOrderList.filter((item) => item !== action.overlayId);\n      if (state.overlayOrderList.length === remainingOverlays.length) {\n        return state;\n      }\n\n      const copiedOverlayData = { ...state.overlayData };\n      delete copiedOverlayData[action.overlayId];\n\n      const current = state.current\n        ? remainingOverlays.includes(state.current)\n          ? state.current\n          : remainingOverlays.at(-1) ?? null\n        : null;\n\n      return {\n        current,\n        overlayOrderList: remainingOverlays,\n        overlayData: copiedOverlayData,\n      };\n    }\n```\n\n## 마치며\n\n선언적으로 관리하는 overlay kit의 장점과 내부 구조를 살펴보았다.\n\n이 과정을 통해서 react와 javascript가 어떻게 연결될 수 있는지 살펴볼 수 있었고, 선언적으로 관리하기 위해서 어떠한 방식으로 코드가 작성되어있는지 이해할 수 있었다.\n\n코드를 볼 수록 토스 팀의 노력과 생각을 이해할 수 있었고, 단순히 이용하는 것이 아니라 앞으로 동료로서 더 발전시키는데 기여하고 싶다는 생각이 들었다.\n"},{"excerpt":"토스에 입사한 후 프론트엔드의 다양한 기술 주제에 대해 새롭게 알게 되면서 하나씩 정리해보고자 한다. 이번 주제는 패키지 매니저로 평소 잘 몰랐던 주제라 흥미롭게 생각해 각각의 특징과 장단점 등에 대해 정리해보려한다. 이미 토스 블로그와 다른 블로그들에 잘 정리된 글이 있기 때문에 해당 글들을 참고하여 작성하였다. node_modules로부터 우리를 구원…","fields":{"slug":"/2024-11-18-패키지매니저/"},"frontmatter":{"date":"November 18, 2024","title":"패키지 매니저 비교해보기","tags":["frontend","javascript"]},"rawMarkdownBody":"\n토스에 입사한 후 프론트엔드의 다양한 기술 주제에 대해 새롭게 알게 되면서 하나씩 정리해보고자 한다.\n\n이번 주제는 패키지 매니저로 평소 잘 몰랐던 주제라 흥미롭게 생각해 각각의 특징과 장단점 등에 대해 정리해보려한다.\n\n이미 토스 블로그와 다른 블로그들에 잘 정리된 글이 있기 때문에 해당 글들을 참고하여 작성하였다.\n\n[node_modules로부터 우리를 구원해 줄 Yarn Berry](https://toss.tech/article/node-modules-and-yarn-berry)\n\n[패키지 매니저의 과거, 토스의 선택, 그리고 미래](https://toss.tech/article/lightning-talks-package-manager)\n\n## 패키지 매니저란?\n\n패키지 매니저는 NPM, YARN과 같이 외부 모듈을 관리할 때 사용하는 도구로 의존성을 관리하고, 패키지를 설치, 업데이트, 제거하기 위한 도구이다.\n\n만약 패키지 매니저가 없이 외부 모듈을 사용하려면 어떻게 해야할지 생각해보자.\n\n1. 패키지 매니저가 없다면 내가 원하는 라이브러리 코드를 프로젝트에서 사용하기 위해서, 특정 폴더에 해당 코드를 직접 복사해서 붙여넣어야 한다.\n\n2. 그리고 붙여넣은 위치에 맞게 라이브러리를 가져올 수 있게 경로를 관리해야 한다.\n\n3. 그리고 어느 시점의 라이브러리를 다운받냐에 따라 사용하고 있는지에 따라 코드가 달라지니까 어떤 버전의 라이브러리를 복사 붙여넣기 했는지 기록해야할 것 같다.\n\n4. 마지막으로 패키지 자체가 안전한지 확인하는 과정도 필요할 것 같다.\n\n방금 말한 패키지 매니저가 없을 때 해야할 과정 4가지 과정은 결국 우리를 위해 패키지 매니저가 담당해주고 있는 일로 볼 수 있다.\n\n결국 한마디로는 `패키지 매니저는 외부 모듈을 프로젝트에 쉽게 설치하고 관리할 수 있게 도와주는 도구`라고 할 수 있다.\n\n## 패키지 매니저가 동작하는 방식\n\n패키지가 동작하는 방식을 알아보면 세가지 스텝으로 진행된다.\n\n- Resolution\n- Fetching\n- Linking\n\n각 스텝에 대해 알아보자.\n\n### Resolution\n\nResolution은 `package.json`에 기록된 의존성 정보를 읽고 해당하는 버전 범위를 체크하는 과정이다.\n\n예를 들어 `package.json`에 `react` 패키지가 `^18.0.0` 버전으로 기록되어 있다면, Resolution 과정에서는 `react` 패키지의 버전이 `18.0.0` 이상이면서 최대한 최신 버전인 `18.99.99` 버전을 이용할 수 있구나하고 사용가능한 버전을 체크하는 과정이다.\n\n이때 의존성의 의존성의 버전도 체크하는 과정을 거쳐서 각 의존성들의 버전을 고정시켜서 최종적으로 사용할 수 있는 버전을 찾는 과정이다.\n\n### Fetching\n\nFetching은 체크된 버전의 패키지를 다운받는 과정으로 로컬 캐시가 있는지 확인하고 없다면 원격 저장소에서 패키지를 다운받는 과정이다.\n\n### Linking\n\nLinking은 다운받은 패키지를 프로젝트에 연결하는 과정으로 패키지를 사용할 수 있도록 프로젝트에 연결하는 과정이다.\nnpm과 yarn은 node_modules 폴더에 패키지를 설치하고 각 매니저별로 최적화된 방식으로 패키지를 연결한다.\n\n## 패키지 매니저 비교하기\n\n패키지 매니저의 역할을 알아보았으니 이제 각 패키지 매니저에 대해 알아보자.\n알아볼 패키지매니저는 NPM, Yarn, Pnpm, Yarn Berry이다.\n\n### NPM\n\nNPM은 Node Package Manager의 약자로, 가장 역사가 오래된 Node.js 패키지 매니저다.\n\n편한 CLI 명령어를 제공하고 NPM 공식사이트를 통해서 패키지를 검색할 수 있다.\n\n<img src=\"npm.png\" alt=\"npm\" />\n\n위에서 소개된 Linking 과정에서 NPM은 정해진 의존성 트리를 기반으로 `node_modules` 폴더에 패키지를 설치하고 연결하는 과정을 거친다.\n\n```\nnpm-project/\n└─ node_modules/\n| ├─ a/\n| |\n| └─ b/\n|    └─ node_modules/\n|        └─ c\n|\n└─ src\n└─ index.ts\n```\n\n![node_modules...](node_modules.png)\n\n이렇게 거대해진 `node_modules` 폴더는 프로젝트 크기가 커질수록 CI/CD 과정에서 오래걸리게 되고 시간 뿐 아니라, 큰 용량을 차지하게 된다.\n\n![Ghost Dependencies](ghost_dependencies.png)\n\n이렇게 커진 `node_modules` 폴더를 최적화하기 위해서 `hoisting`이라는 기법을 이용하지만, 이러한 최적화 방식은 오히려 사용하려고 하지 않았던 패키지를 설치하거나 삭제될 수 있는 `Ghost Dependencies` 문제가 발생하게 된다.\n\n#### Ghost Dependencies\n\nGhost Dependencies를 이해하기 위해 간단한 예제를 만들어 보았다.\n\n먼저 간단히 가장 기본이 되는 패키지 `@choi2021/ghost-dep-test-package-a`를 만들어보았다.\n해당 패키지는 정말 간단한 sum이라는 함수를 반환한다.\n\n```javascript\nfunction sum(a, b) {\n  return a + b\n}\n\nmodule.exports = {\n  sum,\n}\n```\n\n이제 두번째 패키지 `@choi2021/ghost-dep-test-package-b`를 만들어보자.\n해당 패키지는 앞서 만든 `@choi2021/ghost-dep-test-package-a`를 의존성으로 가지고 있다.\n\n```javascript\n// package.json\n{\n  \"name\": \"@choi2021/ghost-dep-test-package-a\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\"\n}\n\n// index.js\nconst { sum } = require(\"@choi2021/ghost-dep-test-package-a\")\n\nfunction sumAndMultiply(a, b, c) {\n  return sum(a, b) * c\n}\n\nmodule.exports = {\n  sumAndMultiply,\n}\n```\n\n이제는 실제로 npm-example이라는 프로젝트에 `@choi2021/ghost-dep-test-package-b`를 설치해보자.\n\n```package.json\n{\n  \"name\": \"npm-example\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@choi2021/ghost-dep-test-package-b\": \"*\"\n  }\n}\n```\n\n해당 프로젝트에 npm install을 진행하면 아래와 같이 `node_modules` 폴더에 패키지가 설치된다.\n\n![npm-example](npm-example.png)\n\nnode_modules 폴더를 살펴보면 `@choi2021/ghost-dep-test-package-b`만 의존성을 가지고 있지만 `@choi2021/ghost-dep-test-package-a` 패키지가 설치되어 있는 것을 확인할 수 있다.\n\n그리고 의존성 트리가 앞서 설명한 호이스팅과정을 통해서 최상위 레벨에 위치하게 된다.\n\n여기서 문제가 되는 Ghost Dependency가 발생하게 되는데 해당 패키지가 가지는 의존성은 `@choi2021/ghost-dep-test-package-b`이지만, 프로젝트 내부에서 `@choi2021/ghost-dep-test-package-a`를 직접 사용할 수 있다.\n\n```javascript\nimport { sum } from \"@choi2021/ghost-dep-test-package-a\"\n\nconsole.log(sum(1, 2))\n```\n\n![npm-ghost-dep](npm-ghost-dep.png)\n\n이렇게 직접 의존하지 않은 패키지에 접근할 수 있게 되는 현상을 Ghost Dependency라고 하며, 이는 실제 프로젝트에서 다음과 같은 문제를 일으킬 수 있다.\n\n1. 의도치 않은 패키지 사용으로 인한 보안 취약점 발생\n2. 패키지 업데이트 시 예상치 못한 오류 발생\n3. 프로젝트의 의존성 관리가 불명확해짐\n\nnpm은 가장 오래된 패키지 매니저이라 커뮤니티가 크지만, 프로젝트의 규모가 커질 수록 용량을 많이 차지하고, CI/CD 과정에서 오래걸리는 단점을 가지고 있다. 이러한 단점을 극복하기 위해 Yarn이 등장하게 되었다.\n\n### Yarn\n\nYarn은 페이스북에서 만든 패키지 매니저로 2016년도에 작성된 페이스북 [Yarn 소개 글](https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/)을 보면 Yarn의 배경에 대해 알 수 있다.\n\n당시 페이스북은 팀과 프로젝트가 커지면서 일관되지 않는 의존성, 안정성, 성능적인 이슈를 겪게 되었고 새로운 npm client로 Yarn을 만들게 되었다.\n\n어떻게 Yarn은 이러한 문제들을 해결한걸까? 하나씩 알아보자.\n\n#### 일관된 의존성\n\nNPM을 이용해 만든 node_modules 폴더는 파일 시스템 기반이다보니 여러 패키지가 얽히다 보면 일관되지 않은 트리를 만들게 되고, \"내 컴퓨터에서는 되는데\"라는 문제점이 발생하게 된다.\n\n이를 개선하기 위해 Yarn은 `yarn.lock` 파일을 도입했다. 이 파일은 모든 패키지의 정확한 버전과 의존성 정보를 저장하여, 어느 환경에서나 동일한 버전의 패키지가 설치되도록 보장한다.\n\n```yaml\n# yarn.lock 예시\nreact@^16.0.0:\n  version \"16.14.0\"\n  resolved \"https://registry.yarnpkg.com/react/-/react-16.14.0.tgz\"\n  integrity sha512-...\n  dependencies:\n    loose-envify \"^1.1.0\"\n    object-assign \"^4.1.1\"\n```\n\n#### 성능\n\nnpm은 순차적인 방식으로 설치하는 반면에 Yarn은 병렬적인 방식으로 설치하기 때문에 성능적인 측면에서 더 빠르다.\n\n#### 명령어\n\n명령어도 조금 더 npm에 비해 간결해져 사용하기 편하다.\n\n<table>\n  <tr>\n    <th>npm</th>\n    <th>yarn</th>\n  </tr>\n  <tr>\n    <td>npm install</td>\n    <td>yarn install</td>\n  </tr>\n  <tr>\n    <td>npm uninstall package</td>\n    <td>yarn remove package</td>\n  </tr>\n</table>\n\n하지만 NPM에 비해 일부 호환성 문제가 있다는 단점이 있고, 자체 최적화 알고리즘을 진행해 node_modules를 이용하는 방식은 여전히 Ghost Dependency 문제가 발생하게 된다.\n\n같은 예제를 Yarn 프로젝트에서 실행했을 때 상황이다.\n\n```javascript\n// package.json\n{\n  \"name\": \"yarn-example\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@choi2021/ghost-dep-test-package-b\": \"*\"\n  },\n  \"type\": \"module\"\n}\n\n// index.js\nimport { sum } from \"@choi2021/ghost-dep-test-package-a\"\n\nconsole.log(sum(1, 2))\n```\n\n![yarn-example](yarn-example.png)\n\n직접 의존성이 없는 패키지에 아직 접근할 수 있는 것을 확인할 수 있다.\n\n### Pnpm\n\npnpm(performant npm) 또한 npm의 문제점을 해결하기 위해 만들어진 패키지 매니저로 Yarn과는 다른 방식으로 해결한다.\n\n[pnpm의 공식문서](https://pnpm.io/motivation)의 motivation 부분을 살펴보면 기존 문제를 어떻게 해결하는지 알 수 있다.\n\n#### 적은 용량\n\nnpm으로 백개의 프로젝트에서 하나의 의존성을 설치해야 하는 경우 100개의 복사본이 생기게 된다. 하지만 pnpm에서는 content-addressable store라는 개념을 도입해 하나의 의존성에 대해서 하나의 복사본만 존재하게 된다.\n\n만약 버전이 다른 의존성이 설치되어야 한다면 다른 버전만 store에 설치하게 되고 모든 파일들은 한 곳에 설치되어 `hard-link` 방식으로 연결되게 된다.\n\nhard-link는 주소를 alias처럼 동일한 파일을 여러 위치에서 참조할 수 있게 하는 방식이다. 실제 파일은 하나만 존재하고, 여러 위치에서 이 파일을 직접 가리키는 참조를 만들기 때문에 용량이 적게 차지하게 된다.\n\n![pnpm-disk](pnpm-disk.png)\n\n#### 빠른 설치 속도\n\npnpm의 설치 과정은 세가지 과정을 거친다고 한다.\n\n1. Resolution: 필요한 의존성을 파악하고 스토어에 설치한다.\n2. Directory structure calculation: npm과 동일하게 node_modules 폴더 구조를 계산한다.\n3. Linking: 정리된 의존성들을 다운받고 스토어와 node_modules를 hard-link로 연결한다\n\n#### Non-flat node_modules와 Ghost Dependencies\n\nnpm과 yarn은 모두 hoist로 인해 flat한 구조를 가지고 Ghost Dependencies 문제가 발생하지만, pnpm은 이러한 문제를 해결하기 위해 바로가기 폴더를 만드는 것과 같은 symlink 방식으로 문제를 해결한다.\n\n![pnpm-node-modules](pnpm-node-modules.png)\n\n앞선 예제를 pnpm 프로젝트에서 설치했을 때 모습이다.\n\n![pnpm-example](pnpm-example.png)\n\nnode_modules에는 직접 의존하는 `ghost-dep-test-package-b`만 존재하고, 실제로 코드에서 실행해보면 에러가 발생하는 것을 볼 수 있다.\n\n```javascript\n// package.json\n{\n  \"name\": \"pnpm-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@choi2021/ghost-dep-test-package-b\": \"*\"\n  },\n  \"type\": \"module\",\n}\n\n\n// index.js\nimport { sum } from \"@choi2021/ghost-dep-test-package-a\"\n\nconsole.log(sum(1, 2))\n```\n\n![pnpm-error](pnpm-error.png)\n\n이렇게 직접 의존하지 않은 패키지에 접근할 수 없게 되어 Ghost Dependencies 문제를 해결할 수 있게 되었다.\n\npnpm도 단점이 존재하는데 적은 용량과 빠른 설치 속도를 위해 추가된 store를 만드는 과정과 symlink, hard link의 오버헤드로 최초에 store를 만드는 시간이 조금 더 걸리지만 이후에는 매우 빠른 속도로 설치할 수 있다.\n\n### Yarn Berry\n\n마지막으로 Yarn Berry에 대해 알아보자.\n\nYarn Berry는 yarn classic(v1)에서 조금 더 개선된 버전으로 앞서 소개한 패키지 매니저들과는 다르게 Plug'n'Play(pnp) 방식을 이용한다.\n\n그러면 동일하게 앞서 만든 패키지를 의존하는 예제를 만들어서 어떤 점이 달라졌는지 살펴보자\n\n#### 적은 용량\n\nyarn berry 세팅하기 위해서는 `yarn set version berry` 명령어를 먼저 실행해야 한다.\n이후에는 기존 yarn 명령어를 그대로 사용할 수 있다.\n\n```bash\nyarn set version berry\nyarn install\n```\n\npnp방식의 큰 특징은 많은 용량을 차지하던 `node_modules` 폴더가 없고 대신에 `.yarn/cache` 폴더 내부에 패키지들이 설치되는 것이다.\n\n![yarn-pnp-example](yarn-pnp-example.png)\n\n그리고 이러한 패키지들은 각 패키지별로 하나의 zip만 가지기 때문에 훨씬 적은 용량을 차지하게 된다.\n\n#### 빠른 설치 속도\n\n먼저 여러 파일을 다운받아서 복잡한 구조를 만들던 node_modules 대신 yarn.lock을 기반으로 `.pnp.cjs` 파일 하나만 만들면 되기 때문에 기존 패키지들에서 많은 시간을 소요하던 I/O 작업에서 많은 시간이 단축 된다.\n\n패키지를 찾을 때도 javascript map을 이용해서 패키지의 직접 참조 주소로 바로 접근하기 때문에 훨씬 빠르게 패키지를 찾을 수 있다.\n\n아래는 `.pnp.cjs` 파일의 일부를 가져온 것으로 packageRegistryData에 각 패키지 별로 어디에 위치해 있는지, 어떤 패키지에 의존하는지 등의 정보를 기록하고 있다.\n\n#### 패키지 관리와 Ghost Dependencies\n\npnp는 `.pnp.cjs` 파일을 이용해서 패키지를 관리하기 때문에 아래와 같은 형태로 패키지들의 위치와 의존성을 기록하고 있다.\n\n```javascript\n// .pnp.cjs\n\nconst RAW_RUNTIME_STATE =\n  '{\\\n  \"packageRegistryData\": [\\\n    [null, [\\\n      [null, {\\\n        \"packageLocation\": \"./\",\\\n        \"packageDependencies\": [\\\n          [\"@choi2021/ghost-dep-test-package-b\", \"npm:1.0.0\"]\\\n        ],\\\n        \"linkType\": \"SOFT\"\\\n      }]\\\n    ]],\\\n    [\"@choi2021/ghost-dep-test-package-a\", [\\\n      [\"npm:1.0.0\", {\\\n        \"packageLocation\": \"./.yarn/cache/@choi2021-ghost-dep-test-package-a-npm-1.0.0-baec42f21a-2fac373eba.zip/node_modules/@choi2021/ghost-dep-test-package-a/\",\\\n        \"packageDependencies\": [\\\n          [\"@choi2021/ghost-dep-test-package-a\", \"npm:1.0.0\"]\\\n        ],\\\n        \"linkType\": \"HARD\"\\\n      }]\\\n    ]],\\\n    [\"@choi2021/ghost-dep-test-package-b\", [\\\n      [\"npm:1.0.0\", {\\\n        \"packageLocation\": \"./.yarn/cache/@choi2021-ghost-dep-test-package-b-npm-1.0.0-d8c30a1a6f-caf57e1dd9.zip/node_modules/@choi2021/ghost-dep-test-package-b/\",\\\n        \"packageDependencies\": [\\\n          [\"@choi2021/ghost-dep-test-package-b\", \"npm:1.0.0\"],\\\n          [\"@choi2021/ghost-dep-test-package-a\", \"npm:1.0.0\"]\\\n        ],\\\n        \"linkType\": \"HARD\"\\\n      }]\\\n    ]],\\\n    [\"yarn-pnp-example\", [\\\n      [\"workspace:.\", {\\\n        \"packageLocation\": \"./\",\\\n        \"packageDependencies\": [\\\n          [\"yarn-pnp-example\", \"workspace:.\"],\\\n          [\"@choi2021/ghost-dep-test-package-b\", \"npm:1.0.0\"]\\\n        ],\\\n        \"linkType\": \"SOFT\"\\\n      }]\\\n    ]]\\\n  ]\\\n}'\n```\n\n정확하게 어떤 패키지를 직접 의존하는지 확인할 수 있고, 이를 통해 Ghost Dependencies 문제를 해결할 수 있다.\n실제로 앞서 만든 예제를 yarn berry에서 실행했을 때 모습이다.\n\n```javascript\n// package.json\n{\n  \"name\": \"yarn-pnp-example\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@choi2021/ghost-dep-test-package-b\": \"*\"\n  },\n  \"type\": \"module\",\n  \"packageManager\": \"yarn@4.5.1\"\n}\n\n// index.js\n\nimport { sum } from \"@choi2021/ghost-dep-test-package-a\";\n\nconsole.log(sum(1, 2));\n```\n\n![yarn-pnp-ghost-dep](yarn-pnp-ghost-dep.png)\n\npnp 패키지 매니저에서 패키지를 찾을 수 없다는 에러를 볼 수 있다.\n\n정리해보면 yarn berry는 PnP 방식을 이용해 기존과 달리 node_modules 폴더 없이 패키지를 관리하고, 빠른 설치 속도와 적은 용량을 가지며, 또한 Ghost Dependencies 문제를 해결할 수 있는 장점을 가지고 있다.\n\n하지만 기존의 node_modules 기반의 패키지 매니저와 호환성 문제가 있다.\n\nyarn berry에서는 이렇게 적은 용량으로 패키지를 관리할 수 있다보니 패키지 자체를 git의 버전 관리 대상에 포함시키는 `zero-install`으로도 이용하는 경우도 많다.\n\ngit clone 과정에서 모든 패키지가 함께 설치되다보니 별도의 Install 과정이 필요 없어 새로 프로젝트를 다운받을 때나, CI과정에서 시간을 아껴줄 수 있는 장점이 있다.\n\n토스는 기존에 이러한 장점으로 [zero-install](https://toss.tech/article/node-modules-and-yarn-berry)을 도입했지만, [현재는 PnP를 이용하더라도 레포 크기가 커져서 zero install을 끈 상태](https://toss.tech/article/lightning-talks-package-manager)라고 한다.\n\n## 마치며\n\nRN 개발자에서 프론트엔드 개발자로 전향하면서 보다 javascript 생태계에 대해 조금 더 관심을 갖고 바라보고 있게 되었다. 그중에서 패키지 매니저는 크게 신경쓰지 않았던 부분이었지만 토스에 합류해 메이트 분과 이야기를 나누면서 이전 회사에서는 어떤 패키지 매니저 환경에서 작업을 했는지 질문을 받게 되었다.\n\n토스 기술 블로그들에도 몇번 본적이 있었고, 프론트엔드 개발자로서 이런부분을 알면 좋겠다는 생각이 들어 작성하게 되었다.\n\n이제는 조금은 더 이해할 수 있게된 패키지 매니저를 통해 단순히 CLI만 사용하지 않고 의존성들이 각각 어떻게 관리되는지 어떤 장단점이 있는지 이해하고 사용할 수 있을 것 같다.\n"},{"excerpt":"👋 숨고를 떠나며 23년 2월에 입사해 24년 10월 18일을 마지막으로 숨고라는 제품을 만든지 1년 8개월이 지났다.\n2년을 채우고 떠났으면 좋았겠지만, 좋은 기회가 오게 되어 떠나게 되었고 10월은 대부분 함께 일했던 동료분들과 함께 이야기하고 고마움을 표현하며 보내는 시간을 주로 가졌다. 9월회고에 작성했던 MMKV작업과 React Query작업은 …","fields":{"slug":"/2024-10-25-숨고를-떠나며/"},"frontmatter":{"date":"October 25, 2024","title":"10월 회고, 숨고를 떠나며","tags":["회고"]},"rawMarkdownBody":"\n## 👋 숨고를 떠나며\n\n23년 2월에 입사해 24년 10월 18일을 마지막으로 숨고라는 제품을 만든지 1년 8개월이 지났다.\n2년을 채우고 떠났으면 좋았겠지만, 좋은 기회가 오게 되어 떠나게 되었고 10월은 대부분 함께 일했던 동료분들과 함께 이야기하고 고마움을 표현하며 보내는 시간을 주로 가졌다.\n\n9월회고에 작성했던 MMKV작업과 React Query작업은 현재까지 진행된 내용들에 대한 문서만 인수인계를 위해 작성했고, 실제 적용한 결과를 보지는 못했다.\n\n개발자로서 첫 직장이었던 숨고를 떠나며 기억에 남는 순간들과 배웠던 부분들을 정리해보려 한다.\n\n### 1. 사람은 실수한다\n\n이직을 준비하고 내가 했던 작업들을 정리하면서, 내가 했던 실수들, 그리고 그것을 보완하기 위해서 어떤 노력을 해왔는지 돌아보았다.\n\n숨고에서 가장 가슴을 쓸어내렸던 순간은 단연코, 작년 5월에 있었던 **요청 견적서 작업**이었다. 제품의 메인 비즈니스 도메인인 견적서 작성 퍼널에 딥링크를 이용해 진입했을 때 견적 발송이 되지 않는 장애가 발생했다. 당시 입사한지 3개월이 되었던 시점에 아직 모바일 플랫폼에 대한 이해도 부족해 발생했던 이슈였다.\n\n![당시 23년 5월 회고로 작성했던 글의 일부](5월회고.png)\n\n매출에 직접적인 장애를 만들면서, 사후 회고도 진행하면서 자존감이 많이 떨어졌던 순간이었다.\n개발자는 제품을 직접 만드는 사람이다보니, 제품에 대해 많은 기여를 할 수 있지만, 그만큼의 책임감을 가져야한다는 것을 깨달았던 순간이었다.\n\n그리고 제품의 안정성에 대해 크게 관심을 가지게 되었던 계기가 되었다. 다시는 장애를 만들고 싶지 않아 '어떻게 하면 다시 이런 장애를 만들지 않을 수 있을까' 혼자 엄청나게 고민하게 되었다. 하지만 의도적으로 장애를 만드는 사람이 없듯이, 경험을 통해서 점점 설계와 좋은 코드에 대해 배우면서 놓치는 부분들이 줄여져 가겠지만 여전히 사람이라면 예상하지 못한 곳에서 발생할 수 밖에 없다고 생각이 정리 되었다.\n\n한마디로 빈도는 줄일 수 있어도 **사람은 실수할 수밖에 없다**라고 정리가 되었다. 그러면 내가 해야할 노력해야할 행동은 `예측하는 게 아니라 빠르게 대응하는 것`이라고 생각했다.\n\n개인적으로 공부를 해서 냄새나는 코드를 빠르게 찾는 노력은 당연히 시간을 들여서 하지만, 지금 내가 할 수 있는 노력은 빠르게 대응하기 위한 작업을 담당해 보자는 생각이 들었다.\n\n그렇게 시작한 작업이 바로 에러 모니터링 강화, [에러바운더리 도입](https://choi2021.github.io/2024-06-02-%EC%97%90%EB%9F%AC%EB%B0%94%EC%9A%B4%EB%8D%94%EB%A6%AC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/)이었다.\n\n당시 에러 모니터링은 필요한 부분, 중요 도메인에 한해서 로깅용도로 사용되고 있었고, 여러 에러들이 위계없이 슬랙으로 제보되면서 중요한 에러를 구분하기 어려워 빠른 대처가 어려웠다.\n\n이를 해결하기 위해서 에러 로깅에 위계를 설정하고, 불필요한 에러 로그와 필요한 로그를 구분하고, 비어있는 catch문으로 전파되지 않는 에러가 없게 eslint 룰을 추가하는 로딩 개선 작업과 화이트스크린 에러가 발생한 상황에서도 앱을 계속해서 사용할 수 있도록 에러바운더리를 스크린 단위로 제품 전체에 적용했다.\n\n사고 치기 싫어서(?) 진행했던 작업이었지만 제품 안정성에 대한 고민을 해볼 수 있게 되었고, 챕터 내에서 자연스럽게 담당하게 된 영역 중 하나가 되어 이후, 에러 모니터링 과정에서 어려움이 있을 때, 나에게 물어보시기도 하고 에러 모니터링 툴을 변경하는 작업에서도 POC를 담당해서 진행하는 등 긍정적인 방향으로 이어졌다.\n\n작업을 하면서도 쉽지는 않았다. 모호할 수 있는 기준을 처음부터 세우고, 에러 바운더리라는 기술이 해결할 수 있는 문제들을 소개하고 어떤 장단점이 있는지 설명했을 때를 떠올려보면, 일이 이만큼 커질 줄은 몰랐다. 혼자서 제품 전체에 적용하면서 길어지는 작업 과정에서 지치기도 하고, 동료분들이 공감할 수 있는 작업을 하고 있는 건지 중간중간 힘들기도 했다.\n\n![레몬베이스로 받았던 동료 피드백중 일부](에러바운더리-피드백.png)\n\n다행히 중간 중간 작업 과정을 계속해서 공유드렸던 것의 효과였을까, 작업에 대해 주기적으로 피드백과 좋은 방향을 함께 제시 해주셨고, 덕분에 잘 마무리할 수 있었다. 장기적인 일을 할 때 일의 범위를 적당한 단위로 **끊어가는 것의 중요성**도 덤으로 배워갔다.\n\n앞으로도 아마 실수하고 싶지 않지만, 장애를 만들 수 있다. 중요한 건 일어난 일을 잘 마무리 한 후에 더 좋은 제품을 만드는 기회로 바꿔서, 더 나은 시스템과 코드를 함께 만들어 가기 위해 노력해 나가는 것이라 생각한다. 실수를 성장의 기회로 만들어 준 좋은 동료들에게 감사한 마음을 가지고 더 좋은 제품을 만들어 나가야겠다.\n\n### 2. 나중에 리팩토링할 시간은 없다\n\n작업을 하다보면 늘 **시간**과 **퀄리티**는 늘 고민하게 되는, 함께 가기 어려운 트레이드 오프인 것 같다. 현실의 문제는 늘 시간과 싸우기 때문에 시간 내 빠르게 동작하는 코드를 만들게 되는 경우가 많았고, 쌓여진 동작만 하는 코드들은, 서로 엉켜 더 이상 다음 기능을 붙일 수 없게 되고 결국 `대공사`가 필요해졌다.\n\n![그래 날면 된거야...](리팩토링.png)\n\n그렇다면 이전으로 돌아가서 어떻게 하면 더 좋은 결과물을 만들 수 있을까?\n\n시간을 많이 들이면 제품의 퀄리티가 올라갈 수 있지만, 시간은 한정되어 있는 이러한 현실의 문제를 해결하기 위해 내가 선택한 방법은 **틈틈이, 짬짬히 리팩토링하는 것**이었다.\n\n당시 시간이 없어서 퀄리티가 떨어졌고, 이만큼의 기능을 담당하게 될 줄 몰랐던 코드라면, 지금의 내가 계속해서 과거의 내 작업을 돌아보는 것이 맞겠다는 생각이 들었다.\n\n그러면 지금의 작업은 늦춰지는 건 아닐까 라는 생각이 들지만, 그때보다 도메인에 적응하고, 코드베이스에 익숙해지면서 대체로 어제보다 오늘 더 좋은 코드를 작성하게 되었던 것 같다. 그리고 익숙해진 부분이 많아진 상태에서 다시 요구사항들을 바라보면 그때보다 훨씬 간단히 해결할 때도 많았다.\n\n그리고 하드스킬을 키우기 위한 노력을 지속해 같은 기능을 만들 때 시간을 줄여 더 좋은 코드로 작성하기 위해 노력해왔다. 조금 더 좋은 패턴, 좋은 설계방법들을 보고 배우며, 나와 유사한 문제를 풀어오신 선배 개발자분들의 흔적을 열심히 쫓아갔던 것 같다.\n\n이러한 노력들이 티나지 않는 내 나름의 양심적인 노력이라 생각하고 틈틈히 챕터업무로 진행해왔다. 하지만 동료분들은 그런 모습을 보면서 격려와 계속했으면 하는 점으로, 내가 가진 장점으로 봐주시기도 했다.\n\n![리팩토링관련 피드백 일부](리팩토링-피드백.png)\n\n앞으로도 개발자로서 좋은 코드를 만들기 위해 틈틈히, 짬짬히 리팩토링을 진행해가며 역량을 늘려 더 좋은 코드를 만들어 나가야겠다.\n\n### 3. 질문하는 개발자\n\n현업에서 일하기 전, 내가 생각했던 잘하는 개발자는 주어진 요구사항을 척척 해결하는 개인의 퍼포먼스를 잘 내는 사람이라고 생각했다. 그리고 입사 초기 \"내가 얼마나 잘하는 사람인지 보여줘야 해\"라는 생각에 혼자서 압박감에 시달리고 힘들어 했었고, 1년을 일할 때까지도 나보다 잘하는 동료들의 모습을 보면 \"내가 다른 사람들보다 잘한다고 할 수 있는 무기가 뭘까\" 고민하고 내 부족함을 부끄러워했다. 질문을 할 때 나를 판단하지 않는 동료들이였지만 혼자서 너무 부족한 질문은 아닐까 걱정하기도 했다.\n\n내가 만든 무거운 짐들은 다행히 시간이 흐르면서 관점을 내가 아니라 잘하는 동료의 모습을 조사해보기로 바꾸면서 줄어들게 되었다.\n\n좋은 동료분들의 모습들을 정리해보았을 때 다 달랐다. 어떤 분은 히스토리를 잘 기억하셔서 팀이 정책적으로 힘들어할 때 결정을 잘 내릴 수 있게 돕기도하고, 어떤 분은 비개발자 분들과 소통할 때 기술적인 내용을 잘 풀어서 설명해주시도 했다. 어떤 분은 자동화에 진심이어서 팀의 비효율을 개선하려 노력하셨고, 어떤 분은 설계에 관심이 많아서 잘짜여진 구조를 만드는 일을 잘하셨다.\n\n나라는 한사람이 이 모든것을 다 잘하면 좋겠지만 현실적으로 할 수 없다는 사실을 자연스럽게 받아드리기로 했다.\n대신 작업을 진행하면서 나에게 부족한 부분들이 동료가 잘하는 부분이라면 가서 **적극적으로 물어보고 배우기로** 했다. **모르는 것을 받아드리고, 질문하는 것이 더 빠르게 성장할 수 있는 방법**이라고 생각하게 되었다.\n\n질문하는 과정에서 자연스럽게 동료의 잘하는 부분을 나의 것으로 조금씩 만들어나갈 수 있었고, 더 좋은 제품을 위한 토론을 하면서 우리 팀에서 반복적으로 겪는 문제를 알게 되고, 당장은 중요하지 않을 수 있지만 장기적으로 필요로 하는 부분들에 대해서 제안하고 담당하며 나만의 뾰족함도 만들어 나갈 수 있었다.\n\n현재 내가 되고 싶은 사람, 내가 생각하는 좋은 개발자는 **질문하는 개발자**인 것 같다. 기존 방식을 당연하지 않게 바라보고 조금 더 효율적이고 쉬운방법을 고민하고 질문을 던지는 사람, 코드리뷰 속에서 당연하게 생각했던 부분에 던져진 하나의 물음을 통해 동료가 더 깊이 고민하고 더 좋은 방법을 찾아낼 수 있게 하는 사람이다.\n\n앞으로도 이렇게 질문하며, 계속해서 더 성장해나가길, 그리고 좋은 질문을 던지는 사람이 되어가길 바래본다.\n\n### 4. 코딩은 사회적 활동이다\n\n코딩은 컴퓨터에게 명령을 하고 원하는 결과물을 얻어나가는 과정이라고 개인과 컴퓨터간의 상호작용이라고 생각하기 쉽지만, 혼자서 작업을 진행하는 것이 아니라 동료와 함께 작업을 진행하는 **사회적 활동**이라는 점을 많이 배웠다.\n\n사람은 모두 다르다. 좋아하는 것도, 잘하는 것도, 중요하게 생각하는 것도 다르다. 그리고 그러한 관심사들이 코드를 작성하는 개발자 한명, 한명에게 묻어난다.\n\n나는 선언적인 비동기 처리에 관심이 많았고, 에러바운더리, suspense를 통해서 선언적으로 비동기 상태를 관리하는 방식을 제품에 녹여내고 싶었다.\n\n에러 바운더리는 작업 전에 어떤 장단점이 있는지, 우리가 얻을 수 있는 건 어떤건지, 그리고 얼마나 제품의 복잡도가 올라가게 될지 등 다양하게 설명하는 시간을 가질 수 있었다. 발표를 통해 동료분들과 함께 고민하는 시간을 가지고, 혼자서 오래 고민하던 문제를 더 좋은 방향으로 작업을 진행해 잘 마무리할 수 있었다.\n\n하지만 전역로딩 경험 개선 작업을 진행하면서는 충분한 시간을 가지지 못했다. Tanstack Query와 Suspense를 이용해 로딩상태를 분리하는 작업을 모두 다 진행하고 난 뒤에 사후에 작업 결과를 정리하는 시간을 가졌다. 그때 동료분께서 해주신 피드백은 `작업이 풀고자하는 문제보다 복잡하게 되었다`는 점이었다.\n\n코드리뷰를 하면서 일부 동료분들은 어떻게 작업이 진행되고 있는지 접할 수 있었지만, 랜덤으로 배정되다보니 피드백 시간에 처음보시는 분도 계셨기 때문에 어렵게 느껴지셨던 것 같다.\n\n나에게 당연하다고 느끼는 것이 누군가에게 당연하지 않다는, 어쩌면 당연한 사실을 다시금 깨달았다. 이러한 과정을 겪으면서 단순히 내가 생각하는 좋은 것이 제품에 적용되는 게 중요한 게 아니라, 함께 코드를 작성하는 동료분들이 어떻게 생각하는지 들어보고 **함께 고민하는 시간이 중요하다**는 것을 깊이 깨달을 수 있었다. 제품 내 반영되게 되면 나만 관리하면 되는게 아니라 동료들이 함께 가꾸어야 하는 팀의 자산이 된다는 것을 놓쳤던 것 같다.\n\n이직을 하게 되면서 실제로 더이상 내가 관리할 수 없게 되었고, 마음의 빚이 된 작업으로 남게 되었다. \"먼저 어떤 문제를 어떻게 풀지 설명했더라면, 조금 더 설득력있고 복잡도를 낮추는 방향으로 미리 작업 방향을 바꿨을텐데\"하는 아쉬움이 아직도 많이 든다.\n\n앞으로는 시간이 더 걸리고, 이해를 맞춰가는데 어려울 수 있지만 코드를 작성하는 동료분들과 더 좋은 방향으로 작업을 진행해 나가야겠다.\n\n## 📝 마무리\n\n숨고는 나에게 너무 감사한 곳이다. 배울 수 있는 부분이 너무 많았고, 부족한 나에게 많은 기회를 주고, 개발자라는 직업에 대해 더 깊이 이해하게 해준 곳이었다. 그리고 앞으로 어떤 개발자가 되고 싶은지, 어떤 사람이 되고 싶은지 옆의 동료들을 보며 많이 느끼고 배울 수 있는 곳이었다.\n\n이제는 다음 회사로 떠나지만, 숨고에서 배운 것들을 기억하며 더 성장해 더 많은 것을 나누어줄 수 있는 개발자가 되고 싶다.\n\n![바이바이 숨고](bye-soomgo.png)\n"},{"excerpt":"9월은 스쿼드 업무로 신규 비즈니스 모델에 대한 마지막 실험을 진행해보고, 3분기 동안 진행했던 프로젝트를 마무리하는 시간이었다.\n로딩경험 개선 작업에 대해 글을 작성했고, 토스 FE 멘토링 accelerator에 참여하면서 분석했던 useFunnel에 대한 글도 작성했다.\n3개월의 업무를 정리했던 9월에 대해 회고하고 10월의 계획을 세워보려 한다. 9…","fields":{"slug":"/2024-10-01-2024년-9월-회고/"},"frontmatter":{"date":"October 01, 2024","title":"9️⃣ 2024년 9월 회고","tags":["회고"]},"rawMarkdownBody":"\n9월은 스쿼드 업무로 신규 비즈니스 모델에 대한 마지막 실험을 진행해보고, 3분기 동안 진행했던 프로젝트를 마무리하는 시간이었다.\n로딩경험 개선 작업에 대해 글을 작성했고, 토스 FE 멘토링 accelerator에 참여하면서 분석했던 useFunnel에 대한 글도 작성했다.\n3개월의 업무를 정리했던 9월에 대해 회고하고 10월의 계획을 세워보려 한다.\n\n## 9월의 액션아이템\n\n9월의 액션아이템은 아래 3가지로 설정했었다.\n\n- React Query를 이용한 로딩 경험 개선 작업 정리하기\n- useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기\n- MMKV 데이터 스토리지 라이브러리 적용 작업 정리하기\n\n이중 위 2가지는 진행했지만 마지막 MMKV 데이터 스토리지 라이브러리 적용 작업 정리하기는 하지 못했다.\n\n### React Query를 이용한 로딩 경험 개선 작업 정리하기\n\n로딩 경험 개선을 위해 React Query와 Suspense를 제품 내 도입하면서 이를 적용한 결과를 정리해 [글](https://choi2021.github.io/2024-09-25-%EB%A1%9C%EB%94%A9%EA%B2%BD%ED%97%98-%EA%B0%9C%EC%84%A0/)로 작성했다.\n해당 글을 작성하면서 다시 돌아보니 Suspense와 React Query를 이용해 적용한 방법이 어려웠을 수 있겠다는 생각이 들었다.\n\n처음 작업을 보았을 때 Suspense, Query의 생소한 개념들에 대해 이해하는데 어려웠을 것 같았다.\n챕터에서 진행하는 일들은 보통 제품 전역에 영향을 주거나, 새로운 표준이 될 수 있는 작업이 되는 것 같다.\n\n그래서 더더욱 안정적으로 잘 정리와 공유시간이 필요했는데, 현실적인 시간이 없었던 부분과 코드리뷰로도 충분했겠지라는 나만의 생각으로 인해 작업이 온전히 공유되지 못했던 것 같다.\n\n코딩은 사회적 활동이라는 말의 의미를, 이번 작업을 통해 다시 한번 느낄 수 있었던 것 같다.\n\n### useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기\n\n토스 FE Accelerator 멘토링 과정을 진행하면서 분석했던 useFunnel 라이브러리에 대한 [글](https://choi2021.github.io/2024-09-17-useFunnel-%EB%B6%84%EC%84%9D%ED%95%B4%EB%B3%B4%EA%B8%B0/)을 작성했다.\n발표자료에 워낙 잘 정리되어 있었기 때문에 풀고자 하는 문제와 해결방법을 따라 만들면서 많이 배울 수 있었고, 이러한 과정을 글로 정리해 녹여내보고 싶었다.\n\n현재는 해당 라이브러리에 대한 새로운 버전이 나와있어 추후에 해당 라이브러리도 조금 더 공부해보면 좋을 것 같다.\n\n처음부터 큰 라이브러리들을 분석하는 것은 쉽지 않지만, 내가 사용하고 있는 라이브러리에 대해 분석하고 공유하는 것은 좋은 방법이 될 수 있겠다는 생각이 들었다.\n앞으로도 이러한 작업을 지속적으로 해보면 좋을 것 같다.\n\n### MMKV 데이터 스토리지 라이브러리 적용 작업 정리하기\n\nMMKV 데이터 스토리지 라이브러리 적용 작업은 Native Module에서 token을 어떻게 가져올지에 대한 문제로 인해, 보류되고 있다.\n실제 적용 후에 적용 과정과 성능에 대한 결과를 정리해보고 싶었지만, 아직 적용을 못한 상태이다.\n\n다음 달에 배포 후에 해당 작업에 대한 결과를 정리해보려 한다.\n\n## 10월의 액션아이템\n\n- React Query 도입 가이드 작성하기\n- 토스 오픈소스 라이브러리 분석해보기\n\n10월의 액션아이템으로 위 두가지로 정한 이유는, 토스로 **이직**을 준비하고 있기 때문이다.\n\n현재 3분기 로딩경험 개선을 위해 적용한 React Query를 현재까지 적용해온 기준과 가이드를 작성하고, 토스에서 잘 적응하기 위해 토스의 오픈소스 라이브러리를 분석해보려 한다.\n\n이직을 결심하게 된 건, 토스 FE Accelerator 멘토링 과정을 진행하면서 Native 쪽 보다는 웹에 대한 업무를 더 많이 하고 싶다는 생각에 시작하게 되었다.\n\n부족하지만 멘토링 과정 이후에 멘토님의 추천을 받을 수 있었고, 11월 4일을 입사일로 정해지게 되었다.\n\n10월에는 아마 현재 진행 중인 프로젝트를 마무리하는 시간을 가지게 될 것 같다. 숨고에서 너무 많이 배웠고, 아직도 배울게 많지만 조금 더 주도적으로 일할 수 있고, 내가 채우고 싶은 전문성을 더 깊이있게 고민하고 있는 동료들이 있는 환경에 가고 싶었다.\n\n현재의 안정적인 환경보다 새롭게 도전하며 나를 밀어 붙여서 성장하고 싶다는 생각에 이직을 결심했다.\n\n10월에는 내가 맡았던 업무들을 잘 마무리할 수 있기를 바라고, 새로운 환경에서 잘 적응할 수 있을 준비를 하려 한다.\n"},{"excerpt":"❓로딩 경험 개선은 왜 필요할까 일전에 동료분께서 공유해주신 글로 카카오 페이지의 무조건 스켈레톤 화면을 보여주는게 사용자 경험에 도움이 될까요?라는 글을 읽게 되었다.\n글의 내용을 요약하면 무조건 스켈레톤 UI와 같은 로딩 상태를 위한 UI를 보여주는 것이 사용자 경험에 도움이 되지 않는다는 내용이었다. 아티클의 예시로 나왔던 이미지 둘을 보면, 100…","fields":{"slug":"/2024-09-25-로딩경험-개선/"},"frontmatter":{"date":"September 25, 2024","title":"⏳ 로딩 경험 개선","tags":["UX","suspense"]},"rawMarkdownBody":"\n## ❓로딩 경험 개선은 왜 필요할까\n\n일전에 동료분께서 공유해주신 글로 카카오 페이지의 [무조건 스켈레톤 화면을 보여주는게 사용자 경험에 도움이 될까요?](https://tech.kakaopay.com/post/skeleton-ui-idea/)라는 글을 읽게 되었다.\n글의 내용을 요약하면 **무조건** 스켈레톤 UI와 같은 로딩 상태를 위한 UI를 보여주는 것이 사용자 경험에 도움이 되지 않는다는 내용이었다.\n\n<table>\n    <tr>\n        <th>예시 100ms</th>\n        <th>예시 300ms</th>\n    </tr>\n    <tr>\n        <td><img src=\"100MS_SKELETON.gif\" alt=\"100ms 로딩\"></td>\n        <td><img src=\"300MS_SKELETON.gif\" alt=\"300ms 로딩\"></td>\n    </tr>\n</table>\n\n아티클의 예시로 나왔던 이미지 둘을 보면, 100ms는 300ms 응답보다 유저에게 빠르게 와서 더 좋은 상황임에도 불구하고,\n로딩 상태로 인해 **깜빡임이 발생하는 것**처럼 보여 사용자에게 불편함을 줄 수 있다.\n\n이러한 상황은 당시 우리 제품에서도 발생하고 있는 상황이었다.\n\n![전역 로딩으로 인해 깜빡이는 듯한 알림 목록 화면](loading_before.gif)\n\n위 예시처럼 dim처리가 있는 **전역 로딩**을 사용하는 화면들에서 많이 느껴지던 불편함이었고, 진입시 **전역로딩**을 사용하는 화면들을 작업범위로 정하고 작업을 시작했다.\n\n## ❗️로딩 경험 개선을 위한 두가지 접근법\n\n그러면 어떻게 로딩 상태에 대해 개선할 수 있을까? 여기에 대해서는 두가지 접근 방법이 있었다.\n각각을 **지연 로딩 시간 설정**과 **최소 로딩 시간 설정**이라고 부르려한다.\n\n### 1. 최소 로딩 시간 설정: 임의로 최소 로딩시간을 주기\n\n최소 로딩 시간 설정 방식은 응답 속도와 무관하게 일정시간을 로딩UI를 노출한 후에 성공/실패 화면을 보여주는 방식으로,\n로딩 시간이 깜빡임으로 느껴지지 않을 만큼 충분히 길게 노출시키는 방식이다.\n\n해당 방식의 장점은 응답속도와 무관하게 적용되기 때문에, 전체 유저에게 일정한 유저 경험을 보장할 수 있다.\n하지만 응답이 빠르게 왔지만, 특정 시간만큼 기다려야 하기 때문에 유저 입장에서 불편함을 느낄 수 있다.\n\n### 2. 지연 로딩 시간 설정: 특정 시간만큼의 Delay를 준 후에 노출시키기\n\n지연 로딩 시간 설정 방식은 로딩 UI 노출을 특정시간만큼 지난 후에 노출시키는 방식으로 빠른 응답이 오는 경우에\n로딩 UI가 노출되지 않고 성공/실패 화면으로 넘어갈 수 있기 때문에 깜빡임을 방지할 수 있다.\n\n해당 방식의 장점은 응답속도에 따라 로딩 UI를 노출시키기 때문에, 빠른 응답속도를 보장하면서 깜빡임을 방지할 수 있다.\n하지만 해당 시간 이후로 걸릴 경우 일부 사람에게는 여전히 깜빡임이 발생할 수 있기 때문에, 기준이 될 시간에 대한 고려가 필요했다.\n\n예를 들어 200ms를 기준으로 지연 로딩 시간을 설정하면, 200ms 이내에 응답이 오면 로딩 UI를 노출하지 않고, 200ms 이후에 응답이 오면 로딩 UI를 노출하는 방식이다.\n하지만 250ms가 걸린 경우에는 200ms 이후에 로딩 UI가 노출되기 때문에, 50ms동안 로딩 UI가 보였다 사라지기 때문에 여전히 깜빡임이 발생할 수 있다.\n\n각각 장단점이 있는 방식이기 때문에 고민이 필요해 동료분들의 의견을 여쭤보았고 최소 로딩 시간 설정 방식으로 진행했을 때 **로딩 시간을 임의로 늘리는 것**이기 때문에,\n유저에게 안좋을 것 같다는 동료분들의 의견이 있어 **지연 로딩 시간 설정**을 적용하기로 했다.\n\n## 🚀 지연 로딩 시간 설정 적용\n\n전역로딩을 이용하는 화면들에 지연 로딩 시간을 설정하기 위해서는 생각보다 간단했다.\n\nRedux 전역 로딩상태를 구독하고 있는 최상위 컴포넌트에 정의되어 있는 FullScreenLoading 컴포넌트에 지역 상태를 추가한 후에 전역상태가 변경되면\n지연시간을 주고 로딩 UI를 노출하도록 구현했다.\n\n```tsx\nexport const FullScreenLoading: React.FC = () => {\n  const globalLoading = useSelector(state => state.globalLoading)\n  const [show, setShow] = useState(false)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setShow(visible)\n    }, 200)\n    return () => {\n      clearTimeout(timeout)\n    }\n  }, [globalLoading])\n\n  return show ? <Loading loading={globalLoading} /> : null\n}\n```\n\n하지만 두가지 포인트에 대한 고려가 필요했다.\n\n먼저 전역로딩의 용도가 다양했다. POST 요청 과정에서 여러번 호출되지 않게 막을 때, 발송 과정에서 안드로이드 백버튼과 같이 뒤로가기를 하지 못하게 막는 역할을 함께 하고 있다보니,\n진입시에 필요한 지연 로딩을 전체적으로 적용하는 것이 적절하지 않아 보였다.\n\n두 번째로는 지연 로딩 시간 설정의 단점인 특정 시간 이상 걸리는 유저에게는 여전히 깜빡임이 발생할 수 있다는 점을 고려해, 페이지별 지연시간 설정이 가능하게 구현하는 게 필요하다고 생각했다.\nRedux에 추가적인 속성을 정의해서 해결할 수 있지만, Redux 사용을 지양하는 팀내 컨벤션을 생각해 Redux 의존성을 줄이는 방향으로 구현하려 했다.\n\nRedux 없이 구현하는 방식으로 개인적으로 관심이 많던 **Tanstack Query**와 **Suspense**를 이용해, 로딩 상태를 선언적으로 분리한 후에 지연시간을 설정하는 방식을 적용하기로 했다.\n\n### Suspense로 로딩 상태 선언적으로 분리하기\n\n**Suspense**는 React에서 비동기 상태를 선언적으로 처리하는 방식으로, 에러바운더리는 에러를 suspense는 로딩 상태를 분리할 수 있다.\n\n예를 들어 아래 코드와 같이 컴포넌트 내에서 데이터 조회에 대한 성공/실패/로딩 세가지 경우에 대한 상태가 함께 존재했을 때 분기문이 길어져 코드 가독성이 떨어지고,\n일일이 상태를 manual하게 관리하면서 실수가 발생할 수 있다.\n\n```tsx\nfunction MyComponent() {\n  const [data, setData] = useState()\n  const [isLoading, setIsLoading] = useState(true)\n  const [isError, setIsError] = useState(false)\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        setIsLoading(true)\n        const data = await fetchData()\n        setData(data)\n        setIsLoading(false)\n      } catch (error) {\n        setIsError(true)\n        setIsLoading(false)\n      }\n    }\n    fetchData()\n  }, [])\n\n  if (isLoading) return <div>Loading data...</div>\n\n  if (isError)\n    return (\n      <div>\n        Oops failed to fetch data! <a href=\"/home\">Home page</a>\n      </div>\n    )\n\n  return (\n    <ul>\n      {data.map(({ id, name }) => {\n        return <li key={id}>{name}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n위 코드를 개선해 에러는 에러바운더리, 로딩은 Suspense로 분리하면 우리가 관심을 가지고 있는 성공 상태에 대해서만 신경쓰면 되어 코드 가독성이 향상되고,\n선언적인 방식으로 상태를 관리해 개발자의 실수를 줄일 수 있다.\n\n```tsx\nfunction MyComponentContent() {\n  const data = useFetchData() // 임의의 suspense 사용가능한 훅\n  return (\n    <ul>\n      {data.map(({ id, name }) => {\n        return <li key={id}>{name}</li>\n      })}\n    </ul>\n  )\n}\nfunction MyComponent() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<div>Loading data...</div>}>\n        <DataLoader />\n      </Suspense>\n    </ErrorBoundary>\n  )\n}\n```\n\n이제 여기에 지연로딩을 위해 전역 로딩 컴포넌트에 적용하는 방식과 유사하게 지연시간을 주고 로딩 UI를 노출하도록 구현해보자.\n\n### 지연 로딩을 위한 Delay 컴포넌트 구현하기\n\n지연 로딩을 위한 컴포넌트를 카카오 페이지 글에서는 **DeferredComponent**라고 명명했지만, 토스의 [Suspensive](https://suspensive.org/) 라이브러리 내의 Delay 컴포넌트를 참고해\n조금 더 직관적인 Delay로 정하게 되었다. 아래는 Delay 컴포넌트 구현 코드이다.\n\n```tsx\nexport const Delay: React.FC<{ ms?: number }> = ({ ms = 200, children }) => {\n  const [show, setShow] = useState(false)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setShow(true)\n    }, ms)\n    return () => {\n      clearTimeout(timeout)\n    }\n  }, [ms])\n\n  return show ? <>{children}</> : null\n}\n\n// Delay 컴포넌트 사용 예시\nfunction MyComponentContent() {\n  const data = useFetchData() // 임의의 suspense 사용가능한 훅\n  return (\n    <ul>\n      {data.map(({ id, name }) => {\n        return <li key={id}>{name}</li>\n      })}\n    </ul>\n  )\n}\nfunction MyComponent() {\n  return (\n    <ErrorBoundary>\n      <Suspense\n        fallback={\n          <Delay>\n            <div>Loading data...</div>\n          </Delay>\n        }\n      >\n        <DataLoader />\n      </Suspense>\n    </ErrorBoundary>\n  )\n}\n```\n\nDelay 컴포넌트는 기존 전역 상태를 이용하는 방식과 유사하게 지연시간을 주고 로딩 UI를 노출하도록 구현했다.\nProps으로 ms를 받아 지연시간을 설정할 수 있고, 기본값은 카카오 페이지 글을 참고해 200ms로 설정했다.\n\n하지만, Suspense 자체적으로 아직 Next JS와 같은 프레임워크나, 특정 인터페이스로 데이터를 가져오는 경우가 아니면 사용할 수 없는 한계점이 존재했다.\n\n![공식문서 suspense에 대한 Note](suspense-official.png)\n\nSuspense를 지원하는 라이브러리들은 Recoil, Relay, Tanstack Query 등이 있고, 다행히 우리 프로젝트에서 아주 일부 사용하고 있던 Tanstack Query가 V5 기준으로 안정적으로 지원하고 있었기 때문에 Tanstack Query를 이용해 적용해보기로 했다.\n\n![Tanstack Query migrate to v5 섹션의 suspense에 대한 노트](migrate_to_v5.png)\n\n### Tanstack Query의 SuspenseQuery를 이용한 Suspense 적용\n\nTanstack Query V5버전에서 suspense를 이용하기 위해서는 새롭게 추가된 `useSuspenseQuery`,`useSuspenseQueries`,`useSuspenseInfiniteQuery` 세가지 훅을 이용해야 한다.\n\n각각에 대한 적용방법을 알아보자.\n\n#### 1. useSuspenseQuery를 이용한 적용\n\nuseSuspenseQuery는 **단일 쿼리**에 대해 suspense를 적용할 때 사용한다. 아래 코드는 useSuspenseQuery를 이용해 데이터를 가져오는 코드이다.\n\n```tsx\nfunction MyComponentContent() {\n  const { data } = useSuspenseQuery({\n    queryKey: \"data\",\n    queryFn: fetchData,\n  })\n\n  return (\n    <ul>\n      {data.map(({ id, name }) => {\n        return <li key={id}>{name}</li>\n      })}\n    </ul>\n  )\n}\nfunction MyComponent() {\n  return (\n    <ErrorBoundary>\n      <Suspense\n        fallback={\n          <Delay>\n            <div>Loading data...</div>\n          </Delay>\n        }\n      >\n        <DataLoader />\n      </Suspense>\n    </ErrorBoundary>\n  )\n}\n```\n\n<img src=\"suspenseQuery.gif\" width=\"500\">\n\n#### 2. useSuspenseQueries를 이용한 적용\n\n여러 쿼리에 대해 Suspense를 적용할 때는 각각을 SuspenseQuery로 함께 작성하게 되면 Promise를 순서대로 던지면서 컴포넌트 렌더링이 suspend되게 되기 때문에, 병렬로 처리되지 못하게 된다.\n\n![각각 suspenseQuery를 적용했을 때 길어지는 요청시간](suspenseQueries_before.gif)\n\n이러한 길어지는 요청시간을 개선하기 위해서는 하위 컴포넌트에서 각각 useSuspenseQuery로 호출하게 하거나, **useSuspenseQueries**로 병렬로 호출할 수 있다.\n\n![공식문서 parallel queries 섹션의 suspense 사용시 주의점 노트](parallel_queris.png)\n\n```tsx\nimport { useSuspenseQueries } from \"@tanstack/react-query\"\nimport { fetchProjects } from \"../queries\"\n\nexport default function Projects() {\n  const [{ data }] = useSuspenseQueries({\n    queries: [\n      {\n        queryKey: [\"projects\"],\n        queryFn: () => fetchProjects(1),\n      },\n      {\n        queryKey: [\"projects2\"],\n        queryFn: () => fetchProjects(2),\n      },\n    ],\n  })\n\n  return (\n    <div>\n      <h1>TanStack Repositories</h1>\n      {data.map(project => (\n        <p key={project.full_name}>{project.name}</p>\n      ))}\n    </div>\n  )\n}\n```\n\n이렇게 적용하게 되면 앞선 요청이 끝나고 다음 요청을 하는게 아니라 병렬로 처리되기 때문에, 각각의 요청시간이 더해지지 않고 병렬로 처리되어 더욱 빠른 응답속도를 보장할 수 있다.\n\n![suspenseQueries를 이용해 병렬로 처리한 결과](suspenseQueries_after.gif)\n\n### 3. useSuspenseInfiniteQuery를 이용한 적용\n\nuseSuspenseInfiniteQuery는 무한 스크롤/ 페이지네이션이 필요한 목록 화면에 대한 Suspense를 적용할 때 사용한다. 아래 코드는 useSuspenseInfiniteQuery를 이용해 데이터를 가져오는 코드이다.\n\n```tsx\nexport default function PaginatedProjects() {\n  const { data, fetchNextPage, isFetching } = useSuspenseInfiniteQuery<\n    Data,\n    Error,\n    InfiniteData<Data>,\n    QueryKey,\n    number | undefined\n  >({\n    queryKey: [\"projects\"],\n    queryFn: ({ pageParam }) => {\n      return fetchProjects({ pageParam })\n    },\n    initialPageParam: 1,\n    getNextPageParam: (lastPage, pages) => {\n      return lastPage.length === 10 ? pages.length + 1 : undefined\n    },\n  })\n\n  const list = data.pages.flat()\n\n  return (\n    <div>\n      <h1>TanStack Repositories</h1>\n      <button onClick={() => fetchNextPage()}>불러오기</button>\n      {list.map(project => (\n        <p key={project.full_name}>{project.name}</p>\n      ))}\n      {isFetching ? <p>불러오는중...</p> : null}\n    </div>\n  )\n}\n```\n\n<img src=\"suspenseInfiniteQuery.gif\" width=\"500\">\n\nSuspenseQuery 훅들을 적용했을 때 부수적인 장점으로 코드적으로 뿐만 아니라, 타입적으로도 성공했을 때에 대한 타입을 명확하게 지정시켜준다.\n덕분에 라이브러리 내의 초기값으로 정의된 undefined과 구분되어 별도로 undefined을 좁혀주는 Validation 없이 적용이 가능했다.\n\n<table width=\"100%\">\n    <tr>\n        <th>useQuery 타입 정의</th>\n    </tr>\n    <tr>\n        <td><img src=\"queryType.png\"  ></td>\n    </tr>\n    <tr>\n        <th>useSuspenseQuery 타입 정의</th>\n    </tr>\n    <tr>\n        <td><img src=\"suspense_query_type.png\" ></td>\n    </tr>\n</table>\n\n### AsyncBoundary 구현\n\nSuspenseQuery를 이용해 Suspense를 적용하게 되면 Query가 실패했을 때 에러를 던지기 때문에 에러바운더리가 필요하다.\n\n이때 중요했던 것은 기존 처럼 단순히 ErrorBoundary를 이용하는 게 아니라 tanstack Query의 **QueryErrorResetBoundary**를 한번 더 감싸서,\nreset할 수 있게 구현해야 했다.\n\n```tsx\nimport { QueryErrorResetBoundary } from \"@tanstack/react-query\"\nimport { ErrorBoundary } from \"react-error-boundary\"\n\nfunction MyComponent() {\n  return (\n    <QueryErrorResetBoundary>\n      {({ reset }) => (\n        <ErrorBoundary\n          onReset={reset}\n          fallbackRender={({ resetErrorBoundary }) => (\n            <div>\n              There was an error!\n              <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n            </div>\n          )}\n        >\n          <Suspense\n            fallback={\n              <Delay>\n                <div>Loading data...</div>\n              </Delay>\n            }\n          >\n            <DataLoader />\n          </Suspense>\n        </ErrorBoundary>\n      )}\n    </QueryErrorResetBoundary>\n  )\n}\n```\n\n상대적으로 길어진 코드길이와 매번 SuspenseQuery를 사용할 때마다 많은 코드를 작성해야하기 떄문에 이를 추상화하고 재사용할 수 있게 **AsyncBoundary**라는 컴포넌트를 구현해 사용했다.\n\n```tsx\nimport { ReactElement, Suspense } from \"react\"\nimport { ErrorBoundary } from \"react-error-boundary\"\nimport { QueryErrorResetBoundary } from \"@tanstack/react-query\"\n\ntype AsyncBoundaryProps = {\n  pendingFallback: ReactElement\n  rejectFallback: ReactElement\n  children: ReactElement\n}\n\nexport function AsyncBoundary({\n  pendingFallback,\n  rejectFallback,\n  children,\n}: AsyncBoundaryProps) {\n  return (\n    <QueryErrorResetBoundary>\n      {({ reset }) => (\n        <ErrorBoundary onReset={reset} fallback={rejectFallback}>\n          <Suspense fallback={pendingFallback}>{children}</Suspense>\n        </ErrorBoundary>\n      )}\n    </QueryErrorResetBoundary>\n  )\n}\n\nfunction MyComponent() {\n  return (\n    <AsyncBoundary\n      pendingFallback={\n        <Delay>\n          <div>Loading data...</div>\n        </Delay>\n      }\n      rejectFallback={<div>There was an error!</div>}\n    >\n      <DataLoader />\n    </AsyncBoundary>\n  )\n}\n```\n\n### 로딩 UI 개선\n\n지연 로딩 방식은 200ms 이상 걸릴 경우 깜빡임이 발생할 수 있기 때문에, 로딩 UI 자체를 개선하는 작업도 필요하다 생각했다.\n\n기존 전역 로딩 UI는 dim 처리가 되어있어 기본 바탕색이 되는 흰색과 차이가 커서 더 깜빡임이 느껴지는 것 같아 로딩 UI를 흰바탕의 ActivityIndicator를 이용한\nUI로 교체해 개선했다.\n\n<table>\n    <tr>\n        <th>기존 전역 로딩 UI</th>\n        <th>개선된 전역 로딩 UI</th>\n    </tr>\n    <tr>\n        <td><img src=\"loading_before.gif\" alt=\"기존 로딩 UI\" width=\"332\"></td>\n        <td><img src=\"loading_after.gif\" alt=\"개선된 로딩 UI\" width=\"332\"></td>\n    </tr>\n    <tr>\n        <th>기존 전역 로딩 UI</th>\n        <th>개선된 전역 로딩 UI</th>\n    </tr>\n    <tr>\n        <td><img src=\"loading_before.gif\" alt=\"기존 로딩 UI\" width=\"332\"></td>\n        <td><img src=\"loading_after.gif\" alt=\"개선된 로딩 UI\" width=\"332\"></td>\n    </tr>\n</table>\n\n상대적으로 덜하긴 하지만, 깜빡임이 느껴질 수 있을 만한 시간을 체크해서 세부적인 조정도 진행하는 작업을 진행하면 이후에 더 좋은 유저경험을 기대할 수 있을 것 같다.\n\n## 지연 로딩 시간 설정 적용 후 결과와 느낀 점\n\n아래는 앞서 제품내 전역로딩으로 인해 깜빡임이 발생하던 알림 목록화면에 적용한 결과다.\n\n<table>\n    <tr>\n        <th>200ms 이하로 걸릴 때</th>\n        <th>200ms 이상으로 걸릴 때</th>\n    </tr>\n    <tr>\n        <td><img src=\"200ms_under.gif\" alt=\"200ms_under\" width=\"332\"></td>\n        <td><img src=\"loading_after.gif\" alt=\"200ms_over\" width=\"332\"></td>\n    </tr>\n</table>\n\n200ms 이하로 걸릴 때는 로딩 UI가 노출되지 않고, 200ms 이상으로 걸릴 때는 로딩 UI가 노출되는 것을 확인할 수 있다.\n\n깜빡임이 심하게 느껴지던 전역로딩을 진입시 로딩 UI로 사용하는 화면들에 대해서만 작업을 했지만, 작업과정에서 Tanstack Query와 Suspense를 이용해 선언적으로 비동기 상태를 관리하는 방법을 고민하고 적용해,\n평소 비동기 상태 관리에 관심을 제품에 녹일 수 있는 좋은 경험이었다.\n\n하지만 개인적으로 아쉬웠던 건 적용과정에서 페이지별 소요되는 시간들을 이용해 세밀하게 지연 로딩 시간을 적용하지 못했고, 배포 후 결과를 공유하며 구현 방식이 복잡했다는 피드백을 받기도 했다.\n\n나의 기준에서는 제품 내 선언적인 비동기 상태 관리와 Tanstack Query의 적극적 도입이 필요하다고 생각하고 작업 방향을 잡았지만, 팀내에서는 필요성에 대한 공감이 부족한 채로, 밀어붙였던 것 같다.\n\n이러한 작업을 진행할 때에는 팀원들과 충분한 커뮤니케이션이 필요하다는 것을 느꼈다. 다음에는 조금 더 사전 공유와 의견을 듣는 시간을 만들어서 작업을 진행하는 게 좋을 것 같다는 생각이 들었다.\n"},{"excerpt":"2023 토스 Slash의 퍼널: 쏟아지는 페이지 한 방에 관리하기 발표에서 복잡한 퍼널간 상태관리를 위한 라이브러리 useFunnel을 소개했다. 퍼널: 쏟아지는 페이지 한 방에 관리하기 인트로 \n 프론트엔드 개발자라면 여러 스텝에 거쳐서 사용자의 입력을 받고, 해당 정보를 제출하는 폼 정보를 다루는 경험을 한번쯤은 하게된다. 그리고 페이지나 스텝이 많…","fields":{"slug":"/2024-09-17-useFunnel-분석해보기/"},"frontmatter":{"date":"September 17, 2024","title":"📚 useFunnel 분석하고 따라 만들어 보기","tags":["slash","FE Accelerator","useFunnel"]},"rawMarkdownBody":"\n2023 토스 Slash의 [퍼널: 쏟아지는 페이지 한 방에 관리하기 발표](https://www.youtube.com/watch?v=NwLWX2RNVcw&t=50s)에서 복잡한 퍼널간 상태관리를 위한 라이브러리 useFunnel을 소개했다.\n\n[퍼널: 쏟아지는 페이지 한 방에 관리하기 인트로 ]\n![useFunnel Slash 발표](useFunnel-presentation-cover.png)\n\n프론트엔드 개발자라면 여러 스텝에 거쳐서 사용자의 입력을 받고, 해당 정보를 제출하는 폼 정보를 다루는 경험을 한번쯤은 하게된다. 그리고 페이지나 스텝이 많아지면 많아질수록 복잡도는 올라가고, 디버깅의 어려움을 겪기도 한다.\n\n현업에서 자주 마주치는 이 문제를 우아하게 풀어낸 토스의 useFunnel 라이브러리를 언젠가 분석하고 적용해봐야겠다고 생각했지만 당시에는 미래의 나에게 맡겨두고(?) 미뤄두었다.\n\n토스의 프론트엔드 accelerator 멘토링 과정의 2주차 주제였던 `퍼널간 상태 관리하기`라는 주제로 과제를 개선하게 되었고, 더이상 미루지말자라는 마음으로 useFunnel 라이브러리를 분석하고 적용해보는 과정을 진행했다.\n\n![이제는 useFunnel을 분석하고 적용해보자](infinite_challenge.png)\n\nuseFunnel 라이브러리는 당시 Next JS에 의존도를 가지고 있었지만 현재는 타입적으로 강화되었고, Next JS 뿐 아니라 React Router와 같은 다양한 Routing 라이브러리들을 지원할 수 있게 [개선된 버전](https://use-funnel.slash.page/ko)도 만들어졌다.\n![개선된 useFunnel](updated_useFunnel.png)\n\n이번 글은 [구 useFunnel 라이브러리](https://www.slash.page/ko/libraries/react/use-funnel/README.i18n) 발표와 라이브러리를 분석하고, 이를 적용해보는 과정을 공유하려 한다.\n\n## useFunnel이 풀고 싶은 문제\n\n### Funnel이란?\n\nFunnel이란 용어는 현재 재직중인 회사에서도 많이 사용하는 용어로, 원래는 마케팅에서 많이 사용하는 용어로 알려져있다.\n\nFunnel의 의미는 깔때기로 번역되며 초기 단계에 많은 사용자가 들어오다가, 중간 단계에서는 일부 사용자가 빠져나가고, 마지막 단계에서는 일부 사용자만 남게되는 형태를 의미한다.\n\n![funnel 이미지](funnel.png)\n\n그러면 이러한 Funnel 형태로 구성되는 디자인을 알아보자.\n\n### 디자인 요구사항 탐방\n\n발표 자료는 휴대폰 가입에 대한 예제로, 각 스텝별로 가입방식, 주민번호, 집주소를 입력한 후에 제출하는 방식을 취하고 있다.\n\n![디자인 요구사항](design.png)\n\n이를 해결하는 방법, useFunnel을 사용하기 전 후로 나눠서 살펴보자.\n\n### useFunnel 전 해결 방법과 예제\n\nuseFunnel을 사용하기 전에는 전역상태를 사용하여 데이터를 관리하고, 각 스텝을 페이지로 별로 관리하고, 제출 API를 호출할 때 모아온 데이터를 담아 발송하는 방식으로 구현할 수 있다.\n\n![전역상태를 이용한 해결방법](globalstate.png)\n\n발표보다 조금 더 간단히 이동 버튼을 누르면 전역 상태를 업데이트 하고 마지막 집 주소 스텝에서는 alert를 보여주고 제출 완료 화면에서 작성된 내용을 출력하는 예제를 작성해 보았다.\n\n![예제 폴더 구조](전_예제_폴더구조.png)\n\n```tsx\nexport default function PhoneNumberPage() {\n  const setForm = useFormStore(state => state.setForm)\n  const router = useRouter()\n\n  const handleClick = () => {\n    setForm({ phoneNumber: \"010-1234-5678\" })\n    router.push(\"/form/citizenNumber\")\n  }\n\n  return (\n    <div className={styles.page}>\n      <main className={styles.main}>\n        <h1>휴대전화 입력</h1>\n        <button className={styles.primary} onClick={handleClick}>\n          주민번호 입력 스텝으로 이동\n        </button>\n      </main>\n    </div>\n  )\n}\n\nexport default function CitizenNumberPage() {\n  const setForm = useFormStore(state => state.setForm)\n  const phoneNumber = useFormStore(state => state.form.phoneNumber)\n  const router = useRouter()\n\n  const handleClick = () => {\n    setForm({ citizenNumber: \"123456789\" })\n    router.push(\"/form/address\")\n  }\n  return (\n    <div className={styles.page}>\n      <main className={styles.main}>\n        <h1>주민번호 입력</h1>\n        <p>{`입력된 휴대번호: ${phoneNumber}`}</p>\n        <button className={styles.primary} onClick={handleClick}>\n          주소입력 스텝으로 이동\n        </button>\n      </main>\n    </div>\n  )\n}\n\n// 전역 스토어\n\nconst initialForm: Form = {\n  phoneNumber: \"\",\n  address: \"\",\n  citizenNumber: \"\",\n}\n\nexport const useFormStore = create<StoreType>(set => ({\n  form: initialForm,\n  setForm: (form: Partial<Form>) =>\n    set(state => {\n      return {\n        ...state,\n        form: {\n          ...state.form,\n          ...form,\n        },\n      }\n    }),\n  resetForm: () => set({ form: initialForm }),\n}))\n```\n\n<img src=\"적용전_실행.gif\" width=\"400\"/>\n\n요구사항을 모두 충족하면서 정석적인 방법이지만, 두가지 유지보수의 어려움이 존재하게 된다.\n\n1. 스텝별로 어떤 데이터/ 어떤 스텝으로 이동하는지 **페이지를 들어가야 알 수 있다**\n2. 상태를 수집하는 곳과 사용하는 곳이 달라 **수정할 때 전체 흐름을 추적해야한다**\n\n위 두가지 문제를 어떻게 해결한 useFunnel 훅에 대해 알아보자.\n\n### useFunnel을 이용한 해결 방법\n\n위 문제를 해결하기 위해서 우선 여러개의 페이지로 구성된 스텝을 **하나의 페이지**에서 관리하고 각 스텝들은 조건부 렌더링을 이용해 하위 컴포넌트로 변경해 **스텝별 UI 흐름을 한눈에 추적하기 쉽게** 개선할 수 있다.\n\n그리고 기존 전역상태로 관리하던 폼 데이터는 지역상태로 둠으로써 스텝과 데이터가 한곳에서 관리하게 되고, 사용하는 곳과 업데이트 하는 곳 모두 하나의 파일내 작성해 **응집도를 높이는 이점**을 가질 수 있다.\n\n![useFunnel을 이용한 해결 방법](useFunnel-이용방식.png)\n\n그러면 이에 맞게 이전 예제를 리팩토링해보자.\n\n![적용 후 프로젝트 구조 ](적용후_프로젝트구조.png)\n\n```tsx\nexport type Form = {\n  phoneNumber: string\n  address: string\n  citizenNumber: string\n}\n\nconst initialForm: Form = {\n  phoneNumber: \"\",\n  address: \"\",\n  citizenNumber: \"\",\n}\n\nexport default function FormPage() {\n  const [form, setForm] = useState<Form>(initialForm)\n  const [step, setStep] = useState<\n    \"주민번호\" | \"주소\" | \"핸드폰번호\" | \"제출완료\"\n  >(\"핸드폰번호\")\n\n  return (\n    <div className={styles.page}>\n      <main className={styles.main}>\n        {step === \"핸드폰번호\" && (\n          <PhoneNumberStep\n            onNext={(phoneNumber: Form[\"phoneNumber\"]) => {\n              setForm(prev => ({ ...prev, phoneNumber }))\n              setStep(\"주민번호\")\n            }}\n          />\n        )}\n        {step === \"주민번호\" && (\n          <CitizenNumberStep\n            phoneNumber={form.phoneNumber}\n            onNext={(citizenNumber: Form[\"citizenNumber\"]) => {\n              setForm(prev => ({ ...prev, citizenNumber }))\n              setStep(\"주소\")\n            }}\n          />\n        )}\n        {step === \"주소\" && (\n          <AddressStep\n            phoneNumber={form.phoneNumber}\n            citizenNumber={form.citizenNumber}\n            onNext={async (address: Form[\"address\"]) => {\n              try {\n                // 제출 로직\n                await new Promise(resolve => {\n                  setTimeout(resolve, 1000)\n                })\n                setForm(prev => ({ ...prev, address }))\n                setStep(\"제출완료\")\n              } catch (error: unknown) {\n                alert(`제출 실패: ${error}`)\n                return\n              }\n            }}\n          />\n        )}\n\n        {step === \"제출완료\" && <CompleteStep form={form} />}\n      </main>\n    </div>\n  )\n}\n\n// 주민번호 스텝 컴포넌트\n;(\"use client\")\n\nimport styles from \"@/app/page.module.css\"\nimport { Form } from \"@/app/registerForm/page\"\n\ntype CitizenNumberPageProps = {\n  phoneNumber: Form[\"phoneNumber\"]\n  onNext: (citizenNumber: Form[\"citizenNumber\"]) => void\n}\n\nexport function CitizenNumberStep({\n  phoneNumber,\n  onNext,\n}: CitizenNumberPageProps) {\n  const handleClick = () => {\n    onNext(\"123456789\")\n  }\n  return (\n    <>\n      <h1>주민번호 입력</h1>\n      <p>{`입력된 휴대번호: ${phoneNumber}`}</p>\n      <button className={styles.primary} onClick={handleClick}>\n        주소입력 스텝으로 이동\n      </button>\n    </>\n  )\n}\n```\n\n위 리팩토링한 예제 코드를 통해 보면 발표처럼 여러 페이지가 아니라 하나의 페이지로, 전역상태로 폼 데이터를 관리하는 것이 아니라 지역상태로 관리하고, 각 스텝별로 조건부 렌더링을 통해 UI를 관리하는 것을 확인할 수 있다.\n\n<img src=\"적용후_실행.gif\" width=\"400\">\n\n동작도 기존과 동일하게 작동하며, 새로운 스텝이 생겨도 조건부 렌더링 조건을 추가하면 되고, 제출을 다른 스텝에서 진행해야 하더라도 prop만 변경하면 되어, **코드의 가독성과 유지보수성**이 향상되었다.\n\n## useFunnel 라이브러리 따라 만들어가기\n\n그러면 이제 useFunnel 라이브러리를 따라 만들어가보자. 발표에서 순차적으로 추상화 과정이 잘 설명되어있어서 그대로 순차적으로 만들어가보려 한다.\n\n### 1. 조건부 렌더링 추상화\n\n먼저 조건부 렌더링 부분을 Step이라는 컴포넌트로 추상화할 수 있다. 조건이 맞을 때에만 보여줄 수 있게 하는 컴포넌트로 발표에서는 if라는 property로,\n예제에서는 show라는 property로 적용해보았다.\n\n![조건부 렌더링 추상화](조건부렌더링_추상화.png)\n\n```tsx\nexport default function FormPage() {\n  const [form, setForm] = useState<Form>(initialForm)\n  const [step, setStep] = useState<\n    \"주민번호\" | \"주소\" | \"핸드폰번호\" | \"제출완료\"\n  >(\"핸드폰번호\")\n\n  return (\n    <div className={styles.page}>\n      <main className={styles.main}>\n        <Step show={step === \"핸드폰번호\"}>\n          <PhoneNumberStep\n            onNext={(phoneNumber: Form[\"phoneNumber\"]) => {\n              setForm(prev => ({ ...prev, phoneNumber }))\n              setStep(\"주민번호\")\n            }}\n          />\n        </Step>\n        <Step show={step === \"주민번호\"}>\n          <CitizenNumberStep\n            phoneNumber={form.phoneNumber}\n            onNext={(citizenNumber: Form[\"citizenNumber\"]) => {\n              setForm(prev => ({ ...prev, citizenNumber }))\n              setStep(\"주소\")\n            }}\n          />\n        </Step>\n        <Step show={step === \"주소\"}>\n          <AddressStep\n            phoneNumber={form.phoneNumber}\n            citizenNumber={form.citizenNumber}\n            onNext={async (address: Form[\"address\"]) => {\n              try {\n                // 제출 로직\n                await new Promise(resolve => {\n                  setTimeout(resolve, 1000)\n                })\n                setForm(prev => ({ ...prev, address }))\n                setStep(\"제출완료\")\n              } catch (error: unknown) {\n                alert(`제출 실패: ${error}`)\n                return\n              }\n            }}\n          />\n        </Step>\n\n        <Step show={step === \"제출완료\"}>\n          <CompleteStep form={form} />\n        </Step>\n      </main>\n    </div>\n  )\n}\n\n// Step 컴포넌트\nexport function Step({ show, children }: PropsWithChildren<{ show: boolean }>) {\n  if (!show) {\n    return null\n  }\n  return <>{children}</>\n}\n```\n\n### 2. 반복되는 조건문과 Step 상태 추상화\n\nstep에 조건문을 반복하지 않고, 단순히 어떤 스텝인지만 넘겨주면, 현재 step과 비교하여 조건부 렌더링을 할 수 있게 추상화해보자.\n\n![반복되는 조건문과 Step 상태 추상화한 인터페이스](step_추상화.png)\n\n이를 위해서 드디어 오늘 주제인 useFunnel 훅이 나오게 된다. 현재 스텝을 Step 컴포넌트가 알기 위해서는 이를 관리하는 Funnel이라는 컴포넌트로 children으로 전달되는 Step들중 현재와 일치하는 step만 렌더링하게 할 수 있다.\n\n![useFunnel](step_상태추상화.png)\n\n예제 코드에 적용해보자.\n\n```tsx\nexport default function FormPage() {\n  const [form, setForm] = useState<Form>(initialForm)\n  const [Funnel, setStep] = useFunnel()\n\n  return (\n    <Funnel>\n      <Funnel.Step name={\"핸드폰번호\"}>\n        <PhoneNumberStep\n          onNext={(phoneNumber: Form[\"phoneNumber\"]) => {\n            setForm(prev => ({ ...prev, phoneNumber }))\n            setStep(\"주민번호\")\n          }}\n        />\n      </Funnel.Step>\n      <Funnel.Step name={\"주민번호\"}>\n        <CitizenNumberStep\n          phoneNumber={form.phoneNumber}\n          onNext={(citizenNumber: Form[\"citizenNumber\"]) => {\n            setForm(prev => ({ ...prev, citizenNumber }))\n            setStep(\"주소\")\n          }}\n        />\n      </Funnel.Step>\n      <Funnel.Step name={\"주소\"}>\n        <AddressStep\n          phoneNumber={form.phoneNumber}\n          citizenNumber={form.citizenNumber}\n          onNext={async (address: Form[\"address\"]) => {\n            try {\n              // 제출 로직\n              await new Promise(resolve => {\n                setTimeout(resolve, 1000)\n              })\n              setForm(prev => ({ ...prev, address }))\n              setStep(\"제출완료\")\n            } catch (error: unknown) {\n              alert(`제출 실패: ${error}`)\n              return\n            }\n          }}\n        />\n      </Funnel.Step>\n      <Funnel.Step name={\"제출완료\"}>\n        <CompleteStep form={form} />\n      </Funnel.Step>\n    </Funnel>\n  )\n}\n\n// useFunnel 훅\ntype StepProps = {\n  children: React.ReactNode\n}\n\nfunction Step({ children }: StepProps) {\n  return <>{children}</>\n}\n\ntype FunnelProps = {\n  children: React.ReactNode\n  step: \"주민번호\" | \"주소\" | \"핸드폰번호\" | \"제출완료\"\n}\n\nexport function useFunnel() {\n  const [step, setStep] = useState<\n    \"주민번호\" | \"주소\" | \"핸드폰번호\" | \"제출완료\"\n  >(\"핸드폰번호\")\n  const FunnelComponent = ({ children }: FunnelProps) => {\n    const validSteps = Children.toArray(children).filter(isValidElement)\n    const targetStep = validSteps.find(\n      (\n        children: React.ReactElement<{\n          name: \"주민번호\" | \"주소\" | \"핸드폰번호\" | \"제출완료\"\n        }>\n      ) => children.props.name === step\n    )\n\n    if (targetStep == undefined) {\n      throw new Error(`${step} 스텝 컴포넌트를 찾지 못했습니다.`)\n    }\n\n    return targetStep\n  }\n\n  return [Object.assign(FunnelComponent, { Step }), setStep] as const\n}\n```\n\n발표 자료의 코드는 짧은 시간내의 이해도를 위해 조금 더 간소화 버전을 소개해주셨지만 [useFunnel 오픈 소스](https://github.com/toss/slash/blob/main/packages/react/use-funnel/src/Funnel.tsx)를 보면 예제 코드처럼 유효한 children만 필터링하여 현재 step과 일치하는 step만 렌더링하는 방식으로 구현되어있다.\n\n![실제 Funnel 컴포넌트](useFunnel_funnel.png)\n\n여기서 또한 볼 수 있는 것은 외부에 노출할 필요가 없는 Step 컴포넌트를 useFunnel 내부에 숨기고, 외부에 노출할 Funnel 컴포넌트만 노출하는 **Compound 패턴**으로 컴포넌트 간 관계를 잘 보여주고 있다.\n\n### 3. Steps 타입 추상화\n\n발표내용에는 없지만 예제 코드에 구현한 훅은 현재 타입이 내부에서 하드코딩되어있어, 이를 추상화하여 외부에서 타입을 지정할 수 있게 만들어보려 한다.\n이 작업은 오픈소스 코드에서 어떻게 타입을 관리하고 있는지를 참고해 구현해보았다.\n\n```tsx\nexport default function FormPage(){\n    const [form, setForm] = useState<Form>(initialForm);\n    const [Funnel,setStep]=useFunnel({\n        steps:['핸드폰번호','주민번호','주소','제출완료'] as const\n    });\n\n    return (\n        // ...\n    );\n};\n\n\n// useFunnel 훅\n\ntype NonEmptyArray<T> = readonly [T, ...T[]];\ntype StepsType = NonEmptyArray<string>;\n\ntype StepProps<Steps extends StepsType> = {\n    name: Steps[number];\n    children: ReactNode;\n};\n\nfunction Step<Steps extends StepsType>({ children }: StepProps<Steps>) {\n    return <>{children}</>;\n}\n\ntype FunnelProps<Steps extends StepsType> = {\n    children: Array<ReactElement<StepProps<Steps>>>;\n    steps: Steps;\n    step: Steps[number];\n};\n\nfunction Funnel<Steps extends StepsType>({children, step, steps}: FunnelProps<Steps>) {\n    const validSteps = Children.toArray(children)\n        .filter(isValidElement)\n        .filter((child) => {\n            return steps.includes(\n                (child.props as Partial<StepProps<Steps>>).name ?? \"\"\n            );\n        }) as Array<ReactElement<StepProps<Steps>>>;\n\n    const targetStep = validSteps.find(\n        (children) => children.props.name === step\n    );\n\n    if (targetStep == undefined) {\n        throw new Error(`${step} 스텝 컴포넌트를 찾지 못했습니다.`);\n    }\n\n    return targetStep;\n}\n\ntype RouteFunnelProps<Steps extends StepsType> = Omit<\n    FunnelProps<Steps>,\n    \"steps\" | \"step\"\n>;\n\ntype FunnelComponent<Steps extends StepsType> = ((\n    props: RouteFunnelProps<Steps>\n) => ReactElement) & {\n    Step: (props: StepProps<Steps>) => ReactElement;\n};\n\nexport function useFunnel<Steps extends StepsType>(steps: Steps) {\n    const [step, setStep] = useState<Steps[number]>(steps[0]);\n    const FunnelComponent: FunnelComponent<Steps> = useMemo(\n        () =>\n            Object.assign(\n                function RouteFunnel(props: RouteFunnelProps<Steps>) {\n                    return (\n                        <Funnel<Steps> steps={steps} step={step}>\n                            {props.children}\n                        </Funnel>\n                    );\n                },\n                { Step }\n            ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        []\n    );\n\n    return [FunnelComponent, setStep] as const;\n}\n\n```\n\n위 코드는 useFunnel 오픈소스 코드를 거의 그대로 가져온 코드로 추상화된 훅을 사용하면서 외부에서 타입을 지정할 수 있게 만들어보았다.\n각 코드들을 조금씩 뜯어보면서 왜 각각이 필요한지 정리해보자.\n\n- StepsType\n\n```tsx\ntype NonEmptyArray<T> = readonly [T, ...T[]]\ntype StepsType = NonEmptyArray<string>\n```\n\nStepsType은 빈배열이 아님을 타입적으로 보장하고, 전달하는 스텝 배열에 따라 `리터럴`로 타입을 좁혀주기 위해, **readonly**로 되어 있다.\nGeneric으로 받은 Steps 타입은 StepProps와 FunnelProps에서 사용되어, 각각의 컴포넌트에서 사용할 수 있게 되었다.\n\n- StepProps\n\n```tsx\ntype StepProps<Steps extends StepsType> = {\n  name: Steps[number]\n  children: ReactNode\n}\n\nfunction Step<Steps extends StepsType>({ children }: StepProps<Steps>) {\n  return <>{children}</>\n}\n```\n\nStepProps는 Step 컴포넌트에서 사용할 타입을 정의한 것으로, name은 **전달된 Steps 배열의 요소중 하나**로 타입을 좁힌다.\n\n- FunnelProps\n\n```tsx\ntype FunnelProps<Steps extends StepsType> = {\n  children: Array<ReactElement<StepProps<Steps>>>\n  steps: Steps\n  step: Steps[number]\n}\n\nfunction Funnel<Steps extends StepsType>({\n  children,\n  step,\n  steps,\n}: FunnelProps<Steps>) {\n  const validSteps = Children.toArray(children)\n    .filter(isValidElement)\n    .filter(child => {\n      return steps.includes(\n        (child.props as Partial<StepProps<Steps>>).name ?? \"\"\n      )\n    }) as Array<ReactElement<StepProps<Steps>>>\n\n  const targetStep = validSteps.find(children => children.props.name === step)\n\n  if (targetStep == undefined) {\n    throw new Error(`${step} 스텝 컴포넌트를 찾지 못했습니다.`)\n  }\n\n  return targetStep\n}\n```\n\nFunnelProps는 Funnel 컴포넌트의 Prop을 지정한 부분이고 Funnel 내부에 유효한 children으로 필터링하는 과정에서 타입 단언으로 작성되어 있다.\n타입 단언으로 작성된 이유가 뭘까하고 제거해보았을 때, 아래 `children.props.name`에서 `name`이 정의되어 있지 않다는 에러가 발생하기 때문에 타입 단언을 사용한 것으로 보인다.\n\n- FunnelComponent\n\n```tsx\ntype RouteFunnelProps<Steps extends StepsType> = Omit<\n  FunnelProps<Steps>,\n  \"steps\" | \"step\"\n>\n\ntype FunnelComponent<Steps extends StepsType> = ((\n  props: RouteFunnelProps<Steps>\n) => ReactElement) & {\n  Step: (props: StepProps<Steps>) => ReactElement\n}\n\nexport function useFunnel<Steps extends StepsType>(steps: Steps) {\n  const [step, setStep] = useState<Steps[number]>(steps[0])\n  const FunnelComponent: FunnelComponent<Steps> = useMemo(\n    () =>\n      Object.assign(\n        function RouteFunnel(props: RouteFunnelProps<Steps>) {\n          return (\n            <Funnel<Steps> steps={steps} step={step}>\n              {props.children}\n            </Funnel>\n          )\n        },\n        { Step }\n      ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  )\n\n  return [FunnelComponent, setStep] as const\n}\n```\n\nRouteFunnel은 Funnel 컴포넌트를 분리하는 대신 바로 작성해도 동작에는 문제가 없지만 코드 가독성을 위해 분리시키신 것으로 보였다.\nFunnelComponent 타입 Step 컴포넌트의 타입을 지정해줌으로서 **Step의 name이 전달받은 Steps 배열의 요소중 하나임을 보장**할 수 있게된다.\n\n해당 타입 없이도 StepsType을 사용하면서 자동으로 좁혀지지 않을까 했지만, 타입 지정전에는 단순 컴포넌트로 암묵적으로 추론되면서 name에 지정된 값이 아닌 다른값을 넣거나, Steps로 빈배열을 넣어도 타입에러가 안나게 된다.\n\n<table width=\"100%\">\n    <tr>\n        <th>타입 지정 전</th>\n    </tr>\n    <tr>\n        <td>\n            <img width=\"655\" src=\"FunnelComponent타입지정_전.png\">\n        </td>\n    </tr>\n    <tr>\n        <th>타입 지정 후</th>\n    </tr>\n    <tr>\n        <td>\n            <img width=\"655\" src=\"FunnelComponent타입지정_후.png\">\n        </td>\n    </tr>\n</table>\n\n### 4. 히스토리 관리\n\n하나의 페이지로 관리하게 되면서 가독성은 올라가게 되었지만 뒤로가기를 했을 때 스텝별 히스토리가 유지되지 못하게 되었다.\n\n해당 문제를 해결하기 위해 발표 내용을 참고해보면 step을 상태가 아니라 **QueryParam**으로 관리하는 방식으로 해결했다.\n![히스토리 관리](history.png)\n\n위 방법과 같이 예제코드에 적용해보자.\n\n```tsx\n// QS\nfunction createQueryString(params: Record<string, any>) {\n  const queryString = createSearchParamString(params)\n\n  if (queryString === \"\") {\n    return \"\"\n  }\n\n  return `?${queryString}`\n}\n\nfunction createSearchParamString(params: Record<string, any>) {\n  return new URLSearchParams(\n    Object.entries(params)\n      .filter(([, value]) => value != null)\n      .map(([key, value]) => {\n        if (Array.isArray(value)) {\n          return value.map(x => [key, x])\n        }\n        return [[key, value]]\n      })\n      .flat()\n  )\n    .toString()\n    .replace(/\\+/g, \"%20\")\n}\n\nexport const QS = {\n  create: createQueryString,\n}\n\n// useFunnel 훅\ninterface SetStepOptions {\n  stepChangeType?: \"push\" | \"replace\"\n}\n\nconst STEP_QUERY_KEY = \"funnel-step\"\n\nexport function useFunnel<Steps extends StepsType>(\n  steps: Steps,\n  initialStep: Steps[number]\n) {\n  const router = useRouter()\n  const setStep = useCallback(\n    (step: Steps[number], setStepOptions?: SetStepOptions) => {\n      const url = `${QS.create({\n        [STEP_QUERY_KEY]: step,\n      })}`\n\n      switch (setStepOptions?.stepChangeType) {\n        case \"replace\":\n          router.replace(url)\n          return\n        case \"push\":\n        default:\n          router.push(url)\n          return\n      }\n    },\n    [router]\n  )\n\n  const FunnelComponent: FunnelComponent<Steps> = useMemo(\n    () =>\n      Object.assign(\n        function RouteFunnel(props: RouteFunnelProps<Steps>) {\n          const step = useQueryParam(STEP_QUERY_KEY) ?? initialStep\n          return (\n            <Funnel<Steps> steps={steps} step={step}>\n              {props.children}\n            </Funnel>\n          )\n        },\n        { Step }\n      ),\n    []\n  )\n\n  return [FunnelComponent, setStep] as const\n}\n```\n\nQueryParam으로 Step을 관리하게 되면서 더이상 step 지역상태는 불필요하게 되었고, setStep의 옵션으로 push와 replace에 따라 히스토리를 관리할 수 있게 되었다.\n\n<table>\n    <tr>\n        <th>히스토리 관리 전 뒤로가기</th>\n        <th>히스토리 관리 후 뒤로가기</th>\n    </tr>\n    <tr>\n        <td>\n            <img width=\"655\" src=\"히스토리관리_전.gif\">\n        </td>\n        <td>\n            <img width=\"655\" src=\"히스토리관리_후.gif\">\n        </td>\n    </tr>\n</table>\n\n### 5. 폼 데이터 관리\n\n발표는 히스토리 관리까지를 라이브러리 작업에 대한 소개로 마무리했지만, 오픈 소스 코드를 보면 폼 데이터 관리에 대한 부분도 있어서 추가해보았다.\n\n코드 중에는 데이터 스토리지를 이용해 이전 작성한 값들을 저장하고 불러오는 로직도 있었지만, 현재 예제에서는 생략하였다.\n\n```tsx\nexport type Form = {\n  phoneNumber?: string\n  address?: string\n  citizenNumber?: string\n}\n\nexport default function FormPage() {\n  const [Funnel, state, setState] = useFunnel([\n    \"핸드폰번호\",\n    \"주민번호\",\n    \"주소\",\n    \"제출완료\",\n  ] as const).WithState<Form>({})\n\n  return (\n    <div className={styles.page}>\n      <main className={styles.main}>\n        <Funnel>\n          <Funnel.Step name={\"핸드폰번호\"}>\n            <PhoneNumberStep\n              onNext={(phoneNumber: Form[\"phoneNumber\"]) => {\n                setState(prev => ({\n                  ...prev,\n                  step: \"주민번호\",\n                  phoneNumber,\n                }))\n              }}\n            />\n          </Funnel.Step>\n          <Funnel.Step name={\"주민번호\"}>\n            <CitizenNumberStep\n              phoneNumber={state.phoneNumber}\n              onNext={(citizenNumber: Form[\"citizenNumber\"]) => {\n                setState(prev => ({\n                  ...prev,\n                  step: \"주소\",\n                  citizenNumber,\n                }))\n              }}\n            />\n          </Funnel.Step>\n          <Funnel.Step name={\"주소\"}>\n            <AddressStep\n              phoneNumber={state.phoneNumber}\n              citizenNumber={state.citizenNumber}\n              onNext={async (address: Form[\"address\"]) => {\n                try {\n                  // 제출 로직\n                  await new Promise(resolve => {\n                    setTimeout(resolve, 1000)\n                  })\n                  setState(prev => ({\n                    ...prev,\n                    step: \"제출완료\",\n                    address,\n                  }))\n                } catch (error: unknown) {\n                  alert(`제출 실패: ${error}`)\n                  return\n                }\n              }}\n            />\n          </Funnel.Step>\n          <Funnel.Step name={\"제출완료\"}>\n            <CompleteStep form={state} />\n          </Funnel.Step>\n        </Funnel>\n      </main>\n    </div>\n  )\n}\n\n// useFunnel 훅\n\nexport function useFunnel<Steps extends StepsType>(\n  steps: Steps,\n  initialStep?: Steps[number]\n) {\n  const router = useRouter()\n  const _initialStep = initialStep ?? steps[0]\n  const setStep = useCallback(\n    (step: Steps[number], setStepOptions?: SetStepOptions) => {\n      const url = `${QS.create({\n        [STEP_QUERY_KEY]: step,\n      })}`\n\n      switch (setStepOptions?.stepChangeType) {\n        case \"replace\":\n          router.replace(url)\n          return\n        case \"push\":\n        default:\n          router.push(url)\n          return\n      }\n    },\n    [router]\n  )\n\n  const FunnelComponent: FunnelComponent<Steps> = useMemo(\n    () =>\n      Object.assign(\n        function RouteFunnel(props: RouteFunnelProps<Steps>) {\n          const step = useQueryParam(STEP_QUERY_KEY) ?? _initialStep\n          return (\n            <Funnel<Steps> steps={steps} step={step}>\n              {props.children}\n            </Funnel>\n          )\n        },\n        { Step }\n      ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  )\n\n  type S = Record<string, unknown>\n  type Step = Steps[number]\n  type NextState = S & { step?: Step }\n\n  const nextPendingStepRef = useRef<Step | null>(null)\n  const nextStateRef = useRef<Partial<S> | null>(null)\n\n  const WithState = <State extends S>(initialState: State) => {\n    const [state, _setState] = useState<S>(initialState)\n    const setState = useCallback(\n      (\n        next: Partial<NextState> | ((next: Partial<NextState>) => NextState)\n      ) => {\n        let nextStepValue: Partial<NextState>\n        if (typeof next === \"function\") {\n          nextStepValue = next(state)\n        } else {\n          nextStepValue = next\n        }\n\n        console.log(nextStepValue)\n\n        if (nextStepValue.step != null) {\n          nextPendingStepRef.current = nextStepValue.step\n        }\n        nextStateRef.current = nextStepValue\n\n        _setState(next)\n      },\n      [_setState, state]\n    )\n\n    useEffect(() => {\n      if (nextPendingStepRef.current == null) {\n        return\n      }\n      if (deepEqual(nextStateRef.current, state)) {\n        setStep(nextPendingStepRef.current)\n        nextPendingStepRef.current = null\n      }\n    }, [state])\n\n    return [FunnelComponent, state, setState] as const\n  }\n\n  return Object.assign([FunnelComponent, setStep] as const, {\n    WithState,\n  }) as readonly [\n    FunnelComponent<Steps>,\n    (step: Steps[number], options?: SetStepOptions) => void\n  ] & {\n    WithState: <StateExcludeStep extends Record<string, unknown>>(\n      initialState: StateExcludeStep\n    ) => [\n      FunnelComponent<Steps>,\n      StateExcludeStep,\n      (\n        next:\n          | Partial<StateExcludeStep & { step: Steps[number] }>\n          | ((\n              next: Partial<StateExcludeStep & { step: Steps[number] }>\n            ) => StateExcludeStep & { step: Steps[number] })\n      ) => void\n    ]\n  }\n}\n```\n\nsetState로 폼 데이터를 업데이트시킨 후에 다음 step으로 이동시키기 위해 nextPendingStepRef와 nextStateRef와 useEffect를 사용한 것으로 보인다.\n마지막 타입 단언을 하지 않았을 때 state의 타입이 주입한 타입이 아니라 `Record<string, unknown>`로 추론되기 때문에 타입 단언을 사용한 것으로 보인다.\n\n이렇게 step과 폼 데이터를 함께 관리하게 되면서, 보다 응집도를 높인 훅을 완성할 수 있었다.\n\n## 마치며\n\nuseFunnel이란 훅을 너무 좋은 방법이다 생각하다 드디어 직접 분석해보았다.\n요구사항들과 해결방법을 코드와 함께 히스토리를 분석해보는 과정에서 더 깊이 있게 공부할 수 있게 되었고, 앞으로도 틈틈히 오픈소스를 분석해보며 더 많은 것을 배워나가야겠다.\n"},{"excerpt":"정신없이 9월을 보내다 보니 8월이 끝나고도 벌써 15일이나 지나버렸다. 조금 늦었지만 8월을 회고하고 9월의 계획을 세워보려 한다. 8월의 액션아이템 7월에 계획했던 8월의 액션아이템은 아래 4가지이다. 이중 앞선 2가지는 완료했지만, useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기와 컴포넌트 설계 추가 작업 진행하기는 하지 못했다. …","fields":{"slug":"/2024-09-15-2024년-8월회고/"},"frontmatter":{"date":"September 15, 2024","title":"🥳 2024년 8월회고 ","tags":["회고","FE Accelerator"]},"rawMarkdownBody":"\n정신없이 9월을 보내다 보니 8월이 끝나고도 벌써 15일이나 지나버렸다. 조금 늦었지만 8월을 회고하고 9월의 계획을 세워보려 한다.\n\n## 8월의 액션아이템\n\n7월에 계획했던 8월의 액션아이템은 아래 4가지이다. 이중 앞선 2가지는 완료했지만, useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기와 컴포넌트 설계 추가 작업 진행하기는 하지 못했다.\n\n- MMKV 데이터 스토리지 라이브러리 적용 후 성능 개선 결과 정리하기\n- React Query를 이용한 비동기 상태 개선 방향 공유하기\n- useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기\n- 컴포넌트 설계 추가 작업 진행하기\n\n### MMKV 데이터 스토리지 라이브러리 적용 후 성능 개선 결과 정리하기\n\n지난 달에 벤치마크 지표들을 공유하면서 기존 사용하던 Async Storage에서 마이그레이션할 라이브러리를 MMKV로 정했고, 이번 달에는 실제 마이그레이션을 진행했다.\n\n이전 발표에서 앱시작과정에서 API 호출과 함께 데이터를 가져오는 시간을 측정했던 부분이 API 의존성을 제거했을 때 수치를 보면 더 좋을 것 같다는 의견을 주셨고,\n개발 환경에서 앱을 빌드하고 비교해 보았을 때 MMKV는 150ms에서 65ms로 50%이상 개선된 결과를 보였다.\n\n하지만 로컬 DB자체를 제품내에서 사용하는 경우가 많지 않아 엄청나게 큰 개선을 가져오지는 못할 것으로 보이지만, Async Storage에서 간혹 200ms까지 걸리는 조회 시간이 있었기 때문에, 이를 개선하는 건 의미있다고 생각이 들었다.\n\n#### 작업 내용\n\n마이그레이션 작업은 이전 마이그레이션 작업들에 비해 상대적으로 간단했지만, 테스트나 기존 코드들이 Async Storage 자체에 의존하고 있어서 이를 수정하는 작업이 조금 까다로웠다.\n이를 해결하기 위해서 기존 아키텍처에서 AsyncStorage 자체에 의존하기 보다 인터페이스를 의존하게 해 이후 다른 라이브러리로 전환하더라도 최소한의 수정으로 가능하도록 설계를 변경하는 작업이 필요했다.\n\n```typescript\n// 기존 예시\n\nclass KeyValueStorage {\n  async setItem(key, value) {\n    await AsyncStorage.setItem(key, value)\n  }\n  async getItem(key) {\n    return AsyncStorage.getItem(key)\n  }\n}\n\nclass Repository {\n  constructor() {\n    this.storage = new KeyValueStorage()\n  }\n\n  async getLocalData(key) {\n    return this.storage.getItem(key)\n  }\n}\n\n// 이후\n\ninterface Storage {\n  getItem: (key: string) => Promise<string | null>\n  setItem: (key: string, value: string) => Promise<void>\n}\nconst storage: Storage = new MMKVStorage()\n\nclass MMKVStorage implements Storage {\n  async setItem(key, value) {\n    await storage.set(key, value)\n  }\n  async getItem(key) {\n    // 기존과 호환을 위해 JSON.parse를 사용\n    const value = storage.getString(key)\n    return value ? JSON.parse(value) : null\n  }\n\n  async setItem(key, value) {\n    storage.set(key, JSON.stringify(value))\n  }\n}\n\nclass Repository {\n  constructor(storage: Storage) {\n    this.storage = storage\n  }\n\n  async getLocalData(key) {\n    return this.storage.getItem(key)\n  }\n}\n\nconst repository = new Repository(storage)\n```\n\n조금 아쉬웠던 부분은 MMKV 라이브러리 자체가 AsyncStorage와는 다르게 기본 자료형들을 바로 가져올 수 있게 지원하지만, 기존 AsyncStorage와의 호환성을 위해 JSON.Stringinfy가 필요하고, 기존 인터페이스를 맞추기 위해 불필요한 promise를 반환해야 했다.\n\n추가로 유틸들의 테스트가 AsyncStorage에 의존하고 있는 경우에 storage를 주입하는 방식으로 수정하다보니, 오히려 사용처 코드들이 복잡해보이기도 했다. 테스트가 필요한 게 맞는지 조금 더 고민해봐야 할 것 같다.\n\n이후 작업 자체는 모두 완료했지만 아직 Native Module에서 어떻게 토큰을 가져오고 할지에 대해 논의가 진행되면서 배포는 보류되게 되었다.\n배포 이후 성능을 측정하고 결과를 정리해보는 작업을 9월 또는 10월에 진행해보려 한다.\n\n### React Query를 이용한 로딩경험 개선 작업 공유하기\n\nReact Query를 이용해 Suspense로 비동기 상태를 분리하고, 전역 로딩경험을 개선하는 작업을 완료했다.\n작업 자체는 완료했지만, 다양한 도메인에서 작업이 진행된 만큼 QA가 각각 진행이 필요하다보니 완전히 배포를 하지는 못했다.\n\n작업 과정에서 중간중간에 공유하려 했지만, 발표를 하기에 다른 분들의 발표 일정이 겹쳤고, 예비군도 다녀오다 보니 작업과정이 아니라 결과를 공유하는 방식이 되어버렸다.\n코드리뷰의 리뷰어로 배정되신 분들은 작업과정에 대해 이해하실 수 있었지만, 다른 분들은 결과만을 보게 된 것 같아 아쉬웠고,\n문제의 크기에 비해 너무 어렵게 작업이 된 것 같다는 피드백을 받기도 했다.\n\n해당 피드백을 받으면서 문제를 해결하기 위해서, 필요한 기술을 사용했는데 어떤 부분이 문제였는지 온전히 이해하는데에는 시간이 필요했다.\n조금 더 일찍 공유했다면 괜찮았을까 아쉬움이 남아 한동안 괴로워하기도 했다.\n\n기술적 문제를 해결하는 것도 중요하지만, 그 과정에서 다른 분들과 소통하는 것도 중요하다는 것을 다시 한번 느낄 수 있었다.\n나름의 성장통을 겪었던 작업이었고, 해당 발표내용을 정리해 9월중으로 해당 작업에 대한 글을 작성해보려 한다.\n\n### 하지 못한 액션아이템\n\n`useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기`와 `컴포넌트 설계 추가 작업 진행하기`는 진행하지 못했다.\n\n8월 동안 아직 `프론트엔드엔드 accelarator 멘토링` 과정 중이었기 때문에 둘째주까지 매주 다른 주제로 과제를 개선시켜나가면서 시간이 부족했다.\n\n9월에는 꼭 이 두가지에 대해 진행해보려 한다.\n\n## 새롭게 진행했던 활동들\n\n7월과 동일하게 프론트엔드엔드 accelarator 멘토링 과정의 3주차, 4주차 과정을 진행해 마무리하게 되었다.\n3주차 주제는 우아한 비동기 처리, 4주차는 UX 개선에 대한 주제로 진행되었다. 각 주차별 주제에 대한 내용을 정리해보자.\n\n### 3주차 - 우아한 비동기 상태관리\n\n3주차 주제의 우아한 비동기에는 `Promise`, `async/await`, `Generator`, `Observable` 등 비동기 처리를 어떻게 하면 더 우아하게 할 수 있을지에 대해 이야기했다.\n\n비동기 상태는 사실 React에서 가장 어려운 부분 중 하나라고 생각한다. 하나의 요청에 대해서는 로딩/성공/실패가 발생하고 n개의 요청에 대해서는 3^n개의 상태가 발생할 수 있기 때문이다.\n\n[참고자료: 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기](https://www.youtube.com/watch?v=FvRtoViujGg&t=1s)\n![요청에 따른 비동기 상태의 경우의수.png](비동기핸들링_경우의수.png)\n\n\"에이, 왠만하면 다 성공하잖아\" 라고 생각할 수 있지만, 개발자의 실수, 서버의 장애, 네트워크의 문제 등 다양한 이유로 실패할 수 있기 때문에 이러한 상태를 고려해야 한다.\n\n그리고 이러한 고려를 일일이 manual하게 관리하기에는 코드가 너무 복잡해지거나 특정 로직가 빠지는 경우가 발생할 수 있기 때문에, 선언적인 방식으로 처리했을 때 각 상태에 대한 처리를 놓치지 않을 수 있다.\n\n```tsx\n// 명령적인 방식\nfunction Profile(){\n\tconst foo=useAsyncValue(()=>{\n\t\treturn fetchFoo()\n\t});\n\n\tconst bar=useAsyncValue(()=>{\n\t\tif(foo.error||!foo.data){\n\t\t\treturn undefined\n\t\t}\n\t\treturn fetchBar(foo.data);\n\t});\n\n\tif(foo.error||bar.error) return <div> 로딩 실패.. </div>\n\tif(!foo.data||!bar.data) return <div> 로딩중... </div>\n\treturn <div>{foo.data.name}님 {bar} 환영합니다. </div>\n}\n\n// 선언적인 방식\n\nfunction FooBar(){\n    const foo= useAsyncValue(()=> fetchFoo());\n    const bar=useAsyncValue(()=>fetchBar(foo));\n    return <div>{foo}{bar}</div>\n}\n\nfunction App(){\n    return (\n        <ErrorBoundary fallback={<MyErrorPage/>}>\n            <Suspenese fallback={<Loader/>}>\n                <FooBar/>\n            </Suspense>\n        </ErrorBoundary>\n    )\n}\n```\n\n이렇게 선언적으로 작성했을 때 기존과 달리 각 상태에 대한 처리를 놓치지 않을 수 있고, 로딩/성공/실패라는 각 비동기 상태에 따른 관심사 분리가 되어 코드가 더욱 깔끔해진다.\n\n이렇게 선언적인 비동기 상태 관리에 대해 의논하고 알아가면서, 3분기 작업중 진행하고 있는 로딩 경험개선 작업을 진행하면서 Suspense를 이용해 선언적으로 비동기 상태를 분리하는 방법을 적용하게 되었다.\n\n추가로 나는 놓쳤던 부분이지만 함께 진행하는 분은 작성된 폼 정보를 여러번 요청할 수 있는 경우를 고려해 Post 요청에 대한 추가 로딩 상태를 구현하는 디테일을 보여주시기도 해서,\n내가 놓쳤던 디테일에 대한 부분들을 배울 수 있었다.\n\n```tsx\nfunction Form() {\n  const [name, setName] = useState(\"\")\n  const [email, setEmail] = useState(\"\")\n  const { mutate, isPending } = useMutation({\n    mutationFn: submitForm,\n    onSuccess: () => {\n      navigate(\"/success\")\n    },\n  })\n\n  return (\n    <form\n      onSubmit={e => {\n        e.preventDefault()\n        mutate({ name, email })\n      }}\n    >\n      <input value={name} onChange={e => setName(e.target.value)} />\n      <input value={email} onChange={e => setEmail(e.target.value)} />\n      <button type=\"submit\" disabled={isPending}>\n        제출\n      </button>\n    </form>\n  )\n}\n```\n\n### 4주차 - UX 개선\n\nUX를 개선하는 방법으로 FCP/LCP 개선 방법과 스켈레톤 UI를 이용한 사용자 체감 로딩 속도를 줄이는 내용에 대해 이야기했다.\n\nFCP/LCP를 개선하는 방법으로 나는 번들의 크기를 줄여서 초기로딩 시간을 개선할 수 있지 않을까 생각하고 작업하게 되었다.\n이를 위한 방법으로 코드스플릿팅과 CRA 대신 vite로 마이그레이션하는 방식을 적용해보았다.\n\n하지만 아쉽게도 과제 자체의 페이지 수가 많지 않고 CRA의 webpack에서 vite의 esbuild와 rollup으로 변경해 본 결과 번들 크기는 차이가 났지만,\nFCP에 큰 영향을 주지 못했다.\n\n이러한 접근은 사실 데이터적으로 접근하는데 너무 많은 시간을 투자했고, 결과적으로는 큰 성과를 보지 못했던 것 같다.\n\n다른 분들은 스켈레톤 UI와 화면 전환 애니메이션을 구현하고, 화면 이탈시에 이탈 방지 모달을 노출하는 등 보다 유저가 느낄 수 있는 실질적인 UX 개선을 진행하셨다.\n이걸 보면서 유저에게 유의미한 개선은 무엇일지, 어떤 방식으로 개선할 수 있을지에 대해 다시 한번 생각해보고 배울 수 있는 순간이었다.\n\n이렇게 하나의 과제에 대해 다양한 주제로 진행하면서 내가 놓치고 있던 점, 다른 분들께서 중요하게 생각하는 점들을 배울 수 있었던 정말 소중한 시간이었다.\n그리고 마음 한켠에 `이제 왠만한 건 다 만들 수 있고, 잘하고 있다`는 생각에 빠져있던 모습을 느꼈고, 다시 한번 겸손해지고 더욱 더 배우고 싶다는 생각이 들었다.\n\nReact Native를 이용한 작업도 좋지만 웹개발에 대한 지식을 더욱 더 깊게 배우고 싶다는 생각이 들었다.\n\n## 9월의 액션아이템\n\n글을 작성하는 시점에 9월 중순이 지나가고 있지만, 9월의 액션아이템을 정리해보려한다.\n\n- MMKV 데이터 스토리지 라이브러리 적용 작업 정리하기\n- React Query를 이용한 로딩 경험 개선 작업 정리하기\n- useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기\n\n이번 달에는 8월에 못했던 작업들과 함께 완료한 작업들에 대해서는 성과와 트러블 슈팅들에 대한 글을 작성해보려한다. 추가로 useFunnel 라이브러리 분석 후 오픈소스 분석 과정을 공유해보려 한다.\n\n8월 한달 동안 다양한 활동을 하면서 새로운 경험을 많이 했고, 이를 토대로 9월에는 더욱 더 성장하고 싶다는 의욕이 생기는 한편, 내가 어디로 가고 싶은지, 어떤 개발자가 되고 싶은지에 대해 다시 한번 고민이 깊어지는 시기를 보내고 있는 것 같다.\n\n앞으로도 더욱 더 성장하고 싶다는 의지를 가지고 9월을 보내보려 한다.\n"},{"excerpt":"7월은 새롭게 한분기를 시작하는 달로, 챕터 내에서는 하고 싶었던 MMKV 데이터 스토리지 마이그레이션과 로딩 경험 개선 두가지 일감을 담당해 진행했고,\n스쿼드에서는 새롭게 요청서 기반이 아닌 새로운 비즈니스 모델 실험에 맞는 퍼널 화면을 구현하는 등 새로운 작업들을 사내에서 담당해서 진행하게 되었다. 외부 활동으로는 오픈 소스 라이브러리에 처음으로 co…","fields":{"slug":"/2024-08-03-2024년-7월회고/"},"frontmatter":{"date":"August 03, 2024","title":"👏 2024년 7월회고 ","tags":["회고","FE Accelerator","es-toolkit","mmkv"]},"rawMarkdownBody":"\n7월은 새롭게 한분기를 시작하는 달로, 챕터 내에서는 하고 싶었던 MMKV 데이터 스토리지 마이그레이션과 로딩 경험 개선 두가지 일감을 담당해 진행했고,\n스쿼드에서는 새롭게 요청서 기반이 아닌 새로운 비즈니스 모델 실험에 맞는 퍼널 화면을 구현하는 등 새로운 작업들을 사내에서 담당해서 진행하게 되었다.\n\n외부 활동으로는 오픈 소스 라이브러리에 처음으로 contribution을 해보고, 토스 FE Accelerator에도 합격해 멘토링 과정을 시작했다.\n\n다양한 새로운 활동을 진행한 7월을 정리하고, 8월의 액션아이템들을 정리해보려 한다.\n\n## 7월의 액션아이템\n\n6월 회고를 작성하면서 7월의 액션아이템으로 아래와 같이 선정했었다.\n\n- Native Stack 적용 글 작성하기\n- Async Storage 대체할 라이브러리 검토 및 마이그레이션하기\n- 제품 내 로딩 상태 개선하기\n- 컴포넌트 설계 추가 작업 진행하기\n- 페이지간 데이터 공유 문제 고민하고 논의하기\n\n### Native Stack 적용기 글 작성하기\n\n2분기 OKR로 **화면 전환간 성능 개선** 작업을 담당하면서 적용한 [Native Stack Navigation 적용과정에 대한 글](https://choi2021.github.io/2024-06-30-NativeStack%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/)을 작성했다.\nNative Stack Navigation을 적용하면서 메모리 사용량과 CPU 사용량을 감소시켜 화면 전환간 버벅임을 개선 과정과, 작업간 어려웠던 점, 트러블 슈팅을 정리할 수 있었고 이후 시도하면 좋을 작업들에 대해서도 정리할 수 있었다.\n\n후작업으로 생각했던 일감 중 하나였던 `검색 화면 진입시 버벅이는 이슈`에 대한 작업을 추가적으로 진행했다.\n\n해당 이슈는 [react native screens에 등록되어 있던 이슈](https://github.com/software-mansion/react-native-screens/issues/1637)로 전환되는 화면의 TextInput이 AutoFocus가 true로 되어있을 경우 AutoFocus로 인한 키보드 노출 이벤트와 화면 전환 이벤트가 함께 처리되면서\n버벅임이 발생하는 것으로 보였다.\n\n[Repo에 등록된 이슈의 재현 영상]\n<img src=\"react-native-screens-issue-laggy.gif\" width=\"600\">\n\nUI 스레드의 부하를 줄이기 위해서 AutoFocus를 true로 설정하는 것 대신, 화면전환 완료 이후에 manual하게 TextInput ref에 focus를 동작시키는 방식으로 해결할 수 있었다.\n\n![해당 이슈에 공유한 해결방법](issue-solve.png)\n\n후작업을 통해 담당했던 일감에 대한 완성도를 높일 수 있어 뿌듯했던 순간이었다.\n\n### Async Storage 대체할 라이브러리 선정하기\n\nAsync Storage를 이용하면서 큰 문제는 없지만, 조금 더 빠르면서도 사용성이 좋은 데이터 스토리지 라이브러리를 찾고 적용하는 작업을 시작하게 되었다.\n\n후보군으로는 [WatermelonDB](https://github.com/Nozbe/WatermelonDB?tab=readme-ov-file), [MMKV](https://github.com/mrousavy/react-native-mmkv), [OP-SQLite](https://github.com/OP-Engineering/op-sqlite?tab=readme-ov-file)로 총 3가지 라이브러리를 선정하게 되었는데 MMKV만을 사실 첫 목표로 작업을 기획했었지만,\n챕터원 분들의 추천으로 다른 라이브러리들도 함께 비교해보면 좋을 것 같다고 알려주신 라이브러리들을 함께 비교해보기로 했다.\n\n해당 라이브러리들을 비교하기 위해 MMKV 레포에 소개되어있는 [Bench Mark 레포](https://github.com/mrousavy/StorageBenchmark)를 참고했고, [새롭게 레포](https://github.com/choi2021/rn-storage-benchmark-test)를 만들어 비교를 진행하고 결과를 정리해보았다.\n\n아래는 각 라이브러리별로 성능을 비교한 결과로 `key: 'k', value: 'hello'` 저장을 1000번 반복한 후에 시간을 측정한 결과로, MMKV가 가장 빠르게 처리되었음을 확인할 수 있었다.\n\n![벤치마크 비교 데이터](img.png)\n\n속도도 중요하지만 개발자 경험, 커뮤니티 지원, 실제 제품에 적용이 가능한지 등 여러가지 비교가 필요했고 결론적으로 `MMKV`를 선정하게 되었다.\n\n[데이터 스토리지 라이브러리 별 npm 트렌드 비교]\n<img src=\"npm-trend.png\" width=\"500\">\n\n정리한 내용들을 통해 챕터원분들께 발표를 진행했고, MMKV를 실제 제품에 적용했을 때 기대되는 성능적인 이점도 공유했다.\n\n공유한 내용중에 시간 측정에 API 응답시간도 함께 포함되어있던 결과를 보고, 조금 더 정확한 측정을 위해 추가적인 작업이 필요하다는 피드백을 받았고, 이에 대한 추가적인 작업을 진행한 후에 정확하게 얼마나 성능적인 이점을 기대할 수 있을지 다시 측정하는 작업을 진행하기도 했다.\n\nMMKV가 왜 빠른지, 또 제품에 적용하면서 고려했던 점 등에 대한 내용은 8월에 제품에 반영한 후에 블로그에 정리해보려 한다.\n\n### 제품 내 로딩 상태 개선하기\n\n제품 내 비동기 상태를 관리를 고도화하기 위해 로딩 상태 개선 작업을 발제하고 진헹하게 되었다.\n에러바운더리 작업을 하면서, 전체 제품의 화면들을 보게 되면서 **로딩화면이 필요한데 없는 경우**, **로딩화면이 있는데 불필요하게 깜빡이는 경우**들을 보게 되었다.\n\n로딩화면이 필요한데 없는 경우는 웹뷰 진입시 화면, 목록 화면에서 탭을 눌렀을 때 새로운 데이터를 가져오는동안 로딩 상태가 없어 반응이 없는 것 처럼 보이는 등 사용성 개선을 위한 로딩처리가 필요한 부분들이 있어보였다.\n해당 케이스는 각각에 맞는 로딩 상태를 추가해서 해결해나가고 있다.\n\n로딩화면이 있는데 깜빡인다고 느껴지는 경우는 화면 조회를 위한 API 응답속도가 너무 빠를 때 오히려 로딩 상태 화면이 나왔다 사라지는 속도가 빨라서 깜빡이는 것처럼 느끼게된다.\n이에 대한 개선 방법으로 두가지 방법이 있었는데 하나는 로딩 화면을 보여주는 **최소시간 설정** 방법과 다른 하나는 카카오 페이지의 [무조건 스켈레톤 화면을 보여주는게 사용자 경험에 도움이 될까요?](https://tech.kakaopay.com/post/skeleton-ui-idea/) 글에서 소개된 일정 시간 내 응답이 오면 로딩화면을 보여주지 않는 방법이 있었다.\n\n두가지 방법에 대해서는 장단점이 존재한다.\n\n첫번째 방법의 장점은 유저가 아무리 빨라도 최소시간 설정이 있으니까 통일화된 로딩 경험을 할 수있지만, 단점으로 빠른 응답을 받았음에도 불구하고 로딩화면이 더 오래 보여지는 것처럼 느껴질 수 있다.\n\n두번째 방법의 장점은 빠른 응답을 받았을 때 로딩화면을 보여주지 않아 사용자 경험이 더 좋아질 수 있지만, 단점으로 해당 시간 이상의 시간이 걸리면서 얼마 차이가 나지 않는 경우 깜빡이는 효과를 또다시 느낄 수 밖에 없다는 점이다.\n(기준 200ms 이내는 보여주지 않는다면 300ms 응답이 왔을 때 로딩은 100ms동안 보이면서 깜빡임을 여전히 느낄 수 있다.)\n\n해당 장단점을 비교하고 일감 목표를 고민했을 때 최소 시간 설정을 생각하고 있었지만 카카오 페이지의 글과, 챕터원 분들께 방향을 공유드리면서 `이미 빠른데 일부로 느리게 보여주는 것이 더 제품에 안좋을 것 같다`는 피드백을 듣고, 두번째 방법을 선택했다.\n이제 두번째 방법을 정하면서 로딩화면을 보여주지 않는 시간을 어떻게 설정할지, 어떤 화면에 적용할지 등 다양한 고민을 하면서 적용작업을 진행하고 있다.\n\n추가적으로 로딩 경험 개선을 위해 React Query를 이용해 비동기 상태를 개선하는 방법으로 적용해가고 있다. 그중 가장 많이 공부하고 적용해보려 하는 방식은 로딩 상태를 선언적으로 관리할 수 있는 **suspense의** 도입인데, suspense가 왜 좋은지, 어떤 문제를 풀기 위한 방법인지 등을 8월 중에 발표해보고 챕터 내 비동기 코드를 개선하는데 기여해보고자 한다.\n\n### 하지 못한 액션아이템\n\n하지 못했던 액션아이템들로는 **컴포넌트 설계 작업 공유**와 **페이지간 데이터 공유** 해결해보기가 있었다.\n\n페이지간 데이터 공유 문제는 챕터 동료 분께서 Zustand를 도입 작업을 해주시면서 도메인 간 공유할 수 있는 방법을 통해 해결해주셔서, 다음 달에는 남아있는 컴포넌트 설계부분을 더 고민하고 해결해보려 한다.\n\n## 새롭게 진행했던 활동들\n\n### 오픈 소스 라이브러리에 contribution하기\n\n7월에는 특별한 경험들을 많이 할 수 있었는데, 먼저 토스의 [es-toolkit](https://github.com/toss/es-toolkit) 라이브러리에 contribution을 했다.\n챕터원분께서 해당 라이브러리에 대해 소개해주시면서 오픈소스에 기여하는 경험을 해보면 좋겠다며 슬랙에 공유해주셨다.\n\n평소 오픈소스에 기여를 하고 싶지만, 어디서부터 어떻게 해야하는지 알지 못해, 늘 분석만 하고 있다가 좋은 기회라 생각해 해당 라이브러리 코드들을 보게되었다.\n\n잘 설명된 문서들과 제품에서 자주 사용하던 lodash를 최신 ECMAScript에 맞게, 성능과 번들 사이즈를 향상시킨 라이브러리다 보니 상대적으로 어떤 패키지보다 나에게 허들이 낮아 보였다.\n\n작업이 필요한 이슈들과 이미 완료된 PR, 해당 라이브러리에 필요한 작업이 어떤 것인지 파악하고, 이미 병합된 PR들을 분석해보면서 어떤 점들을 고민하면 좋을지 라이브러리에 대한 이해도가 높여갔다.\n\n총 7개의 PR을 올렸고, 그중 3개는 수정이 필요하거나, 불필요할 것 같다는 논의 끝에 close하게 되었고, 4개의 PR은 merge되게 되었다.\n\n[내가 올렸던 PR]\n![es-toolkit-내가 올렸던 PR](es-toolkit.png)\n\n이렇게 연초부터 개인적으로 목표로 잡고 있었던 오픈소스 기여를 할 수 있어서 뿌듯했고, 이제는 어떻게 하는지 알았으니 앞으로도 계속해서 관심있게 보고 내가 자주 사용하는 라이브러리들의 문제들을 찾아서 기여해보고 싶다.\n\n### 토스 FE Accelerator 멘토링\n\n우연히 링크드인에서 보게된 토스 FE Accelerator 프로그램에 6월 말에 지원해 테스트, 면접과정을 거쳐 7월부터 멘토링 과정을 시작하게 되었다.\n\n![링크드인 모집 글](fe-accelerator.png)\n\n토스 slash 개발자 컨퍼런스를 열심히 듣던 애청자로서 토스는 어떻게 일하고 있는지, 회사 밖의 다른 개발자 분들의 고민과 좋은 코드는 어떤 것이라 생각하는지 궁금했던 나에게 너무 좋은 기회가 되었다.\n\n함께 조로 배정된 다른 회사의 FE 개발자분들과 토스 리드분과 함께 매주차 오프라인 코드 리뷰를 하면서 서로 같은 과제를 두고 왜 이렇게 코드를 작성했는지, 더 좋은 방법은 없을지 등을 함께 이야기 하면서\n매주차 하나의 주제에 대한 깊이를 더해가는 시간을 가지고 있다.\n\n회사에서 일하다보면 서로 다른 도메인을 담당하고 일을 하게 되고, 코드리뷰를 하더라도 더 깊이 고민하고 작업하신 작업자 분의 말씀을 더 존중하고 `나보다 배경에 대해 더 잘 알고 계시니까`라고 생각하면서 어느 정도 믿고 진행하는 경우도 많았던 것 같다.\n\n하지만 멘토링 과정을 진행하면서 매주 진행하는 과제는 모두가 같다보니, 배경이 동일한 상황에서 이것 저것 물어보다 보니, 매주 내가 고려하지 못했던 부분, 내가 놓친 부분들을 다시 한번 생각해보게 되는 시간이 되고 있다.\n\n#### 7월에 진행한 주제들\n\n7월은 2가지 주제, **관심사 분리**와 **퍼널간 상태관리**를 주제로 한주씩 진행했다. [3월 회고](https://choi2021.github.io/2024-04-07-2024%EB%85%84-3%EC%9B%94%ED%9A%8C%EA%B3%A0/) 때부터 언급했던 퍼널간 상태관리를 고민하던 나에게 자연스럽게, **퍼널간 상태관리**라는 관심사를 어떻게 우아하게 해결할 수 있을지 고민하게 되었다.\n\n해당 문제를 해결하기 위해 첫번째로 Routing 페이지에 필요한 정보를 지역상태로 선언해 각 페이지에 필요한 정보를 주입하는 방식으로 작성하고 이를 공유했지만, 해당 방식은 Routing과 퍼널 스텝 관리 관심사가 혼재해 분리되면 좋을 것 같다는 피드백을 받을 수 있었다.\n\n첫주차 멘토링 시간이 끝나고 리팩토링을 하면서 우선 관심사 분리에 초점을 맞춰서 퍼널간 상태 관리를 위해 정석적인 Zustand를 이용한 전역스토어를 만드는 방법을 이용해 해결할 수 있었다.\n\n과제의 테스트 코드들도 다 통과했고, 기존 피드백에 따라 잘 수정한 것 같지만, 오랫동안 고민했던 주제였고 이번에 공부하지 않으면 이후에도 계속해서 마음 한켠에 남아있을 것 같아 `useFunnel` 코드를 분석하고, 이를 적용해보는 과정을 진행했다.\n\n![useFunnel 문서](useFunnel.png)\n\nuseFunnel 코드를 여러번 보고, 발표내용을 여러번 들으면서, `어떤 문제를 해결하려하는 훅`인지, `왜 코드가 이렇게 작성되었는지` 한땀 한땀 이해하는 과정을 거칠 수 있었다.\n처음에는 과한가 싶었지만 분석하고 직접 적용해보면서 너무 좋은 경험이었다는 것을 깨닫게 되었다.\n\n2주차 멘토링 시간에 비록 완벽하게 구현한 건 아니지만 현재 과제에 맞게 어느정도 구현한 결과물을 가져갔고, 함께 공유했을 때 좋은 피드백을 받을 수 있었고, 실제 사내 제품에도 적용하면 좋겠다는 생각도 들었다.\n\nuseFunnel을 조금 더 완벽하게 분석한 후에 오픈소스 분석과정을 공유하는 글을 작성해도 좋을 것 같다.\n\n벌써 2주나 흘렀지만 앞으로 남은 과정들을 진행하면서, 단순히 내가 알고있는 바운더리 내에서 최선이 아니라, 조금은 과하게 고민하고, 다른 사람들과 함께 공유하면서 더 좋은 방법을 찾아가는 과정을 더 많이 경험해보고 싶다.\n\n## 8월의 액션아이템\n\n7월의 다양한 새로운 활동과 함께 아래와 같이 8월의 액션아이템을 선정했다.\n\n- MMKV 데이터 스토리지 라이브러리 적용 후 성능 개선 결과 정리하기\n- React Query를 이용한 비동기 상태 개선 방향 공유하기\n- useFunnel 라이브러리 분석 후 오픈소스 분석 과정 공유하기\n- 컴포넌트 설계 추가 작업 진행하기\n\n하던 걸 꾸준히 잘하는 것도 중요하지만, 더 잘하기 위해 지금 보다 extra mile을 고민하는 게 지금 시점에 필요하다고 생각이 들었다.\n\n새로운 시야와 다양한 경험을 통해 더 좋은 개발자가 되기 위해 8월에도 노력해보려 한다.\n"},{"excerpt":"2분기 TechOKR 작업으로 선정된 화면전환간 성능 개선 작업을 담당하면서 Native Stack Navigator을 제품에 도입하게 되었다. 해당 작업을 진행하게된 배경, 적용과정에 대해 정리하면서 새롭게 알게된 내용, 시행착오를 기록해보려 한다. 🚀 Native Stack Navigator 작업 배경 Native Stack이란 Native Stack…","fields":{"slug":"/2024-06-30-NativeStack적용하기/"},"frontmatter":{"date":"July 06, 2024","title":"🖥️ Native Stack 적용하기","tags":["회고","react-navigation","react-native","성능","Native Stack"]},"rawMarkdownBody":"\n2분기 TechOKR 작업으로 선정된 **화면전환간 성능 개선** 작업을 담당하면서 **Native Stack Navigator**을 제품에 도입하게 되었다. 해당 작업을 진행하게된 배경, 적용과정에 대해 정리하면서 새롭게 알게된 내용, 시행착오를 기록해보려 한다.\n\n## 🚀 Native Stack Navigator 작업 배경\n\n### Native Stack이란\n\nNative Stack Navigator는 [react navigation](https://github.com/react-navigation/react-navigation)에서 지원하는 Navigator 형태 중 하나로, stack navigator의 인터페이스와 유사하게 제공하면서, stack navigator와 다르게 iOS는 **UINavigationController**, Android는 **Fragment**로 Native 요소를 이용해 화면을 구현하게 된다.\n\nNative 요소를 이용해 화면을 구현하면서 Native가 가지고 있는 성능과 특징들을 이용할 수 있는 장점을 가지지만, stackNavigator와 다르게 커스텀이 어려운 단점을 가진다.\n\n### 왜 Native Stack을 도입하게 되었나\n\nNative Stack은 이전 1분기에 [startup-time 개선 작업](https://choi2021.github.io/2024-03-30-App-StartUp-time-%EA%B0%9C%EC%84%A0/)을 진행하면서 고려했던 방법중에 있었던 작업으로,\n당시에는 화면전환간 속도가 앱 시작 시간을 최적화하는데 큰 영향이 없을 것 같아 보류해 두었다.\n\n![당시 기획해두었던 아이디어들](ideas.png)\n\n이후에 일감으로 발전시켰던 이유로 기존 제품에 stackNavigator를 이용하면서 화면 전환간 버벅임이 발생하는 경우가 간헐적으로 있었고, React Native 공식문서의 Navigation 예제가 NativeStack을 이용하는 방식으로 소개되는 것으로 수정되었고 (커뮤니티에서 성능을 위해 권장하는 방법),\n화면전환 애니메이션을 Native 스레드에서 진행하게 되면 JS 스레드가 바쁘게 진행될 때에도 안정적으로 화면 전환 애니메이션을 보장할 수 있을 것을 기대하며 작업을 시작하게 되었다.\n\n[[react native 공식문서의 Navigating between screens](https://reactnative.dev/docs/0.73/navigation)]\n![react native 공식문서의 Navigating between screens](react-native-navigating.png)\n\n[[React Navigation v2의 소개된 메모리 사용량 비교 데이터](https://twitter.com/janicduplessis/status/1039979591815897088?s=21)]\n![React Navigation v2의 소개된 메모리 사용량 비교 데이터](x-memory-comparison.png)\n\n추가로 현재 React Native는 Expo를 공식적인 프레임워크로 추천하고 있는 흐름 속에 expo에서 사용하는 routing 시스템인 Expo router도 동일하게 React Native Screens를 이용해 file-based routing 방식으로 지원하고 있다.\n\n![expo-router 인트로 섹션](expo-router.png)\n\n## 🛠 Native Stack Navigator 제품에 적용해보기\n\n기존 제품은 Stack Navigator를 사용하고 있었기 때문에 Native Stack Navigator로 마이그레이션하기 위해서는 Stack Navigator의 Navigation Option을 Native Stack Navigator에 맞게 변경하는 작업이 가장 중요하게 진행되었다.\n\n이러한 옵션중 가장 중요했던 부분은 **presentation** 옵션으로, presentation을 어떻게 정하느냐에 따라 화면전환 애니메이션, 화면 렌더링 스타일이 달라지게 된다.\n\n### Stack Navigator의 presentation 옵션\n\nstack navigator에서는 `card`, `modal`, `transparent modal` 3가지 옵션을 사용할 수 있다.\n\n- `card`: 기본 화면전환 방식으로, iOS와 Android에서 default OS animation으로 화면전환이 진행된다.\n- `modal`: 화면이 모달로 뜨는 방식으로, iOS와 android 모두 화면이 아래에서 위로 올라오는 방식으로 화면이 뜨게 된다.\n- `transparent modal`: 모달로 뜨는 화면이지만, 배경이 투명하게 되어있어 이전 화면이 보이게 된다.\n\n[iOS Presentation별 화면전환 애니메이션]\n\n<table>\n  <tr>\n    <th align=\"center\">Card</th>\n    <th align=\"center\">Modal</th>\n    <th align=\"center\">Transparent Modal</th>\n  </tr>\n  <tr>\n    <td><img src=\"js-card-ios.gif\" alt=\"js-card-ios\" width=\"400\"/></td>\n    <td><img src=\"js-modal-ios.gif\" alt=\"js-modal-ios\" width=\"400\"/></td>\n    <td><img src=\"js-transparent-ios.gif\" alt=\"js-transparent-ios.gif\" width=\"400\"/></td>\n  </tr>\n</table>\n<br/>\n\n[Android Presentation별 화면전환 애니메이션]\n\n<table>\n  <tr>\n    <th align=\"center\">Card</th>\n    <th align=\"center\">Modal</th>\n    <th align=\"center\">Transparent Modal</th>\n  </tr>\n  <tr>\n    <td><img src=\"js-card-android.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"js-modal-android.gif\" alt=\"js-modal-android.gif\" width=\"300\"/></td>\n    <td><img src=\"js-transparent-android.gif\" alt=\"js-transparent-android.gif\" width=\"300\"/></td>\n  </tr>\n</table>\n\n또한, stack Navigator의 경우 일반 View로 구현되는 화면이기 때문에 Card <-> Modal 화면간 이동이 자유로워 Card 위에 Modal화면이 쌓이고,\nModal화면에 Card 화면이 다시 쌓일 수 있다.\n\n[Card -> Modal -> Card2 -> TransparentModal 화면전환]\n\n<img src=\"js-card-modal-push.gif\" alt=\"modal\" width=\"300\"/>\n\n### [Native Stack Navigator의 presentation 옵션](https://reactnavigation.org/docs/native-stack-navigator/#presentation)\n\nNative Stack Navigator에서는 `card`, `modal`, `transparent modal`, `contained modal`, `contained transparent modal`, `full screen modal`, `form sheet` 7가지로 구분되어 있다.\n\niOS에서 사용하는 모달 스타일을 조금 더 세부적으로 설정할 수 있게 지원하고 있고, android에서는 모두 modal 또는 transparentModal로 fallback되어 처리된다.\n\n- `card`: 기본 화면전환 방식으로, iOS는 오른쪽에서 왼쪽으로 화면이 전환되고, Android는 OS 버전에 따라 다르게 화면전환 애니메이션이 진행된다.\n- `modal`: iOS는 네이티브 모달처럼 화면이 입체적으로 올라오는 형태의 모달을 가지고 아래에서 위로 화면이 나타나게 되지만, Android는 card와 동일한 애니메이션으로 화면이 전환된다.\n  ([관련 이슈](https://github.com/software-mansion/react-native-screens/issues/1650))\n- `transparent modal`: 이전화면이 보이는 백그라운드로 보이는 모달형태의 화면이다.\n- `contained modal`: iOS는 `UIModalPresentationCurrentContext` 모달 스타일을 이용해 부모 크기에 따라 차지하게 되며, Android는 modal과 동일하게 처리된다.\n- `contained transparent modal`: iOS는 `UIModalPresentationOverCurrentContext` 모달 스타일을 이용해 부모 크기에 따라 차지하게 되며, Android는 transparent modal과 동일하게 처리된다.\n- `fullScreenModal`: iOS는 `UIModalPresentationFullScreen` 모달 스타일을 이용해 전체 화면을 차지하게 되고, 제스처로 제거되지 않는 특징을 가진다. Android는 modal과 동일하게 처리된다.\n- `formSheet`: iOS는 `UIModalPresentationFormSheet` 모달 스타일을 이용하고 Android는 modal과 동일하게 처리된다.\n\n[iOS Presentation]\n\n<table width=\"100%\">\n  <tr>\n    <th>card</th>\n    <th>modal</th>\n  </tr>\n  <tr>\n    <td><img src=\"native-card-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-modal-ios.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n  <tr>\n    <th>transparent modal</th>\n    <th>contained modal</th>\n  </tr>\n <tr>\n    <td><img src=\"native-transparentModal-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-containedModal-ios.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n <tr>\n    <th>contained transparent modal</th>\n    <th>fullScreen modal</th>\n  </tr>\n <tr>\n    <td><img src=\"native-containedTransparentModal-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-full-screen-modal-ios.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n <tr>\n    <th>formSheet</th>\n  </tr>\n <tr>\n    <td><img src=\"native-formsheet-ios.gif\" alt=\"card\" width=\"300\"/></td>\n  </tr>\n</table>\n\n[android Presentation (Android 14, API Level 34)]\n\n<table>\n  <tr>\n    <th>card</th>\n    <th>modal</th>\n  </tr>\n  <tr>\n    <td><img src=\"native-card-android.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-modal-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n <tr>\n    <th>transparent modal</th>\n    <th>contained modal</th>\n  </tr>\n  <tr>\n    <td><img src=\"native-transparentModal-android.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-containedModal-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n  <tr>\n    <th>contained transparent modal</th>\n    <th>fullScreen modal</th>\n  </tr>\n <tr>\n    <td><img src=\"native-containedTransparentModal-android.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-full-screen-modal-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n  <tr>\n    <th>formSheet</th>\n  </tr>\n <tr>\n    <td><img src=\"native-formsheet-android.gif\" alt=\"card\" width=\"300\"/></td>\n  </tr>\n</table>\n\nstack Navigator와 다르게 Native 요소들을 이용해 화면을 구현하기 때문에 모달은 **항상 Navigation History의 마지막에 와야하는 조건**이 있다. 이 조건을 지키지 않으면 Card 화면이 Modal 화면 뒤에 쌓여 보이지 않는 현상이 발생한다.\n\n[Card -> Modal -> Card2 화면전환 ]\n\n<img src=\"native-card-modal-push.gif\" alt=\"modal\" width=\"300\"/>\n\n위 예시를 보면 Modal 이후 Card2로 화면전환을 진행하게 되면, Card2가 Modal 화면 뒤에 쌓이게 되어 보이지 않는 현상이 발생한다. navigation pop을 클릭하게 되면, Card2가 먼저 제거되고, 이후 Modal 화면이 제거되는 현상을 확인할 수 있다.\n\n[React Navigation의 가이드](https://reactnavigation.org/docs/modal)에 따르면 모달 화면은 항상 Navigation History의 마지막에 와야한다고 되어있는데, 이는 Native Stack Navigator의 특징으로 보여진다.\n\n![React Navigation의 가이드](modal-best-practice.png)\n\n### 제품 내 Navigator presentation 반영하기\n\n그러면 이제 Native Stack Navigator의 presentation 옵션을 제품에 적용해보자.\n\n#### Card\n\nStack Navigator와 동일하게 iOS와 Android 모두 동일하게 `Card`에 default Animation을 적용하기로 했다.\niOS는 완전히 동일하게 동작해서 큰 고민이 없었지만 Android는 별도의 애니메이션을 주어야할 지 고민이 되었다.\n그이유는 Android에서는 OS 버전에 따라 다른 화면전환 애니메이션이 진행되게 되고 기존과 다른 유저 경험에 대한 우려가 있었기 때문이다.\n\n[Stack Navigator에 정의된 Transition Preset, Android 버전별 애니메이션 옵션]\n\n```tsx\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android < 9 (Oreo).\n */\nexport const FadeFromBottomAndroid: TransitionPreset = {\n  gestureDirection: \"vertical\",\n  transitionSpec: {\n    open: FadeInFromBottomAndroidSpec,\n    close: FadeOutToBottomAndroidSpec,\n  },\n  cardStyleInterpolator: forFadeFromBottomAndroid,\n  headerStyleInterpolator: forFade,\n}\n\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android 9 (Pie).\n */\nexport const RevealFromBottomAndroid: TransitionPreset = {\n  gestureDirection: \"vertical\",\n  transitionSpec: {\n    open: RevealFromBottomAndroidSpec,\n    close: RevealFromBottomAndroidSpec,\n  },\n  cardStyleInterpolator: forRevealFromBottomAndroid,\n  headerStyleInterpolator: forFade,\n}\n\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android 10 (Q).\n */\nexport const ScaleFromCenterAndroid: TransitionPreset = {\n  gestureDirection: \"horizontal\",\n  transitionSpec: {\n    open: ScaleFromCenterAndroidSpec,\n    close: ScaleFromCenterAndroidSpec,\n  },\n  cardStyleInterpolator: forScaleFromCenterAndroid,\n  headerStyleInterpolator: forFade,\n}\n```\n\n아래 GIF에서 기존은 가운데에서 퍼져나가는 형식(ScaleFromCenterAndroid)으로 화면이 전환된다면, Native Stack에서는 오른쪽에서 왼쪽으로 화면이 전환되는 것을 확인할 수 있다.\n\n<table>\n  <tr>\n    <th>기존 안드로이드 화면전환</th>\n    <th>Native Stack 화면 전환</th>\n  </tr>\n  <tr>\n    <td><img src=\"js-card-android.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"native-card-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n기존 `ScaleFromCenterAndroid`와 최대한 유사한 애니메이션으로 `Fade` 애니메이션을 처음 고민해봤지만, 여전히 기존과 다른게 느껴지는 것 같다는 동료분의 피드백을 받았고,\n버전에 맞게 표준 애니메이션을 적용하는 default 옵션이 이후 유지보수 측면에서 좋을 것 같다는 좋은 조언을 해주셔서, `Card` 옵션을 그대로 적용하기로 했다.\n\n#### Modal\n\n작업 중 가장 이슈가 많았고, OS별로 기본적으로 제공하는 부분이 달라 고민이 많았던 작업 영역이었다.\n\nOS별로 모달 옵션들을 정리해보면 iOS에서는 `modal, contained modal, fullscreen modal, formsheet` 4가지가 있고, android는 `modal` 한가지 옵션만 제공하지만 이슈가 있어서 추가적으로 애니메이션 옵션을 적용해야하는 상황이었다.\n\n여기에 추가적으로 모달이 항상 Navigation History의 마지막에 와야하는 조건이 있어서, 이를 지키지 않으면 기존 제품과 다르게 화면이 보이지 않는 이슈가 발생해, card와 modal간 화면 전환의 자유도도 고민해야 했다.\n\n결론적으로는 위에서 언급한 옵션들이 아닌 iOS와 Android 모두 `Card` 옵션에 `slide_from_bottom` 애니메이션을 적용한 형태로 적용하기로 했다.\n\n왜 뜬금없이 `Card`냐는 의문이 들 수 있겠지만, android에 이슈로 인해 추가적인 애니메이션이 필수적으로 필요한 상황인 점과 기존 제품 내 Navigation History 관리 방식을 유지해 작업범위와 컨벤션을 지키는 것이 더 좋겠다는 점을 고려해 선택하게 되었다.\n\n그러면 각 옵션들을 적용했을 때 발생했던 이슈들을 정리해보자.\n\n##### Modal와 FormSheet\n\niOS에서는 `modal`와 `formsheet` 옵션을 적용했을 때, 기존 제품내 모달과 다르게 화면 전체를 차지하는게 아니라 일정 영역만 차지하고 위로 떠있는 형태를 가지게 되고, android는 card와 동일하게 화면 전환이 이루어지는 이슈가 있어 사용하지 못했다.\n\n[제품내 모달과 Modal 옵션]\n\n<table>\n  <tr>\n    <th>기존 제품내 모달 화면</th>\n    <th>modal iOS</th>\n    <th>modal android</th>\n  </tr>\n  <tr>\n    <td><img src=\"stack-modal-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"product-modal-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"product-modal-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n[제품내 모달과 formsheet 옵션]\n\n<table>\n  <tr>\n    <th>기존 제품내 모달 화면</th>\n    <th>formsheet iOS</th>\n    <th>formsheet android</th>\n  </tr>\n  <tr>\n    <td><img src=\"stack-modal-ios.gif\" alt=\"card\" width=\"300\"/></td>\n    <td><img src=\"product-formsheet-ios.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"product-formsheet-android.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n##### Contained Modal과 FullScreen Modal\n\nandroid는 card와 동일하게 화면 전환이 이루어지는 이슈가 동일하게 있지만, iOS에서는 `contained modal`과 `fullscreen modal` 옵션을 적용했을 때, 기존과 같이 화면이 전체를 차지하는 형태로 화면이 나타낼 수 있어 사용하려 했던 옵션이었다.\n\n하지만 각 옵션은 적용에 있어 문제점들이 각각 존재했다. contained Modal의 경우에는 Navigation History의 마지막에 와야하는 조건을 위해 별도의 Nested Navigator로 모달들을 관리하는 비용이 컸다는 점으로 인해 사용하지 못했다.\n\nfullscreen Modal 옵션은 card,modal간 화면 전환 이슈와 더불어, alert 모달을 상위에 띄워줄 수 없는 이슈가 있어 사용하지 못했다. 아래는 해당 상황을 위한 mimic 코드이다.\n\n[fullscreen modal에서 Modal로 구현한 alert가 뜨지 않는 이슈를 위한 mimic 코드]\n\n```tsx\n// zustand로 구현한 전역 모달 노출 코드\nimport { create } from \"zustand\"\n\nexport const useAlertModal = create(set => ({\n  visible: false,\n  show: () => set({ visible: true }),\n  hide: () => set({ visible: false }),\n}))\n\nconst App = () => {\n  const visible = useAlertModal(state => state.visible)\n  const close = useAlertModal(state => state.hide)\n  const onPressClose = () => {\n    close()\n  }\n\n  return (\n    <SafeAreaView style={{ flex: 1 }}>\n      {visible && (\n        <Modal\n          visible={visible}\n          animationType={\"fade\"}\n          transparent={true}\n          onRequestClose={onPressClose}\n        >\n          <View\n            style={{\n              justifyContent: \"center\",\n              alignItems: \"center\",\n              backgroundColor: \"white\",\n              flex: 1,\n            }}\n          >\n            <Text>Modal이에요</Text>\n            <Button title=\"닫기\" onPress={onPressClose} />\n          </View>\n        </Modal>\n      )}\n      <NavigationContainer>\n        <NativeStack />\n      </NavigationContainer>\n    </SafeAreaView>\n  )\n}\n\nconst FullscreenModal = ({ navigation }) => {\n  const handlePress = () => {\n    navigation.pop()\n  }\n\n  const show = useAlertModal(state => state.show)\n  const showAlert = () => {\n    show()\n  }\n\n  return (\n    <SafeAreaView style={{ flex: 1 }}>\n      <Button title=\"뒤로가기\" onPress={handlePress} />\n      <Button title=\"alert 띄우기\" onPress={showAlert} />\n    </SafeAreaView>\n  )\n}\n```\n\n<table>\n  <tr>\n    <td>Modal로 구현한 alert 컴포넌트가 상위에 뜨지 않는 이슈</td>\n  </tr>\n  <tr>\n    <td><img src=\"mimic-fullscreen-issue.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n이러한 이슈들로 인해 iOS와 Android 모두 `Card` 옵션에 `slide_from_bottom` 애니메이션을 적용한 형태로 적용하기로 했다.\n\n##### slide_from_bottom 속도 이슈 해결하기\n\n이제 더이상 이슈가 없을 것이라 생각했지만 `Card` 옵션에 `slide_from_bottom` 옵션을 적용하는 방식에도 이슈가 있었다.\n\n바로 모달이 뜨는 애니메이션 속도 이슈로 iOS에서는 duration을 옵션으로 정할 수 있게 제공하지만, android에서는 커스텀할 수 없어 기존과 체감이 될정도로 느리게 화면이 전환되는 이슈가 있었다.\n\n![animationDuration 공식문서](react-navigation-animationDuration.png)\n\n<table>\n  <tr>\n    <td>Android Stack Navigator Modal</td>\n    <td>Android Native Stack Card (slide_from_bottom)</td>\n  </tr>\n  <tr>\n    <td><img src=\"js-modal-android.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-animation-velocity-before.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n눈에 띄게 느리다는 느낌이 들어 해당 부분을 해결하기 위해 React Navigation 내부 코드를 하나하나 분석하게 되었다.\n\n먼저 NativeStackNavigator를 만들기 위한 `createNativeStackNavigator`를 보면 `createNavigatorFactory` 팩토리 함수에 `NativeStackNavigator`를 인자로 넘겨주는 방식으로 NativeStackNavigator를 만들고 있다.\n\n```tsx\n//[참조 코드](https://github.com/react-navigation/react-navigation/blob/main/packages/native-stack/src/navigators/createNativeStackNavigator.tsx)\nfunction NativeStackNavigator({...rest }: NativeStackNavigatorProps) {\n    ...\n\n    return (\n        <NavigationContent>\n            <NativeStackView\n                {...rest}\n                state={state}\n                navigation={navigation}\n                descriptors={descriptors}\n            />\n        </NavigationContent>\n    );\n}\n\nexport function createNativeStackNavigator<\n    ParamList extends ParamListBase,\n    NavigatorID extends string | undefined = undefined,\n    TypeBag extends NavigatorTypeBagBase = {\n        ParamList: ParamList;\n        NavigatorID: NavigatorID;\n        State: StackNavigationState<ParamList>;\n        ScreenOptions: NativeStackNavigationOptions;\n        EventMap: NativeStackNavigationEventMap;\n        NavigationList: {\n            [RouteName in keyof ParamList]: NativeStackNavigationProp<\n                ParamList,\n                RouteName,\n                NavigatorID\n            >;\n        };\n        Navigator: typeof NativeStackNavigator;\n    },\n    Config extends StaticConfig<TypeBag> | undefined =\n            | StaticConfig<TypeBag>\n        | undefined,\n>(config?: Config): TypedNavigator<TypeBag, Config> {\n    return createNavigatorFactory(NativeStackNavigator)(config);\n}\n```\n\n내가 궁금한건 스크린이 어떻게 만들어지냐니까 이제 NativeStackView 코드 내부를 보게 되면 `React Native Screens`에서 Screen, ScreenStack 컴포넌트를 받아서 prop을 전달하는 방식으로 wrapping하고 있다는 것을 알 수 있었다.\n\n```tsx\n//[참조 코드](https://github.com/react-navigation/react-navigation/blob/main/packages/native-stack/src/views/NativeStackView.native.tsx):`react-navigation/packages/native-stack/src/views/NativeStackView.native.tsx`)\n//...\nimport {\n    Screen,\n    type ScreenProps,\n    ScreenStack,\n    type StackPresentationTypes,\n} from 'react-native-screens';\n//...\n\n\nconst MaybeNestedStack = (props) => {\n    //...\n    if (isHeaderInModal) {\n        return (\n            <ScreenStack style={styles.container}>\n                <Screen\n                    enabled\n                    isNativeStack\n                    hasLargeHeader={options.headerLargeTitle ?? false}\n                    style={StyleSheet.absoluteFill}\n                >\n                    {content}\n                    <HeaderConfig\n                        {...options}\n                        route={route}\n                        headerHeight={headerHeight}\n                        headerTopInsetEnabled={headerTopInsetEnabled}\n                        canGoBack\n                    />\n                </Screen>\n            </ScreenStack>\n        );\n    }\n\n    return content;\n};\n\nconst SceneView = (props) => {\n    //...\n    return (\n        <Screen\n            key={route.key}\n            enabled\n            isNativeStack\n            style={StyleSheet.absoluteFill}\n            hasLargeHeader={options.headerLargeTitle ?? false}\n            customAnimationOnSwipe={animationMatchesGesture}\n            fullScreenSwipeEnabled={fullScreenGestureEnabled}\n            // ... 기타 props\n        >{...}</Screen>\n    );\n};\n\ntype Props = {\n    state: StackNavigationState<ParamListBase>;\n    navigation: NativeStackNavigationHelpers;\n    descriptors: NativeStackDescriptorMap;\n};\n\nexport function NativeStackView({ state, navigation, descriptors }: Props) {\n    ...\n    return (\n        <SafeAreaProviderCompat style={{ backgroundColor: colors.background }}>\n            <ScreenStack style={styles.container}>\n                {state.routes.map((route, index) => {\n                    //...\n                    return (\n                        <SceneView\n                            key={route.key}\n                            index={index}\n                            focused={isFocused}\n                            descriptor={descriptor}\n                            previousDescriptor={previousDescriptor}\n                            nextDescriptor={nextDescriptor}\n                            isPresentationModal={isModal}\n                            // 기타 props\n                        />\n                    );\n                })}\n            </ScreenStack>\n        </SafeAreaProviderCompat>\n    );\n}\n```\n\n실제 애니메이션 속도를 변경하기 위해서는 React Navigation 코드가 아니라 **React Native Screens** 패키지 내부 코드를 수정해야하는 것을 알게 되었다.\n그래서 React Navigation에서 Native Stack의 이슈는 React Native Screens 레포에 올려달라했구나 이해가 되었다.\n\n![React Native Screens로 안내하는 React Navigation 공식문서](react-native-screens-안내.png)\n\n이어서 React Native Screens 패키지 내부 코드를 분석하게 되었고, 아래와 같이 Screen 코드를 간단하게 나타낼 수 있고, Screen 컴포넌트는 ScreenNativeComponent를 만들어지는 것을 볼 수 있다.\n\n```tsx\n//[참조 코드](react-native-screens/src/components/Screen.tsx)\n// ...\nimport ScreenNativeComponent from \"../fabric/ScreenNativeComponent\"\nimport ModalScreenNativeComponent from \"../fabric/ModalScreenNativeComponent\"\n\nexport const NativeScreen: React.ComponentType<ScreenProps> =\n  ScreenNativeComponent as React.ComponentType<ScreenProps>\nconst AnimatedNativeScreen = Animated.createAnimatedComponent(NativeScreen)\n\n// ...\n\nconst Screen: React.FC<ScreenProps> = props => {\n  // ...\n  return <AnimatedNativeScreen {...props} />\n}\n\nexport default Screen\n```\n\n그리고 ScreenNativeComponent 코드를 보게 되면, `Screen` 컴포넌트를 만들어주는 코드를 찾을 수 있었다.\n아래 코드는 [**codegen**](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/codegen.md)을 이용해 Screen 컴포넌트를 iOS와 Android를 빌드할 때 자동으로 생성하기 위한 인터페이스들이 정의되어 있는 코드이다.\n이제 codegen을 통해 만들어진 해당 코드 부분을 찾아가면 드디어 내가 원하는 안드로이드 애니메이션 속도를 변경할 수 있을 것이라고 생각할 수 있었다.\n\n```ts\n//[참조코드](react-native-screens/src/fabric/ScreenNativeComponent.ts)\nimport codegenNativeComponent from \"react-native/Libraries/Utilities/codegenNativeComponent\"\n// ...\n\ntype StackPresentation =\n  | \"push\"\n  | \"modal\"\n  | \"transparentModal\"\n  | \"fullScreenModal\"\n  | \"formSheet\"\n  | \"containedModal\"\n  | \"containedTransparentModal\"\n\ntype StackAnimation =\n  | \"default\"\n  | \"flip\"\n  | \"simple_push\"\n  | \"none\"\n  | \"fade\"\n  | \"slide_from_right\"\n  | \"slide_from_left\"\n  | \"slide_from_bottom\"\n  | \"fade_from_bottom\"\n  | \"ios\"\n\n// ...\nexport default codegenNativeComponent<NativeProps>(\"RNSScreen\", {\n  interfaceOnly: true,\n})\n```\n\n드디어 rnscreens 내부의 ScreenStack 코드에서 애니메이션 설정 코드를 발견할 수 있었다.\n그중 내가 찾던 `slide_from_bottom`애니메이션은 `R.anim.rns_slide_in_from_bottom`, `R.anim.rns_no_animation_medium`으로 정의되어 있었다.\n\n```kotlin\n[참고 코드](react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenStack.kt)\nclass ScreenStack(context: Context?) : ScreenContainer(context) {\n    ...\n    override fun onUpdate() {\n        ...\n        createTransaction().let {\n            // animation logic start\n            if (stackAnimation != null) {\n                if (shouldUseOpenAnimation) {\n                    when (stackAnimation) {\n                        StackAnimation.DEFAULT -> it.setCustomAnimations(R.anim.rns_default_enter_in, R.anim.rns_default_enter_out)\n                        StackAnimation.NONE -> it.setCustomAnimations(R.anim.rns_no_animation_20, R.anim.rns_no_animation_20)\n                        StackAnimation.FADE -> it.setCustomAnimations(R.anim.rns_fade_in, R.anim.rns_fade_out)\n                        StackAnimation.SLIDE_FROM_RIGHT -> it.setCustomAnimations(R.anim.rns_slide_in_from_right, R.anim.rns_slide_out_to_left)\n                        StackAnimation.SLIDE_FROM_LEFT -> it.setCustomAnimations(R.anim.rns_slide_in_from_left, R.anim.rns_slide_out_to_right)\n                        StackAnimation.SLIDE_FROM_BOTTOM -> it.setCustomAnimations(\n                            R.anim.rns_slide_in_from_bottom, R.anim.rns_no_animation_medium\n                        )\n                        StackAnimation.FADE_FROM_BOTTOM -> it.setCustomAnimations(R.anim.rns_fade_from_bottom, R.anim.rns_no_animation_350)\n                        StackAnimation.IOS -> it.setCustomAnimations(R.anim.rns_slide_in_from_right_ios, R.anim.rns_slide_out_to_left_ios)\n                    }\n                } else {\n                    when (stackAnimation) {\n                        StackAnimation.DEFAULT -> it.setCustomAnimations(R.anim.rns_default_exit_in, R.anim.rns_default_exit_out)\n                        StackAnimation.NONE -> it.setCustomAnimations(R.anim.rns_no_animation_20, R.anim.rns_no_animation_20)\n                        StackAnimation.FADE -> it.setCustomAnimations(R.anim.rns_fade_in, R.anim.rns_fade_out)\n                        StackAnimation.SLIDE_FROM_RIGHT -> it.setCustomAnimations(R.anim.rns_slide_in_from_left, R.anim.rns_slide_out_to_right)\n                        StackAnimation.SLIDE_FROM_LEFT -> it.setCustomAnimations(R.anim.rns_slide_in_from_right, R.anim.rns_slide_out_to_left)\n                        StackAnimation.SLIDE_FROM_BOTTOM -> it.setCustomAnimations(\n                            R.anim.rns_no_animation_medium, R.anim.rns_slide_out_to_bottom\n                        )\n                        StackAnimation.FADE_FROM_BOTTOM -> it.setCustomAnimations(R.anim.rns_no_animation_250, R.anim.rns_fade_to_bottom)\n                        StackAnimation.IOS -> it.setCustomAnimations(R.anim.rns_slide_in_from_left_ios, R.anim.rns_slide_out_to_right_ios)\n                    }\n                }\n            }\n\n            ...\n        }\n    }\n}\n```\n\n이제 진짜 마지막으로 해당 xml 파일을 찾아 duration부분을 수정하고 patch package를 진행해 애니메이션 속도를 변경할 수 있었다.\n기존 duration은 `config_mediumAnimTime`으로 설정되어 있었고, 해당 부분을 수정하면 커스텀하게 수정이 가능하게 되었다.\n\nanimation duration은 react-native-screens에서 20,250,350을 기본 값으로 설정해두고 있는 것으로 보여, 250으로 변경해 적용하게 되었다.\n\n```XML\n\n<!--[참고 코드](react-native-screens/android/src/main/res/base/anim/rns_slide_in_from_bottom.xml)-->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromYDelta=\"100%\"\n    android:toYDelta=\"0%\"\n    android:duration=\"@android:integer/config_mediumAnimTime\" /> <!--250으로 변경 -->\n\n<!--[참고 코드](react-native-screens/android/src/main/res/base/anim/rns_slide_out_to_bottom.xml)-->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromYDelta=\"100%\"\n    android:toYDelta=\"0%\"\n    android:duration=\"@android:integer/config_mediumAnimTime\" /> <!--250으로 변경 -->\n\n<!--[참고 코드] (react-native-screens/android/src/main/res/base/anim/rns_no_animation_medium.xml)-->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromAlpha=\"1.0\"\n    android:toAlpha=\"1.0\"\n    android:duration=\"@android:integer/config_mediumAnimTime\"/> <!--250으로 변경 -->\n```\n\n<table>\n  <tr>\n    <td>개선 전 Android Native Stack Card (slide_from_bottom)</td>\n    <td>개선 후 Android Native Stack Card (slide_from_bottom)</td>\n  </tr>\n  <tr>\n    <td><img src=\"android-animation-velocity-before.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-animation-velocity-after.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n시간상 하지 못했지만, 조금 더 모달 애니메이션을 개선하면 좋았을 것 같다는 아쉬운 생각이 들었다.\n기존에는 끝에 점점 천천히 도착하는 듯한 효과가 있었지만 지금은 linear하게 한번에 뜨고 닫히는 것 같아 어색함이 남아있어보였다.\n이후에 더 `native스러운 느낌`을 줄 수 있게 후작업으로 개선 작업도 진행해보려 한다.\n\n#### TransparentModal\n\n기존 일부 화면에서 사용되고 있던 `transparent modal` 옵션을 `containedTransparentModal`을 이용해 최대한 사용하려 했지만, 다음 화면이 card인 경우에 애니메이션이 버벅이는 듯한 이슈가 발생하게 되었다.\n이를 해결하기 위해서 `transparent modal` 옵션 대신 기존 화면을 바텀시트 컴포넌트를 이용해 구현하는 방식으로 수정하게 되었다.\n\n이렇게 수정했을 때 기존은 모달이지만 서서히 fade in/fade out으로 화면전환이 되었지만, 바텀시트로 변경하면서 overlay가 보이는 모달 느낌이 더 들 수 있어 좋은 선택이라 생각이 들었다.\n\n제품 내 모든 `transparent modal` 옵션을 사용하던 화면들을 다 바꾸지는 못했고, 이슈가 있었던 화면만 수정하게 되었지만, 다음화면에 따라 화면전환 애니메이션에 이슈가 있을 수 있어 후작업을 진행해야할 것 같다.\n\n<table>\n  <tr>\n    <td>이슈가 되었던 transparent modal</td>\n    <td>BottomSheet으로 전환한 transparent modal</td>\n  </tr>\n  <tr>\n    <td><img src=\"signup-modal-issue-before.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"signup-modal-after.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n### 기타 이슈: gesture handler로 사진 끌어당겨 닫기 이슈\n\n해당 이슈는 첫번째 배포 때 롤백하게 된 가장 컸던 이슈로 이미지 슬라이더를 보고 끌어당겨 해당 화면을 pop한 후에, 제품 내 메인 퍼널 중 하나인 요청서 작성화면에 진입한 경우에 질문이 10개만 렌더링되는 이슈가 발생했다.\n\n이미지를 끌어당겨 종류할 수 있게 하기 위해 PanResponder를 이용해 구현했는데, PanResponder로 끌어당겨 `navigation.pop`을 진행하게 하는 동작에서 문제가 발생하는 것으로 보였다.\n\n해당 이슈를 해결하는 과정에서 FlatList로 구현된 요청서 작성화면의 요소가 Flatlist의 [initialNumToRender](https://reactnative.dev/docs/flatlist#initialnumtorender) prop의 default 값처럼 딱 10개만 항상 렌더링되는 것을 근거로 `FlatList` 내부 코드를 확인해보게 되었다.\n\nFlatlist는 VirtualizedList를 상속받아 구현되어 있고, VirtualizedList는 다음 목록을 가져오기 위해서 [Batchinator](https://github.com/facebook/react-native/blob/main/packages/virtualized-lists/Interaction/Batchinator.js)를 이용해 다음 목록을 받아오게된다.\n이때 Batchinator는 InteractionManager의 runAfterInteractions 메소드를 이용해 다음 목록을 받아오게 구현되어 있었다.\n\n[ [Batchinator 코드](https://github.com/facebook/react-native/blob/main/packages/virtualized-lists/Interaction/Batchinator.js)]\n\n```typescript\nclass Batchinator {\n  _callback: () => void;\n  _delay: number;\n  _taskHandle: ?{cancel: () => void, ...};\n  constructor(callback: () => void, delayMS: number) {\n    this._delay = delayMS;\n    this._callback = callback;\n  }\n  /*\n   * Cleanup any pending tasks.\n   *\n   * By default, if there is a pending task the callback is run immediately. Set the option abort to\n   * true to not call the callback if it was pending.\n   */\n  dispose(options: {abort: boolean, ...} = {abort: false}) {\n    if (this._taskHandle) {\n      this._taskHandle.cancel();\n      if (!options.abort) {\n        this._callback();\n      }\n      this._taskHandle = null;\n    }\n  }\n  schedule() {\n    if (this._taskHandle) {\n      return;\n    }\n    const timeoutHandle = setTimeout(() => {\n      this._taskHandle = InteractionManager.runAfterInteractions(() => {\n        // Note that we clear the handle before invoking the callback so that if the callback calls\n        // schedule again, it will actually schedule another task.\n        this._taskHandle = null;\n        this._callback();\n      });\n    }, this._delay);\n    this._taskHandle = {cancel: () => clearTimeout(timeoutHandle)};\n  }\n}\n\nmodule.exports = Batchinator;\n```\n\n이미지를 끌어당겨 종료하기 위해 사용되는 PanResponder 또한 내부 적으로 InteractionManager를 이용하는데 이때 gesture 방해를 막기위해 JS 이벤트를 blocking하게 구현되어 있다.\n\n![pan responder 주석](pan-responder.png)\n\n이를 근거로 자세한 동작과 충돌 과정은 파악하지 못했지만 이미지를 끌어당겨 종료하는 이벤트를 처리하는 과정에서 Interaction Manager가 blocking되어 FlatList의 InteractionManager가 동작하지 못하게 막아서 발생하는 이슈로 추측할 수 있었다.\n\n해당 이슈를 해결하게 위해서 Pan Responder의 interaction 도중에 navigation.pop이 진행되게 하는게 아니라 Interaction이 모두 끝난 후에 진행되게 해 문제를 해결할 수 있었다.\n\n```typescript\n    const panResponder = useRef(\n        PanResponder.create({\n            ...,\n            onPanResponderGrant: () => {\n                // PanGesture가 완료되고 난 이후에 화면 이동을 동작시켜 InteractionManager간 충돌을 막습니다.\n                InteractionManager.runAfterInteractions(() => {\n                        navigation.goBack();\n                });\n            },\n        }),\n    ).current;\n```\n\n## ⭐️ 적용 후 성능 분석\n\n이제 적용 후 성능 분석을 진행한 내용을 정리해보려 한다. 화면 전환간 성능을 개선한다는 목표를 가지고 작업을 진행했다 보니 지표적으로 명확하게 보여줄 방법이 크게 없어 어려움을 느꼈다.\n\n고민 끝에 정했던 방법은 총 3가지로, 먼저 간단하게 실제 제품 내 메인 퍼널들에 대한 **영상**을 찍어서 전/후 비교를 진행했고, 다음으로 직접적이지는 않지만 애니메이션 처리 과정에 필요한 **CPU 사용량과 memory 사용량**을 보기 위해 android에서 웹의 light house처럼 성능측정을 할 수 있는 [**flash light**](https://github.com/bamlab/flashlight)을 이용해 메인 퍼널들에 대한 지표를 측정해보았다.\n그리고 추가적으로 화면 stack이 최대 100개가 되었을 때도 정상적으로 애니메이션을 처리할 수 있을지 보기 위해 **stress 테스트**를 진행해보았다.\n\n### 영상을 통한 전/후 비교\n\n영상을 통한 전/후 비교는 가장 직관적으로 보여줄 수 있는 방법이라고 생각했다. 영상을 찍어서 전/후 비교를 진행했고, 이를 통해 애니메이션의 자연스러움과 끊김이 있는지, 또한 화면 전환 속도가 빨라졌는지 확인할 수 있었다.\n\n아래는 메인 퍼널 중 하나인 고객홈 -> 메인 카테고리 까지 넘어가는 과정을 Android (Galaxy22)에서 찍은 영상이다.\n\n<table>\n  <tr>\n    <td>AS-IS</td>\n    <td>TO-BE</td>\n  </tr>\n  <tr>\n    <td><img src=\"customer-home-before.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"customer-home-after.gif\" alt=\"modal\" width=\"300\"/></td>\n  </tr>\n</table>\n\n영상을 비교해보았을 때 이전보다 조금 더 부드럽게 전환되고 화면전환 이벤트 처리가 빨라진 것을 느낄 수 있었다.\n\n### FlashLight를 이용한 성능 측정\n\n영상을 찍는데에서 끝내지 않고 최대한 숫자로, 지표로 분석해보면 조금 더 좋지 않을까 생각해 flash light를 이용해 성능 측정을 진행해보았다.\nflash light와 maestro e2e 자동화 코드를 이용해 측정해보았고, 앱을 시작해서 위에서 영상으로 찍었던 메인 퍼널 시나리오에 대해 각각 30번 진행했을 때 성능 지표를 측정했다.\n\n<table width=\"100%\">\n  <tr>\n    <th>홈 -> 메인 카테고리 전/후</th>\n  </tr>\n  <tr>\n    <td><img src=\"flashlight-home.png\" alt=\"modal\" width=\"1000\"/></td>\n  </tr>\n <tr>\n    <th>받은 요청 목록 -> 받은 요청 상세 전/후</th>\n  </tr>\n  <tr>\n    <td><img src=\"flashlight-request.png\" alt=\"modal\" width=\"1000\"/></td>\n  </tr>\n <tr>\n    <th>받은 견적 목록 -> 받은 견적 상세 -> 견적서 상세 전/후</th>\n  </tr>\n  <tr>\n    <td><img src=\"flashlight-quote.png\" alt=\"modal\" width=\"1000\"/></td>\n  </tr>\n <tr>\n    <th>채팅방 목록 -> 채팅방 AS-IS</th>\n  </tr>\n  <tr>\n    <td><img src=\"flashlight-chatlist.png\" alt=\"modal\" width=\"1000\"/></td>\n  </tr>\n</table>\n\n성능 지표를 분석해보았을 때 퍼널 별로 오르락 내리락 하는 부분들이 있지만, CPU 사용량과 Memory 사용량이 대부분 감소했고 이는 **애니메이션 처리 과정에서 더 효율적으로 처리되고 있다**는 것을 의미한다고 볼 수 있었다.\n\n그리고 추가적으로 분석해보았을 때 받은견적 목록 -> 받은 견적 상세 -> 견적서 상세 전환에서 다른 퍼널과 다르게 전체적인 지표 모두 좋아진 것을 볼 수 있었다.\n퍼널간 차이점을 보았을 때 측정했던 퍼널 중 가장 긴 퍼널이었다는 점을 고려해 Navigation stack이 쌓일수록 더 효율적으로 처리하고 있다는 것을 알 수 있었다.\n\n이러한 특징을 눈으로 더 명확하게 확인해보기 위해서 `Navigation stack이 100개가 되었을 때도 성능이 좋아지는지` 확인해보는 건 어떨까라는 호기심이 생겨 stress 테스트를 이어서 진행해보았다.\n\n### Stress 테스트를 통한 성능 확인\n\nstress 테스트는 10개, 30개, 50개, 75개, 100개 까지 stack에 화면이 쌓였을 때 어떻게 화면전환이 되는지를 촬영해보았고, 영상 상단에 navigation stack의 길이를 표시해 현재 몇개 stack이 쌓였는지 확인할 수 있게 했다.\n아래 영상은 Android Galaxy22 기기에서 측정한 결과다.\n\n<table width=\"100%\">\n <tr>\n    <th>Stack Navigator 10개 </th>\n    <th>Stack Navigator 50개 </th>\n    <th>Stack Navigator 100개 </th>\n  </tr>\n <tr>\n    <td><img src=\"android-before-10.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-before-50.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-before-100.gif\" alt=\"modal\" width=\"300\"/></td>\n </tr>\n <tr>\n    <th>Native Stack Navigator 10개 </th>\n    <th>Native Stack Navigator 50개 </th>\n    <th>Native Stack Navigator 100개 </th>\n  </tr>\n <tr>\n    <td><img src=\"android-after-10.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-after-50.gif\" alt=\"modal\" width=\"300\"/></td>\n    <td><img src=\"android-after-100.gif\" alt=\"modal\" width=\"300\"/></td>\n </tr>\n</table>\n\nStack Navigator는 stack이 쌓일수록 화면전환 속도가 느려지는 것을 확인할 수 있었고, Native Stack Navigator는 stack이 쌓여도 유사한 속도로 화면전환이 진행되는 것을 볼 수 있었다.\n\n촬영과정에서 기기에서 느껴지는 발열도 Native Stack Navigator가 더 낮은 것을 느낄 수 있었고, 이는 CPU 사용량과 Memory 사용량이 줄어들어 성능이 향상되었다는 것을 체감할 수 있었다.\n\n## 📚 배운점\n\n여태까지 진행했던 프로젝트 중에서 가장 이슈가 많았던 작업이었고, 다행히 잘 해결해서 현재 잘 제품에 반영되어 있어 뿌듯했다.\n\n단순 Javascript 런타임만 고민하는게 아니라 모바일 플랫폼에 특화된 성능 개선을 적용할 수 있어 좋았고, 잘 만들어진 오픈 소스 라이브러리들을 내부구조도 파헤치는 좋은 경험이 되어 이후에 React Navigation에도 기여하고 싶은 마음도 생겼다.\n\n적용하면서 성능이 개선되었는지 확인하기 위해 다양한 방법을 사용해보았는데, 영상을 찍어 전/후 비교를 하는 것이 가장 직관적이었다. 나름 숫자로 표현하기 위해 노력해보았지만 어느정도 한계가 있었다.\n하지만, 메모리나 CPU 사용량과 같이 이전에 관심을 두지 않았던 하드웨어 스펙에 대해서도 관심을 가지게 되었고, 이를 통해 성능을 개선하는데 도움이 되었다.\n\n물론 여전히 남겨진 일들이 있지만, 하나의 또 큰 일감을 잘 마무리하고 사용자 경험과 성능 모두 개선할 수 있었던 좋은 작업이었다고 생각되었다.\n"},{"excerpt":"2분기를 마무리하면서 6월 한달 간 진행했던 스쿼드 업무, 챕터 업무 및 5월달의 action item들을 정리해보고 다음 분기를 위해 어떤 부분들을 더 공부하면 좋을지 개선하면 좋을지 정리해보려 한다. 5월 회고 돌아보기 5월에 삼았던 action item들을 정리해보면 아래와 같다. 화면전환 간 성능 개선을 위해 Native Stack 도입 및 성능 …","fields":{"slug":"/2024-06-30-2024년-6월회고/"},"frontmatter":{"date":"June 30, 2024","title":"🤭 2024년 6월회고","tags":["회고"]},"rawMarkdownBody":"\n2분기를 마무리하면서 6월 한달 간 진행했던 스쿼드 업무, 챕터 업무 및 5월달의 action item들을 정리해보고 다음 분기를 위해 어떤 부분들을 더 공부하면 좋을지 개선하면 좋을지 정리해보려 한다.\n\n## 5월 회고 돌아보기\n\n5월에 삼았던 action item들을 정리해보면 아래와 같다.\n\n- 화면전환 간 성능 개선을 위해 Native Stack 도입 및 성능 분석방법 찾아보기\n- 에러 바운더리를 조금 더 챕터원들이 쉽게 적용하는 방법 고민해보기\n- 컴포넌트 설계 정리\n- 못했던 작업 진행해보기: 리액트 내부 코드 분석, UI 패턴별 최적화 정리해보기\n- 3분기 일감 발제하기: 선언적으로 인증/인가 관리하기, Async Storage 대체하기\n\n이중 리액트 내부 코드 분석은 Native Stack 적용을 위해 React Navigation과 React Native Screens 패키지를 분석하는데 시간을 쏟다보니 하지못했다.\n3분기 일감으로 생각했던 선언적으로 인증/인가 관리하기는 이보다 Native Stack을 적용하면서 여러 퍼널들을 겪으면서 화면전환간 로딩을 개선하는게 조금 더 유저경험에 도움이 될 것 같아 미루게 되었다.\n대신 Async Storage를 mmkv로 대체하는 일감은 챕터업무로 발탁되어 3분기에 담당자로 진행하게 되었다.\n\n이제 5월의 action item들을 진행했던 6월의 작업들을 정리해보자.\n\n## 6월의 작업들\n\n### 🚀 Native Stack 적용하기\n\nReact Navigation의 [Stack Navigator](https://reactnavigation.org/docs/stack-navigator)에서 [Native Stack Navigator](https://reactnavigation.org/docs/native-stack-navigator)를 적용해 화면전환간 성능을 개선하는 작업으로 6월 26일 배포되면서 마무리하게 되었다.\n원래 배포는 6월 12일로 예정되어 있었지만, QA과정에서 애니메이션이 끊기는 이슈와 gesture handler로 사진을 끌어당겨 닫은 이후에, 요청서 화면에서 10개의 질문만 렌더링되는 이슈가 있어 롤백하게 되었는데 해당 이슈를 해결하고 다시 배포하게 되었다.\n해당 이슈들에 대해 간단하게 정리해보려 한다.\n\n#### 애니메이션 끊김 이슈\n\n애니메이션이 끊겼던 이슈는 overlay가 있는 회원가입 안내 모달 화면에서 발생하게 되었다. 해당 화면은 transparent modal로 되어있었는데 Card로 된 다음 화면으로 전환할 때 애니메이션이 끊기는 듯한 현상이 나타났다.\n\n이를 해결하기 위해서 transparent modal 대신 바텀 시트를 사용해 화면을 구현하는 방식으로 수정했고, 해당 이슈를 통해 Native Stack에서 transparent modal의 경우 다음 화면이 어떤 것인지에 따라 애니메이션이 끊겨보일 수 있어, bottomTab이 있는 홈 화면이 아니면\n바텀시트로 구현하는 것이 좋다는 것을 알게 되었다.\n\n#### gesture handler로 사진 끌어당겨 닫기 이슈\n\n이미지를 보고 끌어당겨 종료한 후에, 제품 내 메인 퍼널 중 하나인 요청서 작성화면에서 질문이 10개만 렌더링되는 이슈가 발생했다.\n해당 이슈는 롤백을 하게 되는 가장 큰 이유가 된 이슈로, React Native의 Interaction Manager와 관련된 이슈였다.\n\n이미지를 끌어당겨 종류할 수 있게 하기 위해 PanResponder로 구현했는데, PanResponder로 끌어당김 이벤트가 종료되는 시점에 navigation.pop을 진행하면서 StackNavigator에서는 발생하지 않았던 이슈가 Native Stack에서 발생했다.\n해당 이슈를 해결하는 과정에서 FlatList로 구현된 요청서 작성화면의 요소가 Flatlist의 [initialNumToRender](https://reactnative.dev/docs/flatlist#initialnumtorender) prop의 default 값처럼 딱 10개만 항상 렌더링되는 것을 근거로 삼아 내부 코드를 확인해보게 되었다.\n\nFlatlist는 VirtualizedList를 상속받아 구현되어 있고, VirtualizedList는 다음 목록을 가져오기 위해서 [Batchinator](https://github.com/facebook/react-native/blob/main/packages/virtualized-lists/Interaction/Batchinator.js)를 이용해 다음 목록을 받아오게된다.\n이때 Batchinator는 InteractionManager를 이용해 InteractionManager.runAfterInteractions를 이용해 다음 목록을 받아오게 되는 것을 알게 되었다.\n\n[ [Batchinator 코드](https://github.com/facebook/react-native/blob/main/packages/virtualized-lists/Interaction/Batchinator.js)]\n\n```typescript\nclass Batchinator {\n  _callback: () => void;\n  _delay: number;\n  _taskHandle: ?{cancel: () => void, ...};\n  constructor(callback: () => void, delayMS: number) {\n    this._delay = delayMS;\n    this._callback = callback;\n  }\n  /*\n   * Cleanup any pending tasks.\n   *\n   * By default, if there is a pending task the callback is run immediately. Set the option abort to\n   * true to not call the callback if it was pending.\n   */\n  dispose(options: {abort: boolean, ...} = {abort: false}) {\n    if (this._taskHandle) {\n      this._taskHandle.cancel();\n      if (!options.abort) {\n        this._callback();\n      }\n      this._taskHandle = null;\n    }\n  }\n  schedule() {\n    if (this._taskHandle) {\n      return;\n    }\n    const timeoutHandle = setTimeout(() => {\n      this._taskHandle = InteractionManager.runAfterInteractions(() => {\n        // Note that we clear the handle before invoking the callback so that if the callback calls\n        // schedule again, it will actually schedule another task.\n        this._taskHandle = null;\n        this._callback();\n      });\n    }, this._delay);\n    this._taskHandle = {cancel: () => clearTimeout(timeoutHandle)};\n  }\n}\n\nmodule.exports = Batchinator;\n```\n\n이미지를 끌어당겨 종료하기 위해 사용되는 PanResponder 또한 내부 적으로 InteractionManager를 이용하는데 이때 gesture 방해를 막기위해 JS 이벤트를 blocking하게 구현되어 있다.\n\n![pan responder 주석](pan-responder.png)\n\n이를 근거로 자세한 동작과 충돌 과정은 파악하지 못했지만 이미지를 끌어당겨 종료하는 이벤트가 발생 후 Interaction Manager가 blocking되어 FlatList의 InteractionManager가 동작하지 못하게 막아서 발생하는 이슈로 추측할 수 있었다.\n그래서 Pan responder의 interaction 도중에 navigation.pop이 진행되게 하는게 아니라 Interaction이 모두 끝난 후에 진행되게 해 문제를 해결할 수 있었다.\n\n```typescript\n    const panResponder = useRef(\n        PanResponder.create({\n            ...,\n            onPanResponderGrant: () => {\n                // PanGesture가 완료되고 난 이후에 화면 이동을 동작시켜 InteractionManager간 충돌을 막습니다.\n                InteractionManager.runAfterInteractions(() => {\n                        navigation.goBack();\n                });\n            },\n        }),\n    ).current;\n```\n\n이렇게 두가지 추가 이슈를 모두 마친 이후에 6월 26일 배포를 진행하게 되었다.\n\n#### 성능 분석하기\n\n일감의 목표가 화면전환간 성능개선이었다보니, 어떻게 측정 기준을 잡아야할 지 막막함이 있었다. 왜냐하면 대부분의 상황에서는 JS 스레드에서 애니메이션을 진행하든 UI 스레드에서 애니메이션을 진행하든 큰 차이가 보이지 않을 것으로 예상되었기 때문이다.\n어떻게 하면 수치적으로 나타낼 수 있을까 고민끝에 화면전환과 직접적으로 관련된 것은 아니지만 CPU와 메모리 사용량을 비교해보기로 했다.\n\n측정방법은 [FlashLight](https://github.com/bamlab/flashlight)와 maestro를 이용한 e2e 테스트를 사용했다.FlashLight는 현재 안드로이드만 지원하고 있어 안드로이드를 기준으로, 제품 내 고객, 고수 분들이 가장 많이 사용하는 퍼널들을 사용했다.\n총 30회 반복 측정을 진행했고, 아래는 측정한 받은 견적 목록 도메인의 화면 전환간 성능을 측정한 결과이다.\n\n![받은 견적 화면전환 성능 측정 결과](받은견적.png)\n\n사진은 측정한 퍼널 중 하나의 퍼널 데이터이지만, 총 4가지 퍼널을 측정했을 때 CPU 사용량과 RAM 사용량은 전반적으로 감소되었다.\n\n결과를 분석하다보니 짧은 퍼널일 때보다 퍼널이 길어질 수록 차이가 더 심해지는 것을 알게되어, 페이지가 많아져 메모리 사용량이 많아졌을 때 애니메이션이 정상적을 동작하는지 보기 위해 **Stress 테스트**도 추가로 진행했다.\n\n측정 방법은 stack에 최대 100개까지 화면이 쌓여있는 경우에 101번째 화면으로 진입할 때 애니메이션을 영상으로 찍어보았다.\n영상 상단의 숫자는 Navigator에 쌓여있는 페이지 숫자를 의미한다.\n\n[페이지가 stack에 10개/100개가 쌓였을 때 화면 전환 애니메이션]\n\n<table>\n  <tr>\n    <th>Stack Navigator</th>\n    <th>Native Stack Navigator</th>\n  </tr>\n  <tr>\n    <td>\n        <img src=\"android-before-10.gif\"/>\n    </td>\n    <td>\n        <img src=\"android-after-10.gif\"/>\n    </td>\n  </tr>\n    <tr>\n    <td>\n        <img src=\"android-before-100.gif\"/>\n    </td>\n    <td>\n        <img src=\"android-after-100.gif\"/>\n    </td>\n  </tr>\n</table>\n\nstack Navigator의 경우 100개가 되었을 때 클릭 이벤트처리부터 화면전환까지 10개 때와 비교해 눈에 띄게 느려진 것을 볼 수 있었고,\n그에 반해 Native Stack Navigator의 경우 큰 차이 없이 자연스럽게 처리되는 것을 볼 수 있었다.\n\n추가로 테스트를 진행하면서 기기의 발열감을 느낄 수 있었는데 이는 stack Navigator의 경우 화면이 많아질수록 메모리 사용량이 늘어나고, 메모리 사용량이 늘어나면서 CPU 사용량이 늘어나게 되어 발열이 느껴지는 것으로 추측된다.\n더 자세한 데이터는 Native Stack을 주제로 글을 작성하며 함께 공유할 예정이다.\n\nNative Stack을 적용을 마치고 결과를 챕터원 분들께 공유드렸을 때, 받았던 질문이 몇가지 있었다.\n\n- React Navigation에서 React-native-screens가 사용되는 방식\n- 실제 Native 요소가 사용되는 것과 RN의 View로 화면을 만들었을 때 차이점\n\n당시 답변을 드리지 못했고, 개인적으로도 궁금한 부분이기 떄문에 이에 대한 답변들을 계속해서 찾으며 공부해보고 있고, Native Module에 대한 공부를 추가적으로 진행해서 간단한 패키지를 mimic해서 만들어 글과 함께 정리해볼 예정이다.\n\n2분기 챕터 OKR이었던 Native Stack 적용을 잘 마무리해서 기쁘고, 잘 마무리할 수 있었던 이유는 첫 배포 당시 이슈 파악을 위해 많은 챕터원분들께서 함께 도와주셔서 이후에 두번째 배포때는 문제없이 안정적으로 배포될 수 있었다.\n개인적으로 React Navigation에 대해 많이 공부할 수 있었고, Native 코드도 많이 보고 동작을 이해하는 계기가 되었다.\n\n조금 아쉬웠던 부분은 개선된 결과를 숫자로 표현하기 어려움이 있었다는 점이었다. 애니메이션과 메모리/CPU사용량에 대한 관계를 더 잘 공유하고, 이를 측정하는 작업들을 선행했다면 성과분석에 더 좋았을 것이라는\n아쉬움도 남았다.\n\n### 에러 바운더리 적용작업 마무리\n\n드디어 에러바운더리 적용작업도 완료했다. 5월에 고민했던 새로운 화면들이 추가되었을 때 어떻게 적용할 수 있을지 고민했던 부분을 위한 작업들도 추가로 진행했다.\n현재 적용된 화면과 적용되지 않은 화면들을 파악할 수 있는 script를 추가했고, 새로운 화면을 생성할 때 자동으로 에러바운더리가 적용되도록 하는 작업을 진행했다.\n자세한 시행착오들을 [에러바운더리 도입하기](https://choi2021.github.io/2024-06-02-%EC%97%90%EB%9F%AC%EB%B0%94%EC%9A%B4%EB%8D%94%EB%A6%AC-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/)에 작성해보았다.\n\n하나의 화면에 적용하는 작업은 간단하지만 제품 전체에 적용하면서 다양한 케이스들을 고민하고 적용하는 것은 생각보다 어려운 작업이었다.\n그리고 동료의 학습비용을 줄이기 위한 고민들을 하면서, 지속적인 공유가 필요한 이유를 느낄 수 있었다.\n\n그래도 3분기에 거쳐 해온 에러/예외처리 고도화 작업을 마무리하면서 긴 호흡의 하나의 작업을 완료했다는 점에 뿌듯함을 느낄 수 있었다.\n\n### 컴포넌트 설계\n\n5월에 작업했던 composition 컴포넌트 설계 공부를 하고 적용한 고수 프로필 컴포넌트를 동료분들께 어떻게 변경되었고 어떤 점을 고려해서 리팩토링했는지 전달드리려 했지만, Native Stack과 에러바운더리 적용작업에 많은 시간을 쓰다보니,\n자연스럽게 후순위로 밀리게 되었다.\n\n다행히 스쿼드 작업을 진행하면서 작업한 컴포넌트를 내가 직접 사용하게 되었다. 수정 당시에는 이렇게 사용되면 좋겠다 하며 설계했던 부분이 기존에 없던 요구사항을 적용하면서 어려움을 만들기도 했다.\n1차로는 완료했지만 아직 개선해야할 부분들이 많아 조금 더 공부하고 적용해서 8월 내로 꼭 전달해보려 한다.\n\n### UI 패턴별 최적화 정리하기\n\n스쿼드 작업을 진행하면서 신규 폼 화면을 구현하게 되었다. 여러가지 스텝을 통해 데이터를 모으고 마지막에 전달하는 `설문조사 패턴`으로 앞서 토스 슬래시 발표를 보면서 공부했던 내용을 적용해려 했다.\n하지만 기존 챕터 내 컨벤션은 전역 상태와 화면들간의 결합도를 낮추기 위해서 최대한 스크린 단위로 데이터를 관리하는 방식으로 이루어져 있기 때문에 설문조사 패턴을 적용하기는 어려웠다.\n\n그래서 우선은 각 스텝별 화면에서 데이터를 param으로 전달하는 기존 방식대로 구현을 했고, 3분기에 기존 파편화되어있던 화면간의 데이터 공유 문제를 해결하기 위한 작업들이 예정되어 있기 때문에 조금씩 의견들을 제시해보고 다시 적용해보려한다.\n\n추가적으로는 input 컴포넌트들을 사용하면서 키보드에 따라 어떻게 스크롤을 관리할지, 각종 에러 상황, 로딩상황 등 다양한 유즈케이스들을 정리하면서 유저경험을 개선하기 위한 많은 고민들을 해보려 했다.\n\n### Async Storage 대체하기\n\n3분기 챕터 업무를 기획하면서 5월에 고민했던 Async Storage를 [mmkv](https://github.com/mrousavy/react-native-mmkv)로 적용하는 작업을 발제했다.\nmmkv를 적용했을 때 두가지 장점을 기대하고 작업을 발제했다.\n\n1. Async Storage 보다 빠른 속도 (유저 경험 향상)\n2. Async Storage 사용시 필요했던 비동기 코드를 동기적 코드로 변경해 데이터 흐름을 쉽게 이해할 수 있다 (개발자 경험 향상)\n\n위 두가지 장점을 기대하며 7월부터 작업을 진행할 예정이고, 챕터원분들의 피드백으로 mmkv대신 다른 [op-sqlite](https://github.com/OP-Engineering/op-sqlite)와 같은 다른 스토리지 라이브러리들도 같이 고민하면 좋겠다고 말씀해주셔서,\n먼저 조사 후에 기대하는 효과들을 모두 만족하는 라이브러리를 선택해서 작업을 진행해보려 한다.\n\n## 7월의 action item 정리\n\n6월도 역시 목표했던 만큼 다 완료하지는 못해 아쉽지만, 우선순위에 따라, Native Stack 적용과 에러 바운더리 작업들을 마무리했고 이어서 다음 일감으로 기획했던 작업도 담당하게 되어 2분기를 잘 마무리 할 수 있었다.\n\n7월의 목표는 아래와 같다.\n\n- Native Stack 적용 글 작성하기\n- 컴포넌트 설계 추가 작업 진행하기\n- 페이지간 데이터 공유 문제 고민하고 논의하기\n- Async Storage 대체할 라이브러리 검토 및 마이그레이션하기\n- 제품 내 로딩 상태 개선하기\n\n마지막 로딩 상태 개선은 에러 바운더리 적용 이후에, 고민한 작업으로 너무 빠르게 로딩이 진행될 경우 오히려 깜빡임처럼 느끼게 해, 유저경험을 해치고 있다고 느끼게 되어 3분기 일감으로 발제하게 되었다.\n현재 작업 방식은 일정한 기준 시간을 정해서 로딩을 진행하는 방식을 고민하고 있지만, 어떻게 진행될지는 조금 더 고민을 해보려 한다.\n\n우선 이렇게 5가지로 action item을 정했고, 7월에 다시 한번 회고를 통해 어떤 부분을 개선하면 좋을지, 어떤 부분을 더 공부하면 좋을지 정리해보려 한다.\n"},{"excerpt":"에러바운더리 작업을 작년 2023년 11월에 챕터 주간미팅에서 발표한 후에,24년 1월부터 5월까지 총 5개월동안 작업을 담당하고 제품 내 전체 스크린에 적용을 완료했다. 해당 일감의 목표는 런타임 에러로 인한 화이트스크린 에러를 방지하는데 있었다. 이를 위해 스크린 단위로 런타임 에러를 감지하고 fallback UI를 노출할 수 있게 에러바운더리를 적용…","fields":{"slug":"/2024-06-02-에러바운더리-도입하기/"},"frontmatter":{"date":"June 02, 2024","title":"✅ 에러바운더리 도입하기","tags":["회고","react"]},"rawMarkdownBody":"\n에러바운더리 작업을 작년 2023년 11월에 챕터 주간미팅에서 발표한 후에,24년 1월부터 5월까지 총 5개월동안 작업을 담당하고 제품 내 전체 스크린에 적용을 완료했다.\n\n해당 일감의 목표는 런타임 에러로 인한 **화이트스크린 에러**를 방지하는데 있었다. 이를 위해 **스크린 단위**로 런타임 에러를 감지하고 fallback UI를 노출할 수 있게 에러바운더리를 적용했다.\n에러바운더리가 무엇인지, 어떤 장점과 한계점이 있는지, 그리고 적용과정에서 어떤 점들을 고려했는지 정리해보려 한다.\n\n## 🤔 에러바운더리란\n\n에러바운더리는 react 16에 도입된 개념으로 UI 렌더링 과정에서 발생한 자식 컴포넌트 트리에 에러를 발생했을 때, 상위로 에러를 던지지지 않고 fallback UI를 보여주는 컴포넌트다. `에러 상태를 담당해주는 Context`로 이해할 수 있다.\n\n[에러 바운더리를 시각화한 그림 ([참조. Logrocket 에러바운더리 글](https://blog.logrocket.com/react-error-handling-with-react-error-boundary/))]\n\n![에러바운더리](./error_boundary.png)\n\n에러바운더리는 기본적으로 클래스 컴포넌트로 작성되며 아래 코드를 통해 4가지 정보에 대해 알 수 있다.\n\n[에러 바운더리 컴포넌트]\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true }\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.log(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>\n    }\n\n    return this.props.children\n  }\n}\n\n// Usage in a component\nclass App extends React.Component {\n  render() {\n    return (\n      <ErrorBoundary>\n        <MyComponent />\n      </ErrorBoundary>\n    )\n  }\n}\n```\n\n1. `this.state`: 에러상태를 가지는 컴포넌트\n2. `getDerivedStateFromError`: 렌더링 에러가 발생했을 때, 에러상태를 변경해 fallback UI가 보이도록 업데이트\n3. `componentDidCatch`: 에러가 발생했을 때, 버그 리포팅하는 등 수행할 callback을 등록\n4. `render`: 에러발생시 조건부 렌더링을 이용해 미리 정의한 fallback UI가 노출\n\n사용할 때는 예시 코드의 App 컴포넌트 처럼 우리가 원하는 컴포넌트를 감싸주면 된다.\n\n### 에러바운더리의 장점과 한계\n\n그러면 에러바운더리가 가지는 장점은 아래의 두가지로 정리할 수 있다.\n\n1. 사용자 경험의 향상 (UX👆): 자식 컴포넌트 렌더링 에러가 최상위로 올라가 화이트스크린으로 이어지지 않게 막아준다.\n2. 개발자 경험의 향상 (DX👆): 에러상태를 위임해 에러를 선언적으로 핸들링 할 수 있다.\n\n이러한 장점을 가진 에러바운더리지만 아쉽게도 다음과 같은 에러들은 감지할 수 없다.\n\n[리액트 공식문서에서 작성된 에러바운더리의 한계점]\n\n<img src=\"에러바운더리한계.png\" width=\"700\"/>\n\n#### 내가 만들었던 에러\n\n에러바운더리는 위와 같은 한계점을 가지고 있고 `런타임에러나 렌더링 에러가 얼마나 자주 발생하겠어?`라는 생각이 들 수 있다.\n실제로 개발을 하면서 제품내 발생했던 런타임 에러에 대한 해당 예제로 런타임 에러가 발생할 수 있는 상황에 대해 알아보자.\n\n예시 요구사항은 회원가입 과정에 대한 개선 작업으로, 총 4개의 화면을 3개로 줄이는 작업을 진행하려한다.이때 작성된 데이터들은 임시로 저장하고 저장된 데이터가 있다면 재진입시 불러올 수 있어야 하고 기존 진행했던 step(pageIndex)에 따라 데이터를 불러온다.\n\n새롭게 줄인 화면에서는 임시저장된 데이터를 가져올 때 3번째 화면을 마지막으로 생각하면 되기때문에 이전 데이터를 가져올 때, index가 3을 넘어가면 에러를 던지도록 작성해두었다.\n\n```tsx\nconst 실험전_마지막페이지 = 4\nconst 실험후_마지막페이지 = 3\n\nlet AsyncStorage의_마지막페이지 = 실험전_마지막페이지 // 예시로 AsyncStorage를 let으로 작성했다.\n\nconst getDataFrom = (index: number) => {\n  switch (index) {\n    case 1:\n      return { title: \"페이지1\", content: \"페이지1의 내용\" }\n    case 2:\n      return { title: \"페이지2\", content: \"페이지2의 내용\" }\n    case 3:\n      return { title: \"페이지3\", content: \"페이지3의 내용\" }\n    default:\n      throw new Error(\"없는 페이지입니다.\") // 실험 후 마지막 페이지는 3이니까 3보다 큰값은 안 들어올거야\n  }\n}\n\nfunction ScreenThrowingError() {\n  const [index, setIndex] = React.useState(1)\n  const pageData = getDataFrom(index)\n\n  const handlePress = () => {\n    if (실험후_마지막페이지 === index) {\n      return\n    }\n    setIndex(index + 1)\n  }\n\n  useEffect(() => {\n    const AsyncStorage의_데이터불러오기 = true\n    if (AsyncStorage의_데이터불러오기) {\n      setIndex(AsyncStorage의_마지막페이지)\n    }\n  }, [])\n\n  return (\n    <View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\" }}>\n      <View>\n        <PagerView data={pageData} />\n      </View>\n      <TouchableOpacity\n        style={{ position: \"absolute\", bottom: 12 }}\n        onPress={handlePress}\n      >\n        <Text style={{ fontSize: 32, color: \"teal\" }}>{`다음페이지`}</Text>\n      </TouchableOpacity>\n    </View>\n  )\n}\n```\n\n위와 같은 상황의 코드를 시뮬레이터에서 동작시켜보면 다음과 같이 화이트 스크린 에러가 발생하게 된다.\n원인은 이전에 최대 index를 4로 설정해두었는데, 이후 3으로 줄인 상황에서 4번째 페이지 데이터를 불러와야 하기 때문이다.\n\n![에러바운더리 적용 전](example_before.gif)\n\n<br/>\n\n이렇게 화이트 스크린이 발생하는 상황에서 앞서 작성한 에러바운더리를 적용하면 다음과 같이 코드를 작성할 수 있다.\n\n```tsx\nexport class ErrorBoundary extends React.Component<{ hasError: boolean }> {\n  constructor(props: { children: ReactNode }) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n\n  componentDidCatch(error: Error) {\n    // bugsnag.notify(error);\n    console.log(error)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <View\n          style={{ justifyContent: \"center\", alignItems: \"center\", rowGap: 12 }}\n        >\n          <Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>\n          <TouchableOpacity\n            style={{\n              borderColor: \"red\",\n              borderWidth: 1,\n              padding: 10,\n              borderRadius: 10,\n            }}\n            onPress={() => {\n              AsyncStorage의_마지막페이지 = 실험후_마지막페이지\n              this.setState({ hasError: false })\n            }}\n          >\n            <Text style={{ fontSize: 30, color: \"red\" }}>재시도 하기</Text>\n          </TouchableOpacity>\n        </View>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nfunction App() {\n  return (\n    <SafeAreaView\n      style={{\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flex: 1,\n        rowGap: 12,\n      }}\n    >\n      <ErrorBoundary>\n        <ScreenThrowingError />\n      </ErrorBoundary>\n    </SafeAreaView>\n  )\n}\n```\n\n결과는 동일하게 런타임 에러가 발생하지만 화이트 스크린은 발생하지 않고, 이전 페이지로 돌아가는 것을 볼 수 있다.\n\n![에러바운더리 적용 후](example_after.gif)\n\n위 예제를 통해 에러가 발생했을 때 에러 상황 자체를 해결해 줄 수는 없지만, **앱을 종료하고 다시 실행해야하는 유저의 불편함**을 줄여줄 수 있는 에러바운더리의 장점을 잘 보여준다.\n\n## 🚀 에러바운더리 적용하기\n\n먼저 에러 바운더리를 적용하는 작업범위는 **스크린 단위**로 결정했고, 이를 위해 Route 컴포넌트에 있는 ScreenKey들을 조사했다.\n조사결과 24년 2분기 기준 246개의 스크린이 존재했고, 불필요하거나, 중복된 screenkey들을 제외하고 100% 적용을 목표로 작업을 진행했다.\n\n### 작업 방식\n\n에러 바운더리의 동작방식은 1) 에러가 발생했을 때, 2) 에러를 잡아 fallback UI로 대신 보여준다. 동작방식을 고려한 적용규칙을 아래와 같이 세웠다.\n\n#### 1. 스크린 최상단에 에러바운더리 적용하기\n\n에러 바운더리의 영향범위를 최대한으로 넓히기 위해 화면의 **최상단에 두는 것**을 제 1원칙으로 삼았다.\n\n제품 내 코드를 분석해보면 스크린 컴포넌트에서는 데이터 패칭, 공통 상태 관리, 이벤트 버스 구독 등 다양한 로직을 담고 있었다.\n이러한 상황에서 기존 스크린 컴포넌트에 그대로 에러바운더리를 적용하게 되면, 에러 경계 자체에서 발생하는 에러들이 발생했을 때 에러바운더리가 커버해 줄 수 없어 보였다.\n\n이를 해결하기 위해서는 두가지 방법이 존재한다. 첫번째로 최상위에 에러바운더리로 감싸는 컴포넌트를 추가하거나, 두번째로 기존 컴포넌트를 유지하되 HOC로 에러바운더리를 적용하는 방법이 있었다.\n\n```tsx\n// AS-IS\nfunction AScreen() {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    fetchData().then(data => setData(data))\n  }, [])\n\n  return (\n    <Layout>\n      <Header />\n      {data ? <AScreenContent data={data} /> : <Loading />}\n    </Layout>\n  )\n}\n\n// TO-BE 1. 컴포넌트로 감싸주기\n\nfunction AScreen() {\n  return (\n    <ErrorBoundary>\n      <AScreenContainer />\n    </ErrorBoundary>\n  )\n}\n\nfunction AScreenContainer() {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    fetchData().then(data => setData(data))\n  }, [])\n\n  return (\n    <Layout>\n      <Header />\n      {data ? <AScreenContent data={data} /> : <Loading />}\n    </Layout>\n  )\n}\n\n// TO-BE 2. HOC로 감싸주기\nfunction AScreen() {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    fetchData().then(data => setData(data))\n  }, [])\n\n  return (\n    <Layout>\n      <Header />\n      {data ? <AScreenContent data={data} /> : <Loading />}\n    </Layout>\n  )\n}\n\nexport default withErrorBoundary(AScreen)\n```\n\n두가지 방법 중에서 내가 선택한 방법은 첫번째 최상위에 에러바운더리를 적용한 컴포넌트를 추가하는 방법을 이었다.\n\n최상위에 적용하게 되면 depth가 더 많아지지만, 선언적으로 코드를 작성하기 때문에 조금 더 읽기 편하다고 생각해 결정하게 되었다.\n그리고 변경된 스크린 컴포넌트의 구현방식이 챕터원분들께 허들로 느껴지지 않게, 코드리뷰를 통해 자세히 설명하려 했고, 주간 미팅때 업무 진행 과정을 지속적으로 공유하면서 큰 문제없이 적용을 완료할 수 있었다.\n\n#### 2. Fallback UI 디자인하기\n\n에러 바운더리의 큰 장점 중 하나는 에러가 발생했을 때 미리 정해놓은 **fallback UI**를 보여줄 수 있다는 것이다. fallback UI를 구현할 때 가장 많이 고민했던 부분은 **화면의 레이아웃 변화 최소화하면서 해당 화면을 벗어날 수 있게 해주는 방법**이었다.\n에러가 발생한 것 자체가 유저 입장에서 당황스러운 상황에서 화면이 많이 변경되거나, 화면을 벗어날 수 없다면 더욱 당황스러울 것이라고 생각했다.\n\n이러한 디자인을 기획할 때 모바일 특성을 고려해 **헤더를 어떻게 처리할지**에 대해 많이 고민했다.\n제품 내 화면을 이동하는 방식은 tab, 바텀 버튼, 헤더가 있지만, 그중 대부분의 화면들이 **헤더**를 통해 화면을 이동하고 있기 때문에 헤더의 뒤로가기 버튼 또는 닫기 버튼을 통해 화면을 벗어날 수 있게 해주는 것이 중요했다.\n\n이를 위해서 아래와 같은 prop 구성으로 에러바운더리 컴포넌트를 구현했다. 에러바운더리는 react-error-boundary 라이브러리를 이용해 적용했다.\n\n- screen: 에러가 발생한 스크린에 대한 정보를 에러 리포팅에 전달하기 위한 prop\n- fallbackHeader: 공통 헤더를 적용할 수 없을 때, 스크린별로 커스텀 헤더를 적용하기 위한 prop\n- style: 적용하는 스크린이 overlay가 있어 흰색이 아니거나 할 경우, 커스텀할 수 있는 prop\n\n```tsx\ntype Props = {\n  screen: \"AScreen\" | \"BScreen\" | \"CScreen\" | \"DScreen\"\n  fallbackHeader?: React.FunctionComponentElement<ScreenHeaderPropsInterface>\n  style?: StyleProp<ViewStyle>\n}\nexport const RuntimeErrorBoundary: React.FC<PropsWithChildren<Props>> = ({\n  children,\n  screen,\n  style,\n  fallbackHeader,\n}) => {\n  const handleError = useCallback(\n    (error: Error, info: React.ErrorInfo) => {\n      errorLogging.sendError({\n        error: new Error(\"화이트 스크린 에러발생\"),\n        originalError: error,\n        tag: ErrorTag.WhiteScreen,\n      })\n    },\n    [screen]\n  )\n\n  const fallbackRender = useCallback(() => {\n    return (\n      <View style={[styles.container, style]}>\n        {isNotNil(fallbackHeader) && fallbackHeader}\n        <ErrorContent\n          title={\"오류가 발생했습니다\"}\n          content={\"잠시 후 다시 시도해주세요\"}\n        />\n      </View>\n    )\n  }, [fallbackHeader, style])\n  return (\n    <ErrorBoundary fallbackRender={fallbackRender} onError={handleError}>\n      {children}\n    </ErrorBoundary>\n  )\n}\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n})\n```\n\n위 코드에서 ErrorContent 컴포넌트의 공통 UI는 화이트 스크린 에러는 재시도를 하더라도 해결되지 않기 때문에 `잠시 후 다시 시도해주세요`와 같은 안내 문구만 노출하게 구성했다.\n\n바로 에러 상황을 해결해줄 수 없지만 에러 상황을 빠르게 제보받고 대처하기 위해 에러 리포팅 유틸을 onError 콜백함수로 연결해 `슬랙`채널을 통해 빠르게 제보받을 수 있게 했다.\n\n이렇게 구현한 에러바운더리를 스크린에 적용할 때는 헤더에 단순 navigation 로직이 담긴 경우, 헤더를 함께 최상위로 분리했고, 헤더에 회원가입 스텝이 변경되거나, 검색 text input이 있는 등 추가적인 로직이 담겨있는 경우에는 fallbackHeader를 적용해 별도로 적용할 수 있게 했다.\n\n```tsx\n// 공통 헤더를 사용하는 경우\nfunction AScreen() {\n  return (\n    <Layout>\n      <Header />\n      <RuntimeErrorBoundary screen={\"AScreen\"}>\n        <AScreenContainer />\n      </RuntimeErrorBoundary>\n    </Layout>\n  )\n}\n\nfunction AScreenContainer() {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    fetchData().then(data => setData(data))\n  }, [])\n\n  if (!data) {\n    return <Loading />\n  }\n\n  return <AScreenContent data={data} />\n}\n\n// 공통 헤더를 사용할 수 없는 경우\nfunction BScreen() {\n  return (\n    <Layout>\n      <RuntimeErrorBoundary\n        screen={\"BScreen\"}\n        fallbackHeader={<Header />}\n        style={{ backgroundColor: \"black\" }}\n      >\n        <BScreenContainer />\n      </RuntimeErrorBoundary>\n    </Layout>\n  )\n}\n\nfunction BScreenContainer() {\n  const [data, setData] = useState(null)\n  useEffect(() => {\n    fetchData().then(data => setData(data))\n  }, [])\n\n  return (\n    <>\n      <BHeader />\n      {data ? <BScreenContent data={data} /> : <Loading />}\n    </>\n  )\n}\n```\n\n최대한 공통 헤더를 이용하려 했지만, 제품의 복잡도가 놀라갈 수록, 헤더의 로직이 복잡해져서 fallbackHeader를 사용하는 경우가 더 많아졌다.\n\n적용하면서 부수 효과로 비동기 처리에 따른 로딩/에러/성공 UI들을 간단하게 정리하기도 했다. 이에 더 나아가 Suspense와 useErrorBoundary 훅을 이용해 선언적으로 비동기 분기문들을 처리하는 작업들도 함께 진행하고 싶었지만, 작업 목표가 전체 제품에 적용하는 것이기 때문에, 우선적으로 에러바운더리 적용에 집중했다.\n\n적용한 후에 실제로, 제품 내 화이트스크린 에러가 발생했을 때, 에러바운더리 덕분에 정확한 스크린 단위로 제보를 받아 빠르게 대응할 수 있었고, 해당 이슈를 재현해보면 화이트 스크린을 보지 않고 해당 화면을 벗어날 수 있게 해 유저 편의성을 개선할 수 있었다.\n\n## 🙌 변화하는 제품 따라가기\n\n24년 1분기에 작업을 시작하면서 작년 4분기에 에러 로그 분류작업을 정리했던 화면 데이터를 토대로 진행했다. 당연하게도 시간이 흐르면서 기능 개발 방향에 따라 새롭게 화면이 생기고, 필요없어진 화면은 제거되었다.\n\n1분기 때 작업을 완료하는 시점에는 작년 4분기 데이터 바탕으로 전체 262개의 화면중 63개 화면 (24%)를 남겨두고 마무리되었다. 당시 나는 “다음 분기에 63개만 마저하면 되겠지”라고 생각했지만 2분기 작업 시작전에 다시 조사해보니 전체 화면은 262개에서 246개 화면으로 줄었고, 적용되지 않은 화면이 **63개에서 108개 화면으로** 늘어난 것을 알게 되었다.\n\n1분기 작업 시작 기준이 작년 4분기 때 조사한 화면 기준이다보니 시간이 6개월 정도 시간이 지나면서 이러한 차이가 발생했지만, 앞으로도 제품의 방향에 따라 새로운 도메인, 새로운 화면들이 계속해서 추가되고, 또 필요없어진 화면들은 제거됨에 따라 적용되지 않은 부분들이 늘어나게 될 것이 예상되는 상황이었다.\n\n이러한 문제를 해결하기 위해서 두가지 방법을 생각하고 적용해보았다.\n\n### 1. 적용된 화면과 적용되지 않은 화면을 알기 위한 자동화 스크립트\n\n작업을 마무리하면서 적용된 화면과 적용되지 않은 화면을 알기 위해 `자동화 스크립트`를 작성했다. 이 스크립트는 제품 내 모든 화면을 조사하고, 적용된 화면과 적용되지 않은 화면을 구분해주는 스크립트로 작업을 하면서 세웠던 규칙을 토대로 작성했다.\n\n전체 화면의 기준은 [React Navigation](https://reactnavigation.org/)을 사용하면서 적용할 때의 규칙인 ScreenKey(key)와 Screen 컴포넌트(value) 구조를 이용해, 전체 ScreenKey를 기준점으로 이용했고, 각 화면들은 1) 적용된 화면, 2) 중복된 화면, 3) 보류 화면, 4) 불필요한 화면으로 분류했다.\n\n- 중복된 화면 (DuplicatedScreenKeys) : 같은 Screen에 modal/card 형식에 따라 두가지의 ScreenKey를 가지는 화면\n- 보류 화면 (DelayedScreenKeys) : 제거가 예정되어 있거나, 사용 파악이 어려웠던 화면\n- 불필요한 화면 (NotRequiredScreenKeys) : 개발 환경을 위한 화면이거나, 에러바운더리를 적용해도 큰 효용이 없어보이는 화면\n\n각 분류에 대한 예를 들어 중복된 화면의 경우,프로필 상세화면의 경우 모달형식이냐 카드형식이냐에 따라 ProfileDetail과 ProfileDetailModal ScreenKey가 같이 사용되기 때문에 하나를 제외했다.\n\n보류화면은 스쿼드 작업으로 인해 실험결과에 따라 제거 예정인 화면이거나, 특정 이벤트 화면의 경우 현재 사용되지 않지만 코드로만 남아있는 경우 보류화면으로 분류했다.\n\n불필요한 화면은 개발 환경을 위한 화면이거나, Start 화면과 같이 에러가 발생했을 때 해당 화면을 벗어날 수 없고, 최상위 에러바운더리가 있기 때문에 불필요한 화면으로 분류했다.\n\n이렇게 분류한 기준을 적용한 스크립트 코드는 아래와 같다.\n\n```ts\n// src/screens/index.tsx 내부 스크린 설정\ntype RootStackParamList = {\n  Start: undefined\n  Home: undefined\n  Login: undefined\n  Signup: undefined\n  Profile: { userId: string }\n  ProfileModal: { userId: string }\n  Feed: { feedId: string; userId: string }\n  FeedModal: { feedId: string; userId: string }\n  InviteEvent: { eventId: string }\n  NotFound: undefined\n  OldRequest: { requestId: string }\n}\n\nenum ScreenKeyEnum {\n  Start = \"Start\",\n  Home = \"Home\",\n  Login = \"Login\",\n  Signup = \"Signup\",\n  Profile = \"Profile\",\n  ProfileModal = \"ProfileModal\",\n  Feed = \"Feed\",\n  FeedModal = \"FeedModal\",\n  InviteEvent = \"InviteEvent\",\n  NotFound = \"NotFound\",\n  OldRequest = \"OldRequest\",\n}\n\n// tsconfig.json 설정으로 프로젝트 생성\nconst project = new Project({\n  tsConfigFilePath: \"tsconfig.json\",\n})\n\ntype ScreenKey = `${ScreenKeyEnum}`\n\n// 파일 경로\nconst SCREEN_KEY_ENUM_PATH = \"src/screens/index.tsx\"\nconst SCREENS_DIR = \"src/screens\"\n\nconst checkIsScreenKey = (screenKey: string): screenKey is ScreenKey => {\n  const screenKeyEnumValues: ScreenKey[] = Object.values(ScreenKeyEnum)\n  return screenKeyEnumValues.includes(screenKey as ScreenKey)\n}\n\nconst filterScreenKeys = (keys: string[]): ScreenKey[] => {\n  return keys.filter(checkIsScreenKey)\n}\n\n// RuntimeErrorBoundary 컴포넌트를 사용하는 파일을 찾기 위한 함수\nconst findFilesUsingRuntimeErrorBoundary = (dirPath: string): ScreenKey[] => {\n  const screenKeys: string[] = []\n  const items = fs.readdirSync(dirPath, { withFileTypes: true })\n\n  items.forEach(item => {\n    const itemPath = path.join(dirPath, item.name)\n    if (item.isDirectory()) {\n      screenKeys.push(...findFilesUsingRuntimeErrorBoundary(itemPath))\n    } else if (item.isFile() && item.name.endsWith(\".tsx\")) {\n      const sourceFile = project.addSourceFileAtPath(itemPath)\n      const fileText = sourceFile.getText()\n      if (fileText.includes(\"<RuntimeErrorBoundary\")) {\n        // 정규식을 사용하여 스크린 내부 RuntimeErrorBoundary 컴포넌트의 screen prop의 ScreenKeyEnum 값을 추출\n        const regex =\n          /<RuntimeErrorBoundary[^>]*screen\\s*=\\s*\\{(ScreenKeyEnum\\.\\w+)\\}/\n        const match = regex.exec(fileText)\n        if (match != null) {\n          const screenValue = match[1]\n          const screenKeyRegex = /ScreenKeyEnum\\.(\\w+)/\n          const screenKeyMatch = screenKeyRegex.exec(screenValue)\n          if (screenKeyMatch != null) {\n            screenKeys.push(screenKeyMatch[1])\n          }\n        }\n      }\n    }\n  })\n\n  return filterScreenKeys(screenKeys)\n}\n\n// ScreenKeyEnum enum의 key 값을 가져오는 함수\nconst getScreenKeyEnumKeys = (): ScreenKey[] => {\n  const sourceFile = project.addSourceFileAtPath(SCREEN_KEY_ENUM_PATH)\n  const keys: string[] = []\n\n  sourceFile.forEachDescendant(node => {\n    if (node.getKind() === SyntaxKind.EnumDeclaration) {\n      if (node.getText().includes(\"ScreenKeyEnum\")) {\n        node.getChildrenOfKind(SyntaxKind.EnumMember).forEach(member => {\n          keys.push(member.getName())\n        })\n      }\n    }\n  })\n\n  return filterScreenKeys(keys)\n}\n\nconst main = () => {\n  const screenKeys = getScreenKeyEnumKeys()\n  const screenKeysInScreenDir = findFilesUsingRuntimeErrorBoundary(SCREENS_DIR)\n  const DuplicatedScreenKeys: ScreenKey[] = [\n    ScreenKeyEnum.ProfileDetailModal, // ProfileDetail와 중복\n    ScreenKeyEnum.FeedModal, // Feed와 중복\n  ]\n  const DelayedScreenKeys: ScreenKey[] = [\n    ScreenKeyEnum.OldRequest,\n    ScreenKeyEnum.ModalRequestReview,\n  ]\n  const NotRequiredScreenKeys: ScreenKey[] = [\n    ScreenKeyEnum.Start,\n    ScreenKeyEnum.NotFound,\n  ]\n\n  const DoneArr = new Set([\n    ...screenKeysInScreenDir,\n    ...screenKeysInComponentDir,\n  ])\n\n  const AlreadyCheckedArr = new Set([\n    ...NotRequiredScreenKeys,\n    ...DuplicatedScreenKeys,\n    ...DelayedScreenKeys,\n  ])\n\n  const requiredScreenArr = screenKeys.filter(\n    screenKey => !AlreadyCheckedArr.has(screenKey)\n  )\n  const missingArr = requiredScreenArr.filter(\n    screenKey => !DoneArr.has(screenKey)\n  )\n\n  // 결과 출력\n  console.debug(\"--------------------------------\")\n  console.debug(\"전체:\", screenKeys.length)\n  console.debug(\"불필요:\", NotRequiredScreenKeys.length)\n  console.debug(\"중복:\", DuplicatedScreenKeys.length)\n  console.debug(\"보류:\", DelayedScreenKeys.length)\n  console.debug(\"필요:\", requiredScreenArr.length)\n  console.debug(\"계산결과:\", DoneArr.size)\n  console.debug(\"누락된 스크린:\", missingArr)\n  console.debug(\"--------------------------------\")\n}\n\nmain()\n```\n\n이제 해당 script를 package.json의 script로 등록해두면, `npm run check-screen` 명령어로 전체 화면을 조사하고, 적용된 화면과 적용되지 않은 화면을 알 수 있게 된다.\n\n<img src=\"script_result.png\" width=\"300\" alt=\"스크립트 실행 결과\">\n\n현재 script에 개선할 부분이 많이 있지만 우선 적용되지 않은 화면을 알 수 있게 되어, 이후 작업을 진행할 때 더욱 효율적으로 작업할 수 있게 되었다.\n\n이후 github action으로 연결해 CI 과정과 연결해 master에 병합될 때마다 주기적으로 체크하는 작업도 진행할 수 있을 것 같다는 생각이 들었다.\n\n### 2. 스크린 파일 생성 script에 에러바운더리 적용하기\n\n챕터 동료분께서 주신 아이디어로 나는 몰랐지만 챕터내 많은 분들이 스크린 생성 스크립트를 이용해서 새로운 화면을 생성한다는 것을 알게 되었다.\n새로운 화면을 만들기 위해서는 RootStack.Navigator안에 RootStack.Screen 컴포넌트를 추가하고 해당 컴포넌트에 대한 ScreenKey를 추가해야 한다.\n\n이를 자동으로 추가해주는 script가 기존에 존재해 여기에 에러바운더리를 추가해보기로 했다. 직접 추가하는 경우에는 당연히 에러바운더리 코드를 작성해야 적용되겠지만 스크린 생성 script를 이용할 떄는 별다른 고민없이 적용될 수 있을 것 같다는 생각이 들었다.\n기본 형식은 아래처럼 정하게 되었다.\n\n```tsx\nimport React from 'react';\nimport Screen from '@component/Screen';\nimport { Text, View } from 'react-native';\nimport { ScreenKeyEnum } from '@screen/index';\nimport ScreenHeader from '@component/ScreenHeader';\nimport { RuntimeErrorBoundary } from '@component/RuntimeErrorBoundary';\nimport Screen from '@component/Screen';\n\n\nexport function FooScreen() {\n    return (\n        <Layout>\n            <ScreenHeader title={''} />\n            <RuntimeErrorBoundary screen={ScreenKeyEnum.Foo}>\n                <${screenName}Content />\n            </RuntimeErrorBoundary>\n        </Layout>\n    );\n}\n\nfunction FooContent() {\n    return (\n        <View>\n            <Text>bcg</Text>\n        </View>\n    );\n};\n```\n\n역시 혼자 고민하기 보다 함께 고민할 때 더 좋은 해결책을 얻을 수 있다는 것을 알게 되었고, 앞으로 새롭게 스크린들이 추가될 때 편하게 적용할 방법에 대한 고민을 해결할 수 있었다.\n\n## 📚 마치며\n\n하나의 기술을 알게 되고 적용하는 것은 쉽지 않은 일이다. 단순히 하나의 컴포넌트를 만들고 기존 컴포넌트에 적용하는 작업이라 생각했지만 이과정에서 많은 고민과 시행착오가 있었다.\n어떻게 하면 최대한 기존 코드 컨벤션을 깨뜨리지 않으면서 적용해 동료분들의 학습 곡선을 최소화할 수 있을지, 어떻게 하면 더 효율적으로 작업을 진행할 수 있을지 고민하고, 이를 해결하기 위해 다양한 방법을 시도해보았다.\n\n횡단 관심사인 에러바운더리를 적용하면서 제품내 모든 화면들을 조사하게 되었고, 부수적으로 제품 전체에 대한 이해도가 높아질 수 있었고, 5개월간 하나의 주제의 일감을 혼자 처음부터 끝까지 진행하면서, 일을 지치지 않고 진행하기 위해서는 적절한 단위로 끊어서 진행하는 일하는 방식에 대해서도 배울 수 있었다.\n\n또 좋은 제품을 만들기 위해서는 혼자서 일하는 게 아니라 동료와 함께 고민하고, 함께 공유하며, 함께 성장해야 한다는 것을 다시금 깨달았다. 이번 작업을 통해 앞으로도 함께 성장하며 좋은 제품을 만들어 나가고 싶다.\n"},{"excerpt":"5월은 미리 보는 주 4일제처럼 휴일이 많았고 개인적인 일정이 많았던 달이었다. 업무는 4월부터 담당했던 작업들을 마무리하고 성과분석 및 발표를 진행하기도 했다.\n어떤 작업들을 했는지, 4월 회고 때 하기로 마음먹었지만 어떤 건 놓쳤는지 확인해보려 한다. 🤔 4월 회고 돌아보기 4월 회고때 정리한 action item들을 정리해보면 아래와 같다. 화면전환…","fields":{"slug":"/2024-06-01-2024년-5월회고/"},"frontmatter":{"date":"June 01, 2024","title":"🙌 2024년 5월회고","tags":["회고"]},"rawMarkdownBody":"\n5월은 미리 보는 주 4일제처럼 휴일이 많았고 개인적인 일정이 많았던 달이었다. 업무는 4월부터 담당했던 작업들을 마무리하고 성과분석 및 발표를 진행하기도 했다.\n어떤 작업들을 했는지, 4월 회고 때 하기로 마음먹었지만 어떤 건 놓쳤는지 확인해보려 한다.\n\n## 🤔 4월 회고 돌아보기\n\n4월 회고때 정리한 action item들을 정리해보면 아래와 같다.\n\n- 화면전환 간 성능 개선을 위해 Native Stack 도입 및 성능 분석방법 찾아보기\n- 에러 바운더리를 조금 더 챕터원들이 쉽게 적용하는 방법 고민해보기\n- 컴포넌트 설계에 관해 공부하고 정리해보기\n- UI 패턴별 최적화 정리해보기\n- React 내부 코드 분석해보기\n- 선언적으로 인증/인가 관리하기\n\n이중에서 실제로 진행하면서 발생했던 시행착오들과, 하지 못했던 것들을 정리해보려 한다.\n\n### 1. 화면전환 간 성능 개선을 위해 Native Stack 도입 및 성능 분석방법 찾아보기\n\n5월은 실제로 기존 StackNavigator에서 NativeStackNavigator로 변경하는 작업을 진행했다. 기존에 stackNavigator는 JS를 통해 만들어지는 반면 NativeStackNavigator는 직접 Native 요소들을 사용하게 구현되어 있기 떄문에\n기존과 다른 인터페이스들을 갖게 되었다. 달라진 인터페이스와 함께 플랫폼별로 다르게 구현되는 부분들 때문에 최대한 기존과 유사한 유저 경험을 줄 수 있게 일일이 확인하고 적용했다.\n\n이과정에서 다양한 이슈들이 존재했는데 예로, 기존에 card와 modal 간의 이동이 자유로워 card -> m해dal -> card로 화면 전환이 자유로웠던 반면, Native 요소를 이용하면서 Modal이 Navigation의 마지막으로 노출되어야 한다는 규칙에 따라, Modal 뒤에 쌓여 보이지 않는 이슈가 있었다.\n두번째로 화면전환 애니메이션 자체가 달라지거나, 애니메이션 속도가 줄어드는 등 다양한 이슈를 확인하고 대처하는 작업을 진행했다.\n\n이슈들을 해결하고 나서 성과 분석을 위해 적용 전 제품 내 핵심 퍼널들의 화면 전환들을 비교하보기 위해 영상촬영을 진행하고, 이후 반영된 버전으로 다시 촬영하여 비교해보는 작업을 진행했다.\n추가로 안드로이드만 현재 지원되지만 maestro(e2e 테스트)를 이용한 [FlashLight](https://github.com/bamlab/flashlight) 성능 측정을 통해 화면전환간 성능을 측정했다.\n앞서 촬영했던 메인퍼널들에 대한 e2e script를 작성하고 30회 정도 반복 측정을 통해 화면전환간 성능을 측정했다.\n\n해당 결과는 아직 분석에 시간이 필요해 6월 동안 분석하고 결과를 공유할 예정이다. 6월에는 적용과정에서의 troubleShooting과 성능측정 결과에 대한 글을 작성해보려 한다.\n\n### 2. 에러 바운더리를 조금 더 챕터원들이 쉽게 적용하는 방법 고민해보기\n\n에러 바운더리 작업을 제품 내 전체 화면들에 대한 적용을 드디어 완료했다. 지난 회고 때 고민했던 새로운 화면들이 추가되었을 때 어떻게 적용할 수 있을지 고민했던 부분을 위한 작업들도 추가로 진행했다.\n\n먼저 현재 적용된 화면들과 적용되지 않은 화면들을 알 수 있게 ts-morph를 이용한 script 코드를 작성해 지속해서 에러바운더리가 적용되지 않은 화면들에 대해 체크할 수 있게 했다.\n\n두 번째로는 동료분께서 주신 아이디어로, 기존 스크린 파일 생성 시 사용하는 템플릿 생성 scrip 코드에 에러바운더리를 적용하는 코드를 추가해, 새로운 화면을 생성할 때 자동으로 에러바운더리가 적용되도록 하는 작업을 진행했다.\n제안 받은 당시에 늘 직접 파일을 생성하고 Navigator에 일일이 추가했었기 때문에 템플릿 생성 script에 추가할 생각을 못했는데, 함께 고민해주신 덕분에 쉽게 적용할 수 있었다.\n\n이렇게 현재를 기준으로 한 적용 작업 뿐 아니라, 이후 새롭게 추가될 화면들을 위한 작업들도 진행해 조금 더 완성도 있게 마무리할 수 있었다.\n첫 번째 적용되지 않은 화면들을 찾아낼 수 있게 하는 script는 이후 github action을 이용한 CI에 연동해 주기적으로 체크할 수 있게 발전시켜볼 예정이다.\n\n6월에는 작업 배경, 작업 방식, 결과에 대해 글을 작성해보려 한다.\n\n### 3. 컴포넌트 설계에 관해 공부하고 정리해보기\n\n4월에 컴포넌트 설계에 관한 공부가 필요하다 느꼈던 이유는, 스쿼드 기능개발 작업을 진행하면서 여러 도메인에서 공통으로 사용하는 컴포넌트를 다루게 되었기 때문이었다.\n\n당시 해당 컴포넌트는 1200줄이 넘는 많은 코드들이 하나의 컴포넌트에 담겨있어 한눈에 이해하기가 어려웠고, 자체적으로 API 요청하고 있기 때문에 해당 컴포넌트 밖에서 해당 데이터가 필요할 때 중복 API를 호출해서 사용해야 하는 등의 이슈를 가지고 있었다.\n\n이러한 이슈들을 해결하기 위해서 서로 다른 도메인과 화면에서 공통으로 사용될 때,제품의 요구사항이 달라졌을 때 유연하면서 확장성 있는 컴포넌트를 만들기 위해 컴포넌트 설계를 공부했고, 이를 적용해보려 했다.\n\n스쿼드 작업의 여유가 있을 때, 또는 퇴근 후에 리액트 컴포넌트 설계에 대한 강의와 글을 읽으면서 직접 적용하면서 작업을 진행했다. 공부하면서 다양한 컴포넌트 설계 패턴이 있다는 것을 배울 수 있었고 그중에서 [**compound Pattern**](https://kentcdodds.com/blog/compound-components-with-react-hooks)을 이용한 headless UI를 적용해보았다.\n\n아직 개선할 부분이 많이 남아있지만 1차적으로 작업을 완료했을 때 컴포넌트 내부 코드가 300줄 이내로 줄어들게 되었고, 보다 유연하게 요구사항들을 반영할 수 있게 수정될 수 있었다.\n이부분도 이후에 조금 더 개선 작업을 추가한 뒤에 글로 작성해보려 한다.\n\n### 하지 못한 UI 패턴별 최적화 정리하기, React 내부 코드 분석하기와 선언적으로 인증/인가 관리하기\n\nUI 패턴별 최적화 정리하기와, React 내부 코드 분석하기, 선언적으로 인증/인가 관리하기는 5월에 진행하지 못했다. 스쿼드 업무를 진행하면서 조금씩 정리해보려 했지만 컴포넌트 설계를 공부하고 접목하고 싶은 마음에 해당 일감에 집중하고 우선 미루기로 했다.\n대신 컴포넌트 설계 과정에서 JSX가 실제로 createElement로 컴파일되어 사용된다는 점 등을 배울 수도 있었다.\n\n5월에는 우선순위에서 밀렸지만, 진행중이던 일감들을 마치는 대로 6월의 action item들로 실행해보려 한다.\n\n## 🚀 5월에 고민을 시작한 일감 및 공부\n\n5월은 4월에 고민했던 일감들을 진행하면서 해당 일감들로부터 파생된 일감들을 더 진행하다보니 새로운 주제들을 많이 생각하지 못했다.\n대신 6월이 되면서 다음 분기에 진행하면 좋을 일감들을 현재 챕터 내에서 작성하고 있다. 6월에 진행하지는 않겠지만 7월부터 담당해서 진행하고 싶은 일감들을 아래에 정리해보려 한다.\n\n### 주기적 성능 측정을 위한 CI 구축\n\n화면전환 간 성능 개선 작업을 하면서 FlashLight와 maestro를 함께 이용하면서 e2e 테스트를 통해 주요퍼널들에 대한 성능을 측정했다. 이를 CI에 연동해 주기적으로 성능을 측정하고 결과를 버전별로 관리할 수 있다면, 조금 더 의미있게 비교해볼 수 있지 않을까 생각이 들었다.\n물론 e2e 테스트 코드들을 작성해야하는 점, 현재 FlashLight는 android 기기만을 기준으로 측정하는 점 등의 이슈들이 있지만, 기준이 되는 기기에 대해 주기적으로 앱의 성능을 측정한다면 개선할 부분들을 파악하거나, 문제점들을 조금 더 빠르게 파악해\n제품의 안정성에 기여할 수 있겠다는 생각이 들었다.\n\n### 선언적으로 인증/인가 관리하기\n\n4월 회고 때 작성했던 부분이지만, 현재 제품 내에서 고객/고수의 경우에만 사용 가능한 화면에서 일일이 인증/인가를 체크하는 부분이 많이 존재한다. 이를 선언적으로 관리하는 방법을 찾아보고 적용해보고 싶다.\n예로 react navigation의 가이드로 [Authentication flow](https://reactnavigation.org/docs/auth-flow)를 도입하는 방법 등을 적용해 보고 싶다.\n\n### AsyncStorage 대체하기\n\n현재 제품 내에서 AsyncStorage를 이용해 데이터를 저장하고 있는데, AsyncStorage는 비동기로 동작하기 때문에 데이터를 조회/삭제/변경에 느린 성능이 가지고 있다. 이에 대한 대체재로 [MMKV](https://github.com/mrousavy/react-native-mmkv)를 도입해 보고 싶다.\n\n여기서 어떤 작업들을 담당해서 진행할 수 있을지 모르지만, 3분기에도 계속해서 제품에 다양한 기여해나가는 일들을 진행해보고 싶다.\n\n### 마치며\n\n5월은 4월에 이은 작업들이 많았고, 하겠다 선언한 action item들을 많이 진행하지 못했던 것 같다. 하고 싶은 건 많지만, 하나의 일을 제안, 실행, 마무리하는데 까지 시간이 많이 소요되었다.\n6월에는 5월에 하지 못한 일들을 더 집중해서 진행하고, 7월부터는 3분기에 진행할 일들을 미리 정리해서 더욱 더 성장할 수 있도록 노력해보려 한다.\n"},{"excerpt":"4월은 바빴지만, 내안에 \"어떤게 맞는걸까, 내가 잘하고 있는걸까\" 하는 고민이 많았던 한 달이었다.\n3월 달의 하기로 했던 것들 중 얼마나 했는지에 대해 정리해보고 4월에는 어떤 것들을 했는지 또 어떻게 하면 더 나은 개발자가 될 수 있을지 정리해보려 한다. 💪 3월 회고 돌아보기 3월 회고때 마음먹었던 것들은 아래와 같이 정리할 수 있다. App St…","fields":{"slug":"/2024-05-01-2024년-4월회고/"},"frontmatter":{"date":"May 01, 2024","title":"🙌 2024년 4월회고","tags":["회고"]},"rawMarkdownBody":"\n4월은 바빴지만, 내안에 \"어떤게 맞는걸까, 내가 잘하고 있는걸까\" 하는 고민이 많았던 한 달이었다.\n3월 달의 하기로 했던 것들 중 얼마나 했는지에 대해 정리해보고 4월에는 어떤 것들을 했는지 또 어떻게 하면 더 나은 개발자가 될 수 있을지 정리해보려 한다.\n\n## 💪 3월 회고 돌아보기\n\n[3월 회고](https://choi2021.github.io/2024-04-07-2024%EB%85%84-3%EC%9B%94%ED%9A%8C%EA%B3%A0/)때 마음먹었던 것들은 아래와 같이 정리할 수 있다.\n\n- App Startup Time 줄이기 때 하지 못한 일감 후속 작업 진행하기\n- 에러바운더리 적용하고 과정에 대한 글쓰기\n- 스쿼드 내 소통할 때 적극적으로 소통하기, 기술 용어 대신 이해하기 쉬운 용어로 표현하기\n- 컴포넌트 설계에 대한 공부하기\n- UI 패턴별 최적화하는 방법에 대해 정리하기\n\n위 다섯가지에 대해 4월 한달동안 어떘는지 개인적으로 생각해보려 한다.\n\n### 1. App Startup Time 줄이기 후속 작업\n\n[App Startup Time 개선 작업](https://choi2021.github.io/2024-03-30-App-StartUp-time-%EA%B0%9C%EC%84%A0/)을 잘 마무리하고 당시 미뤄뒀던 후속작업들을 진행하겠다고 3월에 다짐했었다.\n\n다행히 다음 챕터 업무로 **화면 전환간 성능을 개선**을 담당하게 되었다. 그 방법으로 `Native Stack`을 적용하는 작업을 메인으로 진행하고 있다.\n우리 제품은 React Navigation을 이용해 라우팅, 화면전환을 구현하고 있는데, 성능 측정을 위한 자체 Custom Stack Navigation을 만들어서 적용하고 있다.\n\n이를 제거하고 React Navigation의 `Native Stack`을 적용하면서 JS 스레드를 이용한 화면전환이 아니라 Native 스레드를 이용해 화면 전환간 성능을 개선할 수 있을 것이라고 생각했다.\n이뿐 아니라 기존 화면 전환간 문제가 될 수 있을 만한 부분들을 찾아보고 아이디어를 떠올리고 있다.\n\n조금 아쉬운건 화면전환 작업은 순간적으로 일어나는 부분이기 때문에 측정에 어려움이 있고, 동일 기기에서 직접 영상으로 비교해보려 하는데, 그것 또한 큰 의미가 있는 것인지 의미를 찾기 어려워 보인다.\n\n만약 조금 더 측정을 해보려한다면 네트워크 의존이 적은 화면에 대한 E2E 테스트 코드를 작성하거나, 앱을 사용하는 흐름에서 화면전환되는 순간의 CPU, 메모리, FPS가 떨어지는 정도를 비교해보는 방법이 좋아 보여 우선 측정 방법을 계속해서 고민해보고 있다.\n\n### 2. 에러바운더리 제안 및 적용하는 과정에 대한 글쓰기\n\n3월에 이어 4월도 에러바운더리를 적용하는 작업을 진행하게 되었다. 3월까지는 작년 4분기 작업 전에 조사했던 화면들에 대한 기준으로 작업을 진행했고, 그사이에 새롭게 추가되고 수정된 화면들에 대한 반영이 되어 있지 않았기 때문에 4월에 작업을 시작하면서는 현재의 기준으로 조사가 먼저 필요했다.\n\nChatGPT 덕분에 기존 정리해둔 데이터에 새롭게 추가된 데이터를 합친 새로운 테이블을 만들 수 있는 Script를 작성해, 현재 기준 제품 내에는 총 256개 화면이 존재하고 그중 **108개** 화면(42%)에 대한 작업이 필요하다는 것을 알 수 있었다.\n\n분명 3월에 정리했을 때는 작년 4분기 조사한 화면들 기준으로 262개중 **84개**(33%)의 화면이 남아있었는데 다시 정리하니 달라진 것이다. 이렇게 정리하고 나니 단순히 열심히만 해서는 영원히 끝나지 않을 작업이라는 생각이 들었다.\n구멍난 독에 물붓기처럼 구멍을 손으로 막으면서 물을 부었을 때 어느정도 차긴 하겠지만, 새로운 화면들은 생기고, 필요없는 화면들은 제거되게 되면서 끝이 없는 작업이라는 것을 느꼈다.\n\n이를 해결하기 위해서는 단순히 새롭게 추가하는 게 다가 아니라 챕터내 공유를 통해 다시 한 번 왜 필요한지, 어떤 효과가 있는지 공유해, 다같이 노력해야 해결할 수 있는 방법이란 생각이 들었다.\n\n그리고 이렇게 챕터 구성원들이 함께 노력해주시기를 요청하는 동시에 조금 더 쉽게 적용할 수 있는 방법은 없을지 고민이 필요해 보였다. 최상위 컴포넌트인 Screen 컴포넌트 내부로 옮겨서 적용할지 등 기존 작업을 돌아보면서 최대한 쉬운 방법을 고민해보려 한다.\n\n이러한 시행착오들을 잘 정리해서 6월정도에는 글을 써보려한다.\n\n### 3. 스쿼드 내 소통 방식에 대한 노력\n\n3월부터 합류한 스쿼드 내에서 다양한 작업을 진행하게 되었다. 신사업 담당 스쿼드이다 보니 다른 회사와의 협업을 하거나 빠르게 테스트하거나 중간에 다른 일들이 많이 들어오는 상황에서 의사소통이 좀 더 중요하게 느껴졌다.\n\n이번달 주요 작업중 하나였던 쿠팡 광고 연결작업을 진행하면서 쿠팡 광고 상품 클릭시 앱이 설치되면 쿠팡 앱으로 진입 후 광고상품에 랜딩하게 되고, 앱이 설치되어 있지 않으면 모바일 웹을 통해 광고상품에 랜딩시키는 작업을 진행했다.\n\n이때 iOS, Android에 따라 쿠팡 광고에 랜딩할 때 기존 기획과 다른 부분들이 있었고, 이런 기획과 다른 부분들을 정리해서 스쿼드에 공유하는 등, 실제 구현과정에서 예상과 다를 수 있는 부분들을 적극적으로 공유하려 노력했다.\n\n또한 유저 데이터를 측정하기 위한 트래커의 경우에도 PO, Data 엔지니어분께서 설계해주셨을 떄 실제 적용할 때 어떤 요소가 있으면 좋을지, 더 좋은 방법은 없을지 적극적으로 소통하기도 했다.\n\n여전히 기술적인 요소에 대해 설명할 때 어려움이 있는 것 같다. 단순히 된다/안된다 두가지로 나눠서 이야기하는 게 아니라 이해할 수 있게 잘 설명하는 방법들을 계속 연습해가야 겠다는 것을 느꼈던 한달이었다.\n\n### 4. 컴포넌트 설계에 대한 공부하기\n\n스쿼드 기능 개발을 하면서 컴포넌트 설계에 대해서 많이 고민하고 작업했다.\n기존과 다른 요구사항이 생겼을 때 어떻게 하면 변화에 유연하게 개발할 수 있을지, 고민하는 과정은 시간이 더 많이 들었지만, 데이터와 UI와 분리한 뒤에 재사용하기 편한 인터페이스로 개선하는 작업을 진행하면서 하나씩 더 사용하기 좋은 컴포넌트에 대한 개념을 잡아가고 있다.\n\n3월 회고 떄 말했던 UI 라이브러리들을 참고해서 조금 더 확장성있게 컴포넌트를 만드는 건 아직 적용하지 못했다. 대신 기능 개발 과정에서 병목이 되었던 컴포넌트 하나를 정해서 리팩토링 작업을 계획하고 컴포넌트 설계와 관련된 강의들을 참고해 적용해보려한다.\n이과정을 정리해서 주간 미팅 시간에 팀원들과 함께 공유해도 좋을 것 같다.\n\n### 5. UI 패턴별 최적화하는 방법에 대해 정리하기\n\nUI 패턴별 최적화하는 방법에 대해 정리하기는 아직 시작하지는 못했다. 대신 4월 한달간 가장 많이 본 패턴을 정리해보면 목록 -> 상세로 연결되는 화면들로 이루어진 **상점 패턴**이었다.\n\nReact Native에는 ScrollView, FlatList, SectionList 등 다양한 리스트 컴포넌트들이 있고, 컴포넌트 자체 Prop이 지원하는 요소들을 공식문서를 기반으로 구현하려 노력했다.\n\n예를 들어 목록의 특정 요소가 노출되었는지를 감지하는 방법인 FlatList의 `onViewableItemsChanged`를 이용하는 방법을 정리해 [간단한 글](https://choi2021.github.io/2024-04-21-onViewableItemsChanged-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EA%B8%B0/)을 작성했고,\n우리 제품내에서도 처음 사용하게 된 prop이라 공유하면 좋을 것 같아 주간 미팅에서 발표를 하기도 했다.\n\n아직 부족해 한번에 UI 패턴 별 최적화 방법을 정리하지 못했지만 하나하나 계속해서 정리해나가려 한다.\n\n## 🚀 4월에 고민을 시작한 일감 및 공부\n\n4월과 다르게 새롭게 고민을 시작한 일감들에 대해 정리하면서 5월에는 어떤 일을 진행할 지 계획해보려 한다.\n\n### 선언적으로 로그인 필요화면 다루기\n\n기능 개발을 하면서 로그인이 되어있는 유저만 진입가능한 화면들에 대한 작업하게 된다. 그경우 로그인을 했는지 안했는지를 스크린 내부에서 계속해서 고민하면서 개발해야하다 보니 분기문이 늘어나는 것을 느끼게 되었다.\n만약 스크린 상위에서 HOC로 로그인이 되었는지 확인한 후에 하위에서는 무조건 로그인 되어있는 경우로 생각해서 작업할 수 있다면 조금 더 관심사를 잘 분리할 수 있지 않을까 생각이 들었다.\n\nReact의 Protected Route처럼 RN에서 구현할 수 있는 방법을 고민해보려 한다.\n\n### 진입점에 대한 분기문 덜어내기\n\n에러바운더리 작업을 진행하면서 해당 화면에 진입한 진입점에 따라 다른 결과를 실행시키는 코드를 간혹보게 되었다.\n예를 들어 공통 휴대폰 인증화면이 있다고 하면 고객 홈에서 들어왔을 경우에는 인증 실패시 고객홈으로 돌아간다면, 커뮤니티에서 진입한 경우에는 토스트를 띄워줄 수 있다.\n\n이렇게 진입점마다 달라지는 코드가 해당 화면에 존재하게 되었을 때 두가지 문제점이 있다고 생각이 들었다.\n\n먼저 해당 진입점의 변화가 생겼을 때 대처가 어렵다. 만약 진입점의 이름이 바뀌거나 해당 화면이 제거되었을 때에도 분기문이 진입점 이름에 따라만 정의되고 있어서 해당 케이스가 제거/변경에 누락되는 케이스가 발생할 수 있다.\n\n두번쨰로는 진입점에 따라 해당 화면 내부 코드가 분기문으로 인해 복잡해진다. 만약 앞선 예제처럼 인증 실패시에 대한 부분에 대한 정의가 필요하다면 해당 실패를 위한 callback을 전달하는 게 더 좋은 코드이지 않을까 생각이 들었다.\n\n이부분도 정리해서 주간 미팅에 공유해보려 한다.\n\n### React 분석해보기\n\n개인적으로 공부하고 있는 부분은 2월부터 계속해서 매일 리액트 공식문서의 한챕터씩 정리해보고 있다. 이제 거의 마무리되어서 다음 단계로 리액트 내부 코드들을 까보면서 각 요소가 직접 어떻게 동작하는지,\n리액트의 특징이 어떻게 구현되어 있는지에 대해 공부해보려 한다.\n\n리액트에 대해 더 잘 이해하게 되는 것도 좋지만, 정말 많은 사람들이 사용하는 라이브러리 코드를 보면서, 어떤 코드가 좋은 코드인지 이해하는 좋은 기회가 될 것 같다.\n\n![리액트 공식문서에 대한 정리](리액트-정리.png)\n\n## 📚 마치며\n\n이번 회고는 3월 회고때 했던 다짐들을 잘 지켰는지, 새로운 고민을 시작한 일감들에 대해서도 함께 정리해보았다.\n말만 하고 실행하지 않는 것을 막기 위해 매달 회고를 이전 달의 다짐과 비교해보는 것도 좋은 방법이라고 생각이 들었다.\n\n매달 쓰고 있지만 이렇게 정리하면서 다시 한번 내가 어떤 개발자가 되고 싶은지, 어떤 부분을 더 공부해야 하는지, 어떤 부분을 더 신경써야 하는지에 대해 다시 한번 생각해보는 시간이 되는 것 같다.\n\n5월은 쉬는 날이 많다. 이것을 기회로 더 많이 개인공부를 많이 늘려서 회사에서 더 많은 것을 공유할 수 있는 개발자로 나아가는 한달이 되길 바라본다.\n"},{"excerpt":"기능 개발을 하면서 목록의 특정 아이템이 50% 노출되었을 때 트래커가 발송시키는 요구사항을 받게 되었다. 이를 구현하는 과정에서 알게된\nFlatList의  prop에 대해 정리해보려 한다. 🤔 onViewableItemsChanged란? onViewableItemsChanged는 RN의 FlatList에 전달할 수 있는 prop으로 FlatList가 스…","fields":{"slug":"/2024-04-21-onViewableItemsChanged-이해해보기/"},"frontmatter":{"date":"April 21, 2024","title":"👀 onViewableItemsChanged 이해해보기","tags":["ReactNative","FlatList"]},"rawMarkdownBody":"\n기능 개발을 하면서 목록의 **특정 아이템이 50% 노출되었을 때** 트래커가 발송시키는 요구사항을 받게 되었다. 이를 구현하는 과정에서 알게된\nFlatList의 `onViewableItemsChanged` prop에 대해 정리해보려 한다.\n\n## 🤔 onViewableItemsChanged란?\n\n[onViewableItemsChanged](https://reactnative.dev/docs/flatlist#onviewableitemschanged)는 RN의 FlatList에 전달할 수 있는 prop으로 FlatList가 스크롤에 의해 보여지는 아이템들(viewableItems)이 변경됨에 따라 호출되는 함수로\n현재 viewableItems는 어떤 것이고, 변경된 items는 어떤 것인지에 대한 정보를 제공한다.\n\n[onViewableItemsChanged의 타입 정의]\n\n```typescript\nonViewableItemsChanged?: ((\n    info: {\n        viewableItems: Array<ViewToken>;\n        changed: Array<ViewToken>\n    }) => void) | null | undefined;\n\ninterface ViewToken {\n    item: any;\n    key: string;\n    index: number | null;\n    isViewable: boolean;\n    section?: any;\n}\n```\n\n이때 자주 함께 사용되는 config로 [`viewabilityConfig`](https://reactnative.dev/docs/flatlist#viewabilityconfig)를 통해 어떤 조건을 만족할 때 viewableItems로 설정할지에 대해 정할 수 있다.\nconfig의 요소는 아래 4가지가 있다.\n\n1. **minimumViewTime**: onViewableItemsChanged를 호출하기 전에 viewableItem으로 간주되기 위한 최소 시간\n2. **viewAreaCoveragePercentThreshold**: viewport에 얼마나 아이템이 차지해야 viewableItem으로 여길지에 대한 최소 노출 비율\n3. **waitForInteraction**: 사용자의 interaction을 기다릴지 여부\n4. **itemVisiblePercentThreshold**: viewport 기준이 아니라 item 기준으로 viewableItem으로 간주되기 위한 최소 노출 비율\n\n위 4가지 속성에 대한 타입은 아래와 같다.\n\n```typescript\nexport interface ViewabilityConfig {\n  minimumViewTime?: number | undefined\n  viewAreaCoveragePercentThreshold?: number | undefined\n  itemVisiblePercentThreshold?: number | undefined\n  waitForInteraction?: boolean | undefined\n}\n```\n\nviewabilityConfig를 전달하면 4가지 속성중에서 `viewAreaCoveragePercentThreshold`나 `itemVisiblePercentThreshold`는 필수값으로 설정되어야 한다. 해당 속성이 설정되지 않으면\n아래와 같은 에러가 발생한다.\n\n![viewabilityConfig에서 필수값을 설정하지 않았을 때 발생하는 에러](viewabilityConfig에러.png)\n\n## 🚀 onViewableItemsChanged 사용하기\n\n그러면 이제 실제 onViewableItemsChanged를 사용하는 예시를 보자.\n\n### 요구사항 1. 처음 3번째 요소가 70% 노출되었을 때 콘솔 찍기\n\n요구사항으로 처음 3번쨰 요소의 70% 노출되었을 때 콘솔이 찍히게 하려한다.\n\n[[예시 코드 실행해보기](https://snack.expo.dev/@buil1/onviewableitemschanged)]\n\n```tsx\nimport React, { useRef } from \"react\"\nimport {\n  SafeAreaView,\n  View,\n  FlatList,\n  StyleSheet,\n  Text,\n  StatusBar,\n} from \"react-native\"\n\nconst data = Array.from({ length: 50 }, (item, index) => ({\n  id: Math.random().toString(12).substring(0),\n  title: `Item ${index + 1}`,\n}))\n\ntype ItemProps = {\n  title: string\n}\n\nconst Item = ({ title }: ItemProps) => (\n  <View style={styles.item}>\n    <Text style={styles.title}>{title}</Text>\n  </View>\n)\n\nconst TARGET_INDEX = 2\n\nconst App = () => {\n  const isShown = useRef(false)\n\n  const handleViewableItemsChanged = ({\n    viewableItems,\n  }: {\n    viewableItems: Array<ViewToken>\n    changed: Array<ViewToken>\n  }) => {\n    if (isShown.current) {\n      return\n    }\n\n    const isTargetInView = viewableItems.some(\n      item => item.index === TARGET_INDEX\n    )\n    console.log(isTargetInView)\n    if (isTargetInView) {\n      console.log(\"타켓 노출\") // Tracker 찍기\n      isShown.current = true\n    }\n  }\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <FlatList\n        initialNumToRender={4}\n        renderItem={({ item }) => <Item title={item.title} />}\n        keyExtractor={item => item.id}\n        data={data}\n        viewabilityConfig={{\n          itemVisiblePercentThreshold: 70,\n          waitForInteraction: true,\n        }}\n        onViewableItemsChanged={handleViewableItemsChanged}\n      />\n    </SafeAreaView>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: StatusBar.currentHeight,\n  },\n  item: {\n    backgroundColor: \"#f9c2ff\",\n    height: 300,\n    justifyContent: \"center\",\n    marginVertical: 8,\n    marginHorizontal: 16,\n    padding: 20,\n  },\n  title: {\n    fontSize: 32,\n  },\n})\n\nexport default App\n```\n\n[실행 영상]\n\n<img src=\"./실행.gif\"/>\n\n### 요구사항 2. 3번째요소가 50% 노출되었을 때, 5번째 요소가 30% 노출되었을 때 콘솔 찍기\n\n여기에 조금 더 복잡하게 여러 노출 조건이 요구사항으로 왔을 때는 `viewabilityConfigCallbackPairs`를 이용할 수 있다.\n`viewabilityConfigCallbackPairs`는 `viewabilityConfig`와 `onViewableItemsChanged`를 묶어서 전달할 수 있는 prop으로, 배열형식으로 전달할 수 있다.\n\n[[예시 코드 실행해보기](https://snack.expo.dev/@buil1/onviewableitemschanged2)]\n\n```tsx\nimport React, { useRef } from \"react\"\nimport {\n  SafeAreaView,\n  View,\n  FlatList,\n  StyleSheet,\n  Text,\n  StatusBar,\n  ViewToken,\n} from \"react-native\"\n\nconst data = Array.from({ length: 50 }, (item, index) => ({\n  id: Math.random().toString(12).substring(0),\n  title: `Item ${index + 1}`,\n}))\n\ntype ItemProps = {\n  title: string\n}\n\nconst Item = ({ title }: ItemProps) => (\n  <View style={styles.item}>\n    <Text style={styles.title}>{title}</Text>\n  </View>\n)\n\nconst TARGET_70_INDEX = 2\nconst TARGET_30_INDEX = 4\nconst App = () => {\n  const isShownTarget = useRef({\n    [TARGET_70_INDEX]: false,\n    [TARGET_30_INDEX]: false,\n  })\n\n  const handleViewableItemsChanged = (\n    {\n      viewableItems,\n    }: {\n      viewableItems: Array<ViewToken>\n      changed: Array<ViewToken>\n    },\n    targetIndex: typeof TARGET_70_INDEX | typeof TARGET_30_INDEX\n  ) => {\n    if (isShownTarget.current[targetIndex]) {\n      return\n    }\n    const isTargetInView = viewableItems.some(\n      item => item.index === targetIndex\n    )\n    if (isTargetInView) {\n      console.log(`${targetIndex} 타켓 노출`)\n      isShownTarget.current[targetIndex] = true\n    }\n  }\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <FlatList\n        initialNumToRender={4}\n        renderItem={({ item }) => <Item title={item.title} />}\n        keyExtractor={item => item.id}\n        data={data}\n        viewabilityConfig={{\n          itemVisiblePercentThreshold: 70,\n          waitForInteraction: true,\n        }}\n        viewabilityConfigCallbackPairs={[\n          {\n            viewabilityConfig: {\n              itemVisiblePercentThreshold: 70,\n              waitForInteraction: true,\n            },\n            onViewableItemsChanged: info => {\n              handleViewableItemsChanged(info, TARGET_70_INDEX)\n            },\n          },\n          {\n            viewabilityConfig: {\n              itemVisiblePercentThreshold: 30,\n              waitForInteraction: true,\n            },\n            onViewableItemsChanged: info => {\n              handleViewableItemsChanged(info, TARGET_30_INDEX)\n            },\n          },\n        ]}\n      />\n    </SafeAreaView>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    marginTop: StatusBar.currentHeight,\n  },\n  item: {\n    backgroundColor: \"#f9c2ff\",\n    height: 300,\n    justifyContent: \"center\",\n    marginVertical: 8,\n    marginHorizontal: 16,\n    padding: 20,\n  },\n  title: {\n    fontSize: 32,\n  },\n})\n\nexport default App\n```\n\n[실행 영상]\n\n<img src=\"./viewabilityConfigCallbackPairs.gif\"/>\n\n## 📚 마무리\n\n만약에 onViewableItemsChanged를 이용하지 않고 특정 요소의 영역이 노출되었을 때를 확인하려면 Viewport높이, 요소의 위치, scroll offset 위치를 직접 계산해서 확인해야 한다.\n다행히 RN에서는 내장된 prop으로 이를 자체적으로 계산해주기 때문에 편리하게 사용할 수 있다.\n\n조금 더 자세한 under the hood 내용은 [Understand onViewableItemsChanged in FlatList](https://suelan.github.io/2020/01/21/onViewableItemsChanged/)을 참고할 수 있다.\n"},{"excerpt":"3월에는 1분기동안 진행중이던 챕터업무들을 목표했던 만큼 완료했고, 새로운 스쿼드로 합류하게 되었다. 1분기를 마치며 배운점들과 시행착오들, 새로운 스쿼드에서 느낀 점들을 정리해보려 한다. 💪 챕터업무 마무리하기 3월은 1분기동안 챕터 업무로 기획하고 담당하고 있던 작업들을 마무리하는 시간들이었다. 1월부터 진행했던 App Start Time 줄이기 작업…","fields":{"slug":"/2024-04-07-2024년-3월회고/"},"frontmatter":{"date":"April 07, 2024","title":"🙌 2024년 3월회고","tags":["회고"]},"rawMarkdownBody":"\n3월에는 1분기동안 진행중이던 챕터업무들을 목표했던 만큼 완료했고, 새로운 스쿼드로 합류하게 되었다. 1분기를 마치며 배운점들과 시행착오들, 새로운 스쿼드에서 느낀 점들을 정리해보려 한다.\n\n## 💪 챕터업무 마무리하기\n\n3월은 1분기동안 챕터 업무로 기획하고 담당하고 있던 작업들을 마무리하는 시간들이었다. 1월부터 진행했던 **App Start Time 줄이기** 작업과 **에러바운더리 적용** 작업을 기획했던 범위만큼 모두 완료할 수 있었다.\n\n### 🚀 App Start Time 줄이기\n\nApp Start Time 줄이기 일감을 하면서 고민하고 적용했던 작업들을 따로 [회고](https://choi2021.github.io/2024-03-30-RN%EC%95%B1%EC%8B%9C%EC%9E%91%EC%B5%9C%EC%A0%81%ED%99%94/)로 작성했다.\n3개월이라는 시간동안에 퇴근 후에도, 주말에도 계속해서 자료들을 찾아보고 적용해봤다. 정말 말그대로 자다가도 갑자기 생각나서 시도해보기도 할 정도로 최선을 다해서 작업했던 것 같다.\n다행히 3월 내에 목표로 했던 **7초에서 4초 이내**로 줄여보자라는 OKR을 iOS/Android 두가지 플랫폼 모두 3.2초로 달성할 수 있어 뿌듯했다.\n\n여기에 더불어 성능 개선 일감들을 담당하면서 몇초를 더 줄이고, 얼마나 더 빨라지는 것에 대한 성과가 항상 **개발자들만 이해할 수 있는 성과**로 남는 것은 아닐까하는 아쉬움이 있었다.\n이러한 아쉬움은 이전 4분기에 진행했던 [견적발송 로직 개선작업](https://choi2021.github.io/2023-12-31-2023%EB%85%84-12%EC%9B%94%ED%9A%8C%EA%B3%A0/)을 진행하면서 처음 느끼게 되었는데, 견적을 발송하는데 걸리던 시간을 줄였다는 것에 뿌듯했지만, 작업에 대해 회사 사내 세미나에서 발표를 진행하고 자료를 정리하는 과정에서 내가 한 작업이 실제 우리 제품을 사용하는 **유저에게는 어떤 가치를 주었는지**에 대해서 명확하게 알기 어려웠다.\n\n성능 개선은 제품을 사용하는 유저가 분명히 빠르게 \"원하는\" 동작을 할 수 있게 도와주지만, 그게 유저가 정말 원했던 것인지, 답답함을 느끼고 있는 부분이었는지를 이해하는 건 다른 문제다보니 성능개선을 하더라도 비즈니스적인 관점에서 더 접근해보고 싶었고, 분석하는 작업도 같이 진행해보고 싶었다.\n\n이번 일감에서는 개인적으로 가려웠던 부분을 해결할 수 있었는데, 앱 시작화면에서 홈화면으로 5초 이내로 랜딩하는 유저 데이터를 함께 봤을 때 5% 상승하는 결과를 볼 수 있었다. 이를 통해 조금 더 **유저 중심적인 성능 개선**을 할 수 있었던 것 같다.\n\n이후에도 미뤄두었던 후순위 작업들을 하나씩 진행하면서 더 나은 제품들을 만드는데 계속해서 기여해보려 한다.\n\n### 🚑 에러바운더리 적용\n\n23년 4분기에 제안하고 일감화하게된 에러 바운더리 작업을 진행했다. 에러바운더리를 적용하기 위해서 Fallback UI에 어떻게 보여줄지 정하기 위해 UX 리서처분과 플랫폼 디자이너분께 의뢰드려 공통 Fallback UI에 대한 디자인을 전달받을 수 있었다.\n작업은 우선 런타임 에러가 발생했을 때, **재시도를 해도 해결되지 않는 경우**에 대한 Fallback UI를 만드는 작업을 먼저 진행한 이후에 각 스크린에 적용하게 되었고, 런타임 에러바운더리로 명명하게 되었다.\n\n런타임 에러바운더리를 위한 공통 Fallback UI 컴포넌트를 만들면서 특히 신경썼던 부분은 에러 발생시 레이아웃과 스타일 변화가 최대한 없게 만들기 위해 노력했다.\n그러기 위해서 **헤더 부분**이 중요했는데, 비록 유저가 이용중이던 화면은 이용할 수 없지만 앱을 껐다켜거나 하는 재시작 동작이 없어도, 다른 화면으로 진입하거나 **계속해서 제품을 이용할 수 있게** 하는 것을 중요하게 생각하고 작업했다.\n기본 fallback UI에 헤더컴포넌트를 주입하는 방법 등을 고려해 작업했고, 약 70%의 화면들에 대한 작업을 완료할 수 있었다.\n\n다음 분기에서 이어서 나머지 화면들에 대해 적용하고, 이후에는 런타임 뿐아니라 데이터 조회 API에서 발생하는 에러들을 다룰 때에도 분기문으로 되어있는 코드들을 에러바운더리를 적용해 선언적으로 작성할 수 있게 해보려 한다.\n\n기존에는 화이트 스크린 에러가 발생했을 때, 최상단에서 잡히다 보니 정확한 흐름을 보기 위해서는 사용자 이용 패턴을 따라하는 방법에 많은 시간이 소요되었는데, 스크린 단위로 런타임 에러바운더리를 적용하고 나서는 정확히 어느 화면에서 **유저들이 어떤 에러를 겪고 있는지** 제보 받을 수 있어 더 좋았다.\n이후에 에러바운더리를 제안하고, 적용했던 일감에 대해 정리해보려 한다.\n\n### 🙌 새롭게 합류한 스쿼드\n\n챕터업무를 마치고 3월 말부터는 새로운 스쿼드에 합류하게 되었다. 분명 작년에도 스쿼드에서 기능개발을 맡아서 진행해왔지만, 3개월 정도 챕터에서 작업을 하고 다시 돌아가고 나니 느낌이 새로웠다.\n\n챕터업무는 하나의 OKR을 위해서 혼자서 고민하고, 혼자서 목표를 위한 일감들에 대한 계획을 짜고 진행했다면, 스쿼드는 OKR을 위해 혼자가 아니라 PO, PD, Data Analyst, QA, BackEnd Engineer, FrontEnd Engineer 다양한 동료들과 함께 의사소통해야 하다보니 완전히 다른 업무를 하게 되는 느낌이었다.\n더불어 새롭게 합류한 스쿼드의 업무가 많아 나를 포함해 모바일 엔지니어가 두명인 상황으로 함께 하나의 스토리에 대해 일을 분배하고, 서로가 병목이 되지 않게 하는 것이 중요한 상황이 되었다.\n\n달라진 업무환경에 적응하면서 서로간의 의사소통을 통해 정책 결정, 기술적인 결정 등을 진행해야하기에 조금 더 기술적인 용어대신 **조금 더 이해하기 쉬운 용어**로 표현하는 법에 대해 더 연습이 필요하겠다는 점을 느꼈고, 혼자 고민하기 보다 정책적인 결정을 위해 PO, PD분들과 이야기 하고, 기술적으로 고민이 될때 스쿼드 엔지니어 분들과 함께 고민할 수 있어서 혼자 일할 때보다 든든함을 느낄 수 있었다.\n\n1년이 지난 지금, 기능개발에 있어서 이전과 조금 다른 시선을 갖게 된 것 같다. 1분기 동안 성능 개선 작업들과 여러 화면들에 대한 에러바운더리를 적용하면서 프로젝트 전반적인 코드들을 볼 수 있었다. 돌아보면서 내가 짠 코드였는데도 왜 이렇게 작성했는지 알 수 없고, 이후에 리팩토링할 수 있는 시간이 오면 해야지라 생각하며 미뤄뒀던 나의 TODO 주석들이 보이기도 했다.\n\n내가 짠 코드들을 보면서 당시 아쉬운 코드를 작성할 수 밖에 없었던 변명같은 이유는 **기한 내에 완성하기**만을 목표로 작업했기 때문이었던 것 같다. \"동작만하면 된거야\"라는 생각과 **적당히** 덜어내고, 내가 모르는 도메인과 같이 사용하는 코드는 유지보수하기 어려우니까 그냥 **하나 더** 만들어버리는 등 시간에 쫓겨 기능을 개발하다 보니 부족한 부분이 많았던 것 같다.\n\n부족했던 모습에서 더 성장하기 위해서는 기능개발의 가장 기본적인 **컴포넌트 설계**부터 좀 더 공부할 필요가 있어 보였다.\n이를 위해서 이전에 봤던 컴포넌트 설계에 대한 자세한 예시와 인사이트가 잘 담겨있는 토스 slash 컨퍼런스의 [Effective Component 지속 가능한 성장과 컴포넌트](https://www.youtube.com/watch?v=fR8tsJ2r7Eg)를 다시 보며 정리하기 시작했고, 2023 RN 리서치에 정리되어 있는 React Native UI 라이브러리들을 돌아보며 확장성과 변화에 유연한 컴포넌트 설계방법을 공부하고 적용해보려 한다.\n\n![2023 RN 리서치 UI 라이브러리 결과](rn-2023-ui.png)\n\n두번째로는 **UI 패턴별**로 최적화하는 방법들에 대해 정리해보려 한다. 이부분도 토스 slash 컨퍼런스의 [ 퍼널: 쏟아지는 페이지 한 방에 관리하기](https://www.youtube.com/watch?v=NwLWX2RNVcw&t=41s)를 통해 인사이트를 얻을 수 있었다.\n해당 발표에서 총 세가지 UI 패턴,**상점, 단일 페이지, 설문조사**으로 소개하고 있고, 실제로 우리 제품에서 구현되는 UI들의 대부분이 세가지 패턴에 포함된다는 점을 알 수 있었다.\n\n<table width=\"100%\" >\n    <tr>\n        <th>상점(목록->상세)</th>\n    </tr>\n    <tr>\n        <td>\n            <img src=\"store.png\" />\n        </td>\n    </tr>\n    <tr>\n        <th>단일 페이지</th>\n    </tr>\n    <tr>\n        <td>\n            <img src=\"single.png\" />\n        </td>\n    </tr>\n    <tr>\n        <th>설문조사 패턴</th>\n    </tr>\n    <tr>\n        <td>\n            <img src=\"search.png\" />\n        </td>\n    </tr>\n</table>\n\n이렇게 UI 패턴을 묶을 수 있다는 것은 도메인과 요구사항들과 상관없이 **공통되게 적용할 수 있는 최적화 요소**들이 있고 이러한 부분들을 정리해놓는다면, 내가 담당하는 도메인이 달라져도, 좋은 코드를 작성할 수 있게다는 생각이 들었다.\n\n이렇게 정리한 두가지 액션아이템들에 대해서 잘 정리해서 팀내에도 공유하고 적용하며 더 resourceful한 엔지니어가 되기 위해 노력해보려 한다.\n"},{"excerpt":"24년 1Q동안은 스쿼드가 아닌 모바일 챕터에 속해, App Start time 줄이기 업무를 담당했다. App Start Time을 줄이기 위해 시도하고 조사하며 겪었던 시행착오들을 기록해보려한다. ⚠️ App StartUp time이란? 앱 시작 시간 (StartUp time)은 앱을 실행하고 첫 화면이 랜딩되기까지의 시간을 의미한다.\n시작시간을 줄이는…","fields":{"slug":"/2024-03-30-App-StartUp-time-개선/"},"frontmatter":{"date":"April 03, 2024","title":"App StartUp time 개선","tags":["성능","ReactNative","회고"]},"rawMarkdownBody":"\n24년 1Q동안은 스쿼드가 아닌 모바일 챕터에 속해, App Start time 줄이기 업무를 담당했다. App Start Time을 줄이기 위해 시도하고 조사하며 겪었던 시행착오들을 기록해보려한다.\n\n## ⚠️ App StartUp time이란?\n\n앱 시작 시간 (StartUp time)은 **앱을 실행하고 첫 화면이 랜딩되기까지**의 시간을 의미한다.\n시작시간을 줄이는 것에 대한 작업의 비즈니스적 가치는 앱을 이용하는 모든 유저가 필수적으로 거쳐야하는 퍼널을 빠르게 완료함으로서, 앱을 보다 빠르게 이용할 수 있게 해 사용자 경험을 개선하는 것에 있다.\n\n그러면 이제 App Start time을 단축하기 위해 어떤 시도를 했는지 알아보자.\n\n## 📌 App StartUp time 측정하기\n\n성능을 비교하기 위해서는 항상 기준이 필요하다. 성능 비교를 위해 작년 4Q에 진행했던 [견적발송 개선 작업](https://choi2021.github.io/2023-11-01-2023%EB%85%84-10%EC%9B%94%ED%9A%8C%EA%B3%A0/)과 동일하게 **Firebase Performance**를 이용해 측정했다.\n다행이었던 부분은 이전에 측정을 시도했던 코드가 남아있어 참고해서 작업을 진행할 수 있었다.\n\n기존의 기준은 가장 상위 파일인 **App -> Start화면 -> 고객/고수 홈화면으로 이동**하기까지의 시간이었다.\n이미 기준이 잘잡혀 있어 동일한 기준으로 측정하게 되었다.\n\n### 측정 유틸 개선하기\n\n기준을 세운 이후에 데이터를 측정하는데에는 두가지 케이스에 대한 고려가 필요했다.\n\n첫번쨰로 **유저의 타입**으로 앱을 이용하는 유저에 따라 Splash Screen에서 필요한 정보가 달라지기 떄문에 비회원/고객/고수 세가지에 맞게 정리하고 데이터를 필터링 할 수 있어야 했다.\n\n두번째는 코드푸시를 이용한 **필수 업데이트**를 이용하는 경우다. 필수 업데이트를 진행하는 경우에 앱센터에 올라온 새로운 필수 버전이 있는지 체크하고 해당 번들을 설치하게 되는데 이때 설치하는데 추가적인 시간이 소요되기 때문에 이를 고려해야 했다.\n\n위 두가지 케이스를 위해서 먼저 유저타입은 attribute로 trace에 추가하고, 필수업데이트의 경우는 데이터 측정에서 제외시켜 두가지 케이스를 고려해 측정을 진행했다.\n\n측정 코드는 이전 [견적발송시간 측정](https://choi2021.github.io/2023-11-01-2023%EB%85%84-10%EC%9B%94%ED%9A%8C%EA%B3%A0/)때 구현해둔 Firebase Performance util 모듈에 두가지 케이스를 모두 커버할 수 있게 attribute 추가 메소드와 skip 기능을 추가했다.\n\n[Firebase Performance util]\n\n```typescript\nexport class PerformanceTracker {\n  private constructor(\n    private traceMap: Map<\n      keyof typeof PerformanceKey,\n      FirebasePerformanceTypes.Trace\n    > = new Map(),\n    private configMap: Map<\n      keyof typeof PerformanceKey,\n      { startTime: number; isSkipped: boolean; latestTime: number }\n    > = new Map()\n  ) {}\n\n  async start(name: keyof typeof PerformanceKey) {\n    const trace = perf().newTrace(name)\n    const startTime = Date.now()\n    this.configMap.set(name, {\n      startTime,\n      isSkipped: false,\n      latestTime: startTime,\n    })\n    this.traceMap.set(name, trace)\n    await trace.start()\n  }\n\n  async stop(name: keyof typeof PerformanceKey) {\n    const trace = this.traceMap.get(name)\n    const config = this.configMap.get(name)\n    if (isNil(trace) || isNil(config)) {\n      return\n    }\n\n    if (config.isSkipped) {\n      this.traceMap.delete(name)\n      return\n    }\n\n    await trace.stop()\n    this.traceMap.delete(name)\n  }\n\n  addCheckPoint(name: keyof typeof PerformanceKey, metricName: string) {\n    const trace = this.traceMap.get(name)\n    const config = this.configMap.get(name)\n    if (isNil(trace) || isNil(config)) {\n      return\n    }\n\n    const checkPointTime = Date.now() - config.startTime\n    const timeGap = Date.now() - config.latestTime\n    trace.putMetric(metricName, checkPointTime)\n    this.configMap.set(name, { ...config, latestTime: Date.now() })\n  }\n\n  skipTrace(name: keyof typeof PerformanceKey) {\n    const config = this.configMap.get(name)\n    if (isNil(config)) {\n      return\n    }\n    this.configMap.set(name, { ...config, isSkipped: true })\n  }\n\n  addAttribute(name: keyof typeof PerformanceKey, key: string, value: string) {\n    const trace = this.traceMap.get(name)\n    if (isNil(trace)) {\n      return\n    }\n    trace.putAttribute(key, value)\n  }\n}\n```\n\n### 세부 체크포인트 지점 추가하기\n\n이제 구현한 측정 유틸과 전체적인 기준에 각 지점마다의 개선을 보기 위해 **체크포인트**들을 세웠다.\n기준은 4가지로 아래와 같이 정했다.\n\n- App 화면 초기화: 최상위 App화면에서 전역적인 provider들과 전역상태, 이벤트리스너들을 준비하고 기기 내부 storage에서 정보들을 가져오는데 걸리는 시간\n- 앱 업데이트 체크: 앱 버전과 코드푸시 업데이트를 체크하는 시간\n- 로그인: 인증토큰을 이용해 로그인을 완료하고 일부 후처리 작업까지 걸리는 시간\n- 홈화면 이동: 로그인 후 홈화면 이동까지 걸리는 시간\n\n그리고 측정 데이터를 볼 때 **고수**를 기준으로 얼마나 개선되었는지를 보려 했다. 그 이유는 유저 타입별로 호출하는 API 수가 다르기 때문에 데이터의 유저 타입에 의해 결과가 달라지게 되었다.\n이를 개선하기 위해서 가장 많은 API를 호출하는 고수로 데이터를 비교해보려 했다.\n\n정의한 체크포인트에 따라 App Start time의 데이터를 정리해보면 개선 작업전 1월 24일부터 2월 14일간 90% 고수 유저 기준으로 OS별 데이터는 다음과 같이 정리할 수 있었다.\n\n<Table>\n<tr>\n    <th>체크포인트</th>\n    <th>iOS</th>\n    <th>Android</th>\n</tr>\n<tr>\n    <td>App 화면 초기화</td>\n    <td>1.6초</td>\n    <td>1.8초</td>\n</tr>\n<tr>\n    <td>앱 업데이트 체크</td>\n    <td>3.3초 (+1,700ms)</td>\n    <td>2.8초 (+1000ms)</td>\n</tr>\n<tr>\n    <td>로그인</td>\n    <td>5.9초 (+2,600ms)</td>\n    <td>6.2초 (+3,400ms)</td>\n</tr>\n<tr>\n    <td>홈화면 이동</td>\n    <td>6.5초 (+600ms)</td>\n    <td>6.9초 (+700ms)</td>\n</tr>\n</Table>\n\n구간별 시간을 통해서 앱 업데이트부터 로그인 + 홈화면 이동 구간, 업데이트 체크, App화면 초기화 순으로 오래걸리는 구간을 우선순위를 높여 작업을 진행하게 되었다.\n\n## 🚀 개선 작업\n\n이제는 App Start time을 단축하기 위해 검토하고 시도해봤던 부분들에 대해 정리해보자.\n\n## 🛜 네트워크 최적화\n\n가장 먼저 실행한 부분은 **네트워크 요청 최적화**로 불필요한 중복 API를 호출하는 경우가 없는지 체크하고 순서와 상관이 없는 요청들은 동시성을 이용해 네트워크 시간을 최적화했다.\n\n### 불필요한 요청 감지하기\n\n불필요한 네트워크를 제거하는 작업은 두가지 효과를 기대할 수 있다.\n\n먼저, **네트워크 응답 시간을 줄일 수 있다**. 1초가 걸리는 요청을 N번 하고 동기적으로 응답을 기다린다면 N초를 기다려야만 한다.\n\n두번째로, **서버의 부담을 줄여줄 수 있다**. 요청이 많다는 것은 그만큼 서버에서 부담해야할 트래픽이 늘어난다는 것이고, 만약 요청이 몰리게 되면 서버에서 처리가 오래걸리게 되거나 타임아웃이 발생할 수 있다. 불필요한 요청을 제거함으로서 서버의 부담을 줄일 수 있다.\n\n측정 시작부터 완료까지 과정에서 호출되는 중복 네트워크 요청들을 조사하기 위해서 Axios interceptor를 이용해 개발환경에서 특정 시간내의 중복 호출을 감지할 수 있는 모듈을 만들어 적용했다.\n또한, Firebase Performance의 metric을 이용해 네트워크 응답 시간과 성공률에 대한 데이터를 쌓을 수 있었다.\n\n[중복 API 호출 감지 interceptor ]\n\n```tsx\nconst requestMap = new Map<\n  string,\n  {\n    lastTime: number\n    count: number\n    notify?: (count: number) => void\n  }\n>()\n\nconst requestCheckDuplicatedRequestInterceptor = async (\n  config: InternalAxiosRequestConfig\n) => {\n  if (isProduction()) {\n    return config\n  }\n\n  const { method, url, params, data } = config\n  const requestKey = `${method?.toUpperCase()} ${url} ${JSON.stringify(\n    params\n  )} ${JSON.stringify(data)}`\n  const request = requestMap.get(requestKey) ?? { lastTime: 0, count: 0 }\n\n  const now = Date.now()\n  if (request.lastTime === 0 || now - request.lastTime > 1000) {\n    const notify = debounce((count: number) => {\n      console.warn(`${method?.toUpperCase()} ${url} 반복 요청 ${count} times`)\n    }, 1000)\n\n    requestMap.set(requestKey, { lastTime: now, count: 1, notify })\n  } else {\n    requestMap.set(requestKey, {\n      lastTime: now,\n      count: request.count + 1,\n      notify: request.notify,\n    })\n    request.notify?.(request.count + 1)\n  }\n  return config\n}\n```\n\n[Firebase Performance network metric]\n\n![img.png](네트워크응답시간.png)\n\n중복호출 감지 interceptor를 통해 개발 과정에서 중복 호출되고 있는 API들을 체크한 후에, 첫번쨰 호출받은 응답을 두번째에 이용하게 수정함으로서 중복 호출에 대한 최적화를 할 수 있었다.\n네트워크 응답 시간이 오래걸리는 API들은 정리한 후에 백엔드 분들께 전달드려 최적화를 요청해 시간을 단축할 수 있었다.\n\n### 로그인/로그인 후처리 구간 최적화하기\n\n로그인 과정에서 순서가 중요한 작업들을 고려해 flow를 정리해보면 **인증 토큰 가져오기 -> 인증토큰 유효성 검사 -> 로그인 -> 로그인 후처리** 로 정리해볼 수 있다.\nAPI들을 스텝별로 재분류하고 나니 로그인 이후에는 **로그인 후처리** 작업간에는 순서가 상관없기 때문에 `Promise.all` 메소드를 이용해 처리할 수 있어보였다.\n\n그리고 기존에 홈화면 이동 이후에 일부 후처리 작업들이 진행되고 있었지만 모두 완료하고 홈화면으로 랜딩하게 하는 것이 더 합당해보여서 순서를 수정하게 되었다.\n아래는 개선한 코드의 일부를 가져와 정리해보았다.\n\n[개선된 Splash 화면 초기화 flow]\n\n```tsx\n// 유저타입별 초기화\nconst 유저타입별_초기화 = async (userType: UserType) => {\n  await Promise.all([\n    공통_초기화(),\n    유저_초기화(userType),\n    고수_초기화(userType),\n  ])\n}\n\nconst 초기화_실행 = async () => {\n  try {\n    const token = await 토큰가져오기()\n\n    await 업데이트버전체크()\n\n    const deepLink = await 딥링크_정보가져오기()\n\n    const userType = await 로그인(token)\n    performanceTracker.addCheckPoint(\"로그인\")\n\n    await 유저타입별_초기화(userType)\n\n    await 홈_화면으로_이동(deepLink)\n    await tracker.stopTrace(\"측정_완료\")\n  } catch (error) {\n    에러핸들링_및_로깅()\n  }\n}\n```\n\n### 앱 업데이트 체크 최적화\n\n두 번째로 네트워크 최적화를 진행한 부분은 **업데이트 버전 체크**부분으로 Codepush 버전과 앱 최소/권장 버전으로 두가지 버전에 대한 네트워크 요청이 순서대로 진행되고 있었다.\n각각 요청하는 서버가 다르고 서로 다른 데이터이기 때문에 동시성을 이용해 적용했다.\n\n아래 코드푸시 네트워크 응답 데이터를 보면 90% 유저를 기준으로 **android는 1.35초, iOS는 1.69초**가 걸리는 것을 볼 수 있다.\n동시성을 이용하더라도 오래걸리는 응답에 의존하기 때문에, 큰 개선을 기대하기는 어려웠다.\n\n<Table width=\"100%\">\n<tr>\n    <th>iOS</th>\n</tr>\n<tr>\n    <td>\n        <img src=\"코드푸시데이터-ios.png\">\n    </td>\n</tr>\n<tr>\n    <th>Android</th>\n</tr>\n<tr>\n    <td>\n        <img src=\"코드푸시데이터-android.png\">\n    </td>\n</tr>\n</Table>\n\n자체적으로 번들을 캐싱하는 방법도 고려해봤지만 생각보다 리소스가 클 것 같아 이후에 적용해보기로 계획하고 당시에는 넘어가게 되었다.\n\n이후 챕터 동료 분의 작업으로 **자체적인 코드푸시 시스템 구축**으로 업데이트를 체크하는데 300ms 내외로 크게 줄어드는 성과가 있었다.\n\n### App화면 초기화 구간 최적화\n\nApp화면 초기화 구간은 AB테스트 정보와 피쳐플래그를 조회하는 작업과 함께 AppState, 네트워크 상태 등 외부 시스템과의 연결하는 작업이 진행된다.\n\n코드를 보며 발견했던 문제점은 Socket 연결, FCM 연결 등 실시간으로 동작 여부를 체크하는 네트워크 요청이 불필요하게 여러번 호출되고 있었고, AB테스트 정보는 이후 로그인 구간 이후에 다시 조회되는 중복이 발생하고 있었다.\n\nAppState의 경우, 기존 react-native-community의 useAppState 훅을 이용하는 방식에서 RN 내장 모듈 AppState 이벤트 리스너를 이용하는 방식으로 수정해 불필요한 재실행을 해결했다.\n\n[[RN AppState 이벤트 리스너 예제](https://reactnative.dev/docs/appstate#basic-usage)]\n\n```tsx\nconst appState = useRef(AppState.currentState)\nconst [appStateVisible, setAppStateVisible] = useState(appState.current)\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener(\"change\", nextAppState => {\n    if (\n      appState.current.match(/inactive|background/) &&\n      nextAppState === \"active\"\n    ) {\n      console.log(\"App has come to the foreground!\")\n    }\n\n    appState.current = nextAppState\n    setAppStateVisible(appState.current)\n    console.log(\"AppState\", appState.current)\n  })\n\n  return () => {\n    subscription.remove()\n  }\n}, [])\n```\n\n네트워크 상태는 기존과 동일하게 [react-native-netinfo](https://github.com/react-native-netinfo/react-native-netinfo)를 이용하지만 불필요하게 리렌더링을 일으키는 `useNetInfo`를 이용하는 방식이 아니라 Appstate와 동일하게 이벤트 리스너를 이용하는 방식으로 변경했다.\n\n[react-native-netinfo 이벤트 리스너 예제]\n\n```tsx\n// Subscribe\nconst unsubscribe = NetInfo.addEventListener(state => {\n  console.log(\"Connection type\", state.type)\n  console.log(\"Is connected?\", state.isConnected)\n})\n\n// Unsubscribe\nunsubscribe()\n```\n\nAB테스트 정보를 가져올 때는 로그인 전/후 전체 정보를 두번 가져오고 있었다. 이를 개선하기 위해서 **기기별로 필요한 클라이언트 AB테스트 정보**와 로그인 후에 **유저별로 필요한 서버 AB테스트 정보**를 조회 요청으로 분리함으로서 불필요한 요청을 줄일 수 있었다.\n\n해당 구간은 [Async Storage](https://github.com/react-native-async-storage/async-storage)를 많이 이용해 값을 조회하기 떄문에 성능이 더 좋은 storage로 마이그레이션하는 방법도 고민했지만 챕터 내에서 시도했다가 이슈가 있어 적용하지 못했던 적이 있어 후순위로 진행해보기로 했다.\n\n이외 작업으로는 기존에 네트워크 요청을 보낼 때 AsyncStorage에 있는 토큰을 매번 조회해서 보냈지만, 토큰을 전역상태로 저장한 후에 조회하는 방식으로 변경하는 작업을 진행하는 소소한 개선작업도 진행했다.\n\n### 결과\n\n이렇게 구간별로 나누어 네트워크 최적화 작업을 진행하고, 2월 14일부터 3월 6일까지 고수 유저의 결과를 보았을 때 os별로 다음과 같은 결과를 얻을 수 있었다.\n\n<Table>\n<tr>\n    <th>체크포인트</th>\n    <th>iOS</th>\n    <th>Android</th>\n</tr>\n<tr>\n    <td>App화면 초기화</td>\n    <td>1.3초(기존 대비 -300ms)</td>\n    <td>1.3초(기존 대비 -500ms)</td>\n</tr>\n<tr>\n    <td>앱 업데이트 체크</td>\n    <td>2.1초 (+800ms, 기존 대비 -900ms)</td>\n    <td>2.7초 (+1,400ms, 기존 대비 -400ms)</td>\n</tr>\n<tr>\n    <td>로그인</td>\n    <td>3.5초 (+1,200ms, 기존 대비 -1400 ms)</td>\n    <td>3.7초 (+1000ms, 기존 대비 -2400ms)</td>\n</tr>\n<tr>\n    <td>홈화면 이동</td>\n    <td>6.3초 (+2800ms, 기존대비 +2000ms)</td>\n    <td>5.9초 (+2200ms, 기존대비 +1500ms)</td>\n</tr>\n</Table>\n\n결과의 홈화면 이동 이후에 초기화 작업이 진행되지 않기 때문에 이제 측정 완료와 홈화면 이동을 동일하게 볼 수 있다. 결과를 보면 **로그인~홈화면이동** 구간을 제외하고 각 구간에서 개선이 있었다. **로그인~홈화면이동** 구간은 로그인 내부에서 진행하던 작업들을 분리해 후처리 작업을 함께 처리하게 수정했기 떄문에 이전 기록에 비해서 증가했다.\n\n이전기록과 비교했을 때 전체적으로는 **iOS에서 6.5초 -> 6.3초로 0.2초 (3%), android에서는 1초(14%)** 의 개선이 있었다.\n\nOS별로 개선된 정도가 달랐던 이유는 당시에는 몰랐지만 iOS에서만 FCM 메시지 수신과정에서 문제로 고수분들의 로그인이 풀려 다시 로그인하면서 시간이 조금 더 걸리는 이슈가 있었다.\n이후에 해결했을 때, 두 OS 모두 유사한 시간으로 측정되었다.\n\n## 🖥️ 렌더링 최적화\n\n렌더링 최적화 작업은 불필요한 리렌더링을 막아, 복잡한 연산이 필요한 UI가 다시 그려지면서 시간이 소요되는 것을 방지할 수 있다.\n또한 컴포넌트 내부에서 API를 호출하는 경우 불필요한 API 호출을 막아 성능을 개선할 수 있다.\n이과정에서 몇가지 알게되었던 부분들을 정리해보려 한다.\n\n### 전역상태 조회 최적화\n\n스크린간 공유할 데이터 또는 전역적으로 사용되는 데이터를 관리하는 방법으로 **전역상태**를 이용한다. 우리 프로젝트에서는 Redux를 주로 이용하고 있는데 이때 참조하고 있는 값이 객체인지 primitive한 값인지에 따라 리렌더링이 일어날 수 있다.\n\n예를 들어 아래에 `UserProfile` 컴포넌트는 `userProfile`이라는 전역상태를 참조하고 있다. 그리고 OtherComponent는 특정 경우에 userProfile의 일부 속성을 업데이트한다. 코드는 정상적으로 동작하고 문제가 없어보인다.\n\n[UserProfile 컴포넌트]\n\n```tsx\nconst UserProfile: React.FC = () => {\n  const userProfile = useSelector((state: RootState) => state.userProfile)\n\n  return (\n    <div>\n      <h1>{userProfile.name}</h1>\n      {/* 기타 사용자 프로필 정보를 표시 */}\n    </div>\n  )\n}\n\nconst OtherComponent: React.FC = () => {\n  const dispatch = useDispatch()\n\n  const changeUserProfilePhoneNumber = () => {\n    // `userProfile`의 `phoneNumber` 속성을 업데이트합니다.\n    dispatch(updateUserProfile({ phoneNumber: \"987-654-3210\" }))\n  }\n\n  return (\n    <button onClick={changeUserProfilePhoneNumber}>전화번호 업데이트</button>\n  )\n}\n```\n\n하지만 아래 action과 reducer를 보면 `OtherComponent`의 action에 의해, 불변성을 지키기 위해서 `userProfile`의 객체가 새롭게 할당되고, 새롭게 할당된 객체로 인해 `UserProfile` 컴포넌트에 리렌더링이 일어나게 된다.\n\n[action/reducer 코드]\n\n```tsx\n// actions/userProfileActions.ts\n\nexport const UPDATE_USER_PROFILE = \"UPDATE_USER_PROFILE\"\n\nexport const updateUserProfile = (updatedProfile: Partial<UserProfile>) => {\n  return {\n    type: UPDATE_USER_PROFILE,\n    payload: updatedProfile,\n  }\n}\n\n// reducers/userProfileReducer.ts\n\nimport { UPDATE_USER_PROFILE } from \"../actions/userProfileActions\"\n\nconst initialState: UserProfile = {\n  name: \"John Doe\",\n  phoneNumber: \"123-456-7890\",\n}\n\nconst userProfileReducer = (state = initialState, action: any) => {\n  switch (action.type) {\n    case UPDATE_USER_PROFILE:\n      return {\n        ...state,\n        ...action.payload,\n      }\n    default:\n      return state\n  }\n}\n\nexport default userProfileReducer\n```\n\n이를 방지하기 위해서 전역상태를 참조할 때 객체가 아니라 필요한 값을 참조하게 수정했고, 추가적으로 불필요한 전역상태 조회는 제거하는 방식으로 불필요한 리렌더링을 방지할 수 있었다.\n\n[UserProfile 컴포넌트 수정]\n\n```tsx\nconst UserProfile: React.FC = () => {\n  const name = useSelector((state: RootState) => state.userProfile.name)\n\n  return (\n    <div>\n      <h1>{name}</h1>\n      {/* 기타 사용자 프로필 정보를 표시 */}\n    </div>\n  )\n}\n```\n\n### 조건부 렌더링과 custom hook\n\n조건부 렌더링은 특정 조건에서만 노출되어야하는 컴포넌트가 있을 때 자주 사용하게 된다. 하지만 이를 이용할 때도 불필요한 성능이나 API 호출이 일어날 수 있다.\n\n예를 들어 아래는 업데이트 진행률을 표시하기위한 컴포넌트로 `isProgressVisible`를 prop으로 전달하고 내부에 `isProgressVisible`이 true일때만 해당 컴포넌트가 렌더링되도록 구현되어 있다.\n\n```tsx\nconst SplashScreen: React.FC = () => {\n  const { data, loading } = useFetchData()\n  const [isProgressVisible, setIsProgressVisible] = useState(false)\n\n  return (\n    <View>\n      <UpdateProgress isVible={isProgressVisible} />\n    </View>\n  )\n}\n\nconst UpdateProgress: React.FC<{ isProgressVisible: boolean }> = ({\n  isProgressVisible,\n}) => {\n  const { progress } = useVersionInfo()\n\n  if (!isProgessVisible) return null\n  return (\n    <View>\n      <Text>{progress}%</Text>\n    </View>\n  )\n}\n\nconst useVersionInfo = () => {\n  const [progress, setProgress] = useState(0)\n\n  useEffect(() => {\n    const fetchProgress = async () => {\n      const progress = await getVersionProgress()\n      setProgress(progress)\n    }\n\n    const interval = setInterval(fetchProgress, 1000)\n\n    return () => clearInterval(interval)\n  }, [])\n\n  return { progress }\n}\n```\n\n하지만 위 컴포넌트는 문제점을 가지고 있다. UI는 우리가 원한대로 조건부로 보이게 되지만 custom hook은 이와 상관없이 동작하게 된다. 이는 useEffect가 동작하는 사이클과 관련되는데 컴포넌트가 null로 렌더링되더라도 렌더링이 마친것으로 보고 prop과 상관없이 API를 호출하게 된다.\n이를 해결하는 것은 간단하다. 컴포넌트의 렌더링 주체를 컴포넌트 내부에서 하지 않고 부모 컴포넌트에서 관리하게 한다.\n\n```tsx\nconst SplashScreen: React.FC = () => {\n  const { data, loading } = useFetchData()\n  const [isProgressVisible, setIsProgressVisible] = useState(false)\n\n  return <View>{isProgressVisible && <UpdateProgress />}</View>\n}\n\nconst UpdateProgress: React.FC<{ isProgressVisible: boolean }> = ({\n  isProgressVisible,\n}) => {\n  const { progress } = useVersionInfo()\n\n  return (\n    <View>\n      <Text>{progress}%</Text>\n    </View>\n  )\n}\n```\n\n이렇게 수정하게 되면 `UpdateProgress` 컴포넌트는 `isProgressVisible`이 true일때만 렌더링되기 때문에 불필요한 API 호출을 방지할 수 있고, 부모컴포넌트의 코드만 봐도 어떤 컴포넌트가 렌더링 될지를 예측할 수 있는 장점을 가진다.\n\n이외에도 앞서 네트워크 최적화에서 설명했던 Appstate나 Network 상태에 따라 이벤트를 구독할 때 불필요하게 여러번 동작해 리렌더링을 일으키는 부분도 이벤트 리스너를 이용하는 방식으로 수정해 불필요한 리렌더링을 방지할 수 있었다.\n\n### 결과\n\n렌더링 최적화의 결과를 React Devtools를 이용해 측정해보았을 때 다음과 같은 결과를 얻을 수 있었다.\n\n<Table width=\"90%\">\n<tr>\n    <th>리렌더링 최적화 Before</th>\n</tr>\n<tr>\n    <td>\n        <img src=\"rendering-asis.png\">\n    </td>\n</tr>\n<tr>\n    <th>리렌더링 최적화 After</th>\n</tr>\n<tr>\n    <td>    \n        <img src=\"rendering-tobe.png\">\n    </td>\n</tr>\n</Table>\n\n동일한 측정기준에서 총 27번의 리렌더링에서 15번으로 줄일 수 있었다. 더 줄일 수도 있지만 개발 환경에서만 렌더링되는 요소도 있고, React navigation, modal 등 서드파티 라이브러리 자체에서 발생하는 리렌더링도 있다보니 여기서 마무리했다.\n\n## 🛫 최종 결과\n\n1Q 동안 네트워크 최적화와 렌더링 최적화를 주로 진행했고, 90% 유저를 기준으로 4월 3일 90일간 90프로 고수 유저 기준으로 다음과 같은 결과를 얻을 수 있었다.\n\n<Table width=\"100%\">\n<tr>\n    <th>iOS</th>\n</tr>\n<tr>\n    <td>\n        <img src=\"ios-gosu-result.png\">\n    </td>\n</tr>\n<tr>\n    <th>Android</th>\n</tr>\n<tr>\n    <td>\n        <img src=\"android-gosu-result.png\">\n    </td>\n</tr>\n</Table>\n\n결과를 분석해보면 홈화면 이동을 기준으로 iOS는 **6.5초에서 3.2초로 50%** 개선되었고, Android는 **6.9초에서 3.2초로 53%** 개선되었다.\n\n위 작업들 뿐만 아니라 챕터내에서 함께 애써주신 작업들 (android에서 적용된 **proguard**, **자체적인 코드푸시 시스템 구축**으로 앱 업데이트 속도 개선) 덕분에 결과적으로 좋은 성과가 있었다.\n\n비즈니스적으로는 실제 메인화면으로 진입하는 퍼널에서 5초 이내에 업데이트 완료 후에 메인으로 진입하는 진입률이 5% 증가하는 성과가 있었다. 전체적으로 Start time 완료 시간이 줄어들어 사용자 경험에 긍정적인 영향을 준 것으로 보인다.\n\n## 🤔 시도하지 못했지만 이후 적용해볼만한 부분\n\n1분기 동안은 네트워크와 렌더링 최적화에 중점을 맞추어 진행해 기간내에 실행하지 못했던 아이디어들이 있었다.\n\n![개선 아이디어](개선아이디어.png)\n\n각 아이디어별로 간단하게 정리해보면 다음과 같다.\n\n### 번들 최적화\n\n번들 최적화 작업은 react native의 실행환경이자 번들러인 metro는 tree-shaking을 지원하지 않고 있다. 그렇기 때문에 번들링 과정에 사용하지 않는 코드들이나 모듈들이 있을 수 있고 JS는 모든 코드들이 준비된 다음에 동작하기 때문에 번들이 커질수록 초기 실행속도가 느려질 수 있다.\n이를 위해서 프로젝트 내에서 사용중인 lodash나 moment와 같은 라이브러리를 개별적으로 사용하거나, 필요한 부분만 가져와 사용하는 방법을 적용해보려 했다.\n\ntoss에서 발표했던 번들러를 Metro에서 ESBuild로 전환했던 경험을 공유해주신 [React Native, Metro를 넘어서](https://www.youtube.com/watch?v=QfU5REp8sjQ)를 보면서 적용하면 어떨까 생각도 했지만 아직 번들러에 익숙하지 않아 시간이 많이 필요해보여 미루게 되었다.\n\n해당 일감은 1분기에 진행하지 못했지만 2분기 챕터 일감으로 기획되어 있어 일부 기여해보려 한다.\n\n### 네이티브 모듈 최적화\n\n우리가 작성하는 코드의 대부분이 JS이기 떄문에 먼저 JS적인 최적화를 진행했지만, Native 모듈들을 최적화하는 방법도 있다.\nJSI, Turbo module과 같은 new architecture를 도입해 bridge를 이용하지 않고 native 모듈을 사용하는 방법 등 네이티브 적인 개선도 할 수 있을 것 같아보였다.\n\n하지만 Native에 대한 지식이 부족하다보니 조금 더 익숙하고 이해하기 쉬운 JS적인 최적화를 먼저 진행하고 이후에 시도하려고 후순위로 미루게 되었다.\n이후에 Native 모듈을 연결하는 방법들을 공부하고 적용해보면 좋을 것 같다.\n\n### AsyncStorage 마이그레이션\n\n앱 초기단계에서 AsyncStorage를 많이 이용하고 있는데, AsyncStorage는 비동기적으로 동작하기 때문에 성능에 영향을 줄 수 있다. 이를 해결하기 위해서는 성능이 좋은 storage로 마이그레이션하는 방법이 있어 보였다.\n하지만 마이그레이션 자체에 대한 비용이 조금 더 많이 들게 되지 않을까 하는 생각이 들어서 후순위로 미루게 되었다.\n\n2분기 일감으로 계획되어 있지는 않지만 [mmkv](https://github.com/mrousavy/react-native-mmkv)나 [op-sqlite](https://github.com/OP-Engineering/op-sqlite)와 같은 라이브러리를 이용해 AsyncStorage를 대체하는 방법도 고려해보려 한다.\n\n### Native Stack\n\n우리 프로젝트는 React Navigation의 custom router를 이용해 사용하고 있다. Custom Router는 화면 전환시 JS에서 동작하기 때문에 화면전환간 JS 스레드를 blocking하고 성능이 떨어질 수 있다.\n이를 개선하는 방법으로 Native Stack을 이용해 화면전환을 Native에서 처리하게 하여 JS 스레드를 blocking하지 않는 방법을 생각해 봤다.\n\n성능은 개선되겠지만 Start Time 과정에서 화면 전환은 splash 화면에서 메인화면으로 한번밖에 없기 때문에 효과가 미미할 것 같아 후순위로 기획해둔 작업이었다.\n\n2분기 일감으로 기획되어 있어 적용하고 화면 전환간 성능도 함께 알아볼 예정이다.\n\n## 📚 마무리\n\n하나의 큰 일감을 기획하고 3달동안 고민하고 자료조사를 하고 실제로 의미있었던 작업도 성과가 미미했던 작업도 있었다.\n\n이과정에서 ReactNative 환경에서 어떻게 JS가 동작하는지, React의 렌더링 과정이 어떻게 동작하는지에 대한 이해가 더 깊어질 수 있었고, 성능 최적화에 대한 이해도가 높아진 것 같다.\n\n개인적으로 모든 유저가 겪게되는 과정을 개선하는 일감이라 압박도 많았지만 좋은 결과로 마무리된 것 같아 뿌듯하다. 앞으로도 성능 최적화에 대한 고민과 개선을 지속적으로 진행해보려 한다.\n"},{"excerpt":"앞선 글을 통해 Promise.all는 자바스크립트의 동시성을 이용한 메소드임을 정리해보았다.\n이어서 자바스크립트에서 비동기 처리를 가능하게 하는 기본원리인 이벤트 루프를 React와 React Native 예제 코드와 함께 정리해보려 한다. 🤔 이벤트 루프란? 이벤트 루프는 자바스크립트에서 코드를 실행하고 이벤트를 처리하는 역할을 하며, 단일 스레드로 …","fields":{"slug":"/2024-03-17-이벤트루프와-ReactNative/"},"frontmatter":{"date":"March 17, 2024","title":"이벤트 루프 in React/React native 1편","tags":["성능","javascript","React","ReactNative","eventloop"]},"rawMarkdownBody":"\n[앞선 글](https://choi2021.github.io/2024-03-03-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/)을 통해 Promise.all는 자바스크립트의 **동시성**을 이용한 메소드임을 정리해보았다.\n이어서 자바스크립트에서 비동기 처리를 가능하게 하는 기본원리인 **이벤트 루프**를 React와 React Native 예제 코드와 함께 정리해보려 한다.\n\n## 🤔 이벤트 루프란?\n\n이벤트 루프는 자바스크립트에서 코드를 실행하고 이벤트를 처리하는 역할을 하며, **단일 스레드**로 동작하는 자바스크립트에서 **비동기 처리**를 가능하게 한다.\n이벤트 루프의 동작을 코드로 같이 정리해보자.\n\n## ⬇️ 동기 처리\n\n```javascript\nconst foo = () => console.log(\"First\")\nconst bar = () => console.log(\"Second\")\nconst baz = () => console.log(\"Third\")\n\nfoo()\nbar()\nbaz()\n```\n\n위 코드를 실행하면 First, Second, Third 순서로 출력이 된다. 이는 **동기적**으로 실행되는 코드로 자바스크립트는 기본적으로 코드를 위에서 아래로 **순서대로** 읽고 실행한다.\n\n## ⏩ 비동기 처리\n\n그러면 이제 비동기 함수들에 대해서 알아보자.\n\n### ⏩ 비동기 처리: callback 함수\n\n```javascript\nconst foo = () => console.log(\"First\")\nconst bar = () => setTimeout(() => console.log(\"Second\"), 0)\nconst baz = () => console.log(\"Third\")\n\nfoo()\nbar()\nbaz()\n\n// 결과\n// First\n// Third\n// Second\n```\n\n이러한 결과를 이해하기 위해 아래 시각화된 gif를 통해 함께 이해해보자.\n\n[참조: [✨♻️ JavaScript Visualized: Event Loop](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif)]\n![callback event loop](https://res.cloudinary.com/practicaldev/image/fetch/s--dhjH4Wt---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_800/https://devtolydiahallie.s3-us-west-1.amazonaws.com/gif14.1.gif)\n\n코드는 위에서 아래로 동일하게 위에서 아래로 순서대로 실행되지만,\n\n- foo()함수가 실행되고\n- bar()함수가 실행되면서 setTimeout가 실행된다. 이때 브라우저는 **비동기적으로 실행**되는 코드를 **task queue**에 넣는다.\n- baz()함수가 실행되고\n- 이때 call stack이 비어있으면 이벤트 루프는 task queue에 있는 코드를 call stack으로 옮겨 실행한다.\n\n이벤트 루프는 위와 같이 Network 요청, 이벤트 등과 같은 시간이 오래걸리는 작업을 진행할 때 오랜시간 스레드를 차지해 다음 작업을 처리하지 못하는 것을 방지해준다.\n\n### 🅾️ 비동기 처리: Callback의 무한 loop\n\n그러면 만약 callback 함수가 계속해서 쌓이게 되는 상황을 생각해보자. 이때 React와 React Native에서 이벤트 루프가 어떻게 동작할까?\n\nReact에서 콜백을 계속해서 만드는 예제로 두가지 상태를 이용한 예제 코드를 작성해봤다.\n\n- count: 버튼 클릭시 무한 루프로 콜백함수를 task queue에 쌓는 역할\n- value: input에 값을 입력해 리렌더링을 일으켜 JS 스레드 blocking을 확인하는 역할\n\n[React 코드]\n\n```tsx\nfunction App() {\n  const [value, setValue] = useState<string>(\"\")\n  const [count, setCount] = useState<number>(1)\n\n  const makeInfiniteCallback = () => {\n    setTimeout(() => {\n      setCount(prev => prev + 1)\n      makeInfiniteCallback()\n    }, 0)\n  }\n  const handlePress = () => {\n    makeInfiniteCallback()\n  }\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    console.log(e.target.value)\n    setValue(e.target.value)\n  }\n\n  return (\n    <div\n      style={{\n        justifyContent: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        gap: \"10px\",\n      }}\n    >\n      <input value={value} onChange={handleChange} />\n      <span>Count: {count}</span>\n      <button onClick={handlePress}>Click</button>\n    </div>\n  )\n}\n\nexport default App\n```\n\n<table >\n <tr>\n    <th>React 코드 실행 영상 with JS thread</th>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"./callbackloop-react.gif\" alt=\"RN 코드 실행 영상\" />\n    </td>\n  </tr>\n</table>\n\n영상속 이벤트 루프가 동작하고 있는 순서를 정리해보자.\n\n1. 버튼 클릭시 makeInfiniteCallback 함수가 실행된다.\n2. setTimeout이 실행되면서 task queue에 콜백함수가 쌓이게 된다.\n3. 이벤트 루프는 callstack이 비어있으면 queue되어 있는 콜백함수를 call stack으로 가져와 실행한다. (count 값이 1씩 증가)\n4. 이때 다시 callback 함수가 실행되면서 setTimeout이 실행되고 task queue에 쌓이게 된다. <br/> (무한 루프)\n5. 이 사이에 input에 값을 입력하면 상태를 업데이트하게 되고 업데이트된 상태를 이용해 일정 시간마다 다시 DOM을 그리는 과정이 진행된다. (리액트의 렌더링 과정)\n6. callStack에 쌓인 작업을 실행하면서 console을 찍고 화면을 리렌더링한다.\n7. 6번과정 이후 call stack이 비어있으면 다시 task queue에 있는 콜백함수를 call stack으로 옮겨 실행한다.\n8. 1~7까지의 과정을 반복한다.\n\n이를 통해 확인할 수 있는 것은 이벤트루프는 task Queue에 다른 작업이 queue되어 있더라도 **하나씩 callstack에 가져와서 처리**하기 때문에 JS 스레드가 멈추지 않고 계속해서 작동하는 것을 확인할 수 있다.\n\n추가적으로 RN에서도 확인해보면 리액트와 동일하게 작동하며 RN의 performance tool을 이용해 JS 스레드를 보았을 때도 멈추지않고 동작하고 있는 것을 볼 수 있다.\n\n[RN 코드]\n\n```tsx\nfunction App(): React.JSX.Element {\n  const [value, setValue] = useState(\"\")\n  const [count, setCount] = useState(1)\n  const makeInfiniteCallback = () => {\n    setTimeout(() => {\n      setCount(prev => prev + 1)\n      makeInfiniteCallback()\n    }, 0)\n  }\n  const handlePress = () => {\n    makeInfiniteCallback()\n  }\n\n  const handleChange = (text: string) => {\n    console.log(text)\n    setValue(text)\n  }\n\n  return (\n    <SafeAreaView\n      style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\" }}\n    >\n      <StatusBar barStyle={\"dark-content\"} />\n      <Button title={\"시작하기\"} onPress={handlePress} />\n      <TextInput\n        style={{\n          width: 200,\n          height: 40,\n          borderWidth: 1,\n          borderColor: \"black\",\n          margin: 10,\n          textAlign: \"center\",\n        }}\n        value={value}\n        onChangeText={handleChange}\n      />\n      <Text>{count}</Text>\n    </SafeAreaView>\n  )\n}\n\nexport default App\n```\n\n<table width=\"400\">\n <tr>\n    <th>RN 코드 실행 영상 with JS thread</th>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"./callbackloop-rn.gif\" alt=\"RN 코드 실행 영상\" />\n    </td>\n  </tr>\n</table>\n\n### ⏩ 비동기 처리: Promise\n\nPromise는 비동기 처리를 위한 객체로, 성공과 실패를 나타내는 상태와 성공시 결과값, 실패시 에러를 나타내는 값으로 이루어져 있다.\n이러한 상태에는 총 세가지가 있다.\n\n- Pending: 초기 상태\n- Fulfilled: 성공 상태\n- Rejected: 실패 상태\n\nPromise는 callback과 같이 비동기로 동작하지만 별도의 queue를 통해 동작한다. 이를 microtask queue라고 하며, 이벤트 루프는 task queue보다 먼저 실행된다.\n\n이제 코드를 통해 Promise의 비동기 처리과정을 알아보자.\n\n```javascript\nconsole.log(\"Start\")\n\nsetTimeout(() => console.log(\"TimeOut!\"), 0)\n\nPromise.resolve(\"Promise!\").then(res => console.log(res))\n\nconsole.log(\"End\")\n\n// 결과\n// Start\n// End\n// Promise!\n// TimeOut!\n```\n\n위 코드는 앞서 정리했던 콜백함수와 함께 Promise 코드를 처리하는 예제다. 결과를 아래 gif와 함께 분석해보자.\n\n[참조: [⭐️🎀 JavaScript Visualized: Promises & Async/Await](https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke)]\n\n#### 1. Start 출력\n\n이벤트 루프는 `console.log('Start')`를 call stack에 쌓고 JS 엔진이 읽어 `start` 로그가 찍힌다.\n\n<img src=\"./promise-start.gif\"/>\n\n#### 2. setTimeout 실행\n\n이벤트 루프는 다음줄을 call stack에 쌓고 실행된다. setTimeout의 callback은 task queue에 쌓이게 된다.\n\n<img src=\"./promise-timeout.gif\"/>\n\n#### 3. Promise 실행\n\n이벤트 루프는 Promise를 call stack에 쌓고 실행된다. Promise.resolve로 전달된 `Promise!`가 then 메소드로 전달된다. 이후 then의 callback은 microtask queue에 쌓이게 된다.\n\n<img src=\"./promise-promise.gif\"/>\n\n#### 4. End 출력\n\n이벤트 루프는 `console.log('End')`를 call stack에 쌓고 JS 엔진이 읽어 `End` 로그가 찍힌다.\n\n<img src=\"./promise-end.gif\"/>\n\n#### 5. Promise 출력\n\n이벤트 루프는 call stack이 비어있는지 확인하고 queue된 작업을 call stack으로 가져와 실행한다. 이때 **microtask Queue를 먼저** 확인해 Promise의 then 메소드로 전달된 callback을 call stack으로 가져온다.\n이후 콜백이 실행되면 `Promise!`가 출력된다.\n\n<img src=\"./promise-then.gif\"/>\n\n#### 6. setTimeout 출력\n\n이벤트 루프는 다시 call stack이 비어있는지 확인하고 queue된 작업을 call stack으로 가져와 실행한다. 이때 microtask Queue가 **완전히 비었는지** 확인한다.\nmicro task queue가 비었으므로 이제 **task Queue를 확인**해 setTimeout의 callback을 call stack으로 가져오고 실행한다.\n\n<img src=\"./promise-setTimeout.gif\"/>\n\n이러한 과정을 통해서 이루어지기 때문에 결과가 `Start -> End -> Promise! -> TimeOut!` 순서로 promise가 callback보다 먼저 출력되게 되었다.\n\n### 🅾️ 비동기 처리: Promise의 무한 loop\n\n이제 실제 React와 React Native에서 Promise를 사용하는 예제를 통해 이벤트 루프가 동작하는 것을 확인해보자.\n앞서 gif를 이용한 동작과정에 대해 알아보았을 때 Promise는 두가지 특징을 볼 수 있었다.\n\n- 별개의 microtask queue를 통해 동작한다.\n- task queue보다 우선순위가 높다.\n\n앞서 언급했지만 이벤트 루프가 Promise를 처리할 때 또다른 특징을 가진다. 이벤트 루프는 microtask queue에 쌓인 **모든 promise를 처리한 후에** 다시 돌기 시작한다.\n이를 알아보기위해 무한 loop되는 상황을 만들어 확인해보자.\n\n아래 코드는 위 callback 무한 루프와 동일한 예제로 callback을 Promise로만 바꾸어 동작시켜보려 한다.\n\n[React 코드]\n\n```tsx\nfunction App() {\n  const [value, setValue] = useState<string>(\"\")\n  const [count, setCount] = useState<number>(1)\n\n  const makeInfinitePromise = () => {\n    Promise.resolve().then(() => {\n      setCount(prev => prev + 1)\n      makeInfinitePromise()\n    })\n  }\n  const handlePress = () => {\n    makeInfinitePromise()\n  }\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    console.log(e.target.value)\n    setValue(e.target.value)\n  }\n\n  return (\n    <div\n      style={{\n        justifyContent: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        gap: \"10px\",\n      }}\n    >\n      <input value={value} onChange={handleChange} />\n      <span>Count: {count}</span>\n      <button onClick={handlePress}>Click</button>\n    </div>\n  )\n}\n\nexport default App\n```\n\n아래 영상을 보면 리액트 코드를 동작시켰을 때 다음과 같이 이벤트루프가 동작하게 된다.\n\n1. 버튼 클릭시 makeInfinitePromise 함수가 실행된다.\n2. Promise.resolve().then()이 실행되면서 microtask queue에 then 내부 콜백함수가 쌓이게 된다.\n3. 이벤트 루프는 callstack이 비어있으면 microtask queue에 있는 함수를 call stack으로 가져와 실행한다.\n4. 이때 다시 callback 함수가 실행되면서 Promise.resolve().then()이 실행되고 microtask queue에 쌓이게 된다. <br/> (무한 루프)\n5. 1번부터 4번까지의 과정이 반복된다.\n\n<table>\n <tr>\n    <th>React 코드 실행 영상 with JS thread</th>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"./promiseloop-react.gif\" alt=\"RN 코드 실행 영상\" />\n    </td>\n  </tr>\n</table>\n\n예제를 통해 microtask queue가 모두 비어질 때까지 계속해서 microtask queue의 작업을 하는 것을 알 수 있었다. 추가적으로 callback 때와 다르게 클릭 후 count가 올라가지 않는 모습을 보인다. 이는 then 콜백에 포함된 **set함수가 동작하지 않는 것처럼** 보인다.\n\n이부분을 이해하려면 리액트의 렌더링 과정에 대해 이해할 필요가 있다. set함수는 promise를 통해 계속해서 호출되어 V-DOM에 변경사항이 계산된다(render phase, reconciliation). 하지만 실제 DOM을 다시 그리는 과정(Commit phase)은 이벤트 루프가 microtask queue에 갇히게 되어 UI업데이트가 불가능하기 때문에 계산한 DOM을 실제 DOM에 반영하지 못하게 된다.\n이로인해 set함수가 동작하지 않는 것처럼 보이게 된다.\n\n유사한 코드를 RN에서는 어떻게 동작하는지 알아보자.\n\n[RN 코드]\n\n```tsx\nfunction App(): React.JSX.Element {\n  const [value, setValue] = useState(\"\")\n  const [count, setCount] = useState(1)\n  const makeInfinitePromise = () => {\n    Promise.resolve().then(() => {\n      setCount(prev => prev + 1)\n      makeInfinitePromise()\n    })\n  }\n  const handlePress = () => {\n    makeInfinitePromise()\n  }\n\n  const handleChange = (text: string) => {\n    console.log(text)\n    setValue(text)\n  }\n\n  return (\n    <SafeAreaView\n      style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\" }}\n    >\n      <StatusBar barStyle={\"dark-content\"} />\n      <Button title={\"시작하기\"} onPress={handlePress} />\n      <TextInput\n        style={{\n          width: 200,\n          height: 40,\n          borderWidth: 1,\n          borderColor: \"black\",\n          margin: 10,\n          textAlign: \"center\",\n        }}\n        value={value}\n        onChangeText={handleChange}\n      />\n      <Text>{count}</Text>\n    </SafeAreaView>\n  )\n}\n\nexport default App\n```\n\n<table width=\"400\">\n <tr>\n    <th>RN 코드 실행 영상 </th>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"./promiseloop-rn.gif\" alt=\"RN 코드 실행 영상\" />\n    </td>\n  </tr>\n</table>\n\nReact Native는 Main 스레드와 JS 스레드가 **비동기적으로** 소통하며 동작하기 때문에 JS 스레드가 무한루프에 빠져도 Main 스레드가 동작할 수 있어 TextInput에 값을 입력할 수 있었다.\n하지만 JS 스레드는 동일하게 **microtask queue에 머물러있기 때문에** JS 스레드의 프레임 측정이 불가능해지고 TouchableOpacity의 애니메이션도 돌아오지 않는 것을 볼 수 있다.\n\n이를 통해 Promise는 callback과 다르게 **microtask queue**를 통해 동작하며, 이벤트 루프는 **microtask queue에 쌓인 모든 작업을 처리한 후에** 다시 돌기 시작한다는 것을 확인할 수 있다.\n"},{"excerpt":"🙄 자바스크립트가 병렬처리? 아마 작년 말부터 2월까지 작업했던 작업 중 가장 많이 한 작업 중 하나가 순차적으로 진행되는 비동기 코드를 Promise.all()을 이용해 한번에 동작할 수 있게 최적화하는 작업이었다.\n사람들에게 말할 때는 라고 표현하곤 했지만 내안에 어색함이 느껴졌다. 에 대한 질문을 찾아갔던 과정을 정리해보려 한다. 🤔 자바스크립트 엔…","fields":{"slug":"/2024-03-03-자바스크립트의-동시성-이해하기/"},"frontmatter":{"date":"March 03, 2024","title":"Promise.all의 동시성 이해하기","tags":["javascript","성능"]},"rawMarkdownBody":"\n## 🙄 자바스크립트가 병렬처리?\n\n아마 작년 말부터 2월까지 작업했던 작업 중 가장 많이 한 작업 중 하나가 순차적으로 진행되는 비동기 코드를 Promise.all()을 이용해 한번에 동작할 수 있게 최적화하는 작업이었다.\n사람들에게 말할 때는 `병렬처리`라고 표현하곤 했지만 내안에 어색함이 느껴졌다. `자바스크립트는 싱글스레드 언어인데 어떻게 여러가지 일을 동시에 처리하는 걸까`에 대한 질문을 찾아갔던 과정을 정리해보려 한다.\n\n### 🤔 자바스크립트 엔진의 동작 파헤쳐보기\n\n자바스크립트는 싱글 스레드 언어다. 이말의 의미는 한번에 하나의 일만 할 수 있게 설계되어 있는 언어로 이벤트 루프를 이용해 call stack으로 들어온 하나의 일만 한번에 처리할 수 있다. 그러면 어떻게 `Promise.all([...])` 같은 코드를 통해 **동시에 여러가지 일을 동시에 처리하는 것**이 가능할까.\n\n#### Sequence vs Parallel vs Concurrent\n\n자바스크립트에서 여러가지 일을 동시에 처리하는 것에 대해 정확하게 이해하기 위해서는 **Sequence, Parallel, Concurrent**의 차이를 이해해야 한다.\n\n- **Sequence**: 순차적으로 실행되는 것을 의미한다. A -> B -> C 순서대로 실행되는 것을 의미한다.\n- **Parallel**: 말그대로 동시에 실행되는 것을 의미한다. A, B, C가 동시에 실행되는 것을 의미한다.\n- **Concurrent**: 병렬적으로 실행되는 것처럼 보이지만, 실제로는 동시에 실행되지 않는 것을 의미한다. A, B, C가 동시에 실행되는 것처럼 보이지만, 실제로는 A가 실행되고, B가 실행되고, C가 실행되는 것을 의미한다.\n\n![출처: [Does Promise.all Execute in Parallel? How Promise.all Works in JavaScript](https://javascript.plainenglish.io/does-promise-all-execute-in-parallel-how-promise-all-works-in-javascript-fffc2e8d455d)](sequential-concurrent-parallel.png)\n\n따라서 위 정의에 따라 자바스크립트가 여러가지 일을 동시에 처리할 수 있다는 것의 의미가 parallel이라면 실제로 여러가지 일을 동시에 실행하는 것으로, concurrent하다면 순차적으로 진행하지만 빠르게 진행되기에 동시에 진행되는 것처럼 보인다고 할 수 있다. parallel과 concurrent 두가지 동작 중 어떤 게 맞는지 확인하기 위해 예를 들어, 코드와 함께 알아보자.\n\n자바스크립트 스레드를 웨이터로 예를 든다면 다음과 같이 정리할 수 있다.\n\n- **Sequence**: 웨이터가 하나의 테이블에 대해 주문을 받고 음식이 나오면, 다음 테이블에 대해 주문을 받는 것을 의미한다.\n- **Parallel**: **여러 웨이터**가 여러 테이블에 대해 동시에 주문을 받고 동시에 음식이 나오는 것을 의미한다.\n- **Concurrent**: 한명의 웨이터가 여러 테이블의 주문을 **순서대로** 받고 주문을 넣지만 빠르게 이 과정이 진행되다 보니 여러 테이블의 대한 음식이 `거의 동시`에 나오는 것을 의미한다.\n\n그러면 예제 코드를 이용해 위 세가지 상황에 대해 확인해보자. 아래 코드는 `orderAndServe`라는 함수를 이용해 테이블에 대한 주문을 받고 음식을 서빙하는 코드이다.\n\n```javascript\nfunction orderAndServe(startTime, ms, tableNumber) {\n  console.log(`테이블 ${tableNumber} 도착 - ${new Date() - startTime}ms`)\n  return new Promise(resolve => {\n    console.log(`테이블 ${tableNumber} 주문 받음 - ${new Date() - startTime}ms`)\n    return setTimeout(() => {\n      resolve(tableNumber)\n    }, ms)\n  }).then(number => {\n    console.log(\n      `테이블 ${number} ${ms}ms 후 음식 나옴 - $${new Date() - startTime}ms`\n    )\n  })\n}\n\nasync function sequenceRun(startTime) {\n  await orderAndServe(startTime, 1000, 1)\n  await orderAndServe(startTime, 1000, 2)\n}\n\nasync function concurrentOrParallelRun(startTime) {\n  await Promise.all([\n    orderAndServe(startTime, 1000, 1),\n    orderAndServe(startTime, 1000, 2),\n  ])\n}\n```\n\n만약 자바스크립트가 `Parallel`하게 동작하다면 두가지 가정을 해볼 수 있다.\n\n- 실행할 때 마다 끝나는 테이블의 순서가 다를 수 있다. 독립적인 스레드에서 진행되기 때문에 결과의 순서가 보장되지 않을 수 있다.\n- 각 테이블에 도착하는 시간, 주문을 받는 시간, 음식이 나오는 시간이 같다.\n\n<table width=\"100%\" >\n    <tr>\n        <th>Sequential</th>\n        <th>Concurrent</th>\n     </tr>\n  <tr>\n    <td><img src=\"sequential.png\"></td>\n    <td><img src=\"concurrent.png\"></td>\n   </tr>\n  </tr>\n</table>\n\n위 사진은 두가지 테이블에 대해서 각 함수를 실행한 결과로, `sequential`처럼 항상 테이블1에서 테이블 2로 같은 순서로 진행되는 것을 볼 수 있다.\n\n위 가정했던 두가지 중 parallel 하다는 가정의 첫번째가 어긋난 것을 볼 수 있다. 하지만 두 번째 가정이었던 테이블별 도착, 주문, 서빙 시간이 같다는 가정은 맞는 것을 볼 수 있다.\n그러면 조금 더 많은 테이블을 서빙하게 해보자\n\n```javascript\nfunction orderAndServe(startTime, ms, tableNumber) {\n  console.log(`테이블 ${tableNumber} 도착 - ${new Date() - startTime}ms`)\n  return new Promise(resolve => {\n    console.log(`테이블 ${tableNumber} 주문 받음 - ${new Date() - startTime}ms`)\n    return setTimeout(() => {\n      resolve(tableNumber)\n    }, ms)\n  }).then(number => {\n    console.log(\n      `테이블 ${number} ${ms}ms 후 음식 나옴 - $${new Date() - startTime}ms`\n    )\n  })\n}\nconst tables = Array.from({ length: 10 }, (_, i) => i + 1)\n\nasync function concurrentOrParallelRun(startTime) {\n  await Promise.all(\n    tables.map(tableNumber => orderAndServe(startTime, 1000, tableNumber))\n  )\n}\nconcurrentRun(new Date())\n```\n\n아래 사진은 위 10개의 테이블에 대한 코드를 실행한 결과다. 아래결과를 보면 테이블 1부터 10까지 순서가 유지되고, 테이블별 각 동작 완료시간의 차이가 나는 것을 볼 수 있다.\n\n![테이블이 10개일 때 결과](moretable.png)\n\n이를 통해 `Promise.all()`은 병렬적(parallelism)으로 처리하는 것이 아니라 자바스크립트의 **동시성**(concurrency)을 이용해 순차적으로 진행하지만 빠르게 진행함으로서 성능의 이점을 얻을 수 있는 메소드임을 알 수 있었다.\n\n## 번외: 병렬을 지원하면 결과가 어떻게 달라질까\n\n내가 했던 parallelism에 대한 두가지 가정이 실제 병렬 처리 지원하는 언어에서 유의미하게 동작하는지에 대해 알아보고자 ChatGPT를 이용해 `Go`언어로 유사한 코드를 작성해보았다.\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc orderAndServe(startTime time.Time, ms time.Duration, tableNumber int, wg *sync.WaitGroup) {\n\tdefer wg.Done() // 이 함수가 끝나면 WaitGroup의 카운터를 감소시킨다.\n\n\tfmt.Printf(\"테이블 %d 도착 - %vms\\n\", tableNumber, time.Since(startTime).Milliseconds())\n\tfmt.Printf(\"테이블 %d 주문 받음 - %vms\\n\", tableNumber, time.Since(startTime).Milliseconds())\n\ttime.Sleep(ms)\n\tfmt.Printf(\"테이블 %d %vms 후 음식 나옴 - %vms\\n\", tableNumber, ms.Milliseconds(), time.Since(startTime).Milliseconds())\n}\n\nfunc main() {\n\tstartTime := time.Now()\n\tvar wg sync.WaitGroup\n\n\t// 10개의 테이블에 대해 병렬로 처리\n\tfor i := 1; i <= 10; i++ {\n\t\twg.Add(1) // WaitGroup의 카운터를 증가시킨다.\n\t\tgo orderAndServe(startTime, 1000*time.Millisecond, i, &wg)\n\t}\n\n\twg.Wait() // 모든 고루틴이 완료될 때까지 기다린다.\n}\n```\n\n위 코드는 go언어로 작성한 코드로, `sync.WaitGroup`을 이용해 병렬로 함수를 진행시켰다. 아래는 위 코드를 실행한 결과다.\n\n![go언어로 작성한 코드 결과](goresult.png)\n\n결과를 보면 테이블 도착과 주문받음까지 진행 순서가 테이블 1부터 진행하지 않고 (첫번째 가정의 독립적인 스레드), 완료한 시간을 보면 동일하게 처리된 것 (두번째 가정의 같은 시간에 완료)을 볼 수 있었다.\n이를 통해 앞선 두가지 가정이 병렬처리가 가능한 언어의 특징을 잘보여주는 가정이었고, Promise.all()은 병렬적으로 처리하는 것이 아니라 자바스크립트의 **동시성**을 이용하는 메소드임을 한번 더 확인할 수 있었다.\n\n[참조]\n\n- [Does Promise.all Execute in Parallel? How Promise.all Works in JavaScript](https://javascript.plainenglish.io/does-promise-all-execute-in-parallel-how-promise-all-works-in-javascript-fffc2e8d455d)\n- [Speed up your code with Promise.all](https://dev.to/dperrymorrow/speed-up-your-code-with-promiseall-3d4i)\n"},{"excerpt":"🙊 개발자로 일한지 1년이 되다니... 2월은 회사에 입사해 만 1년이 되는 달이었다. 벌써 1년이 되다니, 1년간의 시간 동안 내가 어떤 일을 했고, 어떤 성과를 만들었는지 나와 동료, 회사의 평가를 통해 되돌아 볼 수 있는 시간이었다. 1년간의 나를 되돌아보면서 나에 대해서 리브랜딩(?) 또한 필요하다고 생각이 들어, 블로그를 이전하고 이력서도 새롭게…","fields":{"slug":"/2024-03-02-2024년-2월회고/"},"frontmatter":{"date":"March 01, 2024","title":"🙊 2024년 2월회고","tags":["회고"]},"rawMarkdownBody":"\n## 🙊 개발자로 일한지 1년이 되다니...\n\n2월은 회사에 입사해 만 1년이 되는 달이었다. 벌써 1년이 되다니, 1년간의 시간 동안 내가 어떤 일을 했고, 어떤 성과를 만들었는지 나와 동료, 회사의 평가를 통해 되돌아 볼 수 있는 시간이었다.\n\n1년간의 나를 되돌아보면서 나에 대해서 **리브랜딩**(?) 또한 필요하다고 생각이 들어, 블로그를 이전하고 이력서도 새롭게 작성했고, 이와 함께 더 다양한 시야를 갖기 위해 커뮤니티 활동에 참여하기도 했다. 1년 중 가장 짧은 달이지만 회사 내외적으로 나름 다사다난했던 2월을 되돌아 보려 한다.\n\n## 😍 Gatsby로 블로그 이전하기\n\n블로그 이전은 사실 오랜기간 고민해왔던 일이었다. 기존에 Jekyll로 만들어진 블로그의 디자인은 괜찮긴 했지만, ruby 언어로 작성되어 커스텀을 위해 학습비용이 크다는 점과 상대 경로를 제대로 이해하지 못하는 이슈 등이 있어 2024년에는 꼭 이전해야겠다는 목표를 세웠다.\n\n세웠던 목표는 1년치 계획이었는데... 2월에 회사에 입사한지 1년이 된 겸, 깃허브 프로필에도 걸려있는 블로그가 **내 얼굴**과 같다는 생각이 들어 블로그 이전을 실행에 옮기게 되었다.\n\n블로그 이전은 해야겠는데... 마땅한 플랫폼이 떠오르지 않았다. 내가 직접 만드는 방법도 좋은 경험이 되겠지만, `글을 작성하는 것` 자체에 더 초점을 맞출 수 있게 플랫폼을 먼저 알아보자는 맘이 들어 이것저것 찾아보기 시작했다.\n\n다행히 나처럼 고민하시는 분들이 많았는지 개발자 블로그 플랫폼에 대해 비교하는 다양한 글들을 볼 수 있었다. 티스토리, Velog, wordpress 등의 플랫폼들은 이전에 이미 작성해놓은 글들을 이전하는 작업에 많은 수고가 필요하다는 점과 내가 직접 커스텀할 수 없다는 단점이 크게 작용해 다른 방법은 없을까 고민하게 된다.\n\n그러던 중 우연히 페이스북에서 만든 리액트를 이용한 문서화 서비스인 [Docusaurus](https://docusaurus.io/)에 대한 글들을 접하게 되었다. Docusaurus는 리액트를 이용하다 보니 기존 내가 알고 있는 지식을 이용해 커스텀이 가능했고, 마크다운 형식으로 작성된 글을 그대로 복사/붙여넣기만 하면 해당 글을 분석해 페이지형식으로 만들어 줄 수 있었다. React Native 공식문서에도 쓰이고 있고, 실제 블로그 마이그레이션 후기 글들도 있어 공식문서를 읽으면서 작업을 시작하게 되었다.\n\n### Docusaurus로 블로그 이전하기\n\n![컨텐츠에만 집중하라니 너무 좋은데?](docusaurus.png)\n\nDocusaurus는 markdown으로 작성된 글을 커스텀 디자인, SSG(Static-Site generator)를 이용해 성능이 높은 페이지를 만들어 준다. Docusaurus 내부에는 총 두가지로 컨텐츠를 구분할 수 있는데, 하나는 Docs로 기술 문서를 작성하는 형식으로 버전별 문서관리가 필요하거나, 주제별 하위 컨텐츠 분류 등을 적용할 때 사용할 수 있어 보였고, 다른 하나는 Blog로 블로그 형식의 글을 작성할 수 있게 해준다.\n\n나는 블로그용으로 사용하려 하기 때문에 Blog에 대한 세팅을 하고 프로젝트에 이전에 작성해둔 마크다운 파일들을 옮겨 이전을 하기 시작했다. 세팅을 하고 보니 Docusaurus 블로그 자체적인 아쉬운 점이 눈에 보이기 시작했다.\n\n기술 블로그는 시리즈로 연속된 게시물들을 보여주는게 필요한데, Docusaurus는 해당 기능을 Blog에서 지원하지 않았고, 각 주제에 따라 몇개의 글이 작성되었는지를 알 수 없다는 점이 아쉬웠다. 블로그 이전을 참고했던 [parkgang.log님 블로그](https://parkgang.github.io/2021/12/31/2021%EB%85%84-12%EC%9B%94-%ED%9A%8C%EA%B3%A0.html)에서는 회고와 같은 글을 Blog로, 기술적인 내용은 docs로 분류해 주제별 글을 정리해두셨지만, 똑같이 적용하기 전 \"그래도 내맘에 쏙드는 다른 플랫폼은 없을까\" 마지막으로 찾는 과정에서 **Gatsby**를 발견하게 된다.\n\n### Gatsby로 블로그 이전하기\n\n![Gatsby 메인화면](gatsby.png)\nGatsby 또한 Docusaurus와 같이 SSG를 이용해 정적 페이지를 만드는 데 최적화된 플렛폼으로 리액트로 작성되어있다. Docusaurus와 동일하게 마크다운 파일을 페이지로 만들어 주기 때문에 쉽게 이전이 가능하고, Docusaurus 블로그를 사용하시는 분들을 찾는 것보다 더 다양한 개발자분들이 사용하고 있는 점도 좋았다.\n\n`왜 많은 사람들이 Gasby를 블로그로 많이 사용할까?`에 대해 생각해보았을 때, Gasby는 블로그 플러그인을 통해 마음에 드는 디자인과 구성을 템플릿으로 사용할 수 있게 제공하고 있었고, 원하는 기능들을 플러그인으로 연결할 수 있는 점이 좋아보였다. Jekyll 블로그 때와 같이 어떤 디자인으로 블로그를 만들면 좋을까 고민하다가 devHudi라는 분께서 만들어 두신 [gatsby-starter-hoodie](https://github.com/devHudi/gatsby-starter-hoodie)라는 플러그인이 마음에 들어 현재 블로그로 이전하게 되었다.\n\nGatsby로 이전하는 과정에서 블로그 글들을 다시 한번 읽으며 내가 `이때는 이런 걸 어려워했구나`라는 생각과 `1년사이 많이 성장했구나`라는 생각이 들었다. 한편 **내가 블로그 관리를 소홀히 했구나**를 여실히 느낄 수 있었는데, 참조로 한 글이나 이미지가 사라져서 보이지 않거나, 상대경로가 잘못되어있는 경우도 보였다...\n상대주소와 Jekyll 때 깃허브에 올려서 정리했던 이미지 주소들을 로컬주소로 변경하는 등의 작업을 진행하고 **GA(Google Analytics)**와 **utterance를** 통한 댓글도 적용해보았다. 이후에 방명록, 방문자 수 등의 기능을 추가하고 계속해서 나의 성장과정을 잘 보여줄 수 있게 가꿔나가야겠다.\n\n## 🤿 프론트엔드 다이빙 클럽\n\n2월에는 회사 밖, 커뮤니티 활동에도 관심을 갖고 있었는데 링크드인 게시글을 보고 토스에서 운영하는 프론트엔드 커뮤니티인 `프론트엔드 다이빙 클럽`에 지원하게 되었다. 사실 이전에도 [토스 블로그의 소개 글](https://toss.tech/article/frontend-diving-club)을 보면서 다양한 회사의 각자의 문제를 풀고 계시는 프론트엔드 개발자분들과 이야기를 나눠보고 싶고, 내가 가진 시야를 넓혀주는 좋은 기회가 되지 않을까라는 생각에 지원했지만 떨어졌었다. 이번엔 정말 운좋게 참여하는 기회를 얻어 `개발환경 개선`이라는 주제로 참여하게 되었다.\n\n가서 어떤 이야기를 하게 될까, 아는 사람이 아무도 없을텐데... 별의 별 고민을 하면서 참여했지만 금새 적응해 편하게 이야기할 수 있었다. 조원분들은 내가 생각했던대로 다양한 회사에서 오셨고, 다양한 관심사를 가지고 계셨다. 신기했던 부분은 대부분 조원분들이 `모노레포`에 대한 관심을 많이 가지고 계셨던 점이었다 모노레포로 된 프로젝트 경험이 없던 나에게는 모노레포가 어떤 문제를 해결하기 위한 기술인지, 왜 좋은 건지 등 배경이 없다보니 같이 많은 이야기를 할 수는 없었지만 **좋은 키워드**를 얻어가는 시간이었다.\n\n![명찰과 굿즈](goods.png)\n\n조원분들과 신나게 이야기하던 중에 세션시간이 시작되었는데 첫번째 주제는 **모노레포 파이프라인 최적화**에 대해, 두번째 주제는 **생산성 높게 API 호출하는 방법**에 대한 주제로 발표를 해주셨다.\n\n첫번째 발표를 들으면서 처음 들었던 생각은 \"패키지 관리에 사람들이 정말 많은 관심을 가지고 있구나\"였다. 직전에 조원분들간의 이야기 주제도 발표주제도 모노레포로 서비스를 잘 운영하는 방법이다 보니 더 확 느껴졌다.\n\n발표내용중 놀랐던 점은 yarn을 이용한 **zero install**을 사용할 경우 node_modules에 설치되는 패키지를 모두 함께 올려두게 된다는 점이었다. repository에 올라와있는 파일 자체가 엄청나게 크기 때문에 이를 clone하고 checkout하는 과정 자체의 시간이 오래걸릴 수 있다는 문제가 있었고, 이를 해결하기 위해 circle CI의 config등을 통해 병렬화 또는 배포시간 단축 등에 대해 이야기해주셨다. 패키지를 올리지않고 repo를 가져온 다음에 매번 패키지를 설치하는 게 당연했던 나에게 새로운 이야기였다.\n\n프론트엔드에서 플랫폼적으로 문제를 해결해나가는 모습을 보며 `CI/CD 과정에서도 기술적으로 해결하나가야할 재밌는 문제들이 많이 있구나`를 느낄 수 있었고 우리 팀 프로젝트의 CI/CD중에서 내가 개선할 수 있는 부분은 없을까 고민하는 좋은 시간이 되었다.\n\n두번째 발표는 기능을 구현하는 과정에서 겪을 수 있는 서버의 API와 프론트엔드 코드가 강결합이 되어 있을 때 발생할 수 있는 여러가지 문제를 예시로, 프론트엔드 자체적인 interface를 구현해 어떻게 일정에 맞게 또 안전하게 프론트엔드 코드를 지킬 수 있을지에 대한 내용이었다. 들으면서 우리 프로젝트의 아키텍처 구조에서 Repository 패턴이 동일한 역할을 하고 있고 덕분에 API가 나오지 않았을 때도 API 명세만 알면 병렬로 프론트엔드 코드를 작성할 수 있었던 점이 떠올랐다.\n\n발표가 끝나고 나서는 뒷풀이에도 참여해 같은 조가 아니었던 분들과도 이야기하며 다양한 연차와 경험을 가지신 분들의 이야기를 들을 수 있었다. 만나는 분마다 느꼈던 점은 여기에 모이신 분들은 모두 금요일 저녁에 퇴근 후 모여서 개발얘기를 하고 싶을 만큼 **개발을 너무 좋아하시는 분들이라는 것** 그리고 **더 많이 배우고 성장하고 싶어하시는 분**들이라는 것을 느낄 수 있었다. 처음 참석한 커뮤니티 자리였지만 너무 좋은 영향과 열정을 느낄 수 있었던 시간이었다.\n\n## 😆 마무리\n\n블로그를 이전하면서 기술적인 주제에 대한 이야기와 회사 업무를 진행하면서 해결해간 기술적인 문제에 대한 이야기는 **분리하는 게 좋지 않을까**라는 생각이 들었다. 그래서 앞으로는 회고에는 한달간 공부한 내용들에 대해, 개인적인 이야기를 작성하고, 기술적인 내용은 다른 글로 분리해 조금 더 작성해보려 한다. 앞으로 회고에 쓸 내용이 없으면 어쩌나 고민도 되지만... 오히려 더 부지런하게 기술적 주제에 대한 글을 작성하고 요약하는 방식으로 작성하면 되지않을까 싶다.\n그래서 2월동안 진행했던 에러바운더리 적용 작업과 App Start 시간 줄이기 작업에 대한 내용은 다음 글에서 작성해보려 한다.\n\n2월 한달간도 다양한 경험이 가득한 알찬 시간, 내 자신에 대해 고민하고 다음 1년에 대해 고민하는 좋은 시간이었던 것 같다. 3월은 또 어떤 일이 기다리고 있을지 기대하며 더 열심히 달려보자.\n"},{"excerpt":"1월에는 스쿼드에서 챕터로 소속이 바뀌면서 업무가 기능개발에서, 성능을 최적화하고 안정성을 높이기 위한 업무들이 주를 이루게 되었다.\n크게 집중해서 진행했던 업무는 시간을 최적화와 이었다. 두 가지 챕터 업무와 함께 불필요한 API 호출을 감지하는 방법에 대해 고민하고 해결방법을 찾아 적용해보았다. 1월 업무를 새롭게 배우게 된 점과 느꼈던 점들을 간단히…","fields":{"slug":"/2024-02-07-2024년-1월회고/"},"frontmatter":{"date":"February 07, 2024","title":"🐥 2024년 1월회고","tags":["회고"]},"rawMarkdownBody":"\n1월에는 스쿼드에서 챕터로 소속이 바뀌면서 업무가 기능개발에서, 성능을 최적화하고 안정성을 높이기 위한 업무들이 주를 이루게 되었다.\n크게 집중해서 진행했던 업무는 `App Start`시간을 최적화와 `에러바운더리 적용`이었다. 두 가지 챕터 업무와 함께 **불필요한 API 호출을 감지하는 방법**에 대해 고민하고 해결방법을 찾아 적용해보았다.\n\n1월 업무를 새롭게 배우게 된 점과 느꼈던 점들을 간단히 정리해보려 한다.\n\n### ⚠️ 불필요한 API 호출을 감지해보자\n\n불필요한 API를 줄이는 것은 서비스를 이용하는 고객의 사용성을 높이고, 서버의 부하를 줄일 수 있는 두 가지 장점이 있다.\n그 중요성을 저번 견적 발송 시간을 줄이면서 느끼고 개발단계에서 아는 방법이 없을지 고민했고, 이것을 해결하는 방법으로 **axios interceptor**를 이용해보기로 했다.\n\n#### axios interceptor\n\naxios interceptor는 axios의 요청과 응답을 가로채는 기능이다. 이를 이용해 요청과 응답에 대한 로직을 추가할 수 있어 공통적인 요청과 응답에 대해 처리를 할 수 있다.\n\n[axios interceptor 공식문서 예시 코드]\n\n```javascript\n// Add a request interceptor\naxios.interceptors.request.use(\n  function (config) {\n    // Do something before request is sent\n    return config\n  },\n  function (error) {\n    // Do something with request error\n    return Promise.reject(error)\n  }\n)\n\n// Add a response interceptor\naxios.interceptors.response.use(\n  function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response\n  },\n  function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error)\n  }\n)\n```\n\n이러한 기능을 이용해 구현한 중복 API를 체크하기 위한 코드는 아래와 같다.\n\n[axios interceptor를 이용한 중복 API 체크 interceptor]\n\n```typescript\nconst requestMap = new Map<string, { lastTime: number; count: number }>()\n\nconst 중복체크_request_interceptor = async (\n  config: InternalAxiosRequestConfig\n) => {\n  const { method, url, params, data } = config\n  const requestKey = `${method?.toUpperCase()} ${url} ${JSON.stringify(\n    params\n  )} ${JSON.stringify(data)}`\n\n  const request = requestMap.get(requestKey) ?? { lastTime: 0, count: 0 }\n  const now = Date.now()\n  if (request.lastTime === 0 || now - request.lastTime > 1000) {\n    requestMap.set(requestKey, { lastTime: now, count: 1 })\n  } else {\n    requestMap.set(requestKey, { lastTime: now, count: request.count + 1 })\n    console.warn(\n      `${method?.toUpperCase()} ${url} 반복 요청 ${request.count + 1} times`\n    )\n  }\n  return config\n}\n```\n\n위와 같이 interceptor를 통해 들어온 요청 정보를 key로 한 Map에 기록하고 중복 API라고 볼 수 있는 것의 기준은 우선 1초 정도로 정해보기로 했다. 이렇게 구현하고 나면 다음과 같이 warning이 찍히는 것을 볼 수 있다.\n\n[warning으로 찍힌 중복호출 로그]\n\n![중복호출로그](중복호출로그전.png)\n\n구현하고 나니, 실제로 발생하고 있는 API들을 찾을 수 있었는데, 중복 API가 발생할 때마다 찍히다 보니 **로그가 너무 많이 찍히는** 문제가 있었다. 이를 해결하기 위해서 간단하게 debounce를 이용해 logging 코드를 감싸주었다.\n\n[debounce를 적용한 중복 API 체크 interceptor]\n\n```typescript\nconst notify = debounce(({ method, url, count }) => {\n  console.warn(`${method?.toUpperCase()} ${url} 반복 요청 ${count + 1} times`)\n}, 1000)\n\nconst requestMap = new Map<string, { lastTime: number; count: number }>()\n\nconst 중복체크_request_interceptor = async (\n  config: InternalAxiosRequestConfig\n) => {\n  const { method, url, params, data } = config\n  const requestKey = `${method?.toUpperCase()} ${url} ${JSON.stringify(\n    params\n  )} ${JSON.stringify(data)}`\n\n  const request = requestMap.get(requestKey) ?? { lastTime: 0, count: 0 }\n  const now = Date.now()\n  if (request.lastTime === 0 || now - request.lastTime > 1000) {\n    requestMap.set(requestKey, { lastTime: now, count: 1 })\n  } else {\n    requestMap.set(requestKey, { lastTime: now, count: request.count + 1 })\n    notify({ method, url, count: request.count })\n  }\n  return config\n}\n```\n\n[하나만 찍히는 로그]\n\n![중복호출로그](중복호출로그후.png)\n\n구현 후, 개발과정에서 중복 호출되는 API들을 확인할 수 있었고, 이를 통해 실제로 어떤 화면에서 발생하고 있는지 알 수 있었다.\n조금 아쉬운 점은 개발환경에서 인지하고 싶어서 추가한 코드이지만 우리 프로젝트 코드에 추가되기보다 debugger에 표기되는 게 더 좋아 보였다.\n\n이후에 RN 디버거를 분석해보면서 해당 기능을 만들어보는 것도 좋을 것 같다.\n\n### 🛫App Start 시간 줄이기\n\n챕터로 소속이 변경되고 24년 1분기 모바일 챕터 목표로 **App Start 시간 단축** 일감을 담당하게 되었다. 기존에 측정하고 있던 기준은 최상위 파일인 App.tsx가 렌더링 된 이후 부터 Splash을 거쳐 홈화면에 진입하기까지였다.\n\n#### 측정 기준 잡기\n\n가장 먼저 시도한 방법은 네트워크 적 병목이 있는지 체크함으로써 불필요한 API들은 제거하고 차례로 진행되고 있는 병목지점들을 병렬화함으로써 시간을 단축하려 했다.\n\n홈화면에 들어가기 전에 주요하게 진행해야 할 프로세스는 세 가지로 다음과 같이 정리할 수 있다.\n\n- 앱 버전 체크 및 업데이트\n- 인증토큰을 이용한 로그인\n- 로그인 후 초기화 작업\n\n위 세 가지가 모두 완료되고 나서 홈 화면으로 이동할 수 있기 때문에 이 세 가지 프로세스가 모두 완료되는 데까지 걸리는 시간을 측정하기로 했다. 그리고 각 스텝의 완료지점에 checkpoint를 주어 얼마의 시간이 걸리는지 정보를 추가했다.\n\n[중요 지점에 체크포인트를 반영된 Splash 화면 코드]\n\n```javascript\nconst 초기화_실행 = async () => {\n  try {\n    await 토큰가져오기()\n    performanceTracker.addCheckPoint(\"인증토큰 가져오기\")\n\n    await 업데이트버전체크()\n\n    const deepLink = await 딥링크_정보가져오기()\n    performanceTracker.addCheckPoint(\"딥링크 정보 가져오기\")\n\n    await 로그인()\n    performanceTracker.addCheckPoint(\"토큰 기반 로그인\")\n\n    await tracker.stopTrace(\"기존_trace_측정_완료\")\n    await 홈_화면으로_이동(deepLink)\n    performanceTracker.addCheckPoint(\"홈 화면 이동\")\n\n    await 초기화작업1()\n    // ...\n    await 초기화작업N()\n    await tracker.stopTrace(\"새로운 trece_측정_완료\")\n  } catch (error) {\n    에러핸들링_및_로깅()\n  }\n}\n```\n\n위 코드에서 새로운 trace를 추가한 이유는 **초기화가 모두 완료되는 데까지** 시간을 알고 싶었다. 홈 화면으로 이동시키고, 이후에 일부 초기화 작업이 진행되고 있어, 화면전환이 응답속도보다 빠른 경우는 깜빡이거나 layout shift가 발생하고 있다는 점을 발견하게 되어 모두 완료하는 게 유저 경험에 더 좋을 것 같았다.\n그래서 우선 전체 초기화를 완료하는 데 필요한 시간을 함께 보고자 했다.\n\n현재 추가한 중간지점들의 데이터를 IOS 90% 유저 기준으로, 다음과 같이 데이터를 쌓아볼 수 있었다.\n\n- 인증토큰 가져오기: 1.6초 (최상위 App.tsx를 렌더링한 후부터 Splash 화면에 진입한 후에 인증토큰을 가져오기까지)\n- 딥링크 불러오기: 3초 (버전 체크, 딥링크 정보 불러오기까지)\n- 토큰 기반 로그인: 5.8초 (로그인+ 일부 로그인 후 작업까지)\n- 홈 화면 이동: 6.3초 (로그인 후 홈 화면으로 이동하기까지)\n\n위 측정결과를 보고 먼저 **딥링크 정보를 불러오고 나서 화면 이동까지**의 시간을 단축해 보려 했다. 이를 위해서 **유저 타입**을 기준으로 초기화 작업을 진행할 수 있게 리팩토링했다.\n\n**유저타입**을 중점으로 생각했던 이유는 두 가지로, 먼저 유저타입별로 초기화 작업을 위한 API 호출 횟수가 달랐다. 비회원/고객/고수 모두가 사용하는 공통 초기화 로직, 고객과 고수만을 위한 초기화 로직, 고수만을 위한 초기화 로직 총 세 가지로 구분할 수 있었고, 유저가 고수라면 세 가지 모두를 진행해야 해서 가장 시간이 오래 걸리는 유저 타입으로 예상되었다.\n\n두번째로는 기존에는 로그인 함수 내부에 일부 초기화 작업이 포함되어있거나 초기화 작업 각각 내부에서 로그인 여부 또는 유저 타입을 체크해 실행하게 되어 있었던 것을 타입별로 묶어 병렬처리할 수 있어보였다.\n\n##### 유저타입별 초기화 리팩토링\n\n설계를 마치고 나서는 **필요하지 않은 API를 찾는 것**과 **필요한 API들의 순서 정하기**는 개별 API를 분류하는 작업을 진행했다. 필요하지 않은 API를 찾는 작업에 앞서 구현한 **중복 API 체크 유틸** 덕분에 어떤 API가 중복되는지 알 수 있었고, 이를 통해 필요하지 않은 API를 찾아 제거하는 작업을 진행했다.\n\n이어서 남은 필요한 API들은 서로의 논리적 전후 관계를 정리해 토큰 불러오기 - 로그인 -유저타입별 초기화 순으로 흐름이 진행될 수 있게 했다.\n이렇게 세 가지로 분류된 흐름 속에서 유저 타입별 초기화 작업들을 병렬로 처리해 시간을 단축하려 했다.\n\n[유저타입을 들어낼 수 있게 리팩토링한 초기화 코드]\n\n```javascript\n// 유저타입별 초기화\nconst 유저타입별_초기화 = async (userType: UserType) => {\n  await Promise.all([\n    공통_초기화(),\n    유저_초기화(userType),\n    고수_초기화(userType),\n  ])\n}\n\nconst 초기화_실행 = async () => {\n  try {\n    await 토큰가져오기()\n\n    await 업데이트버전체크()\n\n    const deepLink = await 딥링크_정보가져오기()\n    performanceTracker.addCheckPoint(\"딥링크 정보 가져오기\")\n\n    const userType = await 로그인()\n    performanceTracker.addCheckPoint(\"토큰 기반 로그인\")\n\n    await 유저타입별_초기화(userType)\n\n    await 홈_화면으로_이동(deepLink)\n    performanceTracker.addCheckPoint(\"홈 화면 이동\")\n\n    await 로깅()\n    await tracker.stopTrace(\"새로운_측정_완료\")\n  } catch (error) {\n    에러핸들링_및_로깅()\n  }\n}\n```\n\n작업을 완료하고 개발환경과 Prod환경이 다르다 보니 얼마나 줄어들 수 있을지, 예상이 되지 않지만 앞서 초기화 작업이 화면이동보다 늦어져서 layout shift가 일어나는 문제는 해결할 수 있었고, 예외처리도 적용함으로서 보다 안정적으로 홈화면으로 진입할 수 있게 되었다. 현재 배포되지 않은 상황이라 결과가 어떻게 될지 걱정 반, 기대반으로 기다리고 있다.\n\n#### 그외 시간을 줄이기 위한 방법들\n\n앞서 나눠두었던 세가지 측정지점에 따라 다음 방법들에 대해 고민하고 챕터내에서 논의를 진행했다. 먼저 업데이트 버전체크와 딥링크정보를 가져오는 지점을 개선할 수 있어 보였다. 여기서 가장 핵심이 되었던 부분은 **앱버전 업데이트 체크**로 코드푸시의 자체 메소드를 이용해서 App center의 올라와있는 버전과 현재 앱의 버전을 체크하고 있고, 체크하는데 90프로 유저 기준으로 **1.6**초가 소요되고 있었다.\n\n단축하기 위한 방법으로 배포과정에서 해당 버전과 필수 업데이트 필요 여부등을 기록하는 자체 플래그를 만든다면 codepush 메소드를 사용하지 않고 사용이 가능해보였다. 하지만 진실의 원천이라 할 수 있는 App Center의 버전을 체크하지 않고 자체적으로 구현하는 것은 안정성에 대한 우려가 있고, 비용이 큰 작업이 될 것 같아 앞선 개선작업의 결과를 보고 작업해보기로 했다.\n\n마지막 남은 방법으로는 인증 초기화 전까지의 단계, 앱 번들을 불러오고 실행할 때 병목지점을 찾는 것이었다. 이부분은 아직 정확한 지점을 찾지못해 네트워크적인 접근외에도 여러 React native 최적화와 관련된 글과 논의를 보면서 방법을 찾고있다.\n\nBundle Splitting, Hermes, JSI등에 대해 검토해 보았지만, 이미 우리 앱에서는 Hermes엔진을 사용하고 있고, 현재 우리가 측정기준에 맞춘 최적화가 아니기 때문에 JS 스레드 자체의 부담을 줄일 수 있는 방법에 대해 고민이 필요해 보였다.\n\n가장 기본적인 불필요한 리렌더링을 줄이는 작업을 먼저 진행하고, 이후에 번들의 크기를 줄이는 등의 작업을 진행할 예정이다.\n\n### 🚥 에러바운더리 적용\n\n드디어 에러 바운더리를 적용 작업을 시작했다. 내가 계획한 적용방법은 가장 바깥쪽부터 안쪽으로 에러바운더리를 적용하는 것으로, 최상위 에러바운더리를 시작으로 스크린단위로 적용해 나갈 예정이었다.\n\n필요한 에러바운더리를 최상위에 적용하기 위해 App.tsx를 수정했고, error를 감지할 수 있게 적용했다.\n\n```tsx\nclass App extends Component<{}, State> {\n    state: State = {\n        hasError: false,\n    };\n\n    constructor(props: Record<string, never>) {\n        super(props);\n    }\n\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n       에러로깅()\n    }\n\n    static getDerivedStateFromError() {\n        return { hasError: true };\n    }\n\n    handleRestartApp = () => {\n        CodePush.restartApp();\n    };\n\n    render(): ReactElement {\n        const { hasError } = this.state;\n\n        if (hasError) {\n            return (\n                <FallabckComponent retry={handleRestartApp} />\n            );\n        }\n        return (\n            //...\n        );\n    }\n}\n\nexport default App;\n```\n\n최상위 에러바운더리에 에러가 도달했을 때에 앱을 재시작할 수 있게 도와주는 게 좋을 것 같아, Codepush를 이용한 restart 기능을 추가했다.\n\n구현자체는 어렵지 않았지만, 조금 더 고민이 되었던 것은 어떻게 안내해주는 게 **유저입장에서** 도움이 될 수 있을까였다. 혼자 고민하다가 챕터원분들의 도움을 받아 다양한 시안을 만든 후에, UX writer 분과 플랫폼 디자이너분들의 도움을 받아 완성했다.\n\n`챕터내의 업무인데 다른 챕터분들께 일을 만들어 드리는 건 아닐까`라는 고민이 되었지만 실제로 요청드렸을 때 너무 흔쾌히 도움을 주셨고, 오히려 현재 이번년도 분기 OKR과 연관된 작업이라 개발자분들께 에러 발생시 화면들에 대한 조사를 부탁드리려 했다는 이야기를 들어 함께 협업하는 좋은 계기가 되었다.\n\n나보다 더 잘 아시고, 잘 하시는 분께 **적절한 도움**을 받는게 중요함을 또 다시 느낄 수 있었다.\n\n### 📚그외에 배운점\n\nApp Start개선 작업들을 진행하면서 현재 React Native 아키텍쳐 자체에 대한 공부가 필요했다. 해당 내용들을 따로 정리하면서 블로그에 올려보고 new Architecture, JSI등 RN팀에서 많은 노력을 기울이고 있다는 점도 알 수 있었다. 또한 에러바운더리를 적용하면서 실제적으로 제안하고 적용하면서 앱의 안정성에도 기여할 수 있어 좋았던 한달이었다.\n\n개인적으로 계속해서 자동화나 조금 더 일을 효율적으로 처리하기 위한 방법들도 고민하게 되는 것 같다. 중복 API호출 감지 유틸을 만들기도 하고, App Start 시간을 줄이는 작업을 하면서 JS Bundle 최적화를 위해 Lodash 패키지 전체를 직접 import하지 않게 스크립트를 작성하기도 했다. 유의미한 결과가 나타나게 되면 블로그에 글도 작성해볼 예정이다.\n\n아직 너무너무 배울게 많다고 느껴 버겁게 느껴지기도 하지만, 더 좋은 방법에 대해 치열하게 고민했던 한달이었다. 큰 개선이 되지 않더라도, 치열하게 고민하는 것 자체가 내가 성장해가는 과정이길 바라면서 마쳐본다.\n"},{"excerpt":"12월에는 제 1회 숨테크 사내 세미나에서 발표 연사로 참여했고, 내가 속해있던 스쿼드의 마지막 작업으로 바로견적 상세화면을 개선하는 작업을 진행했다. 그리고 마지막으로 새벽점검에 참여해 챕터원 중 가장 많은 새벽점검을 한 챕터원이 되었다.\n연말이지만 나름 다사다난했던 12월을 회고해보려한다. 🙋‍♂️ 사내 세미나 발표하기 11월에 참여하겠다고 자신있게 자원했…","fields":{"slug":"/2023-12-31-2023년-12월회고/"},"frontmatter":{"date":"December 31, 2023","title":"🌟 2023년 12월 회고","tags":["회고"]},"rawMarkdownBody":"\n12월에는 제 1회 **숨테크** 사내 세미나에서 발표 연사로 참여했고, 내가 속해있던 스쿼드의 마지막 작업으로 바로견적 상세화면을 개선하는 작업을 진행했다. 그리고 마지막으로 새벽점검에 참여해 챕터원 중 가장 많은 새벽점검을 한 챕터원이 되었다.\n연말이지만 나름 다사다난했던 12월을 회고해보려한다.\n\n### 🙋‍♂️ 사내 세미나 발표하기\n\n11월에 참여하겠다고 자신있게 자원했지만... 먼저 주제를 먼저 정하고 발표해보고 싶다고 자원한 게 아니었기 때문에, 내가 너무 성급하게 결정한 게 아닌가 생각이 들었다. 하지만 나는 신입이니까 뭘하든, 앞에서 실수를 많이 하더라도 나에게 도움이 되는 경험이 될 것이란 생각으로 준비해봤다.\n\n주제에 대해 고민하면서 기술 세미나이기 때문에 기술적으로 깊이가 있는 주제를 정하면 좋겠다고 생각했지만, 숨고에 들어와 주요 도메인중 하나인 견적도메인에 대한 일감들을 진행해온 과정을 대해 정리해 모바일 엔지니어로서의 성장기를 주제로 발표해보고 싶었다.\n\n그렇게 정한 주제는 `숨고와 함께 모바일 엔지니어로 자라기`로 1년간 시간 순으로 2Q의 스쿼드, 3Q의 챕터, 4Q의 테크 OKR 작업에 참여하면서 경험과 레슨런들을 정리해 발표했다.\n\n[숨테크 포스터]\n\n![숨테크 포스터](포스터.jpeg)\n\n#### 2Q. 스쿼드에서 처음 만나게된 견적 도메인\n\n2Q에는 스쿼드에서 요청견적서 실험을 진행하게 되었다. [5월 회고](https://choi2021.github.io/review/2023/06/05/5%EC%9B%94-%ED%9A%8C%EA%B3%A0/)에서 작성했던 내용처럼 두가지 스크린을 통해 진행되는 견적작성 flow를 하나의 요청견적서 화면으로 합쳐, 요청서 내용을 보면서 견적서를 작성할 수 있게 사용성을 향상시키려한 일감으로, 5월 회고에 작성했던 실험과정에서 생긴 배포 이후 `딥링크로 접근시 견적을 작성할 수 없었던 장애와 디버깅 과정`을 담았다.\n\n당시 처음 견적도메인에 대한 실험을 진행하다 보니 도메인에 대한 이해도가 낮아 leadId와 requestId로 요청서 Id를 다르게 호출하고 있던 이유를 몰랐고, 웹개발 경험만 있다보니 모바일 개발에서 중요한 딥링크에 대한 고려가 부족해 발생했던 장애였다.\n\n[디버깅 결과를 정리한 코드]\n![디버깅 결과를 정리한 코드](디버깅결과.png)\n\n이과정을 통해서 내가 얻었던 레슨런은 `모바일 개발의 중요한 포인트인 딥링크에 대한 고려`와 `도메인에 대한 정확한 이해`었다. 이어진 고민으로는 \"이러한 장애를 만들지 않기 위해서 노력해도 사람이다 보니 실수를 할 수 있는데 실수가 발생해도 **시스템적으로 빠르게 대응**하기 위해서는 어떻게 할 수 있을까?\", \"어떻게 하면 **시스템적으로 장애를 빠르게 감지**할 수 있을까\"로 이어지게 되었다.\n\n#### 3Q. 에러/예외처리 고도화\n\n3Q에는 스쿼드 작업과 함께 챕터에서 에러/예외처리 고도화 작업을 시작했다. 블로그 회고로는 [7월 회고](https://choi2021.github.io/review/7%EC%9B%94-%ED%9A%8C%EA%B3%A0/#-%EB%82%B4%EA%B0%80-%EC%A7%84%ED%96%89%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%97%90%EB%9F%AC%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EA%B3%A0%EB%8F%84%ED%99%94-%EC%9D%BC%EA%B0%90)부터 등장한 작업으로 발표에는 시간관계상 에러 분류기준을 새롭게 정하고 견적도메인에 적용한 과정을 담았다.\n\n모바일 프로젝트는 에러 로깅 툴로 버그스낵을 사용하고 있는데, 당시 슬랙과 연동되어있는 로깅 알림 채널에 버그스낵으로 로깅되는 모든 에러가 채널에 제보되고 있었다. 에러가 발생했으니 제보받는 것은 맞지만, 에러 핸들링이된 로그들도 모두 찍히다 보니 중요한 에러가 발생해도 한번에 확인이 어려웠다.\n\n이러한 문제점을 해결하기 위해서 분류 기준을 세분화하는 작업을 진행했고, 아래 사진과 같이 기준을 세워 기존 분류를 수정하는 작업과, 새롭게 필요한 부분에 대한 로그를 추가하는 작업을 진행했다.\n\n[에러 분류 기준]\n![에러 분류 기준](에러분류기준.png)\n\n기준을 세우고 먼저 적용한 도메인은 이전에 장애가 발생했던 견적도메인이었고 아래와 같이 분류를 세분화해 로깅하는 작업을 진행했다.\n\n[에러 분류 기준을 적용한 견적도메인]\n![에러 분류 기준](에러분류적용.png)\n\n이러한 분류작업을 하면서 자연스럽게 견적발송 과정에서 사용되는 API들에 대해 조사하게 되었고, 이과정에서 견적발송 가능여부를 체크하는 과정에서 같은 API를 여러번 호출하는 상황을 발견하게 되었다.\n\n#### 4Q. 테크 OKR 견적발송 퍼널 개선\n\n4Q에는 Tech OKR 작업으로 견적발송 퍼널 개선작업에 참여하게 되었다. [10월 회고](https://choi2021.github.io/review/2023%EB%85%84-10%EC%9B%94%ED%9A%8C%EA%B3%A0/#-firebase-peformance%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EA%B2%AC%EC%A0%81%EB%B0%9C%EC%86%A1%EC%9D%84-%EA%B0%9C%EC%84%A0%ED%95%B4%EB%B3%B4%EC%9E%90)에 작성한 내용으로 기존 앞서 에러/예외처리 고도화작업을 진행하면서 발견한 `중복 API를 줄이면 견적 발송시간을 크게 줄일 수 있지 않을까`라는 가설을 가지고 작업을 진행했다.\n\n내가 세운 가설을 검증하기 위해서는 기존 실제 우리 유저가 겪고 있는 견적발송 시간에 대한 데이터가 필요했고, 이를 위해 `Firebase Performance`를 적용해 견적발송 시간을 측정하는 작업을 먼저 진행했다. 측정 결과는 11월 9일부터 11월 23일간 90% 유저 기준으로 IOS는 견적발송 가능 여부를 체크하는데 5.6초, 견적발송 완료에는 총 7.59초, Android는 견적 발송 가능여부 체크에 6초 견적발송 완료에는 8.05초가 걸리고 있었다.\n\n위 데이터를 두가지로 정리해 볼 수 있었는데 먼저, 중복 API가 발생하고 있는 견적발송 가능여부 체크에서 `전체 시간의 70%이상`이 걸리고 있고, 90% 유저 기준이지만 `견적발송이 오래 걸리고 있다`는 점이었다. 데이터를 통해서 중복 API를 줄임으로써 견적발송 시간을 줄일 수 있을 것이라는 가설에 대한 좀 더 높은 확신을 가지고 작업을 진행할 수 있었다.\n\n개선작업은 두가지 step으로 진행되었는데, 기존 각각 useCase 함수 내부에서 가능여부를 체크하기 위해 별도로 호출하던 API들을 `견적발송 전체 flow를 담당하는 상위함수에서 병렬 호출`하게 했다. 다음은 응답 결과를 각각 useCase에 param으로 전달해주었다.\n\n[개선 작업]\n![개선 작업](개선작업.png)\n개선 작업 후 결과를 개선전과 같은 기간 비교해보았을 때 IOS에서 5.6초에서 0.73초로 87%정도 감소했고, 견적발송완료에는 7.59초에서 2.96초로 61프로가 감소했다. Android에서는 견적발송 가능여부 체크에 6초에서 0.89초로 85%정도 감소했고, 견적발송완료에는 8.05초에서 3.06초로 61%정도가 감소했다.\n\n[견적발송 시간 개선 전/후 비교]\n\n![견적발송 시간 개선 전/후 비교](개선전후비교.png)\n이러한 결과를 비즈니스적으로 조금 더 풀어보고자 50%, 75%, 85%, 90%, 95% 유저에 대한 두 OS의 데이터를 보았을 때 50%가 넘는 개선이 있었고 한마디로 `유저가 견적을 한번 보낼 시간에 두번 보낼 수 있게 되었다`고 정리해보았다.\n\n작업을 하면서 얻었던 레슨런은 클라이언트에서 API를 어떻게 사용하는지가 유저경험에 어떤 영향을 줄 수 있는지에 느낄 수 있었다. 이어진 고민으로는 어떻게 우리 프로젝트 내부의 불필요한 API 호출을 감지할 수 있을지, 그리고 어떻게 하면 불필요한 API 호출을 줄일 수 있을지에 대해 고민하게 되었다.\n\n#### 발표하고 느낀점\n\n위 내용들과 함께 간단하게 내년에 숨고에서 하고 싶은 일들에 대해서도 공유해보며 발표를 마쳤다. 발표 당일 3시부터 세미나가 시작되었는데 떨려서 그전까지 일이 잘 잡히지 않았다. 발표를 마치고 나서야 간식도 먹고 웃을 수 있었다 🤣 발표를 위해서 꽤 많이 연습했는데, 내 기준에서는 다행히 준비한 내용을 무사히 다 말할 수 있었고 (청중분들은 다르게 느끼셨을 수도...) 누군가 앞에 서서 말한다는 게 얼마나 힘든일인지, 또 얼마나 큰 경험인지도 같이 느낄 수 있었다.\n내년에는 조금 더 기술적으로 성장해서 깊이 있는 주제로도 발표해보고 싶다는 마음과 함께 `누군가에게 내 이야기를 전할 수 있는 개발자,  공유할 수 있는 게 많은 개발자`가 되고 싶다는 목표가 생긴 정말 좋은 경험이었다.\n\n[발표하는 모습]\n\n![발표하는 모습](발표하는모습.jpeg)\n\n### ‍🥲️ 스쿼드 마지막 작업, 바로견적 상세화면 개선 실험과 서버 점검\n\n12월을 마지막으로 다음 달부터는 챕터으로 소속을 잠시 옮기게 되었다. 그전에 마지막으로 진행하게된 바로견적 상세화면과 새벽점검에 대해서 간단하게 정리해보려 한다.\n\n#### 바로견적 상세화면 개선 실험\n\n바로견적은 고수분이 설정한 조건에 맞는 요청서가 작성되었을 때 미리 작성된 내용을 이용해 자동으로 견적서를 매칭시켜주는 기능이다. 고수분들의 일과 중에 늘 앱에 접속해 있으실 수 없기 때문에 자동으로 매칭시킴으로써 편의성을 개선할 수 있는 도메인이다. 이전 지역 개선 작업 이후에 두번째 개선 작업으로 바로견적 상세화면을 개선하게 되었다.\n\n바로견적은 자동으로 견적을 매칭시키다 보니, 도중에 다양한 실패사유에 의해 멈추게 될 수 있었다. 기존에는 진행/정지/캐시부족 세가지 상태만 보여줬다면 **정확히 어떤 사유로 멈추게 되었는지** 좀 더 명확하게 보일 수 있게 했고, 로띠와 햅틱을 추가해 UX를 개선했다.\n\n##### 📳 햅틱이 뭐야?\n\n로띠는 이전에도 사용해본 적이 있었지만 개선작업을 통해 `햅틱`에 대해 새롭게 알게되었다. 햅틱은 유저에게 진동 또는 모션을 적용해 터치하는 느낌을 줄 수 있는 기술로, 예시로 이번에 적용하려는 부분은 정지된 바로견적 캠페인을 다시 재개하게 되었을 때 유저가 `진동을 느끼면서 바로견적이 다시 시작되었다는 것을 알 수 있게 하는 것`이었다.\n\n이를 구현하기 위해서 [react-native-haptic-feedback](https://github.com/mkuczera/react-native-haptic-feedback) 라이브러리를 사용했고, 사용법은 아래와 같다.\n\n```javascript\nimport HapticFeedback from \"react-native-haptic-feedback\"\n\nconst options = {\n  enableVibrateFallback: true, // 햅틱을 적용할 수 없는 ios 10 이하에서 heavy로 진동하는 설정\n  ignoreAndroidSystemSettings: false,\n}\n\nHapticFeedback.trigger(\"impactLight\", options)\n```\n\n시각적인 요소(애니메이션) 뿐 아니라 진동을 통한 유저 인터랙션에 대해 새롭게 알고 경험할 수 있는 좋은 기회가 되었다.\n\n#### 🌘 새벽 서버 점검\n\n세번째로 참여하게 된 새벽 서버 점검 작업으로 챕터원 중 가장 많이 새벽점검에 참여한 사람이 되었다 🤣\n\n서버 점검이 자주 있는 작업이 아니다 보니, 서버점검에 참여했던 분이 안 계시면 물어볼 분이 없기 떄문에 기존 문서와 달랐진 점들과 내가 직접 겪었던 경험을 바탕으로 가이드라인을 **꼭 문서화해야겠다** 생각했다. 하지만 기존 문제점을 해결하기 위한 뚜렷한 아이디어가 떠오르지 않아 어떻게 하면 좋을지 고민하다가, 가이드라인을 작성하지 못했다.\n\n서버점검을 위해서 내가 해야한 일은 한마디로 **서버 점검을 우회하고 테스트 할 수 있는 빌드**를 만들어서 전달드리는 것이다. 하지만 test 빌드인지 Prod 빌드인지에 따라 우회 키값이 달라지게 설정되어 있어 test 빌드에서는 Prod 서버를 우회하지 못하고, Prod 빌드는 점검 모달 확인 버튼 클릭시 앱을 종료를 시키기 때문에 test 빌드에 Prod 키값을 하드코딩된 별도의 버전을 전달드려야 하는 상황이었다.\n\n별도의 빌드를 전달드리는 것은 큰일은 아니지만, 서버점검이 배포일자와 항상 유사하게 진행되다보니 QA엔지니어께서 기존 테스트를 하시고 계시던 작업들이 반영되어있는 버전에서 서버점검을 하시고 싶어하셨다.\n\n모바일 엔지니어는 별도의 앱을 빌드하지 않아도 되고, QA엔지니어는 테스트중이던 앱 버전에서 확인할 수 있으니 모두의 효율을 높일 수 있을 것 같아 고민중에, 기존 우회 플래그를 켰을 때 설정도는 키값이 앱빌드가 test인지 Prod인지에 따라 달라지게 되어 있던 부분을, 타겟 서버에 따라 달라지게 하면 test 앱 빌드에서도 Prod 서버를 우회할 수 있을 것 같아 작업을 진행했다.\n\n다행히 해당 작업을 통해 기존 QA 엔지니어께서 테스트 하시던 버전 그대로 테스트 점검과 본 점검 모두 성공적으로 우회할 수 있었고, 해당 작업을 통해 좀 더 간단해진 새벽점검 가이드라인도 작성할 수 있었다.\n\n[컨플에 작성한 가이드 라인]\n\n![서버점검가이드](서버점검우회가이드.png)\n\n### 😆 모바일 엔지니어로 2023년을 보내며\n\n12월의 마지막 날, 2023년을 돌아보니 2월에 입사해 많은 걸 배우려고, 어쩌면 내가 부족한 걸 드러내지 않으려고 애썼던 것 같다. \"왜 나는 이걸 모르지\"와 \"이거 안해봤는데 어떡하지\"의 연속이었던 날을 지나, 여전히 잘 모르는 게 많지만 이제는 **질문**을 어떻게 하면 좋을지, 어떻게 **소통**하면 좋을지를 알아가고 있는 것 같다.\n\n내가 어떤 질문을 하더라도 \"왜 저사람은 저런 질문을 하지\"보다는 어떤 게 문제인지부터 같이 찾아주려하는 동료들이 있어서, **심리적 안정감**을 갖고 모르니까 더 잘아시는 분께 도움을 요청하면서 배워가고 있다.\n\n배울 게 많은 동료들과 일하면서, 왜 내가 \"프로그래머, 열정을 말하다\" 책에서 \"가장 못하는 사람이 되라\" (진짜 못하라는 게 아니라 나보다 뛰어난 사람들이 모인 집단에 가라는 뜻)라는 챕터가 가장 좋았는지 이해가 되었다.\n\n아마 내년에도 모르는 게 많을 거고, 매일 새로운 문제를 풀어가겠지만 그럴수록 더 많은 것을 배우고 성장하는 과정이 될 거라 기대도 된다. 더 많이 채워서 나도 더 나눌 수 있는 한해가 되기를 바라면서 마쳐본다.\n"},{"excerpt":"Conditional Types 🤩 타입스크립트에서 조건부 타입은 와 같은 형태로 사용된다. 이는 가 에 할당 가능한지에 따라서 와 중 하나의 타입을 선택하게 된다. 이러한 모습은 기존 javascript의 삼항연산자와 유사하게 느껴진다.  Generic과 함께 사용하기 Generic과 함께 사용하면 더 유용하게 사용할 수 있다. 다음 예제를 보자. In…","fields":{"slug":"/2023-12-19-conditional-types/"},"frontmatter":{"date":"December 19, 2023","title":"Typescript: Conditional Types","tags":["typescript"]},"rawMarkdownBody":"\n## Conditional Types 🤩\n\n타입스크립트에서 조건부 타입은 `T extends U ? X : Y`와 같은 형태로 사용된다. 이는 `T`가 `U`에 할당 가능한지에 따라서 `X`와 `Y`중 하나의 타입을 선택하게 된다.\n\n이러한 모습은 기존 javascript의 삼항연산자와 유사하게 느껴진다. `(condition ? trueExpression : falseExpression)`\n\n```typescript\ninterface Animal {\n  live(): void\n}\ninterface Dog extends Animal {\n  woof(): void\n}\n\ntype Example1 = Dog extends Animal ? number : string // type Example1 = number\n\ntype Example2 = RegExp extends Animal ? number : string // type Example2 = string\n```\n\n### Generic과 함께 사용하기\n\nGeneric과 함께 사용하면 더 유용하게 사용할 수 있다. 다음 예제를 보자.\n\n```typescript\n// 예시 1\ntype MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never\n\ninterface Email {\n  message: string\n}\n\ninterface Dog {\n  bark(): void\n}\n\ntype EmailMessageContents = MessageOf<Email> // string\n\ntype DogMessageContents = MessageOf<Dog> // never\n\n// 예시 2\ntype Flatten<T> = T extends any[] ? T[number] : T\n\n// Extracts out the element type.\ntype Str = Flatten<string[]> // type Str = string\n\n// Leaves the type alone.\ntype Num = Flatten<number> // type Num = number\n```\n\n### Infer와 함께 사용하기\n\n`infer`는 타입스크립트에서 타입을 추론하는 키워드이다. `infer`를 사용하면 조건부 타입을 사용해 동적으로 타입을 추론할 때 유용하게 사용할 수 있다.\n\n```typescript\n// 예시1\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type\n\n//예시2\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never\n\ntype Num = GetReturnType<() => number> // number\n\ntype Str = GetReturnType<(x: string) => string> // string\n\ntype Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]> // boolean[]\n```\n\n예시 2를 보면 함수의 반환타입을 동적으로 변경할 수 있게 infer를 이용해 추론한 예제다.\n\n### Distributive Conditional Types\n\nDistributive Conditional Types는 조건부 타입이 사용될 때 전달되는 타입이 `union`으로 구성되어 있으면 각각의 타입에 조건부 타입을 적용한 후 `union`으로 다시 합쳐진다.\n\n```typescript\ntype ToArray<Type> = Type extends any ? Type[] : never\n\ntype StrArrOrNumArr = ToArray<string | number> // string[] | number[]\n```\n"},{"excerpt":"11월은 스쿼드 일감과 함께 챕터업무를 진행한 한달이었다. 에러 예외처리 고도화 일감을 진행하면서 에러바운더리에 대해 공부하고 발표했고, 앞서 10월에 진행하면서 데이터 측정을 위해 구현했던 Firebase Performance util에 대해 소개하며 총 두번의 발표를 했다. 챕터 일감으로 새로운 에러 리포팅 툴인 로그로켓에 대해 검토하고 직접 미팅을 …","fields":{"slug":"/2023-12-02-2023년-11월회고/"},"frontmatter":{"date":"December 02, 2023","title":"😃 2023년 11월 회고","tags":["회고"]},"rawMarkdownBody":"\n11월은 스쿼드 일감과 함께 챕터업무를 진행한 한달이었다. 에러 예외처리 고도화 일감을 진행하면서 에러바운더리에 대해 공부하고 발표했고, 앞서 10월에 진행하면서 데이터 측정을 위해 구현했던 Firebase Performance util에 대해 소개하며 총 두번의 발표를 했다. 챕터 일감으로 새로운 에러 리포팅 툴인 로그로켓에 대해 검토하고 직접 미팅을 하기도 했다. 다양한 일감을 진행한 11월에 대해 대해 정리해보려한다.\n\n### 비어있는 Catch문 막기 ✋\n\n여러 도메인들의 코드들의 Catch문에 작성된 에러 핸들링 코드를 보면 다양한 고민의 흔적을 볼 수 있었다. 어떤 분은 TODO를 남겨두셨고, 어떤 분은 로그를 추가해주셨고, 어떤 분은 불필요해보여 따로 처리하시지 않은 부분도 있었다. 개인적으로 try-catch문을 사용하게 되면 에러가 전파되는 것을 막기 때문에, **해당 부분에서 반드시 핸들링 로직을 추가해주어야한다**고 생각한다. 그렇기 때문에 비어있는 catch문이 작성되지 않게 제한할 필요가 있다고 생각이 들었고, 이러한 생각을 챕터에 공유드렸을 때 긍정적으로 받아드려주셔서 커스텀 Lint 룰을 만들어 적용하는 작업을 에러/예외 처리 작업으로 진행하게 되었다.\n\n#### ESLint 이해해보기\n\nESLint는 프로젝트의 코드 스타일을 잘 통일해주는 좋은 도구라 생각만 했지, 직접 커스텀 룰을 만들어서 추가하게 될 줄 몰랐다. ESLint에 직접 커스텀 Lint 룰을 추가하기 위해서는 몇가지 개념을 이해할 필요가 있었다.\n\n- meta\n\n  meta는 말그대로 rule에 대한 metadata를 담는 부분이다.\n\n  - type은 `problem, suggestion, layout`으로 구분되어 실제로 문제가 될 수 있는지를 나타낼 수 있다.\n  - docs에는 해당 에러가 발생했을 때 어떻게 안내할 지를 담는 부분으로 추가된 룰에 대한 설명을 담을 수 있다.\n  - fixable은 --fix 옵션을 이용해서 고칠 수 있게 할지를 설정할 수 있다,\n\n- create\n\n  create는 실제로 우리가 작성된 코드에서 어떤 것을 report할 지를 정의하는 부분으로 인자로 context를 받을 수 있는데 context는 어떤 상황에 report할지 등을 담은 여러 메소드와 속성이 담긴 객체다.\n\n[[ESLint Custom Rule](https://eslint.org/docs/latest/extend/custom-rules) ]\n\n<img src='./eslint_custom.png' />\n\nmeta 같은 경우는 아주 간단하게 어떻게 할지를 정의하면 되니까 쉽게 작성이 가능했지만, 내가 원하는 요구사항인 `catch문에 대해 감지해서 비어있을 때 규칙을 어겼다고 보고하기` 위해서는 ESLint가 우리 소스코드를 읽는 방법에 대해 이해가 필요했다.\n\n#### AST (Abstract Syntax Tree)\n\nAST는 ESLint에서 소스코드를 읽은 후 만드는 트리형태의 자료구조를 의미하는데, 자료들을 찾아보면서 토스에서 작성한 [ESLint와 AST로 코드 퀄리티 높이기](https://toss.tech/article/improving-code-quality-via-eslint-and-ast) 글을 통해 도움을 받을 수 있었다.\n\nconsole.log()를 https://astexplorer.net/의 acorn 파서를 이용해서 파싱했을 때 얻을 수 있는 AST를 보면 다음과 같다.\n\n[console.log의 AST]\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 13,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 13,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 0,\n        \"end\": 13,\n        \"callee\": {\n          \"type\": \"MemberExpression\",\n          \"start\": 0,\n          \"end\": 11,\n          \"object\": {\n            \"type\": \"Identifier\",\n            \"start\": 0,\n            \"end\": 7,\n            \"name\": \"console\"\n          },\n          \"property\": {\n            \"type\": \"Identifier\",\n            \"start\": 8,\n            \"end\": 11,\n            \"name\": \"log\"\n          },\n          \"computed\": false,\n          \"optional\": false\n        },\n        \"arguments\": [],\n        \"optional\": false\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n변환된 구조를 보면 어떤 이름의 객체인지, 어떤 속성을 가지고 있는지 등이 트리구조로 변환된 것을 볼 수 있다.\n\n그러면 이번에는 try-catch문을 AST로 변환되었을 때 어떻게 나타나게 되는지 알아보자.\n\n[try-catch문의 AST]\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 12,\n  \"body\": [\n    {\n      \"type\": \"TryStatement\",\n      \"start\": 0,\n      \"end\": 12,\n      \"block\": {\n        \"type\": \"BlockStatement\",\n        \"start\": 3,\n        \"end\": 5,\n        \"body\": []\n      },\n      \"handler\": {\n        \"type\": \"CatchClause\",\n        \"start\": 5,\n        \"end\": 12,\n        \"param\": null,\n        \"body\": {\n          \"type\": \"BlockStatement\",\n          \"start\": 10,\n          \"end\": 12,\n          \"body\": []\n        }\n      },\n      \"finalizer\": null\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n여기서 내가 주요하게 봤던 부분은 `scope 타입이 AST에서 특정되어 구분된다`는 점이었다. 실제로 공식문서를 보았을 때 catch문은 CatchClause로 구분되어 적용할 수 있다.\n\n![scope](scope.png)\n\n내가 만들려고 했던 부분중 첫번째 `catch문을 만났을 때`를 다음과 같이 구현이 가능했다.\n\n[Catch문 감지를 위한 eslint rule]\n\n```javascript\nmodule.exports = {\n  meta: {\n    /*...*/\n  },\n  create(context) {\n    return {\n      CatchClause(node) {\n        // 이제 비어있는 것만 감지하자\n      },\n    }\n  },\n}\n```\n\n두번째로 비어있다는 것을 확인할 필요가 있었는데 이것은 catch문의 block 내부를 보면 되는데 앞선 예제에서 CatchClause의 body안의 body 속성 내부가 빈 배열로 작성되어있는 것을 볼 수 있다.\n\n[비어있는 catch문에 대한 AST]\n\n```json\n{\n  \"body\": [\n    {\n      \"handler\": {\n        \"type\": \"CatchClause\",\n        \"body\": {\n          \"type\": \"BlockStatement\",\n          \"body\": []\n        }\n      }\n    }\n  ]\n}\n```\n\n앞서 정리한 두가지 정보를 통해 다음과 같이 rule을 완성할 수 있다.\n\n[완성된 Custom Rule]\n\n```javascript\nmodule.exports = {\n  \"no-empty-catch-blocks\": {\n    meta: {\n      /*...*/\n    },\n    create(context) {\n      return {\n        CatchClause(node) {\n          if (node?.body.body.length === 0) {\n            context.report({\n              node: node.body,\n              message: \"비어있는 catch문 대신 에러 로그를 남겨주세요\",\n            })\n          }\n        },\n      }\n    },\n  },\n}\n```\n\n마지막으로 만들어진 rule을 .eslintrc.js에서 어떤 심각도로 설정할 지를 정함으로써 우리 프로젝트에 적용할 수 있었다. 간단한 lint 룰을 설정하는 작업이었지만 우리 프로젝트 전반에 추가되는 개발 환경에 새로운 규칙을 추가해 에러 핸들링에 대해 조금 더 관심도를 높이고 신경쓸 수 있게 기여하는 작업이었다.\n\n### 우리 ErrorBoundary 써봐요 😃\n\n에러 핸들링에 대해 관심을 가지고 챕터 업무로 진행하면서 자연스럽게 선언적으로 에러를 핸들링할 수 있는 에러 바운더리를 알 게 되었다. 어떻게 동작하는지 이해하기 위해 많은 발표 자료도 보고 직접 예제들을 만들어 사용하면서 어느정도를 이해를 높일 수 있었고, 우리 프로젝트에 적용하면 좋겠다는 생각이 들었다. 하지만 현재 우리 프로젝트에는 한 곳 정도에서 쓰이고 있었기 때문에 챕터원분들에게 어떤 점이 좋고, 어떻게 적용할 수 있는지, 한계점은 어떤 것인지 알려드리는 게 먼저 필요해 보였다. 기술논의 시간에 내가 직접 겪었던 에러 상황등을 담아 **에러바운더리**에 대해 발표를 진행했다.\n\n#### 에러 바운더리 코드 이해해보기\n\n에러바운더리는 react 16에 도입된 개념으로 UI 렌더링 과정에서 발생한 자식 컴포넌트 트리의 에러를 발생했을 때, 상위로 에러를 던지지지 않고 fallback UI를 보여주는 컴포넌트다. `에러 상태를 담당해주는 Context`로 이해할 수 있다.\n\n[에러 바운더리를 시각화한 그림 ([참조. Logrocket 에러바운더리 글](https://blog.logrocket.com/react-error-handling-with-react-error-boundary/))]\n\n![에러바운더리](에러바운더리.png)\n\n이제 코드를 보며 알아보자. 에러바운더리는 클래스 컴포넌트로 코드를 통해 4가지 정보를 얻을 수 있다.\n\n[에러 바운더리 컴포넌트]\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true }\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.log(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>\n    }\n\n    return this.props.children\n  }\n}\n\n// Usage in a component\nclass App extends React.Component {\n  render() {\n    return (\n      <ErrorBoundary>\n        <MyComponent />\n      </ErrorBoundary>\n    )\n  }\n}\n```\n\n1. `this.state`: 에러상태를 가지는 컴포넌트구나\n2. `getDerivedStateFromError`: 렌더링 에러가 발생했을 때, hasError를 fallback UI가 보이도록 업데이트하구나\n3. `componentDidCatch`: 에러가 발생했을 때, 버그 리포팅하는 등 수행할 callback을 등록할 수 있구나\n4. `render`: 에러발생시 정의한 fallback UI가 노출되구나\n\n사용할 때는 우리가 원하는 컴포넌트를 감싸서 에러가 발생했을 때 상위 컴포넌트로 전달되는 것을 받아주게 context를 설정해주면 된다.\n\n발표자료를 준비하면서 우리 프로젝트에서도 일부 적용되어 있는 것을 볼 수 있었는데, App.tsx의 최상단에서 에러 발생시 화이트스크린 에러를 로깅을 할 수 있게 `componentDidCatch`가 작성되어 있는 것을 확인할 수 있었다.\n\n#### 에러바운더리의 장점과 한계\n\n그러면 에러바운더리가 가지는 장점은 무엇일까? 내가 정리한 장점은 다음과 같았다.\n\n1. 하나의 컴포넌트 렌더링 에러가 화이트스크린으로 이어지지 않게 막아준다 = 사용자 경험의 향상 (UX👆)\n2. 반복적으로 사용되던 에러상태를 위임해 에러를 선언적으로 핸들링 할 수 있다 = 개발자 경험의 향상 (DX👆)\n\n하지만 에러바운더리가 모든 에러를 처리해줄 수는 없는데 리액트 공식문서를 참조하면 다음과 같은 에러들은 감지할 수 없다.\n\n[리액트 공식문서에서 작성된 에러바운더리의 한계점]\n\n<img src=\"리액트.png\" width=\"700\"/>\n\n그렇기 때문에 렌더링 자체의 문제가 없는 에러들은 에러바운더리로 위임시킬 수 없다. 그러면 에러바운더리가 우리 프로젝트에서 필요한 걸까?\n\n#### 내가 만들었던 에러\n\n우리가 코드를 작성하면서 `런타임에러나 렌더링 에러가 얼마나 자주 발생하겠어?`라는 생각이 들 수 있지만, 스쿼드에서 일감을 진행하면서 직접 만들었던 예제를 작성해보았다.\n\n상황은 총 페이지가 4개였던 스크린을 3개로 줄이는 실험을 진행했다. 이때 기존 스크린에는 AsyncStorage를 통해 작성한 데이터들을 저장하는데 이때 pageIndex에 따라 데이터를 불러온다. 문제가 되는 시나리오는 새롭게 퍼널을 줄인 스크린에서는 이후 페이지의 마지막 페이지를 최대값이라 생각해 최대를 넘으면 에러가 발생하게 코드로 작성해둔 상태였다.\n\n```tsx\nconst 실험전_마지막페이지 = 4\nconst 실험후_마지막페이지 = 3\n\nlet AsyncStorage의_마지막페이지 = 실험전_마지막페이지 // 예시로 AsyncStorage를 let으로 작성했다.\n\nconst getDataFrom = (index: number) => {\n  switch (index) {\n    case 1:\n      return { title: \"페이지1\", content: \"페이지1의 내용\" }\n    case 2:\n      return { title: \"페이지2\", content: \"페이지2의 내용\" }\n    case 3:\n      return { title: \"페이지3\", content: \"페이지3의 내용\" }\n    default:\n      throw new Error(\"없는 페이지입니다.\") // 실험 후 마지막 페이지는 3이니까 3보다 큰값은 안 들어올거야\n  }\n}\n\nfunction ScreenThrowingError() {\n  const [index, setIndex] = React.useState(1)\n  const pageData = getDataFrom(index)\n\n  const handlePress = () => {\n    if (실험후_마지막페이지 === index) {\n      return\n    }\n    setIndex(index + 1)\n  }\n\n  useEffect(() => {\n    const AsyncStorage의_데이터불러오기 = true\n    if (AsyncStorage의_데이터불러오기) {\n      setIndex(AsyncStorage의_마지막페이지)\n    }\n  }, [])\n\n  return (\n    <View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\" }}>\n      <View>\n        <PagerView data={pageData} />\n      </View>\n      <TouchableOpacity\n        style={{ position: \"absolute\", bottom: 12 }}\n        onPress={handlePress}\n      >\n        <Text style={{ fontSize: 32, color: \"teal\" }}>{`다음페이지`}</Text>\n      </TouchableOpacity>\n    </View>\n  )\n}\n```\n\n위와 같은 상황의 코드를 시뮬레이터에서 동작시켜보면 다음과 같이 화이트 스크린이 발생하게 된다.\n\n![에러바운더리 적용 전](적용전.gif)\n\n<br/>\n\n기존 화이트 스크린이 발생하는 상황에서 앞서 작성한 에러바운더리를 적용해 다음과 같이 코드를 작성했다.\n\n```tsx\nexport class ErrorBoundary extends React.Component<{ hasError: boolean }> {\n  constructor(props: { children: ReactNode }) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n\n  componentDidCatch(error: Error) {\n    // bugsnag.notify(error);\n    console.log(error)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <View\n          style={{ justifyContent: \"center\", alignItems: \"center\", rowGap: 12 }}\n        >\n          <Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>\n          <TouchableOpacity\n            style={{\n              borderColor: \"red\",\n              borderWidth: 1,\n              padding: 10,\n              borderRadius: 10,\n            }}\n            onPress={() => {\n              AsyncStorage의_마지막페이지 = 실험후_마지막페이지\n              this.setState({ hasError: false })\n            }}\n          >\n            <Text style={{ fontSize: 30, color: \"red\" }}>재시도 하기</Text>\n          </TouchableOpacity>\n        </View>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nfunction App() {\n  return (\n    <SafeAreaView\n      style={{\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flex: 1,\n        rowGap: 12,\n      }}\n    >\n      <ErrorBoundary>\n        <ScreenThrowingError />\n      </ErrorBoundary>\n    </SafeAreaView>\n  )\n}\n```\n\n<br/>\n\n결과는 다음과 같이 동일하게 런타임 에러가 발생하지만 화이트 스크린은 발생하지 않고, 이전 페이지로 돌아가는 것을 볼 수 있다.\n\n![에러바운더리 적용 후](적용후.gif)\n\n위 예제는 에러 상황 자체를 해결해 줄 수는 없지만, 앱을 종료하고 다시 진입해야하는 유저의 불편함을 크게 해줄 수 있는 에러바운더리의 장점을 잘 보여준다.\n\n#### 그러면 우리가 **자주** **사용하는** **이벤트와** **비동기에서** **사용할** **수** 없을까 🤔\n\n에러바운더리의 장점을 알고 적용하려고 보니 렌더링 에러만 감지할 수 있는 한계점이 있었다. 우리가 자주 사용하는 비동기와 이벤트 핸들러에서 발생한 에러에서도 적용하는 방법은 없을까라는 생각이 든다.[React-Error-Boundary](https://github.com/bvaughn/react-error-boundary)는 이러한 한계를 극복하기 위한 라이브러리로 다음과 같은 사용방법이 있다.\n\n**Fallback**\n\n에러바운더리로 에러가 전달되었을 때 어떤 컴포넌트를 보여줄지 직접 전달하는 방식이다.\n\n```tsx\nfunction App() {\n  return (\n    <ErrorBoundary\n      fallback={<Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>}\n    >\n      <MyComponentThatMayError />\n    </ErrorBoundary>\n  )\n}\n```\n\n**fallbackRender**\n\nfallback과 달리 컴포넌트 함수를 전달하는데, 이때 prop으로 **error**와 **resetErrorboundary**를 전달받아 어떤 에러인지에 대한 정보와 에러바운더리를 벗어날 수 있게 연결할 수 있다.\n\n```tsx\nfunction FallBackComponent({ resetErrorBoundary }: Props) {\n  return (\n    <View style={{ rowGap: 12 }}>\n      <Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>\n      <TouchableOpacity\n        style={{\n          borderColor: \"red\",\n          borderWidth: 1,\n          padding: 10,\n          borderRadius: 10,\n        }}\n        onPress={() => resetErrorBoundary()}\n      >\n        <Text style={{ fontSize: 32, color: \"red\", textAlign: \"center\" }}>\n          재시도\n        </Text>\n      </TouchableOpacity>\n    </View>\n  )\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary fallbackRender={FallBackComponent}>\n      <MyComponentThatMayError />\n    </ErrorBoundary>\n  )\n}\n```\n\n**onReset, onError, resetKeys**\n\nonReset은 에러가 reset됐을 때 수행할 callback을, onError는 에러가 발생했을 때 수행할 callback을, resetKeys는 전달된 dependency가 달라졌을 때 fallback UI가 제거되게 할 수 있는 props이다.\n\n```tsx\n<ErrorBoundary\n  fallbackRender={FallbackComponent}\n  onError={error => {\n    // 에러 리포트\n    console.log(error)\n  }}\n  onReset={() => {\n    // state 초기화\n  }}\n  resetKeys={[\"API로 받아올 상태\"]}\n>\n  <MyComponentThatMayError />\n</ErrorBoundary>\n```\n\n**useErrorBoundary**\n\nuseErrorBoundary는 비동기, 이벤트 핸들러 함수에서 에러 발생했을 때 에러바운더리를 보여줄지, 또는 에러바운더리를 벗어나게할지를 조절할 수 있게 하는 훅으로, 앞선 errorboundary가 가지는 한계점을 해결할 수 있게 도와주는 함수다.\n\n```tsx\nfunction MyComponentThatMayError() {\n  const { resetBoundary, showBoundary } = useErrorBoundary()\n\n  return (\n    <View style={{ rowGap: 12, flex: 1, alignItems: \"center\" }}>\n      <TouchableOpacity\n        style={{\n          borderColor: \"teal\",\n          borderWidth: 1,\n          padding: 10,\n          borderRadius: 10,\n        }}\n        onPress={resetBoundary}\n      >\n        <Text style={{ fontSize: 30, color: \"teal\" }}>리스트 불러오기</Text>\n      </TouchableOpacity>\n      <TouchableOpacity\n        style={{\n          borderColor: \"red\",\n          borderWidth: 1,\n          padding: 10,\n          borderRadius: 10,\n        }}\n        onPress={() => {\n          showBoundary(true)\n        }}\n      >\n        <Text style={{ fontSize: 30, color: \"red\" }}>에러발생버튼</Text>\n      </TouchableOpacity>\n    </View>\n  )\n}\n```\n\n#### 비동기핸들링 예제 리팩토링해보기\n\n소개한 여러가지 사용법을 이용해 간단한 비동기 코드를 리팩토링해보자. 우리 프로젝트의 많은 스크린에서 사용하고 있는 형식으로 에러 상태를 다루고, 에러 상태에 따라 보여줄 화면을 직접 정의해서 보여주고 있다. 로딩 상황, 에러상황에 따라 보여줄 화면에 대한 정의 함께 섞여있어 스크린 코드가 길게 작성되어 있다.\n\n[에러 바운더리 적용 전 예제 코드]\n\n```tsx\nfunction MyComponentThatMayError() {\n  const [isLoading, setIsLoading] = React.useState(false)\n  const [data, setData] = React.useState({ title: \"\", content: \"\" })\n  const [error, setError] = React.useState(false)\n\n  const fetchTask = useCallback(async () => {\n    try {\n      setIsLoading(true)\n      const result = await new Promise<{ title: string; content: string }>(\n        (resolve, reject) => {\n          if (canGetResponse) {\n            resolve({ title: \"페이지1\", content: \"페이지1의 내용\" })\n          } else {\n            reject(new Error(\"에러 발생\"))\n          }\n        }\n      )\n      setData(result)\n    } catch (e) {\n      canGetResponse = true\n      setError(true)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [])\n\n  useEffect(() => {\n    fetchTask()\n  }, [fetchTask])\n\n  if (isLoading) {\n    return <ActivityIndicator size={\"large\"} />\n  }\n\n  if (error) {\n    // 에러상황 때 보여줄 화면을 분기문으로 정의\n    return (\n      <View style={{ rowGap: 12 }}>\n        <Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>\n        <TouchableOpacity\n          style={{\n            borderColor: \"red\",\n            borderWidth: 1,\n            padding: 10,\n            borderRadius: 10,\n          }}\n          onPress={() => fetchTask()}\n        >\n          <Text style={{ fontSize: 32, color: \"red\", textAlign: \"center\" }}>\n            재시도\n          </Text>\n        </TouchableOpacity>\n      </View>\n    )\n  }\n\n  return (\n    <SafeAreaView\n      style={{\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flex: 1,\n        rowGap: 12,\n      }}\n    >\n      <Text style={{ fontSize: 32 }}>{data.title}</Text>\n      <Text style={{ fontSize: 32 }}>{data.content}</Text>\n    </SafeAreaView>\n  )\n}\n```\n\n<br/>\n\n위 코드를 이제 React-Error-Boundary를 이용해서 에러상태와 fallback UI를 에러바운더리에 위임해보자 😆\n\n[에러 바운더리 적용 후 예제 코드]\n\n```tsx\ntype Props = {\n  error: Error\n  resetErrorBoundary: () => void\n}\n\nlet canGetResponse = false\n\nfunction MyComponentThatMayError() {\n  const [isLoading, setIsLoading] = React.useState(false)\n  const [data, setData] = React.useState({ title: \"\", content: \"\" })\n  const { showBoundary } = useErrorBoundary()\n\n  const fetchTask = useCallback(async () => {\n    try {\n      setIsLoading(true)\n      const result = await new Promise<{ title: string; content: string }>(\n        (resolve, reject) => {\n          if (canGetResponse) {\n            resolve({ title: \"페이지1\", content: \"페이지1의 내용\" })\n          } else {\n            reject(new Error(\"에러 발생\"))\n          }\n        }\n      )\n      setData(result)\n    } catch (e) {\n      canGetResponse = true\n      showBoundary(e)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [showBoundary])\n\n  useEffect(() => {\n    fetchTask()\n  }, [fetchTask])\n\n  if (isLoading) {\n    return <ActivityIndicator size={\"large\"} />\n  }\n\n  return (\n    <SafeAreaView\n      style={{\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flex: 1,\n        rowGap: 12,\n      }}\n    >\n      <Text style={{ fontSize: 32 }}>{data.title}</Text>\n      <Text style={{ fontSize: 32 }}>{data.content}</Text>\n    </SafeAreaView>\n  )\n}\n\nfunction FallBackComponent({ resetErrorBoundary }: Props) {\n  return (\n    <View style={{ rowGap: 12 }}>\n      <Text style={{ fontSize: 32 }}>에러 발생 ☠️</Text>\n      <TouchableOpacity\n        style={{\n          borderColor: \"red\",\n          borderWidth: 1,\n          padding: 10,\n          borderRadius: 10,\n        }}\n        onPress={() => resetErrorBoundary()}\n      >\n        <Text style={{ fontSize: 32, color: \"red\", textAlign: \"center\" }}>\n          재시도\n        </Text>\n      </TouchableOpacity>\n    </View>\n  )\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary fallbackRender={FallBackComponent}>\n      <MyComponentThatMayError />\n    </ErrorBoundary>\n  )\n}\n```\n\n개선전 코드에 비해 에러바운더리로 에러상태와 fallback UI를 위임하고 나서, 컴포넌트 내부에 불필요한 분기문이 줄어들었고 성공과 로딩중일때만 작성되어 있어 보다 한번에 읽기 쉬워진 것을 볼 수 있다.\n\n#### 발표를 마치고\n\n발표를 준비하면서 우리 앱의 수많은 스크린에 적용할 만하다, 비용(시간) 대비 큰 효과를 얻을 수 있는 작업인지에 대해서 긍정적으로 생각해주실까 고민이 들었다. 그래도 한달정도 관련 여러 자료들을 보고 내 나름 정리하고 발표하는 것만 해도 나에게는 큰 수확이다라고 생각했는데, 다행히 챕터원 분들이 모두 긍정적으로 생각해주셔서 라이브러리를 이용해 조금씩 도입하는 작업을 진행해보기로 정해졌다😊\n\n### 그외의 작업들\n\n기술적으로 정리할만큼의 큰 작업은 아니지만 11월달에 했던 그외 작업들도 정리해보았다.\n\n**버그스낵 custom Grouping 도입**\n\n기존 사용하고 있던 버그스낵을 좀더 잘 사용하기 위해서, 같은 에러지만 발생한 stackTrace에 따라 나뉘어서 찍히고 있던 문제를 해결하기 위해 Custom Grouping을 Group Hash를 도입해 해결했다.\n\n**로그로켓 도입 검토**\n\n기존 사용하던 버그스낵은 에러 발생상황을 알기 위해서는 하나하나 흐름을 직접 따라가고 확인해봐야, 디버깅 할 수 있기 때문에, 에러 발생 전후의 영상이 있으면 좋을 것 같다는 아쉬움이 있었다. 이러한 영상을 제공하는 툴로써 로그로켓을 검토하게 되었다. [로그로켓 공식문서](https://docs.logrocket.com/docs)를 봐도 잘 이해가 안되는 부분들 (소스맵, conditional recording)과 같은 부분들을 해결하기 위해서 직접 로그로켓측과 미팅을 가지고 물어보기도 했다. 결과적으로는 비용문제와 우리 챕터에서 세웠던 조건들을 만족하지 못해 도입은 보류되었다.\n\n직접 영어로 미팅을 하다보니 내가 조금 더 다양하게 물어보지 못했고, 좀 더 잘 알아보지 못해서 우리팀의 좋은 툴을 놓치는 것은 아닌가 하는 생각이 들어 맘 한편이 아쉽기도 했다.\n\n**Firebase Performance에 대한 발표**\n\n이전 10월에 작업하면서 유틸을 추가했지만 어떻게 사용하면 좋을지 공유를 하지는 않았었다. 이후 챕터내의 성능 개선 작업을 위한 데이터를 쌓을 수 있게 유틸의 개발 과정과 코드들을 공유면서 코드별로 어떤 문제를 해결하기 위해서 작성되었는지 이후에 또 어떻게 개선하면 좋을지 등을 담아 발표를 진행했다.\n\n**12월 테크팀 세미나 발표 참여**\n\n12월에 테크팀 자체적인 세미나를 진행하게 되면서, 2023년 동안 어떤 일들을 진행했는지 정리하는 발표를 하면 좋겠다는 생각해 자원하여 참여하게 되었다. 챕터내 발표가 아닌 많은 분들 앞에서 처음으로 발표하는 자리라 잘 준비해서 12월에 잘 발표하고 후기도 남기려 한다.\n\n11월을 돌아보니 생각보다 많은 일들을 동시에 진행했던 것 같다. 시간을 더 효율적으로 사용하는 법, 여러가지 일을 동시에 진행할 때 얼마나 시간을 각각 쓸지 고민하고 관리하면서, 일을 잘하는 방법에 대해서도 관심이 생겼다. 자연스럽게 애자일에 대한 관심도 조금씩 생겨 나중에 정리해보려한다. 더 다양한 관심사와 일감들과 함께 즐겁게 일하는 12월이 되기를 바라며 마쳐본다.\n"},{"excerpt":"Keyof 는 객체 타입의 키값, 속성에 대한 타입으로 string 또는 numeric literal의 union으로 나타내진다. 이때 또는  인덱스 signature를 가지고 있다면 keyof는 해당 타입을 반환한다. TypeOf  연산자는 자바스크립트 자체가 이미 가지고 있다. 표현식에서 사용가능하고 변수의 타입을 추론할 때 쓰일 수 있다. typeo…","fields":{"slug":"/2023-11-16-keyof,typeof, indexed Access Types/"},"frontmatter":{"date":"November 16, 2023","title":"Typescript: Keyof, TypeOf, Indexed","tags":["typescript"]},"rawMarkdownBody":"\n## Keyof\n\n`KeyOf`는 객체 타입의 키값, 속성에 대한 타입으로 string 또는 numeric literal의 union으로 나타내진다.\n\n```typescript\ntype Point = { x: number; y: number }\ntype P = keyof Point // \"x\"|'y'\n```\n\n이때 `string`또는 `number` 인덱스 signature를 가지고 있다면 keyof는 해당 타입을 반환한다.\n\n```typescript\ntype Arrayish = { [n: number]: unknown }\ntype A = keyof Arrayish // number\n\ntype Mapish = { [k: string]: boolean }\ntype M = keyof Mapish // string\n```\n\n## TypeOf\n\n`typeof` 연산자는 자바스크립트 자체가 이미 가지고 있다. 표현식에서 사용가능하고 변수의 타입을 추론할 때 쓰일 수 있다.\n\n```typescript\nconsole.log(typeof \"Hello world\") // string\nlet s = \"hello\"\nlet n: typeof s // string\n```\n\ntypeof는 보다 복잡한 상황에서 자주사용되는데 값으로 사용되는지, 타입으로 사용되는지를 타입스크립트가 이해할 수 있게 전달해줄 때 사용된다.\n\n```typescript\ntype Predicate = (x: unknown) => boolean\ntype K = ReturnType<Predicate> // boolean\n\nfunction f() {\n  return { x: 10, y: 3 }\n}\ntype P = ReturnType<typeof f>\n```\n\n그렇다고 항상 사용할 수 있는 것은 아니라 값으로 사용되는 변수나 속성에서만 쓰일 수 있어.\n\n![typeof](typeof.png)\n\n## Indexed Access Type\n\n객체의 key값에 접근하듯이 type 또한 key 명을 이용해 타입을 추론할 수 있다.\n\n```typescript\ntype Person = { age: number; name: string; alive: boolean }\ntype Age = Person[\"age\"]\n\ntype I1 = Person[\"age\" | \"name\"] // type I1 = string | number\n\ntype I2 = Person[keyof Person] // type I2 = string | number | boolean\n\ntype AliveOrName = \"alive\" | \"name\"\ntype I3 = Person[AliveOrName] // type I3 = string | boolean\n```\n\n배열은 특별하게 number를 전달하게 되면 아이템이 어떤 타입을 가지는 지 타입을 추론할 수 있다.\n\n```typescript\nconst MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n]\n\ntype Person = (typeof MyArray)[number]\n\ntype Person = {\n  name: string\n  age: number\n}\ntype Age = (typeof MyArray)[number][\"age\"]\n\n// Or\ntype Age2 = Person[\"age\"]\n```\n"},{"excerpt":"Generics Generic은 재사용 가능한 타입을 만드는 방법이다. 앞서 정리한 대로 단순히 type을 number나 string으로 정의하게 되면 타입에 맞게 여러개의 반복된 함수나 변수를 만들어야하는 불편함이 발생한다. 이를 해결하기 위해 우리는 Generic을 이용할 수 있다. Working with Generic Type Variables \n앞…","fields":{"slug":"/2023-11-07-Generics/"},"frontmatter":{"date":"November 07, 2023","title":"Typescript: Generics","tags":["typescript"]},"rawMarkdownBody":"\n## Generics\n\n**Generic**은 재사용 가능한 타입을 만드는 방법이다. 앞서 정리한 대로 단순히 type을 number나 string으로 정의하게 되면 타입에 맞게 여러개의 반복된 함수나 변수를 만들어야하는 불편함이 발생한다. 이를 해결하기 위해 우리는 Generic을 이용할 수 있다.\n\n```typescript\n// number만 받을 수 있어\nfunction identity(arg: number): number {\n  return arg\n}\n\n// number뿐만 아니라 전달한 타입에 따라 다양하게 사용할 수 있어\nfunction identity<Type>(arg: Type): Type {\n  return arg\n}\n\nlet output = identity(\"myString\") //output: string\n```\n\n### Working with Generic Type Variables\n\n![generic](generic.png)\n앞서 타입의 유연함과 재사용성을 위해 Generic으로 타입을 지정했다. 하지만 Generic으로 정해줬을 때 전달하는 타입에 따라 공통으로 가지는 속성만 알 수 있기 때문에 발생한 에러인 것을 볼 수 있다. string이라면 가능하겠지만 number라면 불가능하다.\n\n```typescript\nfunction loggingIdentity<Type>(arg: Type[]): Type[] {\n  console.log(arg.length)\n  return arg\n}\n```\n\n이것을 해결하기 위해서는 조금 더 구체적인 타입을 정의함으로써 해결할 수 있다. 전달하는 type이 무조건 length를 공통적으로 가진다는 집합임을 정의해주면 해결할 수 있다.\n\n### Generic Types\n\nGeneric 타입을 함수에 대해 정의할 때 다음과 같은 두가지 특징을 가진다.\n\n- Generic으로 타입으로 정의할 때 다양한 이름으로 Generic으로 정의할 수 있다. 보통 라이브러리들을 살펴보면 `T, P, K`등으로 사용하는 것도 볼 수 있다.\n\n```typescript\nfunction identity<Type>(arg: Type): Type {\n  return arg\n}\n\nfunction identity<Input>(arg: Input): Input {\n  return arg\n}\n```\n\n- Object literal로 함수에 대해 정의할 수 있다. 함수도 또한 object이기 때문이라 생각되었따.\n\n```typescript\ninterface GenericIdentityFn {\n  <Type>(arg: Type): Type\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n```\n\n### Generic Class\n\nGeneric Class는 앞서 알아본 함수들과 유사하게 클래스 내부 멤버의 타입을 정의할 때 이용할 수 있다.\n\n```typescript\nclass GenericNumber<NumType> {\n  zeroValue: NumType\n  add: (x: NumType, y: NumType) => NumType\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function (x, y) {\n  return x + y\n}\n```\n\n### Generic Constraints\n\n첫번째 예제의 함수에서 length로 접근했을 때 에러가 발생했던 것을 보았다. 해결방법으로 배열로 정의했지만 배열외의 타입에서도 해당 함수가 필요하고 length에 접근가능해야한다는 요구조건을 만족하기 위해서는 어떻게 Generic 타입을 어떻게 좁힐 수 있을까?\n\n간단하게 해당 전달하는 Generic이 무조건 Length를 가지고 있음을 나타내면된다. 그방법은 **extends**로 가능하다.\n\n```typescript\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<Type extends Lengthwise>(arg: Type): Type {\n  console.log(arg.length) // Now we know it has a .length property, so no more error\n  return arg\n}\n```\n\n위 예제로 정의하게 되면 length를 가지지 않는 인자로 함수를 사용하려 했을 때 타입에러를 발생시키고 우리가 원하는 타입을 유연하면서도 좁혀서 사용할 수 있다.\n\n![typeerror](typeerror.png)\n\n```typescript\nloggingIdentity({ length: 10, value: 3 })\n```\n\n**extends**를 이용해 타입을 좁혔던 것을 이용해 다음과 같은 예제처럼 전달한 객체의 속성 값만 인자로 받을 수 있게 좁힐 수 있다.\n\n```typescript\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key]\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 }\n\ngetProperty(x, \"a\")\n```\n\n### Using Class Types in Generics\n\nclass의 타입을 Generic을 이용해 정의할 때 class를 통해 만들 인스턴스의 타입도 **new**을 이용해 정의할 수 있어.\n\n```typescript\nfunction create<Type>(c: { new (): Type }): Type {\n  return new c()\n}\n\nclass BeeKeeper {\n  hasMask: boolean = true\n}\n\nclass ZooKeeper {\n  nametag: string = \"Mikle\"\n}\n\nclass Animal {\n  numLegs: number = 4\n}\n\nclass Bee extends Animal {\n  numLegs = 6\n  keeper: BeeKeeper = new BeeKeeper()\n}\n\nclass Lion extends Animal {\n  keeper: ZooKeeper = new ZooKeeper()\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c()\n}\n\ncreateInstance(Lion).keeper.nametag\ncreateInstance(Bee).keeper.hasMask\n```\n\n### Default Generic Type\n\nDefault Parameter처럼 Default Generic Type으로 타입을 전달하지 않았을 때의 타입을 정의해줄 수 있다.\n\n```typescript\ndeclare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(\n  element?: T,\n  children?: U\n): Container<T, U>\n\nconst div = create() // const div: Container<HTMLDivElement, HTMLDivElement[]>\nconst p = create(new HTMLParagraphElement()) // const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>\n```\n"},{"excerpt":"Object Types 자바스크립트에서 object는 정말 자주 쓰이는 자료구조로, 함수의 param의 타입이나 interface, type alias를 이용해서 타입을 지정해서 자주 사용한다. Property Modifier object 타입 속성을 정의할 때 modifier를 통해 추가적인 속성들을 정의해줄 수 있다. Optional 자바스크립트에서 …","fields":{"slug":"/2023-10-31-Object-Types/"},"frontmatter":{"date":"October 31, 2023","title":"Typescript: Object Types","tags":["typescript"]},"rawMarkdownBody":"\n## Object Types\n\n자바스크립트에서 object는 정말 자주 쓰이는 자료구조로, 함수의 param의 타입이나 interface, type alias를 이용해서 타입을 지정해서 자주 사용한다.\n\n```typescript\nfunction greet(person: { name: string; age: number }) {\n  return \"Hello \" + person.name\n}\n\ninterface Person {\n  name: string\n  age: number\n}\n\ntype Person = {\n  name: string\n  age: number\n}\n\nfunction greet(person: Person) {\n  return \"Hello \" + person.name\n}\n```\n\n### Property Modifier\n\nobject 타입 속성을 정의할 때 modifier를 통해 추가적인 속성들을 정의해줄 수 있다.\n\n- Optional\n\n```typescript\ninterface PaintOptions {\n  shape: Shape\n  xPos?: number\n  yPos?: number\n}\n\nfunction paintShape(opts: PaintOptions) {\n  // ...\n}\n\nconst shape = getShape()\npaintShape({ shape })\npaintShape({ shape, xPos: 100 })\npaintShape({ shape, yPos: 100 })\npaintShape({ shape, xPos: 100, yPos: 100 })\n```\n\n자바스크립트에서 object의 속성에 접근했을 때 값이 없다면 에러가 나는게 아니라 **undefined**으로 정의되기 때문에 이때 default값을 설정해줄 수 있다.\n\n```typescript\nfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {\n  console.log(\"x coordinate at\", xPos)\n  console.log(\"y coordinate at\", yPos)\n  // ...\n}\n```\n\n- readonly\n\nreadonly로 정의한 속성의 경우 다른 값으로 수정할 수 없다.\n\n![readonly](readonly.png)\n이때 중요한 것은 readonly로 정의한 속성에 객체로 할당되었다면, 해당 객체의 속성에는 접근이 가능하다. 이는 자바스크립트의 객체는 참조값으로 할당되기 때문이다. 위 예제에서 resident 속성 자체를 바꾸는데 타입에러가 발생하지만 resident의 내부 속성은 수정할 수 있는 것을 볼 수 있다.\n\n```typescript\ninterface Person {\n  name: string\n  age: number\n}\n\ninterface ReadonlyPerson {\n  readonly name: string\n  readonly age: number\n}\n\nlet writablePerson: Person = {\n  name: \"Person McPersonface\",\n  age: 42,\n}\n\n// works\nlet readonlyPerson: ReadonlyPerson = writablePerson\n\nconsole.log(readonlyPerson.age) // prints '42'\nwritablePerson.age++\nconsole.log(readonlyPerson.age) // prints '43'\n```\n\nreadonly를 사용하면 개발 환경에서 항상 속성을 변경하는 것을 막을 수 있다고 생각할 수도 있지만 그렇지는 않다. 위 예제 처럼 서로 compatible한 타입을 가진 두가지 변수에 같은 객체를 할당할 경우, 같은 참조값을 가지기 때문에 readonlyPerson의 속성을 바꾸면 writablePerson의 속성 값이 변하는데, 이때 타입에러가 발생하지 않는 것을 볼 수 있다.\n\n- Index Signature\n\n```typescript\ninterface StringArray {\n  [index: number]: string\n}\n\nconst myArray: StringArray = getStringArray()\nconst secondItem = myArray[1]\n```\n\nindex signature는 동적인 속성을 할당해야할 때 사용할 수 있는 타입으로, 값으로 정의할 수 있는 타입은 **string, number, symbol**만 가능하다.\n\n![index](index.png)\n이때 주의할 점은 index signature로 정의한 타입의 값은 해당 타입만 가능하기에 위의 예제에서 타입 에러가 발생한 것을 볼 수 있다.\n\n```typescript\ninterface NumberOrStringDictionary {\n  [index: string]: number | string\n  length: number // ok, length is a number\n  name: string // ok, name is a string\n}\n```\n\n이를 해결하기 위해 앞서 설명한 값으로 정의할 수 있는 타입은 string, number, symbol만 가능하지만 세 종류 타입의 union 타입 또한 허용되기 때문에 union으로 정의해 해결할 수 있다.\n\n### Excess Property Checks\n\n타입스크립트에서 속성을 체크할 때, 속성 값이 존재하는지 오타인지를 자동으로 체크해주는 것을 excess property checking 라고 부른다.\n\n![excess](excess.png)\n위 예제에서 color가 아니라 colour 속성을 가진 객체가 할당되었기 때문에 에러가 발생한 것을 볼 수 있다. 이것을 회피하는 방법이 있지만 굳이 회피하지 말고 정확하게 사용하자.\n\n### Extending Types\n\ninterface로 정의한 타입은 `extends`로 상속할 수 있다.\n\n```typescript\ninterface BasicAddress {\n  name?: string\n  street: string\n  city: string\n  country: string\n  postalCode: string\n}\n\ninterface AddressWithUnit {\n  name?: string\n  unit: string\n  street: string\n  city: string\n  country: string\n  postalCode: string\n}\n\n// 대신\ninterface AddressWithUnit extends BasicAddress {\n  unit: string\n}\n```\n\n위 예제에서 공통적인 속성을 다시 작성하기보다 extends로 중복을 제거했다. 클래스에서 다른 클래스를 상속하는 것과 동일하게 느껴진다.\n\n```typescript\ninterface Colorful {\n  color: string\n}\n\ninterface Circle {\n  radius: number\n}\n\ninterface ColorfulCircle extends Colorful, Circle {}\n\nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n}\n```\n\n클래스와 달리 타입은 extends를 이용해 여러개의 타입을 상속할 수도 있다.\n\n### Intersection Types\n\nintersection Type은 두가지 type의 교집합을 의미하므로 두가지 타입을 모두 만족하는, 모두의 속성을 가지는 객체의 타입을 의미한다.\n\n```typescript\ninterface Colorful {\n  color: string\n}\ninterface Circle {\n  radius: number\n}\n\ntype ColorfulCircle = Colorful & Circle\n\nfunction draw(circle: Colorful & Circle) {\n  console.log(`Color was ${circle.color}`)\n  console.log(`Radius was ${circle.radius}`)\n}\n\n// okay\ndraw({ color: \"blue\", radius: 42 })\n```\n\n### Generic Object Type\n\nObject 타입을 정의할 때 속성 타입을 변수처럼 다양한 타입을 전달해야할 때가 있다. 이러한 요구사항을 만족하기 위해서 다음과 같은 방법들을 사용할 수 있다.\n\n- any와 unknown, 또는 assertion 사용하기\n\n```typescript\ninterface Box {\n  contents: any\n}\n\ninterface Box {\n  contents: unknown\n}\n\nlet x: Box = {\n  contents: \"hello world\",\n}\n\n// we could check 'x.contents'\nif (typeof x.contents === \"string\") {\n  console.log(x.contents.toLowerCase())\n}\n\n// or we could use a type assertion\nconsole.log((x.contents as string).toLowerCase())\n```\n\n타입을 `any`나 `unknown에 assertion`을 이용하면 어떤 값이나 다 넣어도 되기 때문에 요구사항은 만족시킬 수 있지만 런타임 에러를 미리 알 수 있는 장점을 모두 잃어 버린다.\n\n- 필요한 속성 타입에 따라 다른 타입 정의하기\n\n```typescript\ninterface NumberBox {\n  contents: number\n}\n\ninterface StringBox {\n  contents: string\n}\n\ninterface BooleanBox {\n  contents: boolean\n}\n\nfunction setContents(box: StringBox, newContents: string): void\nfunction setContents(box: NumberBox, newContents: number): void\nfunction setContents(box: BooleanBox, newContents: boolean): void\nfunction setContents(box: { contents: any }, newContents: any) {\n  box.contents = newContents\n}\n```\n\n이렇게 정의하게 되면 같은 타입에도 여러개의 타입이 중복적으로 선언되는 단점이 존재하고 함수를 정의할 때는 overload를 통해 정의해야한다.\n\n- Generic 이용하기\n\n```typescript\ninterface Box<Type> {\n  contents: Type\n}\n\ninterface Apple {\n  // ....\n}\n\n// Same as '{ contents: Apple }'.\ntype AppleBox = Box<Apple>\n\nfunction setContents<Type>(box: Box<Type>, newContents: Type) {\n  box.contents = newContents\n}\n```\n\nGeneric은 앞선 예제들이 각각 가지고 있던 Type narrowing과 중복코드를 발생이라는 두가지 단점을 한번에 해결하는 방법이다.\n\n```typescript\ninterface Box<Type> {\n  contents: Type\n}\n\ntype Box<Type> = {\n  contents: Type\n}\n\ntype OneOrMany<Type> = Type | Type[]\n\ntype OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>\n\n// type OneOrManyOrNull<Type> = OneOrMany<Type> | null\n\ntype OneOrManyOrNullStrings = OneOrManyOrNull<string>\n\n// type OneOrManyOrNullStrings = OneOrMany<string> | null\n```\n\nGeneric은 interface와 type alias 두가지 모두에 적용할 수 있고, 특히 Type alias는 Generic 타입끼리 엮어서 generic helper type을 정의할 수 있다.\n\n### Array Type\n\n```typescript\ninterface Array<Type> {\n  /**\n   * Gets or sets the length of the array.\n   */\n  length: number\n\n  /**\n   * Removes the last element from an array and returns it.\n   */\n  pop(): Type | undefined\n\n  /**\n   * Appends new elements to an array, and returns the new length of the array.\n   */\n  push(...items: Type[]): number\n\n  // ...\n}\n```\n\n배열을 정의할 때 사용할 수 있는 Array 타입은 generic type을 통해 정의할 수 있다. 실제로 프로젝트에서는 `Array<T>`와 `T[]`를 혼용해서 자주 사용한다.\n\n- ReadOnlyArray\n\n![readonlyarray](readonlyarray.png)\n자바스크립트에서 배열 또한 object이기 때문에 참조값으로 저장되고 이때 배열의 값을 접근해 변경할 수 있다. ReadonlyArray는 몇개의 값을 가지고 있을지는 모르지만 더이상 배열에 새로운 item을 추가 삭제할 수 없게 막을 수 있다.\n\n- Tuple\n\n```typescript\ntype StringNumberPair = [string, number]\n\n// 아래와 같이 볼 수 있다.\ninterface StringNumberPair {\n  // specialized properties\n  length: 2\n  0: string\n  1: number\n\n  // Other 'Array<string | number>' members...\n  slice(start?: number, end?: number): Array<string | number>\n}\n\nfunction doSomething(pair: [string, number]) {\n  const a = pair[0] // const a: string\n\n  const b = pair[1] // const b: number\n\n  // ...\n}\n\ndoSomething([\"hello\", 42])\n```\n\nTuple 타입은 배열 내부 item들의 길이와 타입을 알고있는 배열을 의미한다. 정의된 길이 밖의 값에 접근할 수 없는 특징을 가진다. 프로젝트를 진행하면서 보통 동적인 값을 다룰 때 배열을 사용하기 때문에 길이가 정해져있지 않아서 잘 사용해보지는 못했다.\n\n```typescript\ntype Either2dOr3d = [number, number, number?]\n\nfunction setCoordinate(coord: Either2dOr3d) {\n  const [x, y, z] = coord // const z: number | undefined\n  console.log(`Provided coordinates had ${coord.length} dimensions`)\n  //(property) length: 2 | 3\n}\n\nfunction doSomething(pair: readonly [string, number]) {\n  // ...\n}\n\ntype StringNumberBooleans = [string, number, ...boolean[]]\ntype StringBooleansNumber = [string, ...boolean[], number]\ntype BooleansStringNumber = [...boolean[], string, number]\n\nconst a: StringNumberBooleans = [\"hello\", 1]\nconst b: StringNumberBooleans = [\"beautiful\", 2, true]\nconst c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true]\n\nfunction readButtonInput(...args: [string, number, ...boolean[]]) {\n  const [name, version, ...input] = args\n  // ...\n}\n```\n\ntuple을 사용할 때 `?`를 이용해 optional한 요소 타입을 정해주거나 readonly 속성을 넣어줄 수 있고, 일부의 타입만 알고 있을 경우의 나머지 타입은 rest parameter처럼 정의해줄수도 있다.\n"},{"excerpt":"10월은 9월과 유사하게 스쿼드 업무보다는 챕터 업무에 주된 시간을 보냈던 한달이었지만, 보다 기술적으로 많이 배울 수 있는 시간이었다. 성능 측정을 위한 유틸을 구현해기도 하고, 측정된 데이터를 통해서 더 개선될 수 있는 작업해 주요 도메인을 개선하는 작업에 참여했다. 업무 외적으로 프론트엔드에서 가장 큰 행사인 FECONF에 엠버서더로 참여하는 기회가…","fields":{"slug":"/2023-11-01-2023년-10월회고/"},"frontmatter":{"date":"October 31, 2023","title":"🧐 2023년 10월 회고","tags":["회고"]},"rawMarkdownBody":"\n10월은 9월과 유사하게 스쿼드 업무보다는 챕터 업무에 주된 시간을 보냈던 한달이었지만, 보다 기술적으로 많이 배울 수 있는 시간이었다. 성능 측정을 위한 유틸을 구현해기도 하고, 측정된 데이터를 통해서 더 개선될 수 있는 작업해 주요 도메인을 개선하는 작업에 참여했다. 업무 외적으로 프론트엔드에서 가장 큰 행사인 **FECONF**에 엠버서더로 참여하는 기회가 있었다. 지난 한달과는 또 다른 한달을 보낸 10월에 대해 정리해보려한다.\n\n### 😍드디어 참여해본 컨퍼런스, FEConf\n\n10월 21일 국내 최대 Front-end 컨퍼런스인 **FEConf**에 숨고의 엠버서더로써 참여했다. 나는 모바일 엔지니어이지만 기술 스택으로 `React-Native`을 사용하고 있기 때문에 함께 참여할 수 있는 기회가 있었다. 엠버서더로써 행사를 준비하면서 부스에 오실 분들을 위한 굿즈들에 대한 아이디어 회의에 참여하고, 나는 채용경험이 없어서 참여하지 않았지만, 프론트엔드 챕터분들과 웹 경력이 있으신 모바일 엔지니어 분들은 사전에 전달받은 이력서들에 대한 코칭을 위한 준비 등 숨고를 알리기 위해 준비를 했다. (그래서 사실 내가 한 일은... 현장에서 홍보가 주된 일이었다.)\n\n엠버서더로 참여했지만 타임별로 나눠서 일을 진행했기 때문에 남는 시간들에 다양한 세션들을 들을 수 있었다. ABC로 나뉜 공간에서 각각의 세션이 따로 진행되기 때문에, 전부를 들을 수는 없어 내가 관심있는 주제들에 대한 세션들을 들을 수 있었다. 내가 들었던 세션은 토스의 프론트엔드 분들이 일하는 방식을 설명해주신 **토스 후원사 세션**, 데브 시스터즈 분께서 발표해주신 **use 훅이 바꿀 리액트 비동기 처리의 미래 맛보기**, 숨고를 대표해서 발표해주신 홀란드의 **vue에서 Next JS로 마이그레이션 세션**, 그리고 RN 개발자로써 가장 기대했었던 토스의 **React Native, Metro를 넘어서** 세션까지 총 4가지 세션에 참여해서 들었고, 마지막 타임에는 우리 회사가 준비한 **이력서 세션**에서 다른 개발자분들과 네트워킹하는 시간에 참여했다.\n\n토스 후원사 세션에서는 토스 계열사들의 각각 팀 리드분들과 팀원분들이 나오셔서 어떻게 일하는 지에 대해 전달받을 수 있었고, 어떻게 일하는지 새롭게 추가된 토스 플레이스라는 계열사가 어떤 문제를 해결하기 위해 기획이 된 팀인지 등 소개해주는 시간이었다. 회사 소개에 가까워 조금 더 사내 문화 등에 대해 알려줬으면 하는 아쉬움도 있었다.\n\nuse훅이 바꿀 리액트 비동기 처리의 미래는 현재 리액트에서 실험단계에 있는 **use** 훅에 대해 발표해주셨다. use 훅은 context나 promise를 읽을 수 있게 하고 기존 hook들과 달리 조건부로 호출도 가능한 특징이 있었다. RN과 비동기 처리에 대해서 관심이 많은 나에게 `비동기를 잘 다루는 것`에 대해 나뿐만 이 아니라 많은 분들이 관심을 갖고 해결하고자 하는 문제라는 점과 리액트에서 시도하고 있는 다양한 해결방법들에도 더 관심을 가져야 겠다는 생각이 들었던 세션이었다.\n\n[use 훅에 대한 리액트 공식문서 설명]\n\n![usehook](usehook.png)\n\n우리 회사 대표로 홀란드께서 준비해주신 vue에서 next로 마이그레이션 과정에 대한 발표는, 현재도 계속해서 프론트엔드 챕터에서 진행중인 마이그레이션과 함께, 새로운 기능들을 추가하고, 점진적으로 마이그레이션할 수 있는 방법들에 대해 담고 있었다. 사내 리허설때 한번 들은 적이 있었지만 얼마나 연습하셨는지 발표내용이 더 명료해져 잘 이해할 수 있었다. 나도 1년 뒤에는 다양한 경험을 쌓아, 여러가지 문제를 해결한 경험을 발표할 수 있기를 바래보기도 했다.\n\n토스의 발표 세션은 번들러에 대한 기본적인 과정과 RN에서 필수적으로 사용중인 metro 번들러 대신 esBuild를 이용함으로써 빌드시간 단축과, 번들 사이즈를 줄인 과정을 담고 있었다. RN 개발자로써 우리 팀 내에서도 많은 관심을 가지고 있던 주제였고, 팀원분들이 시도했지만 다른 번들러로 전환하기에 아직 어려움을 겪고 있어서 이번 발표로 우리 제품에도 적용하면 좋겠다는 생각을 가지고 있었다. 하지만 주된 내용은 번들러에 대한 기본지식을 전달하는 내용이었고, 실제 metro에서 어떻게 esBuild 번들러를 어떻게 적용했는지에 대해서는 공개되지 않은 부분이 많아 아쉬웠다. 이후 팀원중 한분이 여쭤봤을 때 esBuild는 HMR을 지원하지 않기 때문에 실제 개발시에 실시간으로 반영이 되지않는 단점을 가지고 있어 토스팀에도 현재는 PROD를 위해서 이용중이라는 답변을 얻을 수 있었다. 발표내용을 우리 제품에 적용할 수 있을지는 모르겠지만 나에게는 모호했던 **번들러**라는 것이 어떤 일을 하는지에 대한 이해도를 높일 수 있는 좋은 시간이었다.\n\n마지막으로 우리 회사의 이력서 코칭 세션에는, 좋은 이력서에 대해서 이야기하고 마지막에 각 테이블별로 네트워킹 시간을 가졌다. 내가 참여한 테이블에는 세분이 계셨고, 각각 회사를 다니고 계시는 분들로 이력서 코칭 내용들에 대해 이야기도 하고, 회사에서 어떻게 일하고 계신지에 대해 이야기하는 시간을 가졌다. 회사-집만 반복하는 나에게 다른 회사 개발자분들의 경험을 들을 수 있는 좋은 기회였다.\n\n들을수 있는 모든 세션을 듣고 중간중간 홍보도 하면서 많은 사람들이 프론트엔드 개발자로 일하고 있고, 다양한 회사들이 정말 세상의 많은 문제들을 해결하기 위해 애쓰고 있다는 생각이 들었다. 작년만해도 지망생에서 일을 많이 하지는 않았지만 이제는 회사 엠버서더로, 개발자로 같이 있다는 게 좋고 많이 자극을 받을 수 있는 시간이었다.\n\n[회사 굿즈였던 숨식이 스티커]\n![굿즈](굿즈.png)\n\n[뭐 듣고 있는지는 모르겠지만 혼자 심각하게 듣다가 찍힌 나]\n\n<img src='./내사진.jpeg' width=\"400\"/>\n\n### 🤩 Firebase Peformance를 이용해 견적발송을 개선해보자\n\n이번 테크팀의 OKR로 우리 제품의 핵심 도메인인 견적발송과 요청서 작성에 안정성과 개선점들을 찾고 실행하는 작업을 진행하게 되었다. 기존 스쿼드에서 맡아서 하던 업무의 중요 도메인이 견적발송이었기 때문에 자연스럽게 챕터내에서 담당하게 되었고, 다행히 작업하면서도 개선할 수 있을 것 같은 포인트들을 어느정도 생각하고 숙원사업들중 하나여서 나에게는 챕터방향과 개인적인 방향이 잘 맞아 떨어져 감사한 부분이었다.\n\n#### 그러면 기존에는 어땠을까? 🤔\n\n기존 요청서 상세- 견적발송으로 이어지던 퍼널 하나의 페이지로 줄이는 실험을 진행하면서 두가지에 필요한 정보를 모두 하나의 화면에서 확인하고 있었다. 그 당시에 도메인을 잘모르고 매출의 아주 중요한 도메인인 견적발송을 맡아서 진행한다는 부담감과, 부족한 도메인 지식들로 인해 거의 대부분 작성되어있던 코드를 그대로 사용해 구현해 일정에 맞게 실험을 진행했다.\n\n다시 보게된 견적발송 화면의 코드들 중에서 가장 많이 눈에 보였던 점은 견적 발송 API를 호출하기 전 **견적발송 가능여부**를 체크하는 부분이었다. 다른 useCase들에 대한 확인하기 위해 API를 호출하는데 확인해보니 똑같은 API들에 대해서 중복해서 호출하고 있었다. `중복적으로 호출하고 있는 API에 대해서 하나로 합쳐보면 견적발송 시간이 줄지 않을까?` 라는 생각으로 첫번째 목표로 삼아 일감을 진행했다.\n\n[간략하게 나타낸 기존 견적발송 코드]\n\n```ts\nfunction use_견적발송(...arg){\n  try{\n    if(견적발송_가능여부_체크_useCase1()===false){\n      return\n    }\n  \t...\n\n   if(견적발송_가능여부_체크_useCaseN()==false){\n      return\n   }\n\n    const 견적발송결과=await 견적발송(...)\n\n    await 견적발송_후작업(견적발송결과)\n\n  } catch(e){\n      if(e instanceof 견적발송실패_에러케이스1){\n        견적발송실패_에러케이스1에대한_예외처리1()\n      }\n      ...\n      if(e instanceof 견적발송실패_에러케이스N){\n        견적발송실패_에러케이스N에대한_예외처리N()\n      }\n  }\n}\n\n```\n\n#### 일단 데이터를 쌓자 🤥\n\n바로 개선 작업에 들어가기 유저 디바이스에서 진행했을 때 걸리는 시간의 before/after에 대해 기록해보기로 했다. 그러면 어떤 툴을 이용해서 시간을 측정할지를 고민했을 때 두가지 방법이 있어보였다. AB테스트로 데이터를 수집하는데 이용하고 있는 **Amplitude**를 이용하는 방법, 마지막으로 제품에서 FPS와 TTI를 측정하기 위해서 사용하고 있던 **Firebase Performance**가 있었다. 첫번째 방법인 Amplitude의 데이터는 테크팀에서만 보는 지표가 아니라 프로덕트 팀과 함께 보는 지표이다보니, 추가적인 데이터를 쌓는 것에 어려움이 있었고, 두번째 방법은 모바일 챕터 only로 데이터를 쌓을 수 있는 부분이었기 때문에 두번째 툴을 선택하게 되었다.\n\n**Firebase Performance**는 리액트 네이티브에서 이용하기 위해서 [React-native-firebase](https://github.com/invertase/react-native-firebase)를 이용할 수 있다. 기존 우리 프로젝트는 안드로이드와 ios 프로젝트로 구분해서 데이터를 쌓고 있었고, 기존 화면 렌더링 속도를 측정하기 위해 존재하던 유틸과 React-native-firebase docs를 참고해 코드를 작성하려했다.\n\n[처음 구현한 견적 발송 측정 util]\n\n```typescript\nimport perf from \"@react-native-firebase/perf\"\n\nconst trace = perf().newTrace(\"견적발송\")\n\nconst startTrace = async () => {\n  await trace.start()\n  trace.putMetric(\"start\", new Date().getTime())\n}\n\nconst stopTrace = async () => {\n  trace.removeMetric(\"start\")\n  await trace.stop()\n}\n\nconst addCheckPoint = async (name: string) => {\n  const startTime = trace.getMetric(\"start\")\n  trace.putMetric(name, new Date().getTime() - startTime)\n}\n\nexport const 견적발송Trace = {\n  start: startTrace,\n  stop: stopTrace,\n  addCheckPoint,\n}\n```\n\n위 코드는 기존 유틸과 거의 동일하게 구현한 방식으로 **중간지점을 기록**하는 `addCheckPoint`함수를 추가했다. 중간 지점을 기록하기 위해서 시작한 시간에 대한 정보를 가지고 있어야했고, 중간지점에 대한 기록도 함께 남기기 위해서 Firebase Performance가 가지는 **Attribute**와 **Metric** 두가지 metadata에 대해 알게 되었다. **attribute**는 사용기기, OS와 같은 정보를 기록할 수있고 **metrics**은 시간이나 숫자에 대한 정보를 기록하는데 용이해보였다. attribute보다 metric이 대시보드에서 탭으로 바로 바로 볼수 있는 장점이 있어 metric에 중간지점을 기록할 수 있게 구현했다.\n\n[성능 측정코드가 추가된 견적발송 코드]\n\n```ts\nfunction use_견적발송(...arg){\n  try{\n    await 견적발송Trace.start();\n    if(견적발송_가능여부_체크_useCase1()===false){\n      return\n    }\n  \t...\n\n   \tif(견적발송_가능여부_체크_useCaseN()===false){\n      \treturn\n   \t}\n\n   \tawait 견적발송Trace.addCheckPoint('견적발송_가능여부_체크');\n\n    const 견적발송결과=await 견적발송(...)\n\n    await 견적발송_후작업(견적발송결과)\n\n    await 견적발송Trace.stop();\n\n  } catch(e){\n     \tif(e instanceof 견적발송실패_에러케이스1){\n        견적발송실패_에러케이스1에대한_예외처리1()\n      }\n      ...\n      if(e instanceof 견적발송실패_에러케이스N){\n        견적발송실패_에러케이스N에대한_예외처리N()\n      }\n  }\n}\n\n```\n\n구현한 유틸은 정상적으로 작동되는 것처럼 보였지만 예상치 못한 문제상황이 발생했다. 문제상황은 두가지로 항상 첫번째 데이터만 쌓이게 된다는 점과 측정시도 도중에 실패했을 경우에 `stop`이 호출되지 않아 다시 시도했을 때 성공할 때까지의 시간이 측정된다는 점이었다. 첫번째 문제는 원하는 데이터가 덜 쌓이는 문제가 있고, 두번째 문제는 데이터가 뒤죽박죽이 되어 신뢰도를 떨어뜨렸다.\n\n두가지 문제점의 원인을 찾기위해서 RN Debugger의 로그로 찾아보려했지만 Firebase Performance와 관련된 로그를 볼수 없어 어려움을 겪었다. 여러가지를 찾아보다 안드로이드 스튜디오의 **LogCat**을 이용해 안드로이드 시뮬레이터에서 확인할 수 있는 Firebase Performance 로그를 분석했다.\n\nLogCat으로 확인해본 결과, 첫번째 기록에 대한 로그는 정상동작했지만 실제로 두번째 견적발송 시도시에는 아무 기록이 되지 않는 것을 볼 수 있었다. 계속해서 시도하면서 Trace데이터의 특징을 발견하게 되었다.\n\n- 한번 시작된 Trace는 stop을 할때까지 기록이 된다.\n- stop된 Trace는 다른 데이터를 기록할 수 없다.\n\n이러한 특징 때문에 내가 구현했던 유틸은 하나의 Trace에 계속해서 기록하려하다보니 첫번째 성공한 데이터만 기록이 되고, 실패한 경우에는 계속 같은 데이터에 기록이 되고 있으므로 성공할 때까지 시간이 측정되는 문제가 발생했다.\n\n디버깅을 하고나서 문제 해결방법은 간단했는데 측정시작시 **매번 새로운 Trace로 측정을 시작하는 것**이었다. 현재 코드 구조상에는 매번 새로운 Trace를 이용하기 위해서 let이용해서 매번 새로운 Trace를 할당할 수도 있었지만, Firebase Performance 측정과 관련 데이터와 메소드를 하나의 클래스로 표현하는 게 좀 더 응집도를 높인 코드가 될 수 있을 것 같았다.\n\n[새롭게 구현한 성능측정 유틸]\n\n```typescript\nexport class 견적발송Trace {\n  constructor(\n    private trace: null | FirebasePerformanceTypes.Trace = null,\n    private startTime = 0\n  ) {}\n  async start() {\n    if (this.trace === null) {\n      this.trace = perf().newTrace(\"견적발송\")\n    }\n    await this.trace.start()\n    this.startTime = new Date().getTime()\n  }\n\n  async stop() {\n    if (this.trace === null) {\n      return\n    }\n    this.trace.putAttribute(\"result\", value)\n    await this.trace.stop()\n  }\n\n  addCheckPoint(name: string) {\n    if (this.trace === null) {\n      return\n    }\n    this.trace.putMetric(name, new Date().getTime() - this.startTime)\n  }\n}\n\nexport const 견적발송Tracker = 견적발송Trace.getInstance()\n```\n\n위의 코드는 클래스로 다시 구현한 성능측정 유틸이다. instance에 접근가능한 스코프 내에서만 사용할 수 있는 한계점이 생길 수 있어, 싱글톤 패턴을 이용해 하나의 instance를 export해서 사용하게 구현했다. 앞서 겪었던 문제점을 해결하기 위해 start시 새로운 Trace를 할당하고, stop시에는 Trace를 삭제해 불필요한 메모리를 차지하지 않게 구현했다. 구현한 코드는 이후 코드리뷰를 통해서 좀 더 범용성 높은 유틸로 개선되어 프로젝트에서 사용하게 되었다.\n\n#### 이제 진짜 개선 작업을 시작해볼까 😎\n\n측정작업을 선배포 후에 데이터를 쌓는 동안에 개선작업에 들어갔다. 개선작업 동안에 견적발송이 실패하는 모든 유스케이스들을 확인하면서 실제로 중복된 API들에 대해 조사할 수 있었다. 견적발송이라는 아주 핵심적인 도메인에 서비스가 커지면서 생긴 여러가지 정책들이 useCase로 여러가지 파일로 나뉘어 들어가다보니 반복되는 API라는 점을 체크되기 어려웠겠다는 생각이 들었다. 여러가지 useCase들에 필요한 API들을 한번만 호출해서 각 useCase 함수에 param으로 전달함으로써 중복된 호출부를 제거했다. 또한 필요한 API들은 `Promise.All() `을 이용한 병렬 호출로 데이터를 가져와 응답시간을 단축시켰다.\n\n[개선한 견적발송 코드]\n\n```typescript\nfunction use_견적발송(...arg){\n  try{\n    const [필요정보1,...,필요정보N]=await Promise.all([...필요정보_조회_API들])\n\n    await 견적발송Trace.start();\n    if(견적발송_가능여부_체크_useCase1(필요정보)===false){\n      return\n    }\n  \t...\n\n   \tif(견적발송_가능여부_체크_useCaseN(필요정보)===false){\n      \treturn\n   \t}\n\n   \t견적발송Trace.addCheckPoint(, '견적발송_가능여부_체크');\n\n\n    const 견적발송결과= await 견적발송(...)\n\n    await 견적발송_후작업(견적발송결과)\n\n    await 견적발송Trace.stop();\n\n  } catch(e){\n      if(e instanceof 견적발송실패_에러케이스1){\n        견적발송실패_에러케이스1에대한_예외처리1()\n      }\n      ...\n      if(e instanceof 견적발송실패_에러케이스N){\n        견적발송실패_에러케이스N에대한_예외처리N()\n      }\n  }\n}\n\n```\n\n이렇게 단축한 결과 현재 기존 90프로 유저가 겪고 있던 시간을 기준으로 다음과 같은 결과를 얻을 수 있었다.\n\n- 견적발송가능여부 체크: 4.5초 -> 0.763초 (**83%**)\n- 전체 견적발송 시간: 7.11초 -> 2.98초 (**58%**)\n\n개선 작업자체를 봤을 때 코드적으로 큰 변화가 있었던 것은 아니지만, 개선할 부분을 찾고, 전후 비교를 위한 측정 유틸을 만들어보고, 만드는 과정에서 생긴 문제를 위해서 네이티브영역에서 디버깅하고 의미있는 결과까지 볼 수 있어 개발자로써 뿌듯하고 의미있는 일감이었다.\n\n### 마치며\n\n10월 한달은 다른 개인 사정(예비군 등)도 많았지만, 여러가지 업무에 참여하면서 의미있는 결과까지 볼 수 있었던 한달이었다. 컨퍼런스에 참여해서 동료가 발표하는 모습을 보면서 나도 내년엔 발표할 수 있을 만큼 많은 기여를 하고싶은 욕심과 열정도 끌어오르기도 했고, 데이터를 이용해 문제점부터 개선까지 보면서 여태까지 중 개발자로써 많은 뿌듯함을 느낀 한달이었다. 개선 작업 과정속에서 많은 동료들과 이야기하고 더 좋은 방법들에 대해 의논하면서 많이 배우고, 내가 가진 부족함을 다른 동료가 채워주는 것을 경험할 수 있었다. 정말 좋은 팀과 환경에서 일하고 있다는 점이 더 열심히 하고 싶은 맘을 갖게 하는 것 같다. 나 또한 그런 동료가 되기 위해 계속해서 채워나가는 하루하루를 보내야겠다고 생각했던 한달이었다.\n"},{"excerpt":"More On Functions😃 타입스크립트에서 함수를 다루는 법을 알아보자 Function Type Expressions 타입스크립트에서 fuction을 표현할 때 기본적으로 parameter와 return 값에 대해 타입으로 표현한다. Parameter type의 경우 타입을 정해주지 않으면 any로 정해진다. Call Signatures 자바스크립…","fields":{"slug":"/2023-10-23-MoreOnFunctions/"},"frontmatter":{"date":"October 23, 2023","title":"Typescript: More On Functions","tags":["typescript"]},"rawMarkdownBody":"\n## More On Functions😃\n\n타입스크립트에서 함수를 다루는 법을 알아보자\n\n### Function Type Expressions\n\n타입스크립트에서 fuction을 표현할 때 기본적으로 **parameter**와 **return** 값에 대해 타입으로 표현한다. Parameter type의 경우 타입을 정해주지 않으면 any로 정해진다.\n\n```typescript\nfunction greeter(fn: (a: string) => void) {\n  fn(\"Hello, World\")\n}\n\nfunction printToConsole(s: string) {\n  console.log(s)\n}\n\ngreeter(printToConsole)\n```\n\n### Call Signatures\n\n자바스크립트에서 함수는 **객체**다. 이점이 중요한 점은 함수가 속성을 가질 수 있다는 의미이기 때문인데, **function type annotation**에서는 속성을 할당하지 못하게 한다. 속성을 할당하고 싶다면 해당 속성에 대한 call signature를 할당해야 한다.\n\n```typescript\ntype DescribableFunction = {\n  description: string\n  (someArg: number): boolean\n}\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + \" returned \" + fn(6))\n}\n\nfunction myFunc(someArg: number) {\n  return someArg > 3\n}\nmyFunc.description = \"default description\"\n\ndoSomething(myFunc)\n```\n\n### Construct Signatures\n\n자바스크립트에서 함수 선언문으로 정의된 함수는 모두 **생성자 함수**로 쓰일 수 있기 때문에 new 키워드가 사용될 수 있다.`new`키워드를 이용한 타입 정의를 통해 construct signature를 정의할 수 있다.\n\n```typescript\ntype SomeConstructor = {\n  new (s: string): SomeObject\n}\nfunction fn(ctor: SomeConstructor) {\n  return new ctor(\"hello\")\n}\n```\n\n### Generic Functions\n\n보통 param의 타입과 반환값의 타입은 관련이 있거나 param들간의 타입이 관계가 있다. any를 사용하지 않고 우리가 원하는 타입으로 좁혀서 재사용하는 방법으로 **generic**을 이용할 수 있다.\n\n```typescript\nfunction firstElement<Type>(arr: Type[]): Type | undefined {\n  return arr[0]\n}\n\n// s is of type 'string'\nconst s = firstElement([\"a\", \"b\", \"c\"])\n// n is of type 'number'\nconst n = firstElement([1, 2, 3])\n// u is of type undefined\nconst u = firstElement([])\n```\n\n#### inference\n\ninference는 타입을 직접 정하는 것은 아니지만 typescript를 통해 **추론**되는 타입을 의미한다.\n\n```typescript\nfunction map<Input, Output>(\n  arr: Input[],\n  func: (arg: Input) => Output\n): Output[] {\n  return arr.map(func)\n}\n\nconst parsed = map([\"1\", \"2\", \"3\"], n => parseInt(n)) // parsedsms number[]이야\n```\n\n#### Constraints와 오류\n\ngeneric을 이용해서 연관있는 input 타입들의 관계를 정의했지만 어느정도 우리가 원하는 타입으로 좁힐 수 있다. 좁힐 때는 **extends**를 통해 해당 속성을 가지고 있는 타입 등으로 좁힐 수 있다.\n\n![constraint](constraint1.png)\n\n이런 Generic을 이용한 타입 좁히기는 유용할 수 있지만 조심해야할 부분이 있다.\n\n![constraint](constraint2.png)\n\n위 코드에서 에러가 난 이유는 우리 Generic으로 전달한 인자의 타입이 반환값으로 그대로 반환될 것라고 선언했다. 하지만 else문 안에는 좁혀진 범위의 객체를 반환하기 때문에 기존과 다른 타입이기 때문에 타입에러가 났다. 타입스크립트에서 큰 집합은 작은 집합에 할당될 수 있지만, 그렇다고 큰집합이 작은 집합이라고 할 수는 없다.\n\n`사자는 동물에 포함된다` 라는말은 사자가 동물에 포함되기 때문에 맞지만, `사자와 동물은 같다`라는 말에는 오류가 있는 것과 같다.\n\n#### Guidelines for Writing Good Generic Functions\n\nGeneric 함수를 잘 작성하는 방법 3가지를 정리해보자.\n\n- Push Type Param Down: param을 더 구체적인 값으로 사용한다.\n\n```typescript\nfunction firstElement1<Type>(arr: Type[]) {\n  return arr[0]\n}\n\nfunction firstElement2<Type extends any[]>(arr: Type) {\n  return arr[0]\n}\n\n// a: number (good)\nconst a = firstElement1([1, 2, 3])\n// b: any (bad)\nconst b = firstElement2([1, 2, 3])\n```\n\n- Use Fewer Type Parameters: 더 적은 타입의 param으로 이용한다.\n\n```typescript\nfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {\n  return arr.filter(func)\n}\n\nfunction filter2<Type, Func extends (arg: Type) => boolean>(\n  arr: Type[],\n  func: Func\n): Type[] {\n  return arr.filter(func)\n}\n```\n\nfilter2의 경우는 어떤 함수 타입인지 일일이 정해줘야하므로 사용처에서 불편함이 존재한다.\n\n- Type Parameters Should Appear Twice: 재사용이 필요한 상황에만 제네릭을 쓰자.\n\n```typescript\nfunction greet<Str extends string>(s: Str) {\n  console.log(\"Hello, \" + s)\n}\n\ngreet(\"world\")\n\nfunction greet(s: string) {\n  console.log(\"Hello, \" + s)\n}\n```\n\n훨씬 간단하게 사용할 수있는 방법을 고민해보고, 반복되는 타입에 한해서 재사용을 위해 제네릭을 쓰자.\n\n### Optional Parameters\n\nparam이 없을 수 있는 경우를 위해 `?`를 이용할 수 있다. 이렇게 사용하게 되면 `T|undefined` 로 타입이 할당된다.\n\n```typescript\nfunction f(x?: number) {\n  // ...\n}\nf() // OK\nf(10) // OK\n```\n\n또는 param이 없을 때를 위한 기본 값을 parameter default로 정의할 수 있다.\n\n```typescript\nfunction f(x = 10) {\n  // ...\n}\n```\n\n주의할 점은 callback을 이용할 때의 의미는 optional한 parameter는 필요없이 호출 될 수 있음을 의미하는 것이니까 불필요하게 사용하지 말자.\n\n![callback](callback.png)\n\n### Function Overloads\n\n함수 오버로드는 평소에 잘 사용하지 않던 부분이다 보니 이해하는데 어려움이 있었다. **함수 Overload**는 같은 이름의 함수에 param이 다르게 정의하는 방법이다.\n\n```typescript\nfunction makeDate(timestamp: number): Date\nfunction makeDate(m: number, d: number, y: number): Date\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d)\n  } else {\n    return new Date(mOrTimestamp)\n  }\n}\nconst d1 = makeDate(12345678)\nconst d2 = makeDate(5, 5, 5)\n```\n\nOverload 함수를 작성하는데에는 몇가지 규칙이 있다.\n\n- 인자가 없을 때의 어떤 함수인지 구현이 필요하다.\n\n![overload1](overload1.png)\n\n위 예제에서 에러가 발생한 이유는 param이 없을 때의 함수가 **어떻게 구현될지** 정의되지 않았기 때문이다.\n\n아래와 고치면 타입에러가 사라지는 것을 볼 수 있다.\n\n```typescript\nfunction fn(x: string): void\nfunction fn(): void\nfunction fn() {\n  // ...\n}\n// Expected to be able to call with zero arguments\nfn()\n```\n\n- Overload 끼리 compatible해야한다.\n\n![overload2](overload2.png)\n\n위 예제에서 같은 param 갯수를 가지는 overload 함수를 작성했다. 타입에러가 발생한 이유는 먼저 작성한 overload 함수 param 타입이 `boolean`으로 정의된 상황에서 같은 param 갯수를 가지는 두번째 overload 함수에서 boolean타입과 compatible 하지 않은 string 타입으로 정의했기 때문이다.\n\n- Overload 함수는 조건부로 쓰이면 안된다.\n\n```typescript\nfunction len(s: string): number\nfunction len(arr: any[]): number\nfunction len(x: any) {\n  return x.length\n}\n```\n\n위 예제는 string과 array를 param으로 받을 수 있는 함수 overload가 정의된 상황이다.\n\n![overload3](overload3.png)\n\n위 타입에러는 조건에 따라 다른 타입의 param을 전달하는 상황이기 때문에 발생했는데, 그 이유는 타입스크립트는 하나의 overLoad에서만 함수를 호출하기 때문이다. 이럴때는 param을 정의할 때 union type으로 정의하는 게 더 올바른 방법이다.\n\n```typescript\nfunction len(x: any[] | string) {\n  return x.length\n}\n```\n\n### this 다루기\n\njavascript에서의 this 처럼 typescript의 this도 동적으로 정의된다.\n\n```typescript\nconst user = {\n  id: 123,\n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true\n  },\n}\n```\n\n위 예제에서 **this**는 암시적 바인딩에 의해 호출되는 위치에 따라 다른 값을 의미하게된다.\n\n이러한 this를 상대적으로 쉽게(?) 정의하는 방법으로 **화살표함수**를 이용하는 방법이 있다. 화살표 함수는 함수 선언식과 다른 특징이 있는데 그중 생성자 함수로 쓰일 수 없다는 점이 있다. 그렇기 때문에 자체적인 this를 가지지 않고 화살표 함수에서 this는 상위 스코프의 this를 참조하는 규칙 가진다.\n\n![this](this.png)\n위 코드에서 타입 에러가 발생한 이유는 화살표함수로 정의된 메소드의 this는 상위 스코프인 globalThis이기 때문이다.\n\n### Other Types to Know about\n\n몇가지 앞서 소개되지 않았던 타입들에 대해 정리해보자.\n\n- Void\n\n함수에서 반환하는 값이 없을 때를 위한 타입으로, return 문이 없을 때 자동으로 undefined이 반환되지만 타입스크립트에서는 따로 void로 정의한다.\n\n- unknown\n\nany와 유사하지만, any와 달리 어떤 속성을 가지는 지 알 수 없기 때문에 속성에 접근할 수 없다. 주로 try-catch 문으로 에러를 받을 때 **unknown**으로 반환되기 때문에 비즈니스 에러로 적절하게 타입을 정의한 후 `instanceOf` 를 이용해 에러 객체를 정의하는 방식으로 현업에서 사용하고 있다.\n\n- never\n\nnever는 어떤 것도 포함될 수 없는 타입을 의미한다. union이나 switch문에서 더이상 없다는 것을 의미한다.\n\n```tsx\nfunction fn(x: string | number) {\n  if (typeof x === \"string\") {\n    // do something\n  } else if (typeof x === \"number\") {\n    // do something else\n  } else {\n    x // has type 'never'!\n  }\n}\n```\n\n### Rest Parameters and Arguments\n\nRest Parameter는 인자가 **동적으로** 들어올 때의 param을 의미한다. arguments로 받을 param의 타입들을 정의할 수 있다.\n\n```typescript\nfunction multiply(n: number, ...m: number[]) {\n  return m.map(x => n * x)\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4)\n```\n\nrest parameter를 생길 수 있는 타입에러로는 배열과 튜플의 타입 차이에서 발생할 수 있다.\n\n![rest](rest.png)\n\n위 예제에서 `Math.atan2(...)`메소드는 **딱 두개의 인자**를 받지만 args는 `number[]`로 타입이 되어있기 때문에 몇개의 값이 더 들어올지 모르는 타입을 의미해 생긴 타입 에러다.\n\n이를 해결하기 위해서는 배열이 아니라 몇개의 요소로 되어있는 타입인지 정의된 **tuple**을 이용하면 해결할 수 있다.\n\n```typescript\nconst args = [8, 5] as const\n// OK\nconst angle = Math.atan2(...args)\n```\n\n### Parameter Destructuring\n\n객체 param을 전달할 때 각 속성에 대한 타입을 정의해서 전달할 수 있다.\n\n```typescript\ntype ABC = { a: number; b: number; c: number }\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c)\n}\n```\n\n### Assignability of Functions\n\nvoid를 반환타입으로 가지는 함수들 끼리 가지는 특이한 특징이 있다. void 자체는 해당 함수들이 반환하는 타입에 대해 강하게 타입을 따지지 않기 때문에 반환 타입이 무시된다.\n\n```typescript\ntype voidFunc = () => void\n\nconst f1: voidFunc = () => {\n  return true\n}\n\nconst f2: voidFunc = () => true\n\nconst f3: voidFunc = function () {\n  return true\n}\n```\n\n위 예제에서 `f1,f2,f3` 다 반환하는 타입이 boolean이지만 voidFunc로 정의해도 타입에러가 발생하지 않는다.\n\n```typescript\nfunction f2(): void {\n  return true // 에러 발생\n}\n```\n\n하지만 직접 정의할 때 void를 반환한다고 정의할 시에 타입 에러가 걸리게 된다.\n"},{"excerpt":"타입 좁히기😎 타입스크립트를 이용하면서 다양한 타입을 사용하다보면 확장성을 고려하거나 다양한 타입이 될 수 있다고 정의하는 경우가 많다. 이때 너무 넓은 타입으로 정의될 경우에는 공통된 속성과 메소드만 사용할 수 있기 때문에 이를 방지하기 위해 전달 받을 때는 넓히돼, 사용할 때는 우리가 원하는 타입으로 좁혀줘야 한다. \n위의 예제는 은 repeat 메소…","fields":{"slug":"/2023-10-18-Narrowing/"},"frontmatter":{"date":"October 17, 2023","title":"Typescript: Narrowing","tags":["typescript"]},"rawMarkdownBody":"\n## 타입 좁히기😎\n\n타입스크립트를 이용하면서 다양한 타입을 사용하다보면 확장성을 고려하거나 다양한 타입이 될 수 있다고 정의하는 경우가 많다. 이때 너무 넓은 타입으로 정의될 경우에는 공통된 속성과 메소드만 사용할 수 있기 때문에 이를 방지하기 위해 전달 받을 때는 넓히돼, 사용할 때는 우리가 원하는 타입으로 좁혀줘야 한다.\n\n![narrowing](narrowing.png)\n위의 예제는 `string`은 repeat 메소드를 가지고 있지 않기 때문에 발생한 타입오류다. 우리가 원하는 대로 사용하기 위해서는 타입을 좁혀줘야 한다.\n\n```typescript\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return \" \".repeat(padding) + input\n  }\n  return padding + input\n}\n```\n\n### typeof\n\ntypeof는 자바스크립트 문법으로 자바스크립트가 기본적으로 가지는 7가지 타입에 대한 확인이 가능한 키워드다.\n\n- `string, number, bigint, boolean, symbol, undefined, object, function`\n\n여기서 주의할 점은 `null`은 `object`이기 때문에 object 타입에 포함되어진다는 점이다.\n\n![typeof](typeof.png)\n\n### Truthiness Narrowing\n\n자바스크립트에서 조건문등에서 boolean타입으로 형변환이 일어날 때 **Truthy/Falsy**한 값이 있다.\n\n- Falsy한 값\n  - `0`\n  - `NaN`\n  - `\"\"` (the empty string)\n  - `0n` (the `bigint` version of zero)\n  - `null`\n  - `undefined`\n\n```typescript\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    // null과 \"\"가 제외\n    for (const s of strs) {\n      console.log(s)\n    }\n  } else if (typeof strs === \"string\") {\n    // \"\" 빠진 string\n    console.log(strs)\n  }\n}\n```\n\n위 코드는 이러한 점을 이용해서 null과 undefined을 조건문에서 제외했다. 하지만 주의할 점은 **빈 문자열**도 falsy로 되기 때문에 원하지 않은 예외사항이 생겼다.\n\n### Equality Narrowing\n\n자바스크립트에서 비교연산자로 4가지가 존재한다.( `==`, `===`, `!=`, `!==` )\n\n이중 `===`, `!==`는 값뿐만 아니라 타입까지 비교하기 때문에 타입을 좁히는데 사용될 수 있다.\n\n```typescript\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // x와 y 모두 string\n    x.toUpperCase()\n    y.toLowerCase()\n  } else {\n    console.log(x) // x: string | number\n    console.log(y) // y: string | boolean\n  }\n}\n```\n\n이를 이용해서 기존 Truthiness에서 분리가 까다로웠떤 null타입을 직접 타입을 비교하므로써 제거할 수 있다.\n\n```typescript\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s) // (parameter) strs: string[]\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs) //(parameter) strs: string\n    }\n  }\n}\n```\n\n### The `in` operator narrowing\n\n`in` operator는 object나 prototype chain 상에 존재하는 속성인지 체크하는 연산자다.\n\n```typescript\ntype Fish = { swim: () => void }\ntype Bird = { fly: () => void }\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    // Fish만 해당\n    return animal.swim()\n  }\n\n  return animal.fly()\n}\n```\n\n### `instanceof` narrowing\n\n`instanceof`는 자바스크립트에서 prototype chain위에 해당 객체가 있는 지 확인하는 연산자다.\n\n```typescript\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString()) // (parameter) x: Date\n  } else {\n    console.log(x.toUpperCase()) // (parameter) x: string\n  }\n}\n```\n\n### Assignments\n\nlet으로 선언된 값의 경우 타입이 union으로 정해지고 나서 다른 타입의 값으로 재할당할 경우 타입정의가 변하기 때문에 기존 타입의 값을 할당할 수 없다.\n\n```typescript\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\" // let x: string | number\nx = 1 // let x: number\nx = \"goodbye!\" // let x: string\n```\n\nunion 타입의 경우 각 타입의 합집합이기 때문에 포함하고 있는 number와 string 타입의 값은 할당할 수 있다.\n\n```typescript\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\" // let x: string | number\nx = 1 // let x: number\nx = \"goodbye!\" // let x: string\n```\n\n![assignment](assignment.png)\n위 예시는 string|number로 타입이 선언된 이후에 x에 기존 union 타입이 포함하지 않는 다른 값을 할당할 경우 발생하는 타입에러를 보여준다.\n\n### Control flow analysis\n\n앞서 설명했던 방법들을 통해 우리가 원하는 타입들로 좁혀갔다. 이렇게 특정타입이 어디까지 도달할 수 있는지를 *control flow analysis*라고 부른다.\n\n```typescript\nfunction example() {\n  let x: string | number | boolean\n\n  x = Math.random() < 0.5\n\n  console.log(x) // boolean\n\n  if (Math.random() < 0.5) {\n    x = \"hello\"\n    console.log(x) // string\n  } else {\n    x = 100\n    console.log(x) // number\n  }\n\n  return x //  string | number\n}\n```\n\n### Using type predicates\n\n우리가 정의한 타입 가드를 통해 원하는 타입으로 좁힐 수 있는 것을 *type predicate*라고 부른다. 이때 `is`가 많이 쓰이는데 우리가 원하는 타입이 맞다는 것을 의미한다. 타입가드로 실무에 잘 쓰이는 부분이다.\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n```\n\n위 예제에서 pet이 `Bird`타입이라면 swim이라는 속성이 없어 undefined이 될 것이므로 이점을 이용해 undefined이 아니라면 `Fish`타입으로 좁혀줄 수 있다. 이 타입가드를 이용하면 다음과 같이 코드를 작성할 수 있다.\n\n```typescript\n// Both calls to 'swim' and 'fly' are now okay.\nlet pet = getSmallPet()\n\nif (isFish(pet)) {\n  pet.swim()\n} else {\n  pet.fly()\n}\n```\n\n참고로, 클래스 에서는 this를 우리가 원하는 타입으로 좁혀줄 수 도 있다.\n\n```typescript\nclass FileSystemObject {\n  isFile(): this is FileRep {\n    return this instanceof FileRep\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked\n  }\n  constructor(public path: string, private networked: boolean) {}\n}\n```\n\n### Discriminated unions\n\n아마 내가 타입을 좁히는 방법중 자주 사용하는 방법중 하나라고 생각된다. `Discrimited unions`은 타입간의 공통 속성을 이용해 타입을 분리하는 방법이다.\n\n```typescript\ninterface Shape {\n  kind: \"circle\" | \"square\"\n  radius?: number\n  sideLength?: number\n}\n```\n\n우리는 이제 kind에 타입에 따라 circle일 경우 radius가 있고, square일 경우는 sideLength가 있을 것을 생각하면서 타입을 위와 같이 정의했다. 하지만 문제점은 이렇게 정의해두면 타입스크립트는 circle일때 **radius를 가지는지 undefined인지 알 수 없다**는 점이다.\n\n![discriminated](discriminated.png)\n이러한 문제를 해결하기 위해서 **공통된 속성**을 가진 두가지 타입을 만들고 공통된 타입값에 따라 어떤 속성을 가지는 지를 정의할 수 있다.\n\n```typescript\ninterface Circle {\n  kind: \"circle\"\n  radius: number\n}\n\ninterface Square {\n  kind: \"square\"\n  sideLength: number\n}\n\ntype Shape = Circle | Square\n```\n\n위와 같이 정의하게 되면 kind값에 따라 shape타입을 Circle과 Square으로 좁혀줄 수 있다.\n\n```typescript\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2 // shape: Circle\n    case \"square\":\n      return shape.sideLength ** 2 //  shape: Square\n  }\n}\n```\n\n### Never 타입\n\nnever타입은 존재하지 않을 타입으로 **가장 작은 집합**을 의미한다. 이를 이용해서 switch문에서 default문 내부에 존재하지 않을 타입을 나타낼 수 있다. 실제로 코드리뷰에서 단순히 default 문에서 에러를 던지는 코드를 작성했었는데, 변수에 never로 타입을 좁혀서 사용하면 좋을 것 같다는 말씀을 해주셨는데 이제야 정확히 이해할 수 있었다.\n\n```typescript\ntype Shape = Circle | Square\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2\n    case \"square\":\n      return shape.sideLength ** 2\n    default:\n      const _exhaustiveCheck: never = shape\n      return _exhaustiveCheck\n  }\n}\n```\n"},{"excerpt":"Everyday Types 😊 이제 기본적인 타입스크립트의 타입들에 대해 알아보자. 대부분 기본적인 부분이라 크게 정리할 부분은 없었다. Primitive 자바스크립트의 기본 타입들인 이 동일하게 타입스크립트에서 사용된다. Arrays 배열은 두가지로 표현할 수 있는데 과 같은 number 배열의 경우 와  두가지로 나타낼 수 있다. any any는 타입…","fields":{"slug":"/2023-10-17-Everyday-Types/"},"frontmatter":{"date":"October 17, 2023","title":"Typescript: EveryDay Types","tags":["typescript"]},"rawMarkdownBody":"\n## Everyday Types 😊\n\n이제 기본적인 타입스크립트의 타입들에 대해 알아보자. 대부분 기본적인 부분이라 크게 정리할 부분은 없었다.\n\n### Primitive\n\n자바스크립트의 기본 타입들인 `string, number, boolean`이 동일하게 타입스크립트에서 사용된다.\n\n### Arrays\n\n배열은 두가지로 표현할 수 있는데 `[1,2,3]`과 같은 number 배열의 경우 `number[]`와 `Array<number>` 두가지로 나타낼 수 있다.\n\n### any\n\nany는 타입스크립트를 사용하면서 **가장 쓰지 말아야하는 타입**으로 유명한데, 그 이유는 any는 모든 타입을 감싸는 **가장 큰 집합**에 해당되기 때문에 어떤 타입을 넣어도 타입체크를 통과할 수 있다. 그러므로 any를 지양하자.\n\n### Type annotation\n\n타입스크립트는 똑똑해서 우리가 할당한 변수의 값에 따라 타입에 따라 타입을 추론할 수 있는데, 덕분에 primitive 타입의 값들은 굳이 타입을 정하지 않아도 적절하게 부여할 수 있다.\n\n```typescript\n/ No type annotation needed -- 'myName' inferred as type 'string'\nlet myName = \"Alice\";\n```\n\n### Functions\n\n자바스크립트의 함수는 타입스크립트에서 필요한 타입 정보는 두가지, **인자와** **반환값**이다.\n\n인자의 타입을 전달하지 않고 `noImplicitAny` 옵션이 켜져있을 경우에 타입에러가 뜨게 되니 함수의 인자에 타입을 정해주자. 타입은 각 인자 뒤에 정해주면 된다.\n\n```typescript\n// Parameter type annotation\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\")\n}\n```\n\n반환값은 특별한 인자를 감싸는 `()` 다음에 타입을 넣어주자. 반환값이 없다면 자동으로 `void`타입으로 추론된다.\n\n```typescript\nfunction getFavoriteNumber(): number {\n  return 26\n}\n```\n\nAnonymous function의 경우는 특이하게 인자에 타입을 전달하지 않아도 타입스크립트가 자동으로 타입을 추론해준다. 이러한 게 가능한 이유는 *contextual typing*을 이용하기 때문으로, 콜백함수로 어떤 값이 전달 될 지 충분히 추론할 수 있기 때문이다.\n\n```typescript\nconst names = [\"Alice\", \"Bob\", \"Eve\"]\n\n// Contextual typing for function - parameter s inferred to have type string\nnames.forEach(function (s) {\n  console.log(s.toUpperCase())\n})\n\n// Contextual typing also applies to arrow functions\nnames.forEach(s => {\n  console.log(s.toUpperCase())\n})\n```\n\n### Object\n\n자바스크립트에서 primitive 타입을 제외하면 모두 객체라고 할 수 있다.\n\n```typescript\n// The parameter's type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x)\n  console.log(\"The coordinate's y value is \" + pt.y)\n}\nprintCoord({ x: 3, y: 7 })\n```\n\n타입스크립트에서의 `?`는 옵셔널 속성으로 없을 경우에 runtime에러가 나는 것이 아니라 undefined으로 반환될 수 있게 타입을 허용한다.\n\n```typescript\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// Both OK\nprintName({ first: \"Bob\" })\nprintName({ first: \"Alice\", last: \"Alisson\" })\n```\n\n### Union Type\n\n이제 타입스크립트만의 타입을 소개하려 한다. Union type은 두가지 타입의 **합집합**으로 볼 수 있다.\n\n![union](union.png)\n위의 코드가 에러가 난 이유는 toUppserCase는 string만이 가지는 메소드인데 number|string은 가지고 있지 않기 때문이다. 이러한 타입에러를 해결하기 위해서는 인자에 대한 타입을 좁혀줌으로써 해결할 수 있다.\n\n```typescript\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // In this branch, id is of type 'string'\n    console.log(id.toUpperCase())\n  } else {\n    // Here, id is of type 'number'\n    console.log(id)\n  }\n}\n```\n\n### Type Alias\n\nType Alias는 우리가 변수처럼 타입을 원하는 대로 이름을 정하고 정의하는 방법이다.\n\n```typescript\ntype Point = {\n  x: number\n  y: number\n}\n\n// Exactly the same as the earlier example\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x)\n  console.log(\"The coordinate's y value is \" + pt.y)\n}\n\nprintCoord({ x: 100, y: 100 })\n```\n\n### Interface\n\nInterface는 Object 타입을 우리가 원하는대로 정의하기 위한 또다른 방법이다.\n\n자주 혼용해서 사용되는 두가지 **Type alias**와 **Interface**에 대해 정리해보면 다음과 같은 차이점을 가진다.\n\n- 타입은 새로운 속성을 확장할 때 **intersection**을 이용해야하고 interface는 **extends**를 이용한다.\n\n![차이1](차이1.png)\n\n- 타입은 중복이 불가능하지만 interface는 중복선언이 가능하다.\n\n![차이1](차이2.png)\n\n각각의 목적을 위한 방법들을 가지기 때문에 생각보다 큰 차이가 없다고 느껴졌다.\n\n### Type Assertion\n\nObject.keys() 문이나 try/catch문으로 받은 error를 다루거나 할때 우리는 unknown타입을 마주한다. 이럴 때 필요한 타입으로 좁혀주어야할 경우가 현실적으로 필요하다. 이럴 때 사용할 수 있는 방법이 Type Assertion이다.\n\nType assertion이 무서운 이유는 런타임에 우리가 예측한 타입과 다른 값이 실제로 들어올지 모른다는 점 때문이다. 꼭 필요할 때만 사용하자.\n\n```typescript\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement\n```\n\n### Literal Type\n\n값을 이용해서 타입을 정하는 방법으로 타입이 하나의 값으로 고정되기 때문에 주로 Union type으로 여러가지 값을 이용해 정의한다.\n\n```typescript\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\")\n```\n\n객체를 이용할 때는 그 값이 가지는 타입으로 속성을 타입을 정의하지 값으로 정의하지 않는다.\n\n![literal](literal.png)\n\n위 코드가 에러가 난 이유는 method의 타입이 `\"GET\"|\"POST\"` 값의 union 타입으로 정의되어있는데 req의 method는 `\"GET\"`값으로 타입이 추론된 것이 아니라 string으로 추론되었기 때문이다.\n\n### Null과 Undefined\n\n- strictNullChecks: null을 반드시 거를 수 있게 하는 옵션이다.\n- Non-null Assertion Operator(!): null과 undefined이 아니라 단언하는 operator로, 단언이기 때문에 지양하자.\n"},{"excerpt":"🧐 타입스크립트를 아세요? 타입스크립트는 내가 매일 사용하지만 나에게 \"타입스크립트를 잘아세요?\"라고 한다면 나는 \"그... 쓸줄은 알아요\"라고만 말할 수 있을 것 같다. 그러면 잘하려면 어떻게 해야할까를 고민해 봤을 때, 나에게 들었던 생각은 \"고개를 들어 공식문서를를 보게하라\"였다. 공식문서 한번 읽지 않고 얼마나 잘할 수 있을까, 책보다도 더 빠르게…","fields":{"slug":"/2023-10-16-the_Basics/"},"frontmatter":{"date":"October 16, 2023","title":"Typescript: The Basics","tags":["typescript"]},"rawMarkdownBody":"\n## 🧐 타입스크립트를 아세요?\n\n타입스크립트는 내가 매일 사용하지만 나에게 \"타입스크립트를 잘아세요?\"라고 한다면 나는 \"그... 쓸줄은 알아요\"라고만 말할 수 있을 것 같다. 그러면 잘하려면 어떻게 해야할까를 고민해 봤을 때, 나에게 들었던 생각은 \"고개를 들어 **공식문서를**를 보게하라\"였다. 공식문서 한번 읽지 않고 얼마나 잘할 수 있을까, 책보다도 더 빠르게 업데이트되고 누가 봐도 잘 설명할 수 있게 고민의 흔적이 담긴 문서는 공식문서였다. 그래서 한번도 읽지 않았던, 공식문서를 읽고 한번 정리해보려 한다. 영어를 해석하다 보니 오역도 있을 수 있고 쓰다보면 내 맘대로 쓰는 말들도 많겠지만, 이왕 마음먹은 거 하루에 한페이지씩 끝까지 꼭 작성해보려 한다.\n\n### The Basics\n\n타입스크립트는 왜 필요할까? 그냥 사람들이 많이 쓰고 현업에서 많이 사용하니까라고 대답해도 틀린 답은 아닐 것이다. 하지만 내가 느꼈던 타입스크립트의 필요성은 **개발자의 생산성**이었다.\n\n개발자의 생산성이란 말과 타입이 추가되는 것이랑 무슨 상관인지... 오히려 코드량은 더 많고 세팅도 늘어나는 데, 뭘 더 빠르게 해준다는 거지 싶었지만 쓰면 쓸수록 이해할 수 있었다.\n\n타입스크립트 핸드북 첫장의 내용도 동일했다. javascript만으로는 변수에 담긴게 함수인지 객체인지 어떤 것도 알 수 없다고, 개발자가 결국 값에 뭐가 담겼는지 확인해야 하는 불편함을 말하고 있었다.\n\n```typescript\nfunction fn(x) {\n  return x.flip()\n}\n```\n\n자바스크립트 적으로 아무 문제 없는 위 코드의 param인 x가 flip이라는 속성에 함수를 가지고 있지 않다면 **Type error**가 발생하게 될 것이다. 만약 인자가 어떤 타입인지 알았다면 과연 이대로 사용했을까?\n\n타입스크립트는 추가적으로 타입을 추가적으로 작성해줘야 하지만, 개발자가 변수에 대한 타입을 **일일이 기억하지 않아도 되게** 도와주고, 런타임에서 작성되는 자바스크립트 코드에 동작/배포 전에 에러를 잡아줌으로써 생산성을 높여주게 된다.\n\n[히히 못가..]\n\n![random](random.jpeg)\n\n### Non-exception Failures\n\n자바스크립트는 다양한 에러를 만들 수 있는데, 이러한 에러들을 타입스크립트가 먼저 코드를 작성하는 시점에 개발자에게 알려줄 수 있다.\n\n- 없는 속성에 접근했을 때\n\n자바스크립트는 객체의 없는 속성에 접근하게 되면 `undefined`을 반환한다. 그렇기 때문에 자바스크립트만으로는 아무 문제 없이 지나가게 되고 우리가 예상하지 못했던 에러를 마주하게 된다.\n\n![non-exception](nonexception1.png)\n\n- 오타가 발생했을 때\n\n자바스크립트는 오타를 발생해도 알지 못한다. 왜냐면 있을지도(?) 모르기 때문이다. 타입이 없기 때문에 어떤 값을 가지고 있을지 몰라 오타인줄 모른다.\n\n![non-exception](nonexception2.png)\n\n- 함수가 호출되지 않았을 때\n\n함수자체는 참조값으로 저장된다. 호출되지 않고 값으로 사용될 수 있는 상황이라면 우리가 예상하지 못한 일이 펼쳐진다.\n\n![non-exception](nonexception3.png)\n\n### Types for Tooling\n\n위에 언급한 에러들은 자바스크립트로 코드를 작성할 때 흔히 발생할 수 있는 상황이다. 이러한 문제상황을 해결하는 중요한 방법중 하나는 바로 `애초에 문제상황을 만들지 않는 것`이라고 할 수 있다.\n\n타입스크립트는 개발 당시에 타입을 이용해 어떤 값에 접근할 수 있는지를 보여줄 수 있기 때문에 이러한 에러를 먼저 방지하는 데 큰 도움을 준다.\n\n![tooling](tooling.png)\n\n### tsc\n\ntsc는 타입스크립트로 우리가 작성한 코드의 타입을 체크할 수 있게 해주는 compiler를 의미한다. 실제 현업에서는 tsc를 이용과 github action 또는 husky를 이용해서 코드가 병합되기 전 타입에러가 없는지 검사한다.\n\n- --noEmitOnError\n\n이러한 tsc는 다양한 컴파일 옵션을 가지고 있는데 그중 noEmitOnError는 타입 에러가 있을 경우에 컴파일하지 않는 옵션이다.\n\n### Explicit Types\n\n이제 타입스크립트로 타입을 인자에 할당해보자.\n\n```typescript\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`)\n}\n\ngreet(\"Maddison\", Date())\n```\n\n![explicit](explicit.png)\n위 코드를 보았을 때는 언뜩보면 아무문제 없어 보이지만 `Date()`를 통해 반환된 결과값이 `string`이기 때문에 에러가 발생한 것을 볼 수 있다.\n\n타입스크립트가 `Date()`를 자동으로 추론해줌으로써 발생할 수 있는 에러를 미리 알려줄 수 있었다.\n\n### Erased Types\n\n```javascript\nfunction greet(person, date) {\n  console.log(\n    \"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\")\n  )\n}\ngreet(\"Maddison\", new Date())\n```\n\n위 코드를 컴파일 해보면 javascript코드로 우리가 작성된 코드와 다르게 컴파일된 결과를 볼 수 있다.\n\n이는 TSC가 우리가 설정한 ECMAScript 버전에 맞게 컴파일 한 것으로 만약 es2015으로 설정한다면 우리가 작성한 그대로 컴파일 될 수 있다.\n\n```typescript\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`)\n}\ngreet(\"Maddison\", new Date())\n```\n\n### TSC의 옵션 몇가지\n\n마지막으로 basics 페이지의 내용은 tsc의 세가지 옵션에 대해 설명한다.\n\n- Strictness: tsconfig.json의 `\"strict\": true`로 설정시 strict 모드로 코드를 작성하게 한다.\n- noImplicitAny: 타입 설정 중 암묵적으로 any가 할당되는 것을 방지하는 옵션으로 주로 함수의 타입이 정해지지 않은 인자와 같은 코드를 에러로 잡아주는 옵션이다.\n- strictNullChecks: null과 undefined은 둘다 falsy한 값이 지만 다른 결과를 만들기도 하기 때문에 둘을 정확히 핸들링 할 수 있게 에러로 잡아주는 옵션이다.\n"},{"excerpt":"9월동안 했던 업무와 학습한 내용들을 돌아보면 스쿼드 업무로는 사내의 새벽점검작업을 참여했고, 우리 제품의 중요한 도메인중 하나인 바로견적에 대한 개선 작업을 했다. 개인적으로는 매일 사용하지만 부족함을 느꼈던 부분들을 공부했다. 😅 처음해본 새벽 점검 작업 견적발송에 관한 책임이 우리 스쿼드로 모두 넘어오면서 추석과 연휴를 앞두고 필요했던 9월 새벽점검…","fields":{"slug":"/2023-10-03-2023년-9월회고/"},"frontmatter":{"date":"October 03, 2023","title":"🚅 2023년 9월 회고","tags":["회고"]},"rawMarkdownBody":"\n9월동안 했던 업무와 학습한 내용들을 돌아보면 스쿼드 업무로는 사내의 새벽점검작업을 참여했고, 우리 제품의 중요한 도메인중 하나인 바로견적에 대한 개선 작업을 했다. 개인적으로는 매일 사용하지만 부족함을 느꼈던 부분들을 공부했다.\n\n### 😅 처음해본 새벽 점검 작업\n\n견적발송에 관한 책임이 우리 스쿼드로 모두 넘어오면서 추석과 연휴를 앞두고 필요했던 9월 새벽점검 작업을 진행하게 되었다. 점검을 위해서 PO분과 백엔드개발자 분들에 비해 상대적으로 적은 작업을 했지만, 점검을 확인하기 위해 **점검 우회가 가능한 버전**의 앱을 빌드해 공유드리는 역할을 맡았다.\n\n일을 하면서 전 작업자분들과 많이 이야기하고, 스쿼드 내부 점검 테스트도 진행하며 실서버에서 점검을별다른 추가 작업이 없어도 될 것이라 예상했다. 하지만 전달드린 빌드버전이 PROD 서버의 점검을 우회하지 못하는 상황이 벌어졌다. 많이 당황스러웠지만 최대한 빨리 전달드려야할 것 같아 원인을 찾아보았고, 원인은 **점검우회를 위한 키값 설정** 때문이었다.\n\n우리 앱의 환경변수를 설정할 때 **config**를 이용해 서드파티 라이브러리들에 필요한 키값 등을 설정하고 있는데 Dev/Prod에 따라 서버점검 우회 키값이 다르게 설정되어 있다. 내가 전달드린 테스트용 빌드 버전은 dev 버전의 키값이기 때문에 스쿼드 내부 점검 테스트는 우회할 수 있었지만, Prod 서버에 접근할 때는 Prod로 설정되어있는 서버점검 우회 키값이 필요해 발생한 상황이었다.\n\nProd 키 값으로 임의로 수정한 버전을 다시 빌드해 전달드리면서 해결할 수 있었지만, 서비스에 영향을 주지않기 위해 최대한 빠르게 작업을 진행해야하고 사전에 세워둔 프로세스에서 PO, QA분들이 진행해야할 작업이 늦춰지는 것 같아 많이 당황스러운 순간이었다 😂\n\n사전에 PROD 서버 점검을 위해서는 내부테스터 또는 testflight 앱을 다운받아서 QA 하실 수 있게 안내했어야했는데 사전 준비와 우리 앱의 동작이 어떻게 되는지에 대해 이해가 부족해 생긴 이슈였다... 하지만 개인적으로는 모바일 환경에 대해 더 많이 배울 수 있고 이해도를 높일 수 있는 좋은 기회가 되었고, 이후 점검시 더 편하게 진행할 수 있게 세팅을 수정하는 작업도 추가적으로 진행했다.\n\n![image-20231003201510681](https://github.com/choi2021/choi2021.github.io/assets/80830981/d1c3d88a-6da4-475e-b9ea-0616eb100d8c)\n\n### 😎React-native-reanimated 써보기\n\n스쿼드 작업으로 바로견적 지역설정 개선 일감을 진행하면서 **react-native-reanimated** 라이브러리를 이용했다. 라이브러리를 이용하면서 공부했던 내용을 정리해보려 한다.\n\nReact-native-reanimated는 react-native 환경에서 애니메이션을 60FPS에 맞게 구현할 수 있게 도와주는 라이브러리다. 저번달의 sticky 헤더 애니메이션을 구현하면서도 사용하려 했지만, 당시 v1으로 설치되어있었기 때문에 react native 버전을 0.71로 올리는 작업과 병목이 있어 react-native 자체 animated api를 이용했다. 결국은 안드로이드에서... 좌절하게 되었지만...🥲\n\n그러면 왜 reanimated는 자체 React-native의 Animated보다 성능을 잘 보장할 수 있을까?\n\n##### 짤막한 React-native-reanimated의 원리\n\nreact-native-reanimated를 이해하기 위해서는 먼저 RN이 두개의 스레드로 이루어져있다는 점을 알아야한다.\n\nRN의 두가지 스레드는 **JS 스레드**와 **UI스레드**로 구성되어있는데 두가지 스레드가 하는 역할이 다르다.\n\n- JS 스레드: 내가 작성하는 JS 코드(react)가 동작하는 곳\n- UI 스레드: native(IOS/AOS) 코드가 동작하는 곳\n\n두가지 다른 스레드는 **Bridge**를 통해서 JSON 형식으로 소통해 내가 원하는 UI를 만들게 된다. 이러한 소통과정에서 JS 스레드에서 시간이 많이 소요되는 작업이 진행중이라면 UI 스레드에 반영이 늦어져 **프레임 드랍**이 발생하게 되면서 우리가 원하는 자연스러운 애니메이션 구현에 어려움이 생기게 된다.\n\n<br/>\n\n<img src=\"https://blog.xmartlabs.com/images/powerful-animations-rn/frame_drops.png\"/>\n\n저번달에 애니메이션의 어려움을 겪었던 이유를 분석했던 것 처럼 layout을 이동시키는 것은 RN의 Animated API를 이용할 때 useNativeDriver를 사용할 수 없기 때문에, JS 스레드에서 동작하기 때문에 버벅임이 발생한 것으로 이해할 수 있었다.\n\n그러면 reanimated는 이러한 문제를 **어떻게** 해결하는 걸까?\n\n<br/>\n\nreanimated는 자연스러운 애니메이션을 위해 두가지를 이용하는데 바로 **Shared value**와 **worklet** 함수이다.\n\nsharedValue는 JS스레드와 UI스레드 모두에서 읽을 수 있는 값이고 worklet함수는 UI 스레드에서 작동하는 자바스크립트 함수를 의미하는데, 애니메이션을 비동기적으로 전달하는 것이 아니라 **UI 스레드에서 바로 동작**할 수 있게함으로써 성능을 보장한다.\n\n```jsx\nfunction App() {\n  // shared value\n  const sv = useSharedValue(0)\n\n  const handlePress = () => {\n    sv.value += 10\n  }\n\n  // worklet function\n  const style = useAnimatedStyle(() => {\n    console.log(\"Running on the UI thread\")\n    return { opacity: 0.5 }\n  })\n}\n```\n\nJS 코드를 바로 UI 스레드로 동작하게 위해서는 Reanimated의 자체 babel plugin을 통해 worklet함수를 파악함으로써 동작할 수 있다. 왜 reanimated 설치시 `babel.config.js`에 플러그인을 추가하게 하는지 이해할 수 있었다.\n\n[Reanimated 설치시 필요한 플러그인]\n\n```tsx\nmodule.exports = {\n  presets: [\n    // ... // don't add it here :)\n  ],\n  plugins: [...\"react-native-reanimated/plugin\"],\n}\n```\n\n좀 더 깊은 내용은 [Reanimated 플러그인 README](https://github.com/software-mansion/react-native-reanimated/blob/main/plugin/README-dev.md)를 통해 이해할 수 있다.\n\n<br/>\n\n[Reanimated를 이용해 UI 스레드에서 동작하는 애니메이션 코드]\n\n<img src=\"https://blog.xmartlabs.com/images/powerful-animations-rn/declarative_way.png\"/>\n\n##### Reaniamted를 이용해 내가 만들었던 애니메이션\n\n간단하게 reanimated를 통해 구현했던 애니메이션 코드를 정리해보려 한다. 내가 구현해야하는 요구사항은 조건에 따라 롤링이 되는 섹션으로 조건에 따라 다음으로 넘어가듯이 나타나게 되는 애니메이션이었다.\n\n이를 위한 코드 예시는 간단히 다음과 같다.\n\n```tsx\nexport default function App() {\n  const animatedOpacity = useSharedValue(1)\n  const animatedTranslateY = useSharedValue(0)\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: animatedOpacity.value,\n      transform: [{ translateY: animatedTranslateY.value }],\n    }\n  })\n\n  const handlePressSteady = () => {\n    animatedTranslateY.value = withTiming(0, { duration: DURATION })\n    animatedOpacity.value = withTiming(1, { duration: DURATION })\n  }\n\n  const handlePressUp = () => {\n    animatedTranslateY.value = withTiming(-DISTANCE, { duration: DURATION })\n    animatedOpacity.value = withTiming(0, { duration: DURATION })\n  }\n\n  const handlePressDown = () => {\n    animatedTranslateY.value = withTiming(DISTANCE, { duration: DURATION })\n    animatedOpacity.value = withTiming(0, { duration: DURATION })\n  }\n\n  return (\n    <View style={{ flex: 1, alignItems: \"center\", justifyContent: \"center\" }}>\n      <Animated.View style={animatedStyle}>\n        <View\n          style={{\n            width: 100,\n            height: 100,\n            backgroundColor: \"teal\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n          }}\n        >\n          <Text style={{ color: \"white\", fontSize: 30 }}>돌거야</Text>\n        </View>\n      </Animated.View>\n      <View style={{ flexDirection: \"row\", marginTop: 100 }}>\n        <Button onPress={handlePressUp} title=\"올라가유\" />\n        <Button onPress={handlePressSteady} title=\"보여유\" />\n        <Button onPress={handlePressDown} title=\"내려가유\" />\n      </View>\n    </View>\n  )\n}\n```\n\n<br/>\n\n위 코드로 구현한 애니메이션은 다음과 같다.\n\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/836938bb-bc34-4189-8bf6-ca7c23c6d11e\" width=\"300\"/>\n\n이제 하나일때가 아니라 여러개 일때의 애니메이션을 만들어 보자.\n\n```tsx\nconst RollingView: React.FC<{ text: string; show: boolean }> = ({\n  text,\n  show,\n}) => {\n  const animatedOpacity = useSharedValue(1)\n  const animatedTranslateY = useSharedValue(0)\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: animatedOpacity.value,\n      transform: [{ translateY: animatedTranslateY.value }],\n    }\n  })\n\n  const startAnimation = useCallback(() => {\n    if (show) {\n      animatedTranslateY.value = withTiming(0, { duration: DURATION })\n      animatedOpacity.value = withTiming(1, { duration: DURATION })\n    } else {\n      animatedTranslateY.value = withSequence(\n        withTiming(-DISTANCE, { duration: DURATION }),\n        withTiming(DISTANCE, { duration: 0 })\n      )\n      animatedOpacity.value = withTiming(0, { duration: DURATION / 2 })\n    }\n  }, [animatedOpacity, animatedTranslateY, show])\n\n  useEffect(() => {\n    startAnimation()\n  }, [startAnimation])\n\n  return (\n    <Animated.View\n      style={[\n        {\n          backgroundColor: \"teal\",\n          position: \"absolute\",\n          justifyContent: \"center\",\n          alignItems: \"center\",\n        },\n        animatedStyle,\n      ]}\n    >\n      <Text style={{ color: \"white\", fontSize: 30 }}>{text}</Text>\n    </Animated.View>\n  )\n}\n\nexport default function App() {\n  const [showingNumber, setShowingNumber] = useState(1)\n\n  const handlePressOne = () => {\n    setShowingNumber(1)\n  }\n\n  const handlePressTwo = () => {\n    setShowingNumber(2)\n  }\n\n  return (\n    <View style={{ flex: 1, alignItems: \"center\", justifyContent: \"center\" }}>\n      <View\n        style={{\n          position: \"relative\",\n          justifyContent: \"center\",\n          overflow: \"hidden\",\n          width: 100,\n          height: 100,\n        }}\n      >\n        <RollingView text={\"1번\"} show={showingNumber === 1} />\n        <RollingView text={\"2번\"} show={showingNumber === 2} />\n      </View>\n      <View style={{ flexDirection: \"row\", marginTop: 100 }}>\n        <Button onPress={handlePressOne} title=\"1번 보여줘\" />\n        <Button onPress={handlePressTwo} title=\"2번 보여줘\" />\n      </View>\n    </View>\n  )\n}\n```\n\n위 코드를 동작시키면 다음과 같은 애니메이션이 만들어진다.\n\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/0a45c37e-3ac9-4090-a5a9-696d49430c6f\" width=\"300\"/>\n\n내가 한 방법이 최선은 아닐 수도 있지만 reanimated를 이용해서 애니메이션 요구사항을 AOS/IOS 모두에서 적절하게 구현할 수 있어서 뿌듯했던 일감이었다.\n\n### 😊하루하루 내가 공부해온 것들\n\n개발자로 8개월이란 시간이 쌓이면서 내가 우선시해서 공부해야할 것이 무엇일까 고민했다. 9월은 블로그에 기록하지는 않았지만 3월부터 클린코드, 클린 아키텍처, 함수형 프로그래밍, 리팩터링 4권의 책을 읽었고 다음은 어떤걸 공부해볼까 고민이 되는 시점이었다. 아침 저녁 출퇴근 시간에 선배 개발자분들의 유튜브 영상들을 많이 찾아보는데, 그때 **드림코딩**의 [개발 공부 제대로 하는 법 🤓 (정체기에서 성장기로 가보자, 함 해보자!)](https://www.youtube.com/watch?v=DmK7d0xB2j0) 의 일정관리 부분에 대해 들으면서 내가 우선해서 학습해야할 내용은 어떤 것인지 정해보게 되었다.\n\n##### 타입스크립트를 아세요? 🧐\n\n나는 **react-native**를 이용해 모바일 엔지니어로 일하고 있고 개발 언어는 **Typescript**로 개발하고 있다. 그렇다면 내가 더 많이 회사에 기여하고 성장하기 위해서 우선시 해서 잘해야할 부분이 어떤 것인지에 대해 생각해보았을 때, 가장 먼저 떠올랐던 부분이 `Typescript` 였다.\n\n\"나는 타입스크립트를 잘알고 있나?\"라는 질문을 했을 때 그렇지 않다는 생각이 들었다. 단순히 내가 type alias와 interface를 정의하고 사용하는 것에 그치고 있었다. \"그러고 보니 나는 한번도 타입스크립트 공식문서를 보지 않았구나... \"라는 생각에 **하루에 한페이지**씩 타입스크립트 공식문서 핸드북을 정리해보자는 목표가 생겼다.\n\n나름 매일 한 챕터씩 정리해서 현재 거의 대부분의 핸드북 내용을 한번씩 다읽어보았다. 읽으면서 왜 코드리뷰때 switch문의 default문을 작성할 때 never 타입으로 변수를 만들어서 적용하는 게 좋겠다고 말씀해주셨는지, enum과 object는 어떻게 다른지 등등을 알 수 있었다.\n\n내맘대로 정리한 Typescript Handbook 내용은 조금 더 다듬어서 typescript 섹션에 정리해보려 한다.\n\n[내맘대로 정리한 Typescript HandBook 내용]\n\n<img width=\"400\" src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/ab929707-55dd-49b6-a4b2-1ea115c9806c\"/>\n\n##### Native도 공부해보자 🫡\n\n챕터내 업무로 에러/예외처리 고도화 업무를 맡아서 진행하면서 네이티브 에러들을 보면 잘 이해가 안되고 해결하지 못해서 답답하게 느껴졌다. 우리 프로젝트 내의 코드가 아니라 라이브러리들이나 react-native가 가지고 있는 문제로 인해 발생하는 경우가 많았기 때문에 `java`라고 적혀있기만 하면 괜히 무서운 느낌이 들고, 해결하기 어렵겠다는 생각에 후순위로 미뤘다.\n\n하지만 Firebase의 Crashanalytics에 제보되기도 하고 에러로그에 갑자기 죽는 로그들을 보면서 내가 더 공부한다면 더 많은 것을 우리 챕터에 기여할 수 있겠다는 생각이 들어 Native에 대한 이해도를 해결하고자 **안드로이드**를 공부하기 시작했다.\n\n내가 처음 자바스크립트를 배울 때 처럼 우선은 코틀린 문법, 코딩테스트 문제들을 풀고, 클론 코딩 강의들을 보면서 어떻게 앱을 만들어가는지를 보고 따라하며 학습하고 있다. 학습할 수록 기존에 사용하던 자바스크립트, 파이썬과 비교하면서 `동적 타입 언어와 정적타입 언어`의 차이점들을 많이 느낄 수 있었고, 자바스크립트와 코틀린이 어떤 점이 다른지 어떤 점은 비슷한지 느끼며 해당 부분도 정리해가고 있다. 이부분도 블로그에 추가적으로 기록해나갈 예정이다.\n\n#### 마치며\n\n멀리 멋있어보이는 것들이 나올 때마다 저것을 배우지 않으면 뒤쳐지지 않을까 걱정도 되지만, 지금 내가 있는 자리에서 필요한 부분들을 채워나가는 것을 먼저해야겠다고 다시 한번 생각한 한달이었다. 매일 사용하는 타입스크립트와 Git, 리액트와 네이티브 코드들, 충분히 잘 이해하고 있는지 점검해보면서 우선순위를 세울 수 있었다. 더 많이 나누고 더 많이 기여하기 위해서는 내가 먼저 채워져야함을 많이 느낀다. 아직 8개월 차 응애(?)고 매일매일 새롭게 배울게 넘쳐나지만 여기서 주어지는 키워드들을 놓치지 않고 내것으로 만들다보면 내가 보고 배워야겠다고 느끼는 동료들의 모습을 나도 가지게 되어가지 않을까 생각한다. 그냥 꾸준히 하는 것, 내가 제일 잘하는 **꾸준히**를 매일 해보자.\n\n[참고한 자료]\n\n- [reanimated 공식문서](https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/glossary/#ui-thread)\n- [reanimated 플러그인 Readme](https://github.com/software-mansion/react-native-reanimated/blob/main/plugin/README-dev.md)\n\n- [Powerful animations in React Native](https://blog.xmartlabs.com/2020/04/27/powerful-animations-in-RN/)\n- [원리와 예제를 통해 React-native-reanimated V2 입문하기](https://medium.com/crossplatformkorea/%EC%9B%90%EB%A6%AC%EC%99%80-%EC%98%88%EC%A0%9C%EB%A5%BC-%ED%86%B5%ED%95%B4-react-native-reanimated-v2-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0-336e832f6ed6)\n"},{"excerpt":"항상 시간은 빠르게 흘러 개발자로 일한지 벌써 6개월이란 시간이 지나버렸다. 이번 한달은 스쿼드의 인원변동이 있어서 업무보다는 모바일 챕터 업무에 많은 시간을 쏟았다. 7월 회고에 언급했던 예외/에러 처리 고도화 작업과 함께 React native 발표 자료들을 찾아보다 발견한 성능 측정 툴인 Flash Light에 대해서 정리해서 챕터 기술 세션에 발표…","fields":{"slug":"/2023-09-09-2023년-8월회고/"},"frontmatter":{"date":"September 09, 2023","title":"😊 2023년 8월 회고","tags":["회고","에러모니터링","에러핸들링"]},"rawMarkdownBody":"\n항상 시간은 빠르게 흘러 개발자로 일한지 벌써 6개월이란 시간이 지나버렸다. 이번 한달은 스쿼드의 인원변동이 있어서 업무보다는 모바일 챕터 업무에 많은 시간을 쏟았다. 7월 회고에 언급했던 **예외/에러 처리** 고도화 작업과 함께 React native 발표 자료들을 찾아보다 발견한 성능 측정 툴인 **Flash Light**에 대해서 정리해서 챕터 기술 세션에 발표하기도 했다. 두가지 주제에 대해서 조사하고 공부했던 내용을 적으면서 내가 어떤 점이 부족했는지, 어떤 점은 잘했다고 생각하는지 돌아보려 한다.\n\n### 🥹 본격적으로 시작한 예외/에러 처리 작업\n\n에러/예외 처리 작업은 우리 챕터의 3분기 큰 일감중 하나로 내가 리드를 맡아서 진행하게 되었다. 이를 위해서는 우선 우리 프로젝트에서 사용하고 있는 에러 리포팅 툴인 **Bugsnag**에 대해 잘 알아야했고, 이와 함께 어떤 방식으로 큰 일감을 작은 스토리와 티켓들로 나눠서 작업을 해갈지 **전체적인 로드맵**을 구성해 나가야 했다.\n\n#### 우리가 사용하는 툴, 버그스낵 알아보기\n\n**버그스낵**은 에러/버그 리포팅을 위한 툴이다. 버그스낵을 통해서 어느 코드에서 해당 에러 로그가 제보되었는지 또는 사용자가 호출했던 API나 방문한 페이지 등에 대한 정보들을 기록해준다. 기록된 에러로그는 아래 사진의 대시보드와 같이 모아서 확인할 수 있고 각각을 태그나 에러 메시지 등을 모아서 필터링 하는 등 다양하게 활용이 가능하다.\n\n<br/>\n\n[버그스낵 대시보드 화면]\n\n![image-20230909145825228](https://www.bugsnag.com/wp-content/uploads/2023/05/607f4f6df411bd87c37dd774_prod-searchtab-stacktrace-js.png)\n\n<br/>\n\n먼저 기본 세팅을 하는 것에 있어서 자체 CLI를 제공하기 때문에 DEV/PROD로 구분된 로그 모니터링 프로젝트의 API Key를 연결하고 앱의 source map을 올림으로써 암호화된 JS Bundle 중 어디서 발생된 로그인지를 파악할 수 있다.\n\n[설정 명령어]\n\n```bash\nnpm install --global @bugsnag/react-native-cli\n# or\nyarn global add @bugsnag/react-native-cli\n\n# then\nbugsnag-react-native-cli init\n\n```\n\n#### Error Boundary\n\n이렇게 설정된 버그스낵을 사용할 때는 버그스낵 자체적인 **Error Boundary** plugin을 이용할 수 있다. 우리 프로젝트는 Error Boundary를 프로젝트 최상위에서 에러를 리포팅 받을 수 있게 설정되어 있는 상태였다.\n\n[버그 스낵 Error boundary 예시 코드]\n\n```tsx\n// Start BugSnag first...\nBugsnag.start({...})\n\n// Create the error boundary...\nconst ErrorBoundary = Bugsnag.getPlugin('react').createErrorBoundary(React)\n\nconst onError = (event) => {\n  // callback will only run for errors caught by boundary\n}\n\nconst ErrorView = ({ clearError }) =>\n  <View>\n    <Text>Inform users of an error in the component tree.\n    Use clearError to reset ErrorBoundary state and re-render child tree.</Text>\n    <Button onPress={clearError} title=\"Reset\" />\n  </View>\n\nconst App = () => {\n  // Your main App component\n}\n\nexport default () =>\n  <ErrorBoundary FallbackComponent={ErrorView} onError={onError}>\n    <App />\n  </ErrorBoundary>\n\n```\n\n우리 프로젝트에서 ErrorBoundary가 프로젝트 최상위에 설정되어 있어 핸들링 하지 않는 에러들을 제보받아 로그로 남기고 있었다. 하지만 스크린단이나 컴포넌트 수준에서는 API 호출에 따른 에러를 예외처리를 적용하는 Error boundary가 적용되어 있지 않고 성공/실패/로딩 케이스에 따른 분기문으로 처리된 코드가 일부 남아있었다.\n\n[성공/실패에 따라 렌더링되는 스크린 코드 예시]\n\n```tsx\nconst ExampleScreen: React.FC = () => {\n  const [list, setList] = useState([])\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState(null)\n\n  useEffect(() => {\n    ;(async () => {\n      try {\n        setIsLoading(true)\n        const result = await getRemoteData()\n        setList(result)\n      } catch (e) {\n        setError(e)\n      } finally {\n        setIsLoading(false)\n      }\n    })()\n  }, [])\n\n  if (isLoading) {\n    return <LoadingView />\n  }\n\n  if (isNotNil(error)) {\n    return <ErrorView />\n  }\n\n  return <SuccessView />\n}\n```\n\n이렇게 분기문으로 정의 되어있다면 성공/실패/로딩 세가지에 대한 **관심사가 한곳에 뭉쳐있게** 되기에 이를 해결할기 위해서 성공케이스만 남기고 실패시 보여줘야할 부분은 ErrorBoundary와 Fallback 컴포넌트로 위임시켜 **관심사를 분리**할 수 있어 보였다.\n\n#### Notify/LeaveBreadCrumb\n\n버그스낵은 직접 필요한 곳에서 로그를 남길 수 있는 **notify** 메소드를 제공한다. notify 메소드를 이용하게 되면 원하는 곳에 다양한 데이터를 담아서 보낼 수 있게 되는데 여기에 스크린/파일 위치/ 태그 등을 기록함으로써 보다 로그를 잘 분류하고 한눈에 잘 볼 수 있다. Notify 함수 내부에 event 객체를 받는데 이때 전달받은 event객체의 metadata등 다양한 설정을 추가할 수 있다.\n\n```typescript\ntry {\n  something.risky()\n} catch (e) {\n  Bugsnag.notify(error,(event)=>{\n    event.severity='warning'; //위험도 설정\n    event.unhandled='unhandled'; // unhandled/handled 설정\n    event.addMetadata('metadata',{...}); // metadata 추가\n    return true      // true로 함으로써 발송해\n  })\n}\n\n```\n\n**😅 사용시 주의점 **\n\nnotify를 이용해서 버그를 찍어보려할 때 주의할 점은 버그스낵은 **remote Debug tool과 함께 사용하게 되면 정상적으로 로그가 남지 않는다**는 점이다. 이런 이유로는 remote debugger를 사용하게 되면 사용하는 JS 엔진이 달라지기 때문에 정상적으로 버그스낵이 시작되지 못하는 것으로 보인다.\n\n[React native Debugger와 함께 사용했을 때 Warning]\n\n<img width=\"901\" alt=\"image-20230910011831924\" src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/4702a0bc-1eba-403b-b716-7f07acf9552f\"/>\n\n버그 스낵에는 *breadcrumbs*이라는 짧은 로그가 있어 다음과 같은 기록을 각 에러 로그에 자동으로 남김으로써 디버깅을 도와준다.\n\n- Low memory warnings\n- Device rotation\n- Menu presentation\n- Screenshot capture (not the screenshot itself)\n- Undo and redo\n- Table view selection\n- Window visibility changes\n- Non-fatal errors\n- Log messages\n- User navigation (when enabled through our [navigation plugins](https://docs.bugsnag.com/platforms/react-native/react-native/navigation-libraries/))\n- HTTP requests (from JavaScript layer)\n\n이러한 사용자의 동작을 추적함으로써 실제로 불필요한 API가 호출되거나 실패하거나, 메모리 부족으로 발생하는 에러 등을 확인할 수 있었다.\n\n[Breadcrumbs가 남겨진 모습]\n\n<img src=\"https://docs.bugsnag.com/assets/images/platforms/cocoa-network-crumb.png\" width=\"600\"/>\n\n#### Severity\n\n버그스낵에서 에러의 심각도는 2가지로 기준으로 구분된다.\n\n1. handled/unhandled\n2. Error/Warning/ Info\n\n조합해보면 총 6가지의 에러 심각도가 나올 수 있지만 unhandled Info와 unhandled Warning을 불필요해보여 아래 **4가지**로 구분하기로 했다.\n\n- Unhandled Error\n- Handled Error\n- Warning\n- Info\n\n버그스낵 자체 default로는 handled Error는 warning, unhandled Error는 error 심각도로 로그가 남겨진다.\n\n기존 우리 프로젝트 코드는 notify 메소드를 이용해 로그를 찍을 때, 별도의 severity를 설정해서 찍지 않아 기본적인 default severity로 찍히고 있었다. severity를 설정하는 코드는 앞서 설명한 notify 메소드 내부의 onError를 통한 설정으로 예외처리가 되어있는 에러들은 info나 warning으로만 남길 수 있게 적용하려 했다.\n\n#### 이제 일감을 쪼개보자\n\n이렇게 버그스낵를 잘 사용하는 방법에 대해서 조사한 이후에는 다음과 같이 크게 두가지 스텝으로 나누어서 일감을 분리해보았다. 단순히 3분기 내에 모든 작업을 완료할 수는 없을 것이라 생각하고 3분기에는 Step1에만 집중하고자 했다.\n\n<br/>\n\n| **Step 1. 기존 에러 리포트 방식 개선**         | **Step 2. 에러 핸들링 컨벤션 세우기**         |\n| :--------------------------------------------- | :-------------------------------------------- |\n| 에러 로그 호출 방식 통일화 (완료)              | 에러 바운더리 적용                            |\n| 에러 로그 리포트 함수 인터페이스 정리 (진행중) | 비어있는 try-catch 문 제한 커스텀 룰 적용하기 |\n| 기존 에러 로그 분류 (진행중)                   |                                               |\n| 에러 심각도에 따라 슬랙채널에 공지받기         |                                               |\n\n<br/>\n\nStep 1은 기존 찍고 있는 로그를 정리하는 작업으로 **의미있고 풍부한 로그를 쌓게하는 작업**과 **로그를 편하게 사용할 수 있게 인터페이스**를 정리하는 작업을 우선으로 잡았다. 그중 8월 한달 동안은 호출 방식을 통일화 하는 작업을 완료했고 인터페이스는 더 필요한 정보들을 잘 전달하기 위해 실제 쌓여있는 로그들을 분석하면서 필수적인 요소들을 담을 수 있게 인터페이스를 정비했다.\n\n9월 동안에는 계속해서 쌓이고 있는 로그들을 분석하면서 변경된 인터페이스에 맞게 더 의미있는 로그들로 바꿔갈 예정이다. 임시적이지만 분류를 위한 기준은 다음과 같이 잡았다.\n\n- Error: 긴급 대응이 필요한 에러를 기록하기 위한 로그\n  - 예시: 화이트 스크린, unhandled Error\n- Warning: 앱이 죽는 에러는 아니지만 유저 경험에 좋지 않은 상황을 기록하기 위한 로그\n  - 예시: Authorization 에러, TIme Out 에러\n- Info: 예외 처리가 가능 하지만 기록을 남기기 위한 로그\n  - 예시: 요청서/ 견적서 / 결제 등 주요 도메인에 추적을 위한 로그\n\n이 기준은 더 다양한 케이스들을 보고 챕터원들과 의논을 통해 계속해서 확장해 나갈 예정이다.\n\n버그 스낵에 있는 수많은 로그들을 보면서 압도되기도 했지만 하나하나 보면서 우리 앱에서 놓치고 있는 부분이나 빠져있는 부분들을 보기도 하고, **Native 에러**를 보면서 모바일 개발자로써 더 많이 공부하고 싶다는 의욕도 생기는 계기가 되었다. 더 튼튼하고 사용성 좋은 앱으로 만들어가는 데 많은 기여를 할 수 있는 일감이 되기를 바라면서 나 또한 더 성장하는 계기가 되어가고 있다.\n\n### 🚀모바일의 Light House, Flash Light\n\nExpo와 React Native 컨프런스인 App.js 채널의 자료들을 찾아보다 앱의 성능 측정에 대한 발표를 보게 되었다. 우리 챕터의 큰 목표중 하나인 성능 개선을 위해서 적용해볼 수 있지 않을까 하는 마음으로 정리했고, 챕터 기술 논의 시간에 발표 자료를 정리해서 전달했다.\n\n본 영상은 웹에서의 성능 측정 도구인 Light house와 같이 객관적으로 측정할 수 있는 툴인 Flash Light에 대한 내용으로 성능 측정을 위한 툴로써 사용방법과 어떻게 사용성을 높여왔는지에 대한 내용이 담겨있었다.\n\n<br/>\n\n**공식 사이트와 관련 자료**\n\n[FlashLIght 발표 영상 ](https://www.youtube.com/watch?v=XO8O1iL4Rxg&t=578s)\n\n[FlashLight Github Repo](https://github.com/bamlab/flashlight)\n\n[FlashLight 공식 문서](https://docs.flashlight.dev/)\n\n<br/>\n\nFlash Light는 앱 성능 측정 도구로 **안드로이드를** 기준으로 성능을 측정한다. 이러한 기준을 안드로이드로 잡은 이유는 현재 가장 많은 사람들이 사용하고 있는 안드로이드 기기인 삼성 A21과 아이폰 13을 비교했을 때 다음과 같은 차이가 존재하기 때문에 성능이 낮은 안드로이드를 기준으로 잡았다.\n\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/67635a74-a320-48c2-b49a-7ba5edbd7642\"/>\n\n발표에서 Flash light를 쓸 수 있는 방법을 5가지로 소개하고 있다. 각 방법은 사용성을 더 높이고 객관적인 데이터를 만들기 위한 방향으로 개선되었다.\n\n#### 1. Flipper Plugin\n\n**Flipper**는 IOS/AOS/RN에서 사용할 수 있는 디버깅 툴로써 디버그 앱을 이용해 성능을 측정하는 방식으로 개발되었다. 하지만 Dev 모드 앱만 측정할 수 있는 한계가 있기 때문에 다음 방식인 명령어를 이용한 방식이 고안되고나서 플러그인은 deprecated 되었다.\n\n#### 2. CLI를 이용한 실시간 측정\n\n다음 방식으로 **CLI 명령어**를 이용한 실시간으로 성능을 측정하는 방법으로 간단한 명령어로 Dev모드 뿐아니라 스토어로 시뮬레이터에 설치한 후에 PROD 모드 앱까지 측정할 수 있는 방법을 소개했다. 사용하는 방법은 다음과 같다\n\n```bash\ncurl https://get.flashlight.dev | bash  // 명령어 설치\nflashlight measure\n```\n\n아래 영상을 보면 명령어를 실행하게 되면 localHost로 웹이 켜지는데 자동으로 안드로이드 에뮬레이터를 감지한 후에 해당 에뮬레이터에서 실행중인 앱의 성능을 측정할 수 있다\n\n<br/>\n\n[공식 사이트 CLI 소개 영상]\n\n<iframe width=\"600\" height=\"450\" src=\"https://github.com/bamlab/flashlight/assets/4534323/4038a342-f145-4c3b-8cde-17949bf52612\" frameborder=\"0\" allowfullscreen></iframe>\n\n<br/>\n\n#### 3. 자동화와 유의미한 데이터를 위한 E2E 테스트\n\n위의 방식으로 실시간으로 측정을 할 수 있지만 항상 우리가 수동으로 측정하기 보다는 **E2E를 이용한 자동화**를 이용해 편의성을 높이려 했다. 공식문서에서 E2E툴로써 [Maestro](https://github.com/mobile-dev-inc/maestro)를 이용한 방식을 추천하고 있다. 자동화 명령어를 이용하면 E2E 코드를 이용해 에뮬레이터에서 자동으로 10번 반복해서 실행하고 데이터를 얻을 수 있다.\n\n##### 공식 문서의 트위터를 Maestro를 이용한 E2E 테스트를 측정하는 예시\n\n1.E2E 테스트를 위한 yaml 파일 코드 작성\n\n```\nappId: com.twitter.android\n---\n- launchApp\n- assertVisible: Search and Explore\n```\n\n2.자동화 명령어\n\n```\nflashlight test --bundleId com.twitter.android \\ // 실행할 앱의 bundle Id\n  --testCommand \"maestro test twitter.yaml\" \\ // 실행할 e2e yaml 파일\n  --duration 10000 \\ // 측정 시간\n  --resultsFilePath results.json // 결과 보고서를 저장하는 방식\n```\n\n\\*\\* 앱의 bundle Id는 `npx @perf-profiler/profiler getCurrentApp` 를 통해서 구할 수 있다.\n\n3.결과 보기\n\n```\nflashlight report results.json\n```\n\n자동화 방식을 보면서 좀 더 객관화된 데이터를 얻을 수 있고 e2e 테스트를 확장함으로써 각 스크린에 대한 성능을 더 잘 측정할 수 있지 않을까란 기대감이 생겼다.\n\n#### 4. CI와 연동\n\n위의 자동화 script를 AWS Device Farm의 에뮬레이터를 가상 환경과의 연결 기능을 소개했다. 이를 통해서 프로젝트의 CI과정에서 성능 측정을 자동화 함으로써 주기적으로 리포팅을 받을 수 있지 않을까 기대감도 생겼다.\n\n#### 5. Cloud 환경\n\n마지막 apk를 올리고 원하는 e2e테스트 코드를 작성해서 성능을 가상환경에서 측정해주는 자체 서비스를 소개했다.\n\n사이트 주소는 다음과 같으며 성능 측정이 끝나게 되면 이메일로 결과를 받을 수 있고 결과를 보면 영상으로 나타난다.\n\nFPS, RAM/CPU 사용량 등이 그래프로 나타나지며 영상과 함께 연동되어 있어 어느 지점에서 많은 메모리가 사용되는 지 등을 한눈에 볼 수 있다.\n\n[Cloud 측정 사이트](https://app.flashlight.dev/)\n\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/a727c5ed-1bb8-45ef-bcc5-945929008d4c\" width=\"800\"/>\n\n[당시 공유했던 우리 앱의 측정 결과]\n\n<table>\n  <tr>\n    <th>전체 점수</th>\n  </tr>\n  <tr>\n    <td>\n    <img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/e0eea30c-05b9-4c5a-8da4-6c932e6341a2\" width=\"800\" />\n    </td>\n  </tr>\n  <tr>\n    <th>FPS</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/c2a00cf1-52a2-4d48-9a7a-602e105c4cfc\" width=\"800\" />\n    </td>\n  </tr>\n  <tr>\n    <th>CPU 사용량</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/d6231d9e-9712-4dd3-9972-1d03568dadb8\" width=\"800\" />\n    </td>\n  </tr>\n  <tr>\n    <th>스레드 별 CPU 사용량</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/ccb10691-fdcf-4577-b7fe-c442c6e5b707\" width=\"800\" />\n    </td>\n  </tr>\n  <tr>\n    <th>RAM 사용량</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/f0d89756-9649-43f8-bf46-8c0fdcedb066\" width=\"800\" />\n    </td>\n  </tr>\n</table>\n\n사양이 아주 낮은 기기를 기준으로 하기 때문에 점수는 낮지만 이를 기준으로 개선되었는지를 보는데 사용할 수 있을 것 같아 보였다.\n\n발표내용에 대해서 챕터원 분들이 긍정적으로 들어주셨고 성능 개선 업무를 맡은 챕터원 분들께서 직접 좀 더 조사하시고 flash light를 이용해 성능 측정하는 일감에 적극적으로 사용되고 있다. 조사한 내용이 실제로 의미있는 데이터를 모으는데 도움이 되고 있다는 점에 기뻤고 계속해서 기술 세션들에 대해 관심을 갖게 되는 좋은 계기가 되었다.\n\n### 마치며\n\n8월 한달은 챕터업무가 주로 되었던 만큼 기능을 새롭게 개발하는 작업은 적었다. 챕터에 기여하는 작업을 한다는 것은 즐거웠지만 에러와 예외처리를 위해서 기존에 쌓여있던 로그들을 보며 앱이 강제로 종료되거나 화이트스크린이 왜 뜨는지 재현하기 어려워 하루 종일 로그들만 보다가 지나가기도 하고, 필요한 로그를 분류하기보다 불필요하게 쌓이고 있는 로그들을 먼저 제거하게 되기도 하면서 진행 방향이 중간중간 바뀌기도 했다. 순간 순간 하루를 돌아보면서 `내가 의미있는 작업을 하는 걸까, 내가 잘못하고 있는 것은 아닐까` 고민이 되기도 했지만 챕터원들의 격려에 힘을 받아 진행했던 한달이었다.\n\n에러/ 예외처리라는 일이 당장 눈에 보이는 성과가 적은 일이지만 내가 하는 작업을 통해서 누군가 겪고 있는 에러들을 막으면서 안정성을 높여 더 많은 사람들이 편하게 사용할 수 있기를 기대하고 더 힘내서 진행해보고자 한다. 그리고 혼자서 끙끙대기 보다 각 도메인을 잘 아시는 분들께 적극적으로 도움을 청함으로써 더 효율적으로 일해 9월까지 3분기를 잘 마무리해보려한다.\n"},{"excerpt":"7월의 기억남았던 작업은 이전에 디바이스 서체 설정에 따라 잘리는 것을 막는 방법을 조사했던 것을 일감화해서 직접 트래커를 찍어서 우리 실 사용자들이 어떤 크기로 사용하고 있는지 확인하기도 했고, 받은 요청 화면에서 필터링을 추가해 기능을 더하기도 했다. 또한 7월이 되면서 챕터내의 3분기 일감들을 함께 정하고 그중에 에러/예외처리에 대한 고도화 작업을 …","fields":{"slug":"/2023-08-09-2023년-7월회고/"},"frontmatter":{"date":"August 09, 2023","title":"☂︎ 2023년 7월 회고","tags":["회고"]},"rawMarkdownBody":"\n7월의 기억남았던 작업은 이전에 디바이스 서체 설정에 따라 잘리는 것을 막는 방법을 조사했던 것을 일감화해서 직접 트래커를 찍어서 우리 실 사용자들이 어떤 크기로 사용하고 있는지 확인하기도 했고, 받은 요청 화면에서 필터링을 추가해 기능을 더하기도 했다. 또한 7월이 되면서 챕터내의 3분기 일감들을 함께 정하고 그중에 에러/예외처리에 대한 고도화 작업을 위한 로드맵을 세우기도 했다. 여러가지 일들에 대해 기록하고 과정 속에서 아쉬웠던 점, 좋았던 점을 기록해보려 한다.\n\n### 😃 앱의 완성도를 높여보자, 디바이스 서체 설정 제한하기\n\n어플은 웹과 다른 단위를 사용해서 UI를 구현한다. Android는 DP(Density Independent Pixel) 와 SP(Scale Independent Pixel)을 IOS는 PT(point)를 사용하는데 이렇게 서로 다른 단위를 사용하는 이유는 바로 <b>디바이스마다 화소(pixel)의 밀도 </b>가 다르기 때문이다.\n\n화소밀도, PPI(Piexls Per Inch)는 1제곱인치 면적에 들어가는 픽셀 수를 의미하는데 디바이스가 발전하면 발전할 수록 스크린 사이즈는 그대로이지만 PPI는 증가하게 된다.\n\n<img src=\"https://uidesignguides.files.wordpress.com/2018/09/null7.png\" />\n\nPPI가 증가하면 같은 면적에서도 pixel양이 달라지기 때문에 Pixel단위로 표현하지 않고 디바이스 별로 같은 비율로 보일 수 있게 DP,SP/PT 와 같은 단위로 디자인을 표현한다,\n\n우리 앱에서 사용하고 있는 react-native에서 raw 값으로 전달하면 자동으로 두가지 플랫폼에 맞는 상대값으로 변환해서 전달된다.\n\nReact-native가 자체적으로 계산해주지만 여기서 또 중요한 점은 <b>사용자가 설정한 기기의 디바이스 서체 설정</b>이다.\n\n아래 사진은 각각 IOS 16버전과 Android 13버전 설정할 수 있는 크기 설정 화면이다. 크기 설정에 따라 현재 변환된 글자크기에 해당 비율을 곱해주는 방식으로 글자크기를 크거나 작게 만들 수 있다.\n\n<table>\n<tbody>\n<tr>\n<th>IOS 16버전</th>\n<th>Android 13 버전</th>\n</tr>\n  <tr>\n<td width=\"400\">\n![IOS 16버전](./ios.jpeg)\n</td>\n<td width=\"400\">\n![Android 13 버전](./android.jpeg)\n</td>\n</tr>\n</tbody>\n</table>\n\n조사 당시 우리 앱은 해당 디바이스별 크기 설정에 대한 디자인적인 대응이 되지 않아, QA분과 디자이너분께서 조사해주신 결과 Android는 다섯번째 크기이상, IOS는 여섯번째 크기이상으로 설정시에 앱을 사용하기 어려울 정도로 UI가 깨지는 것을 알게 되었다. 이를 해결하기 위해 스쿼드의 일감으로 발전시켜 UI가 깨지지 않으면서 최대한 크기를 키워줄 수 있는 기준으로 <b>Android는 네번째 크기로, IOS는 다섯번째 크기</b>로 서체크기를 제한하기로 결정했다.\n\n크기 제한을 작업을 하기 위해서 다음과 같은 작업이 필요했고 각 스텝에 따라 정리해보려 한다.\n\n1. 사용자 디바이스의 글자 크기 설정 알아내기\n2. 각 플랫폼별로 글자 크기 설정에 따른 비율 알아내기\n3. 사용자 디바이스 글자 크기가 기준을 넘어갈 시 기준 비율로 보여주기\n\n##### 1. 사용자 디바이스의 글자 크기 설정 알아내기\n\n우리 앱을 사용하는 사용자 디바이스 글자 크기를 알아내기 위해서 알아낸 방법은 React native 자체적으로 지원하는 **PixelRatio** API을 이용하는 방법이었다.\n\nPixelRatio API가 지원하는 메소드 중 **getFontScale**을 이용하면 디바이스의 서체 설정에서 정한 비율을 알 수 있었다.\n\n<img width=\"851\" alt=\"image-20230812171558531\" src=\"image-20230812171511531.png\"/>\n\n##### 2. Android, IOS 글자 크기 설정 별 비율 알아내기\n\n앞서 알아낸 pixelRatio 모듈의 getFontScale을 통해서 디바이스의 서체 설정을 알아낼 수 있으므로 이를 이용해 각 지점마다의 비율이 얼마나 되는지를 조사했다.\n\n|        기준별 크기         | IOS 16 | Android 13 |\n| :------------------------: | :----: | :--------: |\n|             1              | 0.823  |    0.8     |\n|             2              | 0.882  |    0.9     |\n|             3              | 0.941  |     1      |\n|             4              |   1    |    1.1     |\n|             5              | 1.118  |    1.3     |\n|             6              | 1.235  |    1.5     |\n|             7              | 1.353  |    1.7     |\n| 8 ( IOS의 더크게 조절부터) | 1.786  |     2      |\n|             9              | 2.145  |            |\n|             10             | 2.643  |            |\n|             11             | 3.143  |            |\n|             12             | 3.571  |            |\n\n<br/>\n\n##### 3. 서체크기 제한하기\n\n우리가 타겟하는 비율은 **IOS는 1.118 보다 클 경우 AOS는 1.1보다 클 경우** 각각 1.118배와 1.1배로 제한해서 크기 설정을 해주면 되는데 이를 위한 방법으로는 두가지 방법이 있었다.\n\n첫 번째 방법은 공통으로 사용하고 있는 텍스트 컴포넌트를 감싸서 fontSize를 변환해주는 컴포넌트를 만들어서 적용하는 방법으로 부분 적용이 가능하지만 일일히 공통 컴포넌트를 교체해줘야하는 비용이 드는 방법이다.\n\n두 번째 방법은 React native의 Text 컴포넌트의 `maxFontSizeMultiplier`설정을 이용하는 방법으로 우리 기준 값만 플랫폼에 따라 적용해 전체 적용하는 방법이다.\n\n두가지 방법 중 우선은 첫번째 방법으로 고객 홈 화면을 시작으로 스쿼드 내 일감으로 담당 도메인에 적용하고 이후에 디자인적인 보완을 더해서 전체 적용하는 방법으로 일감을 진행하기로 결정되었다.\n\n계속해서 작업해서 앱 전체의 완성도를 높이는 데 계속해서 기여하고 싶다. 😎\n\n<br/>\n\n<table>\n<tbody>\n  <tr>\n<th><b> IOS 크기 설정 7 AS-IS</b></th>\n<th><b> IOS 크기 설정 7 TO-BE </b></th>\n</tr>\n  <tr>\n<td>\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/f7bce269-61fc-45d7-bfa6-5e85e6b1b95a\"/>\n</td>\n<td>\n <img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/256cc5f8-56b2-4588-9bb0-4266ede66bfc\" />\n</td>\n</tr>\n  <tr>\n<th><b>AOS 크기 설정 7 AS-IS</b></th>\n<th><b>AOS 크기 설정 7 TO-BE</b> </th>\n</tr>\n  <tr>\n<td>\n  <img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/84392f9b-2025-4250-9e88-aa013c239205\"  />\n    <!-- <video src=\"\" width=\"300\" /> -->\n</td>\n<td>\n <img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/de1ccbb0-cf26-4d51-b479-e02f7d9b0427\" />\n</td>\n</tr>\n</tbody>\n</table>\n\n<br/>\n\n### 🤩 받은 요청화면의 필터링 기능\n\n이번에 스쿼드에서 구현한 기능은 받은 요청의 필터링 기능으로 기존 고수가 받아온 다양한 요청서를 원하는 필터와 정렬방식에 맞게 보여주는 기능이었다. 해당 기능을 구현하면서 겪었던 어려움 두가지에 대해 정리해보려 한다.\n\n#### 😬앱 종료시까지 데이터를 유지하는 방법\n\n우리가 정한 필터/정렬 정책은 **앱을 종료하기 전까지** 해당 유저가 선택 했던 데이터를 저장한다였다. 요구사항을 만족시키기 위해서 우리 프로젝트 내에서 앱 종료시까지 데이터/상태를 보관하는 방법에 대해 고민해봤고 내 나름 세 가지 방법이 떠올랐다.\n\n##### Async Storage\n\n앱의 로컬 스토리지와 같은 Async storage에 해당 필터 정보를 보관하는 방법이다. 하지만 Async Storage는 앱을 종료해도 정보를 기억하고 있어야하는 자동 로그인을 위한 유저정보 등과 같은 상황에 사용하는 것이 더 적절하지 앱 종료 전에 저장하고 다시 불러오는 방법은 용도에 부적합해 보였다.\n\n##### 전역 상태 이용하기\n\n우리 프로젝트 내에서 전역상태를 위한 라이브러리로 사용하고 있는 Recoil을 이용해서 상태관리를 하는 방법이 있다. 전역상태이기 때문에 필터/ 정렬 조건이 바뀔 때만 해당 atom 내 상태가 업데이트 되고 navigation stack과 별도로 해당 데이터를 보관할 수 있기 때문에 적합한 방법이라 생각되었다.\n\n##### 로컬 상태와 자체 로컬 storage 만들기\n\n자체 로컬 storage를 만드는 방법은 필터/ 정렬 스크린이 mount되었을 때 이전 로컬 storage에 저장된 필터/정렬 데이터를 지역 상태에 업데이트하고, unMount되었을 때 지역 상태 값을 로컬 storage에 보관하는 방식으로 관리하는 방식으로 이 방법도 적합해 보였다.\n\n세가지 방법중에서 **전역상태**와 **자체 local storage**를 구현하는 방식에 대해서 고민했고, 둘 중에 **전역상태를** 선택했다. 개인적으로는 자체 local Storage를 구현하는 방식이 챕터 컨벤션에 더 맞지 않을까 고민했다. 왜냐하면 전역상태를 추가하는 방식은 구현은 간단하지만 하나의 스크린에서 변화가 일어나면 다른 화면에서도 불필요한 리렌더링이 일어날 수 있는 위험은 늘 가지고 있기 때문이고, 자체 local Storage를 구현하면 다른 스크린에서도 사용할 수 있겠다는 기대도 되었다.\n\n챕터내의 컨벤션도 중요하기 때문에 챕터원 분들과 해당 부분에 대해서 이야기를 해보았을 때 대부분 **전역상태로** 관리하는 게 좋을 것 같다는 의견을 주셨다. 그이유는 만들려는 기능이 받은 요청화면과 필터 설정을 위한 모달 스크린 화면, **두가지 스크린이 하나의 상태**에 대한 정보를 바라봐야하기 때문에 동기화가 필요하하는 것이 중요한 상황이며, 앞서 내가 우려한 부분에 대해서는 페이지별로 사용을 제한하는 방향으로 사용하면 해결할 수 있을 것 같다는 의견을 주셨기 때문이었다.\n\n챕터내 의견을 종합해서 고민해보았을 때 자체 local Storage의 경우 데이터를 업데이트하고 읽는 시점에 대한 추가적인 고민이 필요하고 챕터원 분들의 의견들을 종합했을 때 전역상태로 관리하기로 선택했다.\n\n### 😞 애니메이션과 성능 이슈\n\n받은 요청 화면에서 구현이 필요했던 애니메이션은 리스트 화면에 Sticky 헤더를 구현하는 것이었다. Sticky 헤더 자체는 Flash list를 이용해 간단하게 구현할 수 있지만 문제가 되는 것은 스크롤을 내릴 때/ 올렸을 때/ 스크롤을 최상단으로 올렸을 때 총 세가지 조건에 따라 다른 header가 되어야한다는 점이었다.\n\n[IOS에서 정상적으로 동작하는 모습]\n\n<img src=\"https://velog.velcdn.com/images/choi2021/post/002f8620-962e-4b87-8117-d051fb5d6723/image.gif\" width=\"300\"/>\n\nIOS에서는 정상적으로 구현되어서 안심했지만... 문제는 Android에서 발생하기 시작했다. Android에서는 스크롤 방향에 따라 최상단 헤더가 흔들리고 내릴 때 헤더 위치가 올릴 때 헤더위치 처럼 되는 등 애니메이션 구현의 어려움을 겪었다.\n\n원인으로 생각되는 부분은 스크롤을 내릴때 header가 translation으로 올라가게 되는데 그러면서 생긴 빈 공간을 매꾸기 위해 리스트 컴포넌트의 **margin이 변하게 구현했기** 때문으로 생각이 들었다. React native의 Animated API를 이용해 구현했을 때 margin을 변경하는 애니메이션에 대해서 useNativeDriver를 사용할 수 없는데 이로 인해 네이티브의 UI thread에서 처리가 되지 못하고 JS Thread에서 처리하게 되고, margin의 변화는 layoutShift가 발생하는 부분이기 때문에 IOS에 비해 성능이 떨어지는 Android에서 버벅임 현상이 나타나게 되는 것이 아닐까 생각이 들었다.\n\n이러한 구현상 문제로 스크롤을 내릴때와 올릴때의 UI를 통일시켜서 배포하는 방향으로 결정했다. 요구사항과 사용성 모두를 만족시키고 싶었는데.. 내 부족함으로 요구사항을 변경해야하는 상황이 나온 것은 아닐까라는 아쉬움을 가지는 스프린트였다.\n\n### 😆 내가 진행하게 된 에러/예외 처리 고도화 일감\n\n모바일 챕터의 3분기 목표 일감들이 정해졌다. 다양한 주제들이 의논되었는데 내가 발제한 부분은 **에러/예외처리 핸들링**에 대한 부분이었다. 그 이유는 최근 기술 논의 시간에 우리 프로젝트에서 어떻게 에러가 처리가 되고 있는지 발표를 들을 수 있었고, 이에 따라 앱의 안전성과 보다 빠른 에러에 대한 대처를 위한 조사및 대처의 필요성을 많이 느꼈기 때문이었다.\n\n챕터원분들도 많이 공감을 해주셨고 이에 따라 일감의 진행을 내가 책임을 맡게 되었다. 큰 일감을 담당하고 진행하는 것은 처음이라 어떻게 에픽/스토리/티켓의 구조들을 잡아가면 좋을지 어떻게 분배해서 일을 같이 진행하면 좋을지에 대해서 고민했고 큰 그림을 그려보게 되었다.\n\n참고한 자료는 카카오 페이에서 발표해주시고 정리해주신 [Sentry를 이용한 에러 추적기, React의 선언적 에러 처리](https://www.youtube.com/watch?v=012IPbMX_y4)와 토스에서 발표한 [프론트엔드 웹 서비스에서 우아하게 비동기 처리하기](https://www.youtube.com/watch?v=FvRtoViujGg&t=46s)를 참고해서 어떻게 큰 그림들을 그려가면 좋을 지 아이디어를 얻을 수 있었다.\n\n일감을 크게 두가지 스텝으로 **의미있는 에러 로그를 쌓기 위한 에러 로깅 고도화**와 **고도화된 에러 로깅을 바탕으로 에러/예외처리를 위한 컨벤션 세우기**로 분류했다.\n\n먼저 의미있는 에러 로그를 쌓기 위한 에러 로깅 고도화를 위해서는 우리 프로젝트에서 사용하고 있는 에러 로그를 쌓고 모니터링을 하는 툴인 **Bugsnag**을 잘 사용하기 위한 조사와 우리 프로젝트는 로그들을 쌓고 있는지 조사하는 게 필요해보였고, 프로젝트내 컨벤션으로 에러의 위계를 정하고 Error Boundary를 이용한 선언적코드, custom lint룰 추가 등의 일감을 이후에 진행하려고 계획했다.\n\n챕터내 큰 일감을 진행하는 것에 걱정도 되지만 프로젝트에 많은 기여를 할 수 있는 기회로 생각되어 기대도 된다. 큰 목표를 잡고 작은 일부터 천천히 진행해 완성하는 것까지 꼭 볼 수 있게 중간에 흐지부지 되지 않게 꾸준히 진행하려 한다.\n\n### 마치며\n\n이제 개발자로 일한 지 6개월이 가까워지고 있다. 개발자로 일하는 것에 큰 기쁨을 느끼고 재밌지만 그에 따라 조금씩 더 맡는 부분이 생기고, 큰 일감도 생기는 것 같다. 주체적으로 일할 수 있는 환경에 감사하고 함께 고민할 수 있는 좋은 사람들이 많이 있다는 것에 감사함을 느낀다. 새로운 기술적 주제들을 던져주고 새로운 문제들을 해결하면서 내가 나아지고 있음을 느끼는 것 같다.\n\n개발자는 문제를 해결하는 사람이라는 말에 크게 공감하는 한달이었다. 서체 크기 제한을 하면서는 꼭 코드적으로 많은 것을 작성하지 않아도 정책을 정함으로써 사용성과 완성도를 높일 수 있다는 것을 느꼈고, 받은 요청에 필터/정렬 기능을 더하면서 아직 내가 부족하다는 점도 느꼈다. 에러/예외처리 일감을 만들면서 큰 그림을 그리고 거기에 작은 스토리들, 더 작게는 티켓들을 만들면서 일을 기획하고 수행할 수 있는 단위로 쪼개는 것의 중요성도 느낀다.\n\n내가 쌓아온 경험은 아직 너무 미미하지만 더 의미있는 작업들로 많은 기여를 할 수 있기를 기대해본다.\n"},{"excerpt":"6월은 다양한 기술적 주제에 대해 고민이 더 많았던 것 같다. 5월 회고 때 다짐했던 목표 중 하나였던 테스트에 대해 공부하고 실 작업에서 TDD로 개발했던 경험을 간단한 10분정도 세션으로 발표하기도 했고, 디바이스 설정에 따라 앱의 UI가 깨지는 것을 해결하기 위해 방법들을 조사하고, 앱의 하드 버전을 체크하기 위한 작업을 하기도 했다. 그리고 특이한…","fields":{"slug":"/2023-07-06-2023년-6월회고/"},"frontmatter":{"date":"July 06, 2023","title":"☼ 2023년 6월 회고","tags":["회고","TDD"]},"rawMarkdownBody":"\n6월은 다양한 기술적 주제에 대해 고민이 더 많았던 것 같다. 5월 회고 때 다짐했던 목표 중 하나였던 테스트에 대해 공부하고 실 작업에서 TDD로 개발했던 경험을 간단한 10분정도 세션으로 발표하기도 했고, 디바이스 설정에 따라 앱의 UI가 깨지는 것을 해결하기 위해 방법들을 조사하고, 앱의 하드 버전을 체크하기 위한 작업을 하기도 했다. 그리고 특이한(?) 경험으로 원티드의 인터뷰를 하러가기도 하고, 토스 슬래쉬 발표를 들으며 우리 프로젝트에 적용하면 좋을 기술적 키워드들에 대해 고민하기도 했다. 한달간 했던 기술적 고민과 다양한 경험들을 정리해보고자 한다.\n\n### 😎 배웠으면 써먹어봐야지, 테스트를 해보자!\n\n저번달 페어프로그래밍을 통해 테스트의 필요성을 느끼면서 직접 스쿼드 기능 개발을 하면서 테스트 코드를 작성해봤다. 컴포넌트 단위의 유닛테스트부터 하기보다, 간단하게 Repository 계층의 전달 받을 데이터에 대해 테스트를 짜고 적용했다. 테스트 코드를 작성하는 방식으로 `TDD`을 이용했는데, 이유는 먼저 스쿼드 내에서 기술 명세서, API가 어떤 데이터 (input) 줄지가 의논을 통해 어느정도 정해져 있었기 때문에, 해당 데이터를 이용해서 어떻게 UI에 이용할 지를 먼저 고민하다보니 자연스럽게 <b>TDD</b>방식을 선택하게 되었다.\n\n#### TDD란\n\nTDD는 `Test-Driven-Development`로 테스트를 먼저 작성하고 해당 테스트를 통과할 수 있게 개발해나가는 개발 방식을 의미한다. TDD가 거창하고 멋있어 보이는 것도 있었지만, 나에게 가장 좋았던 점은 내 자신에게 `테스트코드 작성을 의무화`할 수 있었기 때문이었다.\n\n[ TDD 프로세스]\n\n![Untitled](TDD.png)\n\nTDD에서의 개발 순서는 다음과 같다.\n\n1. 실패하는 테스트 코드를 먼저 작성한다.\n2. 테스트를 통과할 수 있을 만큼의 코드를 작성한다.\n3. 통과한 코드를 리팩토링한다.\n\n이러한 1~3번까지의 방식을 계속해서 반복하는 과정을 통해 개발해나가는 방식으로 <b>요구사항</b> 대해 먼저 고민하고 코드를 작성하고, 테스트 자체를 통해 <b>명세서</b> 역할을 할 수 있게 도울 수 있다는 장점을 느꼈다.\n\nTDD로 개발한 경험에 대해서 기술 논의 시간에 해당 내용을 mimic한 간단한 예제에 대해서 발표했다.\n\n#### 간단한 TDD 예시: HomeRepository의 getServices\n\nHomeRepository를 통해 홈화면의 서비스들에 대한 정보를 받아오는 요구사항에 대한 작업에 대한 예시를 준비했다.\n\n- 요구 조건:\n\n1. 요청 발송 이력이 없는 고객은 인기 서비스를 보여준다.\n2. 요청 발송 이력이 있는 고객은 추천 서비스를 보여준다.\n\n위 요구사항을 위해 HomeRepository는 API 응답을 전달받고 스크린에 필요한 데이터를 전달해주려 한다. API 응답 데이터와 스크린에 필요한 데이터의 interface는 다음과 같다.\n\n```typescript\n// 서버 데이터에 대한 타입\ninterface GetServicesResponse = {\n    service: {\n        id: number;\n        name: string;\n        imageUrl: string;\n    }[];\n    type: 'recommend' | 'popular';\n};\n\n// 스크린에 전달할 타입\ninterface HomeServices {\n    isRecommendation: boolean;\n    services: {\n        id: number;\n        name: string;\n        featureImage: string;\n    }[];\n}\n```\n\n#### 0. 테스트세팅\n\n테스트 세팅으로는 Repository만을 테스트하기 위해서는 실제 API 층을 테스트에 이용하는 것이 아니라 Mocking데이터와 가짜 API 층이 필요하다. 그 이유는 실제 데이터 통신이나 다른 계층이 사용될 경우에 Repository 테스트가 실패했을 때 원인을 찾기 어렵고, Repository만의 테스트가 되지 않기 때문이다.\n\n가짜 API 클래스를 전달하기 위해서는 `Dependency Injection`을 이용해서 interface를 구현하는 API층을 전달하게 하고 특정한 모듈을 의존하는 것이 아니라 interface를 의존하게 해 전달한 모듈이 interface를 만족시키는 지만 알게 해 `의존성 역전`을 적용할 수 있다.\n\n이를 위한 가짜 API 클래스의 getServieces 메소드의 타입과 mock 서비스 데이터는 다음과 같다.\n\n```typescript\n// 가짜 API 클래스를 통해 구현할 interface\nexport interface HomeAPI {\n  getServices: (hasSentRequest: boolean) => GetServicesResponse\n}\n\n//Mocking 데이터\nexport function mockServices(): GetServicesResponse[\"service\"] {\n  return [1, 2, 3, 4].map(num => ({\n    imageUrl: `test${num}.jpg`,\n    name: `test${num}`,\n    id: num,\n  }))\n}\n```\n\n이제 해당 interface를 구현하는 가짜 API 클래스와 가짜 API를 주입받을 HomeRepository를 구현해보자. 가짜 API 클래스는 간단하게 객체로 HomeRepository는 클래스로 만들었다. TDD는 테스트가 먼저이기 때문에 메소드만 만들고 기능에 관한 코드는 추가하지 않았다.\n\n```typescript\nconst fakeHomeApi = {\n  getServices: jest.fn((hasSentRequest: boolean): GetServiceResponse => {\n    if (hasSentRequest) {\n      return {\n        type: \"recommend\",\n        service: mockServices(),\n      }\n    } else {\n      return {\n        type: \"popular\",\n        service: mockServices(),\n      }\n    }\n  }),\n}\n\nexport class HomeRepository {\n  constructor(private homeApi: HomeAPI) {}\n  getServices(hasSent: boolean): HomeServices | null {}\n}\n```\n\n#### 1-1. 테스트 작성하기\n\n이제 TDD의 첫 스텝 테스트를 작성해보자. 테스트는 요구사항에 대한 분석으로 부터 시작된다. 앞서 정리한 요구사항에 맞는 테스트에 대해 작성하면 다음과 같다.\n\n```typescript\ndescribe(\"HomeRepository Test:\", () => {\n  // HomeAPI를 mocking하기 위한 부분\n  const fakeHomeApi = {\n    getServices: jest.fn((hasSentRequest: boolean): GetServiceResponse => {\n      if (hasSentRequest) {\n        return {\n          type: \"recommend\",\n          service: mockRecommendServices(),\n        }\n      } else {\n        return {\n          type: \"popular\",\n          service: mockPopularServices(),\n        }\n      }\n    }),\n  }\n\n  //1. test\n  describe(\"getRecommendService에서\", () => {\n    test(\"요청 발송 내역이 없는 고객은 인기서비스를 보여준다.\", () => {\n      expect(\"\").toBe(\"hi\")\n    })\n\n    test(\"요청 발송 내역이 있는 고객은 연관서비스를 보여준다.\", () => {\n      expect(\"\").toBe(\"hi\")\n    })\n  })\n})\n```\n\n이제 앞서 세팅해둔 HomeRepository와 가짜 API를 통해 첫번째 테스트 케이스부터 채워나가면 다음과 같이 코드를 작성할 수 있다.\n\n```typescript\ndescribe(\"HomeRepository Test:\", () => {\n  // HomeAPI를 mocking하기 위한 부분\n  const fakeHomeApi = {\n    getServices: jest.fn((hasSentRequest: boolean): GetServiceResponse => {\n      if (hasSentRequest) {\n        return {\n          type: \"recommend\",\n          service: mockRecommendServices(),\n        }\n      } else {\n        return {\n          type: \"popular\",\n          service: mockPopularServices(),\n        }\n      }\n    }),\n  }\n  //1. test\n  describe(\"getRecommendService에서\", () => {\n    test(\"요청서 발송 내역이 없는 고객은 인기서비스를 보여준다.\", () => {\n      const repository = new HomeRepository(fakeHomeApi)\n      const hasSent = false\n      const result = repository.getServices(hasSent)\n      const expectedService = mockPopularServices().map(item => ({\n        id: item.id,\n        name: item.name,\n        featureImage: item.imageUrl,\n      }))\n      expect(result).toEqual({\n        isRecommendation: false,\n        services: expectedService,\n      })\n    })\n\n    test(\"요청서 발송 내역이 있는 고객은 연관서비스를 보여준다.\", () => {\n      expect(\"\").toBe(\"hi\")\n    })\n  })\n})\n```\n\n테스트 코드만 작성했기 때문에 당연히 아래와 같이 테스트 실패가 된다.\n\n[실패한 테스트들]\n![모두실패](모두실패.png)\n\n#### 1-2. 테스트를 통과시키는 최소한의 기능 구현하기\n\n이제 테스트를 통과시키기 위한 코드를 Repository에 작성할 차례이다.\n\n```typescript\nexport class HomeRepository {\n  constructor(private homeApi: HomeAPI) {}\n  getServices(hasSent: boolean): HomeServices | null {\n    const result = this.homeApi.getServices(hasSent)\n    return {\n      isRecommendation: false,\n      services: result.service.map(service => ({\n        id: service.id,\n        name: service.name,\n        featureImage: service.imageUrl,\n      })),\n    }\n  }\n}\n```\n\n해당 코드를 작성하고 나서 테스트를 통과한 모습이다.\n\n[통과한 첫번째 테스트 케이스]\n\n![첫번째성공](첫번째성공.png)\n\n#### 1-3. 리팩토링하기\n\n이제 우린 통과한 테스트 케이스가 있기 때문에 마음 놓고 리팩토링 할 수 있다. 여기서 리팩토링은 아주 간단하게 ES6 문법을 적용하는 것을 해보려한다.\n\n```typescript\nexport class HomeRepository {\n  constructor(private homeApi: HomeAPI) {}\n  getServices(hasSent: boolean): HomeRecommendService | null {\n    const result = this.homeApi.getRecommendation(hasSent)\n    return {\n      isRecommendation: false,\n      services: result.service.map(({ id, name, imageUrl }) => ({\n        id,\n        name,\n        featureImage: imageUrl,\n      })),\n    }\n  }\n}\n```\n\n리팩토링을 해도 테스트를 통과하는 것을 볼 수 있다.\n\n[리팩토링 이후 통과한 테스트 결과]\n\n![첫번째성공](첫번째성공.png)\n\n#### 이후 작업\n\n이후에는 1~3을 똑같이 두번째 테스트 케이스에 적용해 나간다.\n\n#### 2-1. 테스트 작성\n\n```typescript\ndescribe(\"HomeRepository Test:\", () => {\n  // HomeAPI를 mocking하기 위한 부분\n  const fakeHomeApi = {\n    getServices: jest.fn((hasSentRequest: boolean): GetServiceResponse => {\n      if (hasSentRequest) {\n        return {\n          type: \"recommend\",\n          service: mockServices(),\n        }\n      } else {\n        return {\n          type: \"popular\",\n          service: mockServices(),\n        }\n      }\n    }),\n  }\n  //1. test\n  describe(\"getRecommendService에서\", () => {\n    test(\"요청서 발송 내역이 없는 고객은 인기서비스를 보여준다.\", () => {\n      const repository = new HomeRepository(fakeHomeApi)\n      const hasSent = false\n      const result = repository.getServices(hasSent)\n      const expectedService = mockServices().map(item => ({\n        id: item.id,\n        name: item.name,\n        featureImage: item.imageUrl,\n      }))\n      expect(result).toEqual({\n        isRecommendation: false,\n        services: expectedService,\n      })\n    })\n\n    test(\"요청서 발송 내역이 있는 고객은 연관서비스를 보여준다.\", () => {\n      const repository = new HomeRepository(fakeHomeApi)\n      const hasSent = true\n      const result = repository.getServices(hasSent)\n      const expectedService = mockServices().map(item => ({\n        id: item.id,\n        name: item.name,\n        featureImage: item.imageUrl,\n      }))\n      expect(result).toEqual({\n        isRecommendation: true,\n        services: expectedService,\n      })\n    })\n  })\n})\n```\n\n당연히 두번째 테스트 케이스에 대한 코드가 작성되어 있지 않으므로 여전히 테스트는 실패한다.\n\n[두번째 테스트 작성 이후 결과]\n\n<img width=\"751\" alt=\"image-20230709023353537\" src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/d6859e8b-8cc6-41d3-b372-c6f42992f0e0\"/>\n\n#### 2-2. 테스트를 통과시키는 최소한의 기능 구현하기\n\n이제 두번째 테스트를 통과시키기 위한 코드를 Repository에 작성할 차례이다.\n\n```typescript\nexport class HomeRepository {\n  constructor(private homeApi: HomeAPI) {}\n  getServices(hasSent: boolean): HomeServices | null {\n    const result = this.homeApi.getServices(hasSent)\n    if (result.type === \"recommend\") {\n      return {\n        isRecommendation: true,\n        services: result.service.map(({ id, name, imageUrl }) => ({\n          id,\n          name,\n          featureImage: imageUrl,\n        })),\n      }\n    }\n    return {\n      isRecommendation: false,\n      services: result.service.map(({ id, name, imageUrl }) => ({\n        id,\n        name,\n        featureImage: imageUrl,\n      })),\n    }\n  }\n}\n```\n\n해당 코드를 작성하고 나서 테스트를 통과한 모습이다.\n\n[모든 테스트 케이스를 통과한 결과]\n\n<img width=\"565\" alt=\"image-20230709023322803\" src=\"모두성공.png\"/>\n\n#### 2-3. 리팩토링하기\n\n우린 통과한 테스트 케이스가 있기 때문에 더 마음 놓고 리팩토링 할 수 있다.😆 코드 중복을 제거하고 더 간단하게 만들어보자.\n\n```typescript\nexport class HomeRepository {\n    constructor(private homeApi: HomeAPI) {}\n     getServices(hasSent: boolean): HomeServices | null {\n        const result = this.homeApi.getServices(hasSent);\n        return {\n                isRecommendation:result.type==='recommend',\n                services: result.service.map(({ id, name, imageUrl }) => ({\n                    id,\n                    name,\n                    featureImage: imageUrl,\n                })),\n            };\n        }\n    }\n}\n```\n\n리팩토링을 해도 테스트를 통과하는 것을 볼 수 있다.\n\n[리팩토링 이후 모든 테스트 케이스를 통과한 결과]\n\n<img width=\"565\" alt=\"image-20230709023322803\" src=\"모두성공.png\"/>\n\n테스트를 적용하면서 요구사항에 대해서 더 고민할 수 있었고, 테스트 덕분에 더 맘편하게 리팩토링을 할 수 있다는 큰 장점을 느끼는 경험이었다. 비록 시간이 없어서 간단하게 Repository에만 적용해봤지만, 이후에 Unit Test를 이용한 컴포넌트 테스트들에도 적용해 나가려 한다.\n\n### 스토어에 올라온 하드버전을 체크해보자🙏\n\n챕터 업무로 스토어에 올라온 하드 버전과 현재 버전을 체크해, 더 높은 버전을 스토어에서 설치할 수 있게 하는 방법에 대한 작업을 맡게 되었다.\n\n#### 1. 앱스토어/플레이스토어 API 이용하기\n\n작업을 위해 가장 먼저 조사한 것은 스토어에 올라온 우리 앱에 대한 정보를 API가 있는지였다. 조사한 바로 AppStore(IOS)의 경우에 해당 앱의 정보를 받을 수 있는 API가 존재했지만 PlayStore(AOS)는 자체적인 API를 제공하고 있지 않았다. 앱에 대한 정보에 대한 보안으로 API를 제공하지 않는다고 한다.\n\n라이브러리들에 대해서도 조사했을 때 안드로이드만을 위한 라이브러리나 [react-native-version-check](https://github.com/kimxogus/react-native-version-check/tree/master) 의 코드를 까보았을 때 플레이스토어 페이지에 Html파일을 받아온 후에 버전정보에 대해서 찾는 크롤링 방식을 이용하고 있었다. 크롤링 방식은 페이지 정보가 바뀌게 되면 아예 사용할 수 없는 방식이 되고 해당 정보 뿐 아니라 페이지를 구성하는 다른 정보들을 다 받아오면서 비용이 많이 들기 때문에 배제하는 게 좋을 것 같았다.\n\n```typescript\n// AppStore의 앱정보에 대한 API\nfetch(`https://itunes.apple.com/lookup?bundleId=${bundleIdentifier}`)\n  .then(response => response.json())\n  .then(data => {\n    const appStoreVersion = data.results[0].version\n    if (appStoreVersion > currentVersion) {\n      console.log(\"새로운 버전이 있습니다!\")\n    } else {\n      console.log(\"최신 버전을 사용 중입니다.\")\n    }\n  })\n  .catch(error => {\n    console.log(\"앱 정보를 가져오는 중에 오류가 발생했습니다:\", error)\n  })\n\n//react-native-version-check의 PlayStore.js\nclass PlayStoreProvider implements IProvider {\n  getVersion(option: PlayStoreGetVersionOption): Promise<IVersionAndStoreUrl> {\n    const opt = option || {}\n    try {\n      if (!opt.packageName) {\n        opt.packageName = getVersionInfo().getPackageName()\n      }\n\n      opt.fetchOptions = {\n        headers: { \"sec-fetch-site\": \"same-origin\" },\n        ...opt.fetchOptions,\n      }\n\n      const storeUrl = `https://play.google.com/store/apps/details?id=${opt.packageName}&hl=en&gl=US`\n\n      return fetch(storeUrl, opt.fetchOptions)\n        .then(res => res.text())\n        .then(text => {\n          const match = text.match(/Current Version.+?>([\\d.-]+)<\\/span>/)\n          if (match) {\n            const latestVersion = match[1].trim()\n\n            return Promise.resolve({ version: latestVersion, storeUrl })\n          }\n\n          const matchNewLayout = text.match(/\\[\\[\\[\"([\\d-.]+?)\"\\]\\]/)\n          if (matchNewLayout) {\n            const latestVersion = matchNewLayout[1].trim()\n\n            return Promise.resolve({ version: latestVersion, storeUrl })\n          }\n\n          return Promise.reject(error(text))\n        })\n    } catch (e) {\n      if (opt.ignoreErrors) {\n        console.warn(e) // eslint-disable-line no-console\n      } else {\n        throw e\n      }\n    }\n  }\n}\n\nexport default new PlayStoreProvider()\n```\n\nAPI를 이용하는 방식을 고민하면서 앱을 배포하는 과정을 보면 마켓의 심사를 받고 승인을 받는데에는 상대적으로 PlayStore에 올라가는 시간이 빠르고 AppStore에 올라가는 시간이 오래걸리기 때문에, AppStore를 기준으로 버전을 비교하게 하더라도 안드로이드 유저가 없는 버전을 다운받기 위해 PlayStore로 이동하지는 않을 것 같다고 생각했다. 내가 모르는 다른 방법이 있을 수 있으므로 API를 이용하는 방법는 보류했다.\n\n#### 2. AppCenter API 이용하기\n\n코드 푸시 및 앱의 버전 관리를 위해 사용하는 Appcenter에 관련된 API가 있지 않을까 생각했고, `https://api.appcenter.ms/v0.1/apps/{owner_name:}/{username}/deployments`라는 API를 발견했다. 우리가 원하는 응답값을 얻을 수 있는 장점이 있었지만 문제는 해당 API를 호출하기 위해서는 Auth token을 전달해야하는데, Auth Token은 Appcenter에 인증되어있는 팀 계정의 Token이기 때문에 API호출을 위해 토큰 값을 같이 배포할 경우 모든 사용자들의 기기에 우리의 토큰이 들어가는 보안문제가 있었다.\n\n```json\n[\n  {\n    \"name\": \"Production\",\n    \"key\": \"~\",\n    \"latest_release\": {\n      \"target_binary_range\": \"1.0.0\",\n      }\n    }\n  },\n]\n```\n\n#### 3. S3의 Flag값 이용하기\n\n세번째로 고민한 방법은 s3에 json 하드버전을 기록한 파일을 추가하고, 하드배포시 json의 하드버전을 높이는 방법이 있었다.하지만, 하드배포버전을 올리는 시점과 마켓의 심사가 모두 완료되었을 때 시점이 달라 누군가가 수동으로 결국 관리해야하는 비용문제 발생했다.\n\n이렇게 총 세가지 방법에 대해서 고민하고 공유했을 때 결국 1번 방법이 가장 문제가 적은 방법으로 고려되어, AppStore API를 이용해 스토어에 올라온 하드버전을 비교하는 로직을 구현했고, 이번 작업을 통해 빠르게 새롭게 배포된 버전을 설치할 수있게 유도하는데 도움이 되면 좋겠다.\n\n### 원티드에서의 인터뷰 😋\n\n6월 12일 원티드에서 나를 인터뷰이로 초대하는 메일이 왔다. 이전에 참여했던 프리온보딩 인턴십 수료 후 취업한 사람을 대상으로, 취업준비생들에 대한 조언과 현재 개발자로써 쌓아나아 가는 커리어 스토리에 대한 내용의 인터뷰였다. 나를 인터뷰하고 싶다는 메일을 받은 것에 대해 신기했고, 내가 어떤 이야기를 할 수 있는 사람인지를 생각했을 때, 운이 좋아서 지금 좋은 회사에서 여러 경험을 쌓아나가고 있다고 생각이 들어 망설이는 맘도 들었다.\n\n고민을 계속하면서 합격하고 나서 세웠던 다음 목표가 떠올라 인터뷰를 보기로 했다. 취업을 준비할 때는 빨리 취업을 하는 것에 목표가 있었다면, 취업을 하고 나서는 개발자 커뮤니티에 기여하고, 나와 같이 어떻게 하는 게 공부하는 게 맞는 건지 고민하고 힘들어했던 분들에게 도움이 될 수 있는 멘토가 되고 싶은 목표를 다음 목표로 잡았었다. 이런 공식적인 인터뷰를 통해서 내 이야기가 누군가에게 희망이 되고 도움이 될 수 있기를 바라며 인터뷰를 하기로 결정했다.\n\n인터뷰를 위해 원티드를 방문했는데, 엄청나게 높은 잠실 롯데타워 35층에 위치하고 있었다. 나의 인터뷰를 담당하시는 마케터분과 편하게 여러가지 질문들을 주고 받으면서 내가 왜 개발자가 되기로 결심했는지 부터 현재 어떻게 일하고 있는지 등에 대해서 인터뷰 하며 '아, 내가 정말 짧은 시간에 많은 게 바뀌었구나'라는 생각이 들었다.\n\n단순히 개발자가 되겠다는 목표를 세웠던 2021년 10월부터, 졸업 후 1년간 일하면서 계속 준비했던 2022년, 그리고 수많은 회사에 떨어지고 드디어 개발자가 된 2023 2월, 개발자로써 어떤 삶을 살고 있는지 인터뷰를 하게된 2023년 6월까지 목표로 했던 것을 이루고, 감사한 생활들이 이어지고 있다는 생각이 들었다.\n\n아직 어떻게 글이 나오고 있는지는 전달 받지 못했지만, 이를 기점으로 더 많은 것을 나눌 수 있게 내 자신을 더 채워나가야 겠다는 좋은 자극이 되었다.\n\n[마케터님이 자랑해주신 원티드 회사 뷰]\n\n<img src='원티드뷰.jpeg' width='800'/>\n\n### 마치며\n\n6월에는 상대적으로 스쿼드 일은 적었지만, 그만큼 더 깊이 고민하고 다양한 기술 주제들에 대해서 관심을 갖고 성장하려 노력했다. 대외 활동인 인터뷰를 하고, 회사 내 기술 공유시간에 발표도 하고, 토스의 슬래시 발표도 보면서 내가 가진 더 많은 것을 전달할 수 있는 사람이 되고 싶다는 욕심이 든다. 앞으로 더 깊이 있는 사람으로 내 자신을 만들어가는 시간들로 채워나가야겠다.\n"},{"excerpt":"5월은 이전 두달과 달리 더욱 다이나믹 했던 것 같다. 개인적인 일로는 수습기간이 끝나고 정식으로 입사하기도 했고, 큰 일감들이 배포된 이후 장애가 발생해 급하게 핫픽스를 하는 등 정말 많은 걸 배우고 느낄 수 있었던 한달이었다. 그중에서 내가 느꼈던 일하는 방식과 기술적 이슈들에 대해 정리해보고자 한다. 드디어 출시된 요청 견적서 작업 원래 우리 스쿼드…","fields":{"slug":"/2023-06-05-2023년-5월회고/"},"frontmatter":{"date":"June 05, 2023","title":"☀︎ 2023년 5월 회고","tags":["회고"]},"rawMarkdownBody":"\n5월은 이전 두달과 달리 더욱 다이나믹 했던 것 같다. 개인적인 일로는 수습기간이 끝나고 정식으로 입사하기도 했고, 큰 일감들이 배포된 이후 장애가 발생해 급하게 핫픽스를 하는 등 정말 많은 걸 배우고 느낄 수 있었던 한달이었다. 그중에서 내가 느꼈던 일하는 방식과 기술적 이슈들에 대해 정리해보고자 한다.\n\n### 드디어 출시된 요청 견적서 작업\n\n원래 우리 스쿼드는 사용성을 주로 담당하는 업무를 해왔지만 이번에 새로운 시도로 견적발송과정을 개선하는 실험을 진행했다. 우리가 개선하려하는 부분은 견적발송을 위한 기존 플로우 `요청서 상세 진입점 -> 요청서 상세 -> 견적발송` 에서 요청서 상세화면에서 바로 견적을 발송할 수 있게 하는 작업을 진행했다.\n\n견적발송은 우리 서비스의 핵심적인 부분이기 때문에 다양한 useCase들이 섞여있는 화면이다. 예를 들면 요청서 상세의 경우 요청서가 만료되었는지 여부 등을 확인해해야 하고, 견적발송화면에서는 `본인인증을 한 고수`만 발송할 수 있기 때문에 본인인증 여부를 확인해주는 등의 여러가지 useCase들이 존재했다. 기존 useCase들 중에서 새로운 화면에 필요한 부분들을 확인하고 적용이 필요했고, 두가지 화면에서 관리하고 있던 상태를 하나의 화면에서 관리할 수 있게 관리가 필요했다.\n\n두 페이지에 흩어져있던 정보들을 한 화면에 보여주기 위해서 FAB 버튼을 이용한 스크롤 적용해 한 화면에서 `요청서 상세 정보를 보면서 견적서 작성`이 가능하게 해 사용성을 높일 수 있었다. 아직 실험중이지만 높아진 사용성을 통해서 좀 더 견적 발송률이 증가되는 결과를 보이고 있다.\n\n[완성된 요청 견적서 화면]\n\n![img.png](img.png)\n\n#### 피쳐 플래그\n\n작업하면서 배포가 5월 18일로 예정되어 있었고 그사이에 배포될 건이 없을 것이란 예상이 되었기 때문에 지속적 통합 (CI)를 고려해서 스쿼드 브랜치에 해당 작업들을 병합하고 있었다. 하지만 갑작스럽게 이전에 작업했던 고수 회원가입 작업에서 버그픽스가 필요했고 비정기 배포로 나갈 부분이었기 때문에 스쿼드 브랜치에 해당작업이 반영되어야했다.\n\n이경우에 할 수 있는 선택은 두가지가 존재했다. 하나는 기존 작업했던 부분을 Revert를 하거나, 기존 작업했던 것을 보이지 않게 숨기는 `피쳐 플래그` 기능을 이용해서 함께 배포할 수 있다. 나는 두가지 선택지 중에서 피쳐플래그 기능을 이용해 기존 작업을 포함시켜 배포하는 선택을 했다.\n\n피쳐플래그는 특정기능을 새로운 코드 추가없이 켜고 끄고 할 수 있는 기술을 의미한다. 다음 예시 코드는 ChatGPT를 이용해 간단하게 작성된 피쳐플래그 코드다.\n\n```tsx\nimport React from \"react\"\n\nconst FeatureFlag = {\n  newFeature: true, // 새로운 기능을 활성화하려면 true로 설정\n  experimentalFeature: false, // 실험적인 기능을 활성화하려면 true로 설정\n}\n\nfunction NewFeatureComponent() {\n  return <div>New Feature Component</div>\n}\n\nfunction ExperimentalFeatureComponent() {\n  return <div>Experimental Feature Component</div>\n}\n\nfunction App() {\n  return (\n    <div>\n      {FeatureFlag.newFeature && <NewFeatureComponent />}\n      {FeatureFlag.experimentalFeature && <ExperimentalFeatureComponent />}\n    </div>\n  )\n}\n\nexport default App\n```\n\n위 코드를 보면 `FeatureFlag`의 값에 따라 조건부 랜더링이 가능한데 `FeatureFlag`를 전역 상태로써 관리하고 내부적으로 스위치 버튼을 추가해 켜고 끄고가 가능하게 연결해 활성화되어있을 때만 화면에 보일 수 있게 설정할 수 있다.\n\n피쳐플래그 덕분에 기간이 길게 필요한 큰 작업도 지속적 통합을 하면서 작업을 진행할 수 있었고, 갑작스럽게 배포가 필요할 때에도 기존 작업을 revert하지 않고 배포 할수 있었다.\n\n[피쳐 플래그]\n\n<img src='https://assets.website-files.com/61a60c66d019df8b241b1720/63a558ad6709527a6756a8cb_Feature%20flag_1300x866.jpg' width=\"700\"/>\n\n#### 내가 만든 B급 장애...\n\n요청서상세와 견적발송 두가지 화면을 합치면서 문제가 발생했다. 푸시 알림을 통해 진입한 경우 견적발송이 되지 않는 문제로. 코드적 원인은 요청서 상세와 견적발송 두가지에서 비슷하게 명시된 요청서정보 변수로 인해 딥링크로 접근시에는 올바른 요청서 정보를 전달하지 못하고 있어서 생긴 것으로 확인되었다. 개발자 테스트에서 딥링크로 진입했을 때 견적발송까지 하는 과정을 놓쳤고, 기본 앱에서 견적발송 케이스만 확인했던 점이 부족했던 부분이었다.\n\n장애가 해결하고 나서 챕터내, 팀내에서 어떻게 프로세스적으로 보완할 지, 어떤 점이 문제가 되었는지 분석하고 회고하면서 더 보완할 방법을 함께 고민하기도 했지만 개인적으로 부족함을 많이 느꼈다. 나 혼자 다 책임져야할 부분은 아니지만 개발자로써 먼저 잡아낼 수 있는 부분이었다는 아쉬움이 항상 존재하는 것 같다. 늘 다음에는 더 잘해야지, 다음에는 더 꼼꼼하게 해야지 하지만 늘 부족한... 내가 부끄럽기도 했다. 부끄럽고 후회하는데에서 멈추지 말고 성장할 수 있기를... 다음에 누군가가 내가 만든 코드 작업을 하실 때에 내가 놓쳤던 부분을 챙겨드릴 수 있기를 바라본다.\n\n### 첫 배포\n\n웹과는 다르게 모바일에서의 `배포`는 좀 더 고려해야할 부분이 많다. 왜냐하면 웹과 달리 `하위 버전`이 존재하기 때문이다. 만약 2.0.0 버전을 배포하려 할 때 1.0.0 버전을 사용하던 유저 모두가 2.0.0 버전으로 강제로 업데이트 시켜야하는지 아니면 유저가 선택적으로 업데이트 하게 하는지 고려해야 한다. 강제로 업데이트 시키는 경우 사용자는 앱에 이용하기 위해서 앱스토어 또는 플레이 스토어에 다시 돌아가 업데이트를 하게 되어 이 과정속에서 이탈하는 유저가 늘게된다. 이를 챕터 내에서 `강제 업데이트` 또는 `자율 업데이트`로 부르고 있다.\n\n모바일 배포의 기본 배포방식은 앱스토어와 플레이스토어에 제출하고 심사를 받은 뒤에 배포되는 방식이다. React Native의 장점은 여기서 코드푸쉬 기능을 이용해 스토어에 올라간 앱을 다시 검수를 거치지 않고, 코드를 추가하는 소프트 업데이트가 가능하다는 점이다. 이를 챕터내에서 `하드 업데이트`와 `소프트 업데이트`로 부르고 있다.\n\n이러한 총 강제/자율, 하드/소프트에 따라 총 4가지 배포방식이 존재하고 Native적인 변경점이 생길 때 보통 하드버전을 올리게 되는데 내가 배포 담당자가 되는 날에는 하드배포가 나가게 되었다.\n\n처음하는 배포였기 떄문에 도움을 많이 받아 진행하게 되었고, 도움을 받아 진행하면서 IOS와 AOS의 테스트 버전을 등록하고 심사를 받는 과정, QA분들이 test버전을 확인하시는 과정과 배포가 되기까지를 배울 수 있게 되었다.\n\n### RN Debugger의 React Devtools 되살리기\n\nReact Native를 이용해 디버깅을 하기 위한 디버거로 우리 챕터는 [RN-Debugger](https://github.com/jhen0409/react-native-debugger)를 사용하고 있다. RN debugger는 Redux devtools와 React-devtools, 크롬의 개발자 도구 등을 사용할 수 있게 도와주는 디버깅 툴이다. 그중에서 React-devtools를 우리 챕터가 사용하고 있지 못하고 있다는 것을 발견했다. 웹에서 react-devtools를 사용할 때 해당 state, props등을 코드 변경없이 바꿀 수 있고, profiler를 통해 성능 측정도 가능하다는 것을 알고 있었기 때문에 이부분을 다시 사용할 수 있다면 챕터내의 도움이 되지 않을까 생각해 조사하기 시작했다.\n\n#### 삽질의 시작\n\n우리 프로젝트의 React-native 버전은 `0.67`이고 가장 최신 release된 RN-debugger버전은 `0.13.0`이란 점을 확인했다. 업데이트된 RN-Debugger에 따라 맞춰주는 작업들이 PR에 발견되었었지만 어느 시점부터 사용할 수 없었던 것으로 보였다.\n\n[우리 레포의 package.json]\n\n```json\n{\n  \"dependencies\": {\n    \"react\": \"17.0.2\",\n    \"react-native\": \"0.67.5\"\n  },\n  \"devDependencies\": {\n    \"react-devtools\": \"4.19.1\",\n    \"react-devtools-core\": \"4.25.0\"\n  }\n}\n```\n\n[react-devtools를 사용할 수 없는 문제 상황]\n\n![Untitled](https://github.com/choi2021/choi2021.github.io/assets/80830981/1b6706e6-f377-4661-8410-a293c2005a2f)\n\n우선은 호환이 가능한 RN-Debugger 버전을 찾기 위해서 github issue를 확인하기 시작했고 그중에서 v0.11.7 (dev-tools 4.10.1) 이용하는 방법을 발견했다. ([이슈 답변](https://gist.github.com/bvaughn/4bc90775530873fdf8e7ade4a039e579#react-native-debugger))\n\n![이슈 답변](https://github.com/choi2021/choi2021.github.io/assets/80830981/91a88c26-5408-451e-a97b-dd531539bdce)\n\n발견한 버전으로 설치 이후 다시 프로젝트를 실행했을 때 컴포넌트 정보를 받아올 수 있지만, `react-devtools-core`의 backend,js 에서 에러가 발생해 state, props 정보를 볼 수 없는 상황이었다. 해결책은 되지 않았지만 `0.11.7`을 기준으로 체크하기 시작했다.\n\n[컴포넌트 정보까지 불러오는 것은 성공]\n\n![컴포넌트 불러오기 성공](https://github.com/choi2021/choi2021.github.io/assets/80830981/f98d5d3a-425f-423d-a5dd-850507fba8e6)\n\n#### 어디까지 되는 걸까\n\n`0.11.7`버전 이후 모든 버전을 다 확인했을 때 `0.11.8`부터는 backend.js의 에러도 없이 state와 props가 정확히 뜨는 걸 확인할 수 있었고 `0.12.1`버전까지 문제없이 사용할 수 있었다.\n\n문제는 가장 최신 버전인 `0.13.0`부터 나타나기 시작했고, `0.13.0`버전의 변경점을 확인했더니 `React-devtools-core` 패키지가 `4.14.0`에서 `4.25.0`으로 변경된 한줄의 변경점([RN-Debugger 0.13.0의 변경점](https://github.com/jhen0409/react-native-debugger/commit/9696bb186ff2fc130c9e154b6b4de8a57bdfeaa6) )만 존재했다.\n\n`4.25.0 ` 어디서 많이 본 숫자인데 분명 우리 package.json에서도 동일하게 `React-devtools-core` 패키지가 `4.25.0`으로 설치되어있었다. 하지만 왜 사용하지 못하고 있을까 궁금증이 들었고, React-native 내부 코드를 확인하기 시작했다.\n\n#### 이래도 사용할 수 없었구나\n\nReact native의 코드를 찍먹(?)해보았을 때 자체적으로 `react-devtools-core` 패키지를 불러오고 있었다. 이때 불러오는 패키지에 따라 RN Debugger에서 사용될 패키지 정보가 달라지겠다는 생각이 들어 React Native 0.67버전의 peer dependency를 확인해보기로 했다.\n\n```tsx\n\"use strict\"\n\nif (__DEV__) {\n  let isWebSocketOpen = false\n  let ws = null\n\n  const reactDevTools = require(\"react-devtools-core\")\n  // 여기서 어떤 버전인지 궁금해\n  // ...\n}\n```\n\n확인 해보았을 때 RN 0.67에서는 `react-devtools-core`를 `4.19.0`버전을 사용하고 있었고, 다음 버전인 0.68에서 `4.23.0`으로 올라간 것으로 확인할 수 있었다. 그렇기 때문에 현재 우리 레포에 `react-devtools-core`에 `4.25.0`을 설치하더라도 peer로 설치된 `4.19.0`을 사용하기 때문에 오류가 발생했다.\n\n<table>\n<tr>\n<th>RN 0.67의 package.json</th>\n<th>RN 0.68의 package.json</th>\n</tr>\n<tr>\n<td>\n<img src=\"https://github.com/choi2021/choi2021.github.io/assets/80830981/d4d05b61-f646-4222-8e98-6976b00dba73\" width=\"556\"/>\n</td>\n<td>\n<img src=\"package.png\" width=\"400\" />\n</td>\n</tr>\n</table>\n\n#### 그럼 어떻게 하면 좋을까?\n\n위에 조사한 내용으로 총 3가지 방법이 떠올랐다. RN을 0.68이상으로 업그레이드하거나, RN Debugger client 버전을 downgrade해서 `0.12.1`로 사용하는 방법, 마지막으로 outdated된 패키지들 정리 후에 react-devtools-core 4.23.0 버전도 설치하는 방법이다. 이중에서 우선 가장 적은 비용으로 사용가능한 `0.12.1`버전으로 사용하는 방법을 공유했다.\n\n사실 큰 작업은 아닐 수 있지만 5월 한달 목표로 잡았던 DX 개선 작업중 하나인 RN Debugger의 React-devtools를 사용할 수 있게 하는 작업의 결론을 낼 수 있었고, 기술 공유시간에 발표도 할 수 있어서 좋은 기회가 되었다.\n\n### 이제는 왜 하는지 알겠어, 테스트!\n\n나에게 있어서 테스트는 거리가 멀어보이는 주제였다. 하면 좋지만 왜 해야하는지 아직 이해가 되지 않았기 때문에 미루고 있었던 주제였지만 버그픽스 작업을 하면서 테스트의 중요성을 느끼는 기회가 주어졌다.\n\n내가 해야했던 작업은 신규 유저에게 주어지는 상품에 대해 얼마나 남았는지 보여주는 타이머 컴포넌트였는데, 간헐적으로 1분 미만의 시간에서 3일 1분으로 보여지는 문제가 발생했다. 이 문제의 가장 어려운 점은 재현되는 조건에 대해 알기 어려웠다는 점이었고, 초 단위가 아니라 `3일`이 추가되는 게 이해되지 않았다. 페어프로그래밍의 주제로 제안해 hee와 함께 해결해 보게 되었다.\n\n간단한 확인들은 이미 진행했었기 때문에 hee께서 제안해주신 것은 테스트 코드를 이용해서 10초 내에서 어떻게 결과값이 나오는지 ms단위로 총 1000번의 시간이 어떻게 출력되는지 확인했고, 테스트에서 놀랍게도 문제상황이 재현될 수 있었다. 문제는 시간을 계산하는 라이브러리의 메소드에서 소숫점 단위가 달라지면서 생긴 이슈로 판명되어 해결될 수 있었다.\n\n일일히 확인했다면 포기할 수 밖에 없었을 이슈였지만, 테스트를 통해 확인할 수 있었고, 왜 테스트가 필요하는지를 느끼는 좋은 경험이 되었다. 이후 테스트를 공부하기로 마음먹어 개인 프로젝트에서 작은 컴포넌트들에 대한 테스트를 작성해보고 있고, 다음달부터 작은 부분부터 도입하는 것을 목표로 하고 있다. 새로운 접근법과 필요성을 느끼는 중요한 경험이 되어 행복했다.\n\n### 마치며\n\n나 하나는 부족하지만 팀으로 일하는 법, 도움을 주고 받고, 어떻게 질문하고 커뮤니케이션 하는 지 등 많은 것을 배워가고 있다. 배워서 나도 돌려드릴 수 있게 계속해서 성장하고, 다음달 6월의 목표로 삼은 테스트를 어떻게 작성하고 도입해봤는지 다음달 회고에 꼭 작성할 수 있게 더 노력하려 한다.\n"},{"excerpt":"시간이 너무 빠르게 흘러 글을 쓰는 지금은 벌써 5월 5일 어린이날이다. 휴일을 맞아 4월 한달간 했던 업무들을 돌아보고 내가 발전했던 점, 부족했던 점들에 대해 작성해보고자 한다. 😆 드디어 배포된 나의 작업들 4월에 스쿼드에서 작업한 내용들은 두가지로, 회원가입 퍼널을 개선하는 작업과 대시보드에서 커뮤니티로 진입할 수 있게 하는 진입점을 추가하는 작업…","fields":{"slug":"/2023-05-06-2023년-4월회고/"},"frontmatter":{"date":"May 05, 2023","title":"😎 2023년 4월 회고","tags":["회고"]},"rawMarkdownBody":"\n시간이 너무 빠르게 흘러 글을 쓰는 지금은 벌써 5월 5일 어린이날이다. 휴일을 맞아 4월 한달간 했던 업무들을 돌아보고 내가 발전했던 점, 부족했던 점들에 대해 작성해보고자 한다.\n\n## 😆 드디어 배포된 나의 작업들\n\n4월에 스쿼드에서 작업한 내용들은 두가지로, 회원가입 퍼널을 개선하는 작업과 대시보드에서 커뮤니티로 진입할 수 있게 하는 진입점을 추가하는 작업이었다. 각각의 작업들에 대해 정리해보려 한다.\n\n### 1. 고수 회원가입 퍼널 개선\n\n고수 회원가입 퍼널 개선 업무는 3월부터 진행해 4월 13일에 배포되었다. 클래스 컴포넌트로 2년이 넘었던 레거시 코드였기 때문에 코드 베이스를 우선 이해하는데 많은 시간이 걸렸다. 코드 베이스 중 가장 어려웠던 부분은 단연코 `ViewPager`와 스크롤 이벤트였다.\n\n[현재 PROD에 배포된 고수회원가입 카테고리 선택 화면 ]\n\n<img src='./고수회원가입.jpeg' width=\"400\"/>\n\n#### 기기에서만 보였던 ViewPager 에러\n\nView Pager는 하나의 스크린 컴포넌트에서 ViewPager로 감싸둔 자식 컴포넌트들을 순서대로 페이지 전환 효과를 줄수 있게 도와주는 라이브러리로 현재 모바일 챕터에서 사용하는 패키지는 `https://github.com/callstack/react-native-pager-view` 이다.\n\n당시에 시뮬레이터에서는 정상동작하다가 빌드버전을 확인했을 때 viewPager로 설정해둔 컴포넌트들의 순서가 뒤섞이는 문제가 발생했다. 시뮬레이터에서 문제상황을 재연할 수 있어야 디버깅이 가능한데 시뮬레이터에서는 정상적이고 빌드 버전, 실 기기에서만 나타나는 이슈였기 때문에 디버깅에 큰 어려움을 겪었다.\n\n이슈를 해결하기 위해 챕터에 공유했고 챕터원 분중에서 react-native 경험이 많으신 웨인께서 `먼저 조건부로 랜더링하는 부분`이 있게 되면 viewPager에서 에러가 발생할 수 있다고 이야기 해주셨고, 히께서 같이 디버깅해주시면서 문제점이 웨인께서 말씀해주신 `조건부로 랜더링되던 부분에서 viewPager의 화면전환을 위한 렌더링 타이밍과 부딪혀 생긴 이슈`라는 것을 함께 찾아주셔서 다행히 해결할 수있었다. (너무 감사했다...)\n\n기존의 조건부 랜더링을 했어야 했던 이유는 위 이미지의 헤더문구와 검색바는 고정시키고 아래 카테고리만 스크롤이 되게하는 요구조건을 구현하기 위해서였다. 해당 스크린 컴포넌트 자체가 상속을 통해 전체 UI가 스크롤되게 감싸져있는 상태였기 때문에 헤더부분을 따로 분리해야 했고, 이부분을 ViewPager 바깥에서 조건부로 헤더를 랜더링하게 구현했다.\n\n```tsx\nclass SignupProScreen {\n  //...\n  render() {\n    return (\n      <>\n        {currentIndex === \"Category설정 페이지\" && <고정 헤더 UI />}\n        <PagerView style={styles.pagerView} initialPage={0}>\n          {/*...*/}\n          {/*// 페이지로 하나씩 슬라이드 될 컴포넌트들*/}\n        </PagerView>\n      </>\n    )\n  }\n}\n```\n\n이부분을 해결하기 위해서 먼저 원인이 되었던 viewPager 밖에서 조건부 랜더링하던 부분을 제거했다. 제거 이후에는 ViewPager를 올바르게 사용하기 위해서 좀 더 사용법에 대해 알아보기 시작했다.\n\nViewPager에서 가장 중요한 것은 `바로 아래 자식 컴포넌트`다. 아래 코드와 같이 `<PagerView/>`로 감싸진 바로 아래 자식컴포넌트들이 하나의 페이지처럼 동작하기 때문에 `<></>`로 감싸지던지 아니면 다른 Provider 컴포넌트로 감싸지면 정상 동작을 하지 못한다는 것을 새롭게 알게 되었다.\n\n[react-native-pager-view의 예시 코드]\n\n```tsx\nimport React from \"react\"\nimport { StyleSheet, View, Text } from \"react-native\"\nimport PagerView from \"react-native-pager-view\"\n\nconst MyPager = () => {\n  return (\n    <PagerView style={styles.pagerView} initialPage={0}>\n      <View key=\"1\">\n        <Text>First page</Text>\n      </View>\n      <View key=\"2\">\n        <Text>Second page</Text>\n      </View>\n    </PagerView>\n  )\n}\n\nconst styles = StyleSheet.create({\n  pagerView: {\n    flex: 1,\n  },\n})\n```\n\n기존 헤더를 고정시킨 UI와 스크롤이 되어야하는 카테고리를 구현하면서 ViewPager로 함께 동작할 수 있게 구현하기 위해 두가지 컴포넌트를 감싸는 추가적인 컴포넌트를 만들었다. 다행히 내 예상대로 `PagerView` 바로 아래 자식으로 컴포넌트를 전달함으로써 요구조건을 만족시키면서 ViewPager를 이용할 수 있게 구현할 수 있었다. `PagerView` 밖에서 조건부 랜더링을 지양해야한다는 사실을 새롭게 알게된 이슈였다.\n\n[react-native-pager-view의 예시 코드를 활용해 구현한 개선한 코드]\n\n```tsx\nimport React from \"react\"\nimport { StyleSheet, View, Text } from \"react-native\"\nimport PagerView from \"react-native-pager-view\"\n\nconst SignupProScreen = () => {\n  return (\n    <PagerView initialPage={0}>\n      ...\n      <SignupCategoryComponent key=\"2\" />\n      ...\n    </PagerView>\n  )\n}\n\nconst SignupSelectServices: React.FC<props> = props => {\n  return (\n    <>\n      <고정된 헤더 UI />\n      <기존 카테고리 선택 컴포넌트 />\n    </>\n  )\n}\n```\n\n#### 컴포넌트 위치 찾기\n\n검색화면에서 원하는 서비스 클릭시, 서비스 선택화면으로 이동하고 해당 서비스로 스크롤이 될 수있게 설정해야 했다. 이 조건을 위해서 선택된 서비스가 랜더링된 위치값을 구해야 했는데 이를 위해 react-native의 위치를 구하는 메소드들에 대해 공부하는 기회가 되었다.\n\n##### measure(callback)\n\nmeasure는 부모 컴포넌트를 기준으로 좌표값을 가져오는 메소드다. measure가 가장 간단했기 때문에 먼저 시도했지만 문제는 `AOS에서 measure로   해당 위치를 가져올 수 없는 문제`가 존재했다.\n\n[measure를 사용하는 예제]\n\n```tsx\nconst MyComponent = () => {\n  const ref = useRef<View>(null)\n  const scrollRef = useRef<ScrollView>(null)\n\n  const scrollToItem = () => {\n    ref.current.measure((x, y, width, height, pageX, pageY) => {\n      scrollRef.current.scrollTo({ x: x, y: y, animated: true })\n    })\n  }\n\n  ;<ScrollView ref={scrollRef}>\n    <View ref={ref}>...</View>\n  </ScrollView>\n}\n```\n\nAOS에서 measure로 좌표 값을 받을 수 없는 문제는 나만 겪은 문제가 아니라 RN 레포의 이슈에도 남아있던 오래된 문제로 보였다.\n\n[[RN 레포에서 찾은 이슈 ](https://github.com/facebook/react-native/issues/3282)]\n\n<img src=\"image-20230507145834812.png\" width=\"800\" />\n\n해당 이슈의 해결방법은 2가지가 있었는데 `Collapsable={false}`로 수정하는 방법, `measureLayout`메소드를 사용하는 방법이었다. 둘중에 선택한 방법은 measureLayout을 이용하는 방법이었다.\n\n`Collapsable={false}` 방법은 기존의 AOS가 성능 최적화 목적으로 view를 계층에서 제거하기 때문에 좌표를 반환하지 않는 것을 계층에서 제거하지 않게 막는 방법이다. 결국 성능 문제와 관련 있기 때문에 최대한 지양해야 한다고 생각되었다. 그래서 두번째 방법 measureLayout 메소드를 이용했다.\n\n##### measureLayout(relativeToNativeComponentRef, onSuccess, onFail)\n\nmeasureLayout은 measure와 다르게 ref값을 `findNodeHandle` 를 이용해 네이티브 뷰의 요소를 전달하고, 성공했을 때와 실패했을 때 실행할 콜백함수를 각각 전달할 수 있다. measureLayout을 이용해서 기존 measure코드를 수정했고 다행히 AOS/IOS 모두 동일하게 새롭게 추가한 서비스로 정확하게 스크롤이 되는 것을 확인할 수 있었다.\n\n[해당 이슈의 답변으로 제시된 예제 코드]\n\n```tsx\nimport { findNodeHandle, ScrollView, View } from \"react-native\"\n\nclass SignupProScreen {\n  //...\n  render() {\n    this.VIEW_REF.measureLayout(\n      findNodeHandle(this.SCROLLVIEW_REF),\n      function (x, y) {\n        console.log(x, y)\n      },\n      function (error) {\n        console.log(error)\n      }\n    )\n\n    return (\n      <ScrollView ref={ref => (SCROLLVIEW_REF = ref)}>\n        <View ref={ref => (VIEW_REF = ref)}>{/*...*/}</View>\n      </ScrollView>\n    )\n  }\n}\n```\n\n[개선된 서비스 선택-> 페이지이동-> 스크롤 로직]\n\n<table>\n  <tr>\n<th>AS-IS</th>\n<th>TO-BE</th>\n</tr>\n  <tr>\n<td><video src=\"https://user-images.githubusercontent.com/80830981/232484796-71d72623-2d21-414f-aea9-6e000ad62223.mov\" width=\"300\" />\n</td>\n<td><video src=\"https://user-images.githubusercontent.com/80830981/232484583-968acbe9-f71d-4c11-880f-fd5b28ca8e6f.mov\" width=\"300\" />\n</td>\n</tr>\n</table>\n\n크고 작은 이슈들과 QA들을 거쳐 드디어 첫 작업이 배포되었고 어려웠지만, RN에 대해서, 회사 코드 베이스에 대해서 깊이 이해할 수 있는 기회가 되어서 많이 성장할 수 있는 기회가 된 작업이었다. 현재 실험상으로는 아직 기존 고수 회원가입 화면이 더 결과가 좋아서 롤백이 될 수도 있지만... 내가 한 작업이 의미있는 작업이었길 바래본다 🙏\n\n### 2. 고수 대시보드 커뮤니티 진입점 추가 작업\n\n고수 대시보드 커뮤니티 진입접 작업은 기존에 없던 고수 대시보드에 커뮤니티 큐레이션 카드들을 보여줄 수 있는 섹션을 추가하는 작업이었다. 이전에 했던 고수 회원가입 퍼널 개선 작업보다 상대적으로 적은 스크린 이동과 상태관리의 요구조건으로 편하게 작업할 수 있었다.\n\n[고수 대시보드화면에 추가된 커뮤니티 진입점]\n\n<img src=\"KakaoTalk_Photo_2023-05-06-15-47-00 002.jpeg\" width=\"400\" />\n\n#### RN에는 display:inline이 없어\n\n위 사진에서 보이는 `얼마에요`에 해당하는 UI를 만드는 과정이 조금 어려웠다. 왜냐하면 React와 다르게 RN에서는 `display`에는 inline속성이 없다.\n\n[RN 공식 display 속성 설명]\n\n<img src=\"image-20230507181606569.png\" width=\"800\" />\n\n그렇기 때문에 기본적인 가로 전체 영역을 가지고 있어 inline으로 text길이 만큼만 영역이 표시될 수 있게 방법을 찾아야 했다. 방법은 생각보다 간단했는데 `flexDirection`을 'row'로 설정하게 되면 기본적으로 inline처럼 영역을 차지하게 되는 것을 확인할 수 있었다.\n\n#### API는 전달받은 대로 호출만 하기\n\n커뮤니티 작업을 하면서 코드리뷰를 통해 배울 수 있었던 부분 중 가장 기억이 남는 부분은 `API에 로직이 포함되지 않게하기 `이다. 모바일 팀은 Repository 패턴을 사용하고 있다. Repository 패턴을 쓰는 이유는 전달 받아 Repository를 사용하는 곳에서는 어떻게 데이터를 받아오는 지에 대해 모르게 계층을 추가하기 위해서다. 그래서 컴포넌트에서 직접 API를 호출하지 않고 Repository를 통해 필요한 API를 호출한다.\n\n커뮤니티 작업을 위해서는 기존 API 메소드에 새로운 인자를 추가적으로 전달해야 했고, 해당 인자의 유무에 따라 다른 param으로 API를 호출해야 했기 때문에 API 메소드에서 분기처리를 하는 코드를 작성했다.\n\n코드리뷰를 통해 `API는 repository 의 요청을 수행하기만 하게, 어떤 진입점에서, 어떤 param에서 호출이 되는지 알 필요가 없을 것 같다`는 피드백을 받을 수 있었다. API는 로직을 포함하지 않고 Repository에서 호출한 내용만 수행하게 수정하는 것이 더 적절하다는 점을 알게 되면서 Repository 패턴에 대한 이해가 할 수 있었다.\n\n[코드리뷰 받기 전 API에 분기점을 추가했던 예시 코드]\n\n```tsx\nexport class API {\n    getData = (params: {\n        id: ID,\n        //...\n    }): Promise<ResponseDto> => {\n        const baseConfig = {...}\n        return this.apiClient\n            .get<ResponseDto>('api주소', {\n                params: isNotNil() ? {...baseConfig, id} : baseConfig,\n            })\n            .then((result) => result.data)\n            .then((response) => response.response)\n\n    }\n}\n```\n\n[코드 리뷰 받은 후 Repository에 분기점을 추가한 예시 코드]\n\n```tsx\nexport class Repository{\n\tgetData = (\n    ...\n    id\n\t): Promise<ResponseType[]> => {\n    const baseConfig = { ... };\n    return new Api()\n        .getCuration(isNotNil(location) ? { ...baseConfig, id } : baseConfig)\n        .then((result)=>result)\n  }\n}\n\nexport class API{\n  getData = (params: {\n        //...\n    }): Promise<ResponseDto> => {\n        return this.apiClient\n            .get<ResponseDto>('api주소', {params})\n            .then((result) => result.data)\n            .then((response) => response.response)\n\t}\n}\n```\n\n## 😄 새롭게 사용했던 Git 명령어들\n\n4월 동안 작업하면서 새롭게 사용한 Git 명령어는 `rebase --onto` 와 `reset`으로 각각에 대해 정리해보려 한다.\n\n### rebase --onto\n\nrebase는 다양한 option을 전달함으로써 여러 상황에서 사용할 수 있다. 그중에서 부모 브랜치를 바꿔야할 때 `rebase --onto` 를 사용할 수 있다.\n\n- 사용법: `git rebase --onto <newbase> <upstream> [<branch>]`\n\n기존 `git rebase` 의 경우 예시와 같이 featureA 브랜치 작업내용에 대해 PR를 작성하고 featureA에서 featureB로 브랜치를 만들어 작업하면서 자주 사용했다. featureA PR에서 변경점 (F~G)이 생기고 변경점에 대한 내용이 featureB에서 사용해야 될 때 rebase를 이용하면 브랜치가 만들어진 지점을 C가 아닌 G로 바꿔 해당 작업을 반영할 수 있다.\n\n[예시]\n\n```text\nBefore                         \t\tAfter\nA---B---C---F---G (featureA)   \t\tA---B---C---F---G (featureA)\n         \\                              \t\t  \\\n          D---E (featureB)                   \t           D'---E' (featureB)\n```\n\n`rebase --onto`는 위보다 조금 더 많은 브랜치가 있을 때 부모 브랜치를 바꿀 때 사용될 수 있다. 아래 예시에서 featureB를 부모 브랜치로 가지고 있는 featureC 브랜치의 작업을 featureA로 바꾸고 싶은 상황이다.\n\n그냥 rebase를 사용하게 되면 기존 부모 브랜치의 커밋들도 함께 rebase되어 아래 예시에서 D'~I'으로 커밋이 featureA에 추가되게 된다. 우리가 하고 싶은것은 featureC에서 featureB 작업을 제외하고 featureA로 rebase 시키고 싶은 것이므로 이때는 `git rebase --onto featureB featureC` 를 이용할 수 있다.\n\n```text\nBefore                         \t\t rebase\t\t\t\t\t\t\t\t\t\t\t\t\t\t  After\nA---B---C---F---G (featureA)   \t\t A---B---C---F---G (featureA)  \t\t\tA---B---C---F---G (featureA)\n         \\                              \t  \\\t      \\\t\t\t\t\t \\       \\\n          D---E (featureB)                 \t    D---E      D'---E'\t\t\t           D---E   \\\n               \\\t\t\t\t\t\t      \\\t\t\t\t\t    H---I (featureC)\n                H---I (featureC)\t\t\t               H'---I'\n```\n\n### git reset\n\ngit reset의 경우 커밋한 작업을 되돌릴 때 사용할 수 있는 방법으로 연결리스트의 HEAD를 이전 커밋으로 돌려 기존 커밋들의 연결을 끊어버리는 방법을 사용한다. 옵션에 따라 되돌려진 커밋들의 변경내용을 아예 없애거나 working directory 또는 staging area 상태로 변경내용을 남길 수 있다.\n\n[Git reset b 를 적용한 모습]\n\n<table>\n  <tr>\n    <th>AS-IS</th>\n    <th>TO-BE</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=998\" width=\"500\" />\n    </td>\n    <td><img src=\"https://wac-cdn.atlassian.com/dam/jcr:bdf5fda3-4aac-4170-ba35-58f7a66ea3c4/03%20git-reset-transparent%20kopiera.png?cdnVersion=998\" width=\"500\" />\n    </td>\n  </tr>\n</table>\n\n## 🥹 마치며\n\n4월 한달도 많은 것을 배우고 느꼈고 내가 목표로 했던 작업들도 다 해볼 수 있어서 나름 성공(?)한 한달이었던 것 같다. RN Debugger의 react devtools를 다시 사용할 수 있게 했던 작업들은 5월에 발표자료와 함께 정리해볼 예정이다. 고수 회원가입 퍼널 개선이라는 큰 작업을 하면서 작업단위를 너무 크게 잡아서 코드 리뷰를 받을 때 PR를 더 작게 만드는 게 좋겠다는 점과 내가 반복해서 놓치는 팀 컨벤션에 대한 피드백을 받았다. 이러한 부분은 내가 더 신경쓰면 고쳐질 수 있는 부분이라 생각하고 부족함을 많이 느끼기도 했다. 다음 달은 내가 맡은 도메인, 내가 작성한 코드에 대해서 더 잘 이해할 수 있기를 바라본다.\n"},{"excerpt":"회사에 입사하고 일한 지 한 달이 되었다. 입사일 기준으로 하면 한 달을 넘었지만 3월에 운 좋게 포상휴가를 받아서, 이참에 지금까지 일하면서 배울 수 있었던 부분들을 정리하면 좋겠다고 생각되었다. 회사의 코드에 적응하고, 스쿼드로 함께 일하는 법을 배우고, 챕터의 코드 리뷰를 주고 받으면서 하루 하루 배워나가는 게 너무 많았다. 취업을 준비하면서 단순히…","fields":{"slug":"/2023-03-31-2023년-3월회고/"},"frontmatter":{"date":"March 31, 2023","title":"🐤 2023년 3월 회고","tags":["회고"]},"rawMarkdownBody":"\n회사에 입사하고 일한 지 한 달이 되었다. 입사일 기준으로 하면 한 달을 넘었지만 3월에 운 좋게 포상휴가를 받아서, 이참에 지금까지 일하면서 배울 수 있었던 부분들을 정리하면 좋겠다고 생각되었다. 회사의 코드에 적응하고, 스쿼드로 함께 일하는 법을 배우고, 챕터의 코드 리뷰를 주고 받으면서 하루 하루 배워나가는 게 너무 많았다. 취업을 준비하면서 단순히 공부할 때는 보지 못했던 것과 중요하다 듣기만 했던 부분들에 대해 정리해보고 다음 한 달은 좀 더 개발자다울 수 있기를 바라며 회고를 써보려 한다.\n\n### 😂 Git, 너 좋은 녀석이었구나\n\n혼자서 개인 프로젝트만 하다가 회사에 들어가 누군가와 함께 협업한다는 것은 생각보다 큰 두려움으로 다가왔다. 내가 작성한 코드나 내가 잘못해서 누군가의 작업을 망치지는 않을까라는 막연한 두려움이 있었다. 온보딩 기간 동안 여러 도움을 받고, 스쿼드 업무를 하면서 모바일 챕터의 브랜치 전략에 대해 이해하고 어떻게 작업하면 될지 조금씩 감을 잡아가고 있다.\n\n#### 우리는 변형된 Git flow 전략\n\n숨고 모바일 챕터에서 사용하는 협업 전략은 변형된 `Git flow`전략으로 기존의 git flow전략을 우리팀의 배포 전략에 맞게 변형해서 사용하고 있다. 이에 대한 내용은 우리팀 테크 리더인 Jimmy가 작성해주신 글을 참고해 정리해 보고자 한다.\n\n기존 **Git flow**전략의 경우 Production에 해당하는 `Main 또는 Master 브랜치`, 개발을 위한 `Develop 브랜치` 두 가지로 크게 나뉘는 전략이다. 두 가지 주요 브랜치에 하위 브랜치로 Develop 브랜치에서 여러 개발자가 함께 일하기 위해 각자가 맡은 기능 개발을 위한 `feature 브랜치`, Production에 내보내기 전 QA나 Test를 위한 `release 브랜치`, 배포한 후에 급한 버그를 수정하기 위한 `hotfix 브랜치` 하위 브랜치들이 있다.\n\n[기존 Git Flow 전략]\n\n![Git flow workflow - Feature Branches](https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=913)\n\n우리 모바일 팀은 스쿼드 별로 작업한 내용을 반영할 수 있게 하기 위해서 기존 Git flow 전략에서 develop 브랜치를 스쿼드 별 develop 브랜치로 `squad/스쿼드` 브랜치를 추가해 사용하고 있다. 각 스쿼드 별로 develop 브랜치를 구분함으로써 특정 스쿼드의 작업의 배포를 연기해야 하는 경우 해당 squad의 배포 내용만을 제외할 수 있는 장점을 갖게 되었다.\n\n이러한 배포 전략에 대해서는 어느정도 이해했지만 한주간 돌아가는 배포 사이클 전체에 대해서 이해하는 데에는 좀 더 오래걸렸다. 그이유는 과정마다 `테스트`가 중간 중간에 함께 들어있기 때문이었다. 숨고의 배포 사이클에는 내가 만든 feature에 대해서 테스트 빌드 버전을 통해 PO분과 디자이너 분께서 봐주시는 `스쿼드 내부 디자인 QA`, 배포에 나가기 위한 release 버전을 다양한 테스트 기기를 통해서 QA분께서 봐주시는 `통합 QA`과정이 있다. 이러한 QA를 통해 발견된 버그나 에러 등은 다시 해당 스텝의 브랜치에서 `bugfix`브랜치를 만들어 작업을 하게 된다.\n\n앞서 설명한 변형된 Git flow 전략과 QA과정을 함께 정리해 다음과 같이 배포 사이클을 나타낼 수 있다. Jimmy가 작성해주신 글의 그림을 참고해서 좀 더 간단하게 만들어 보았다. 그림에 설명을 스텝별로 덧붙여보면 다음과 같다.\n\n1. 스쿼드 별 브랜치에 feature 브랜치을 만들어 작업하고 스쿼드 브랜치로 병합한다. 이때 챕터 내의 **코드리뷰**를 거친다.\n2. 스쿼드 브랜치에서 목표 배포 날짜에 맞는 `release/스쿼드명/날짜 브랜치`를 만든다.\n3. 만들어진 브랜치를 App center를 이용해 앱을 빌드하는데 이때 버전을 `Test 빌드`버전이라고 부르고 배포 일자의 전 주 수요일까지 이과정을 완료해야 배포에 포함될 수 있다.\n4. 해당 앱 버전을 다운받아 PO와 디자이너 분들께서 디자인 QA를 진행한다. QA과정에서 수정할 부분이 발생하면 `release/스쿼드명/날짜 브랜치`에서 bugfix 브랜치를 만들어 다시 작업하고 병합한다.\n5. 디자인 QA를 거치고 통합 QA를 위해 `release/날짜 브랜치`로 `release/스쿼드명/날짜 브랜치`를 병합한다.\n6. `release/날짜`브랜치로 병합된 버전의 앱을 빌드하고, 이때 버전을 `Staging 빌드`버전이라 부른다. 배포 일자의 전 주 금요일까지 이 과정을 완료한다.\n7. 병합 후에는 배포 주 월요일 화요일에는 통합 QA를 진행하는데 QA과정에서 수정할 부분이 발생하면 `release/날짜 브랜치`에서 bugfix 브랜치를 만들어 다시 작업한다.\n8. 이과정이 완료되면 배포일자에 작업한 내용이 배포된다.\n\n[모바일 팀의 배포 사이클을 정리한 그림 ]\n\n<img src=\"Main.jpg\"/>\n\n부족한 그림과 설명이지만 내가 한달동안 이해한 배포 사이클을 정리해보았다. 여기에 비정기배포나 hotfix가 나가야하는 경우는 아직 겪어보지 않아 따로 정리하지 않았다.\n\n#### Git에서는 폴더명을 함부로 바꾸면 안돼...\n\n고수 회원가입 부분을 작업하는 과정에서 폴더명의 대소문자를 변경했다. 처음에는 아무 생각 없이 작업했지만 이부분 때문에 Git이 기존에 추적하고 있던 파일들의 경로명이 달라져 에러가 나기 시작했다. 이럴 때 해결방법으로 몇 가지를 찾아보았는데 가장 좋은 방법은 **git 명령어**를 이용해서 폴더명을 변경하는 것이다.\n\n```bash\ngit mv oldName newName\n```\n\n명령어를 이용하지 않고 그냥 폴더명만 변경해버리면 버전이 없는 파일로 기존 파일이 변경되면서 충돌이 발생했다. 단순히 대소문자가 변경되었기 때문에 git뿐 아니라 tsc에서도 에러가 발생하는 것을 볼 수 있었다.\n\n아무것도 몰랐던 나는 이미 엎질러지고 해결법을 찾아야했는데 그 방법으로는 먼저 시도했던 방법은 git의 설정을 변경하는 것이었다. git 자체는 대소문자를 구분하지 않기 때문에 git config의 설정에 구분할 수 있게 추가해줘야 했다.\n\n```bash\ngit config core.ignorecase false\n```\n\n커밋을 정상적으로 했지만 여전히 에러가 발생했기 때문에 **git의 캐싱된 파일들에서 기존 파일을 삭제하는 방법**을 추가적으로 진행했다.\n\n```bash\ngit rm -r --cached filename\n```\n\n덕분에 git자체는 병합에러 없이 정상적으로 처리가 되었지만 이번에는 tsc에서 에러가 발생하기 시작했다.\n\n[당시 발생했던 tsc 에러]\n<img src=\"./image-20230402155550414.png\"/>\n\ntsc 에러가 더 어려웠던 것은 나와 유사한 에러를 경험한 사람을 찾을 수가 없었기 때문이었다. 그나마 찾아낸 방법은 tsconfig.json에 옵션을 추가하는 방법이었는데 이렇게 해도 해결이 되지 않았다.\n\n```json\n{\n  \"forceConsistentCasingInFileNames\": false\n}\n```\n\n막막했지만 기존 파일의 경로로 tsc가 돌아가서 생기는 에러인 것 같아 코드내용이 동일한 임시파일을 만들어 경로를 돌려서 커밋했더니 다행히 tsc가 정상작동했다.\n\n이후에 Jessie가 감사하게 알려준 방법은 마지막에 시도했던 방법처럼 임시파일로 점진적으로 바꾼 후에 다시 변경하는 방법으로 하면 옵션을 추가하거나 하지 않아도 되었다. 다음에 이런 일이 일어났을 때 기억하고 좀 더 빨리 해결할 수 있기를...\n\n이외에도 여러 작업을 동시에 하기 위해서 현재 작업하던 내용을 저장하기 위해서 `stash`를 자주 사용하는 등의 혼자 작업할 때보다 훨씬 다양한 명령어와 상황에서 작업하고 있다. 앞으로 익숙해져서 두려워하고 어려워하기 보다는 정말 좋은 도구로써 사용할 수 있게 노력할 필요를 느꼈던 한달이었다.\n\n### 😎 코드 리뷰와 지속적 통합\n\n팀으로 일하면서 아마 가장 많이 배울 수 있었던 포인트들은 대부분 **코드 리뷰**를 통해서 얻을 수 있었다. 간단한 건 기존 컨벤션에 대해서 알려주시는 부분이나 컴포넌트의 default로 설정되어있어 전달하지 않아도 되는 props에 대해서 알려주시는 부분부터 어려운 부분은 어떤 게 더 좋은 방식일지 내가 고민하고 있는 방식의 trade-off에 대해 같이 고민해주셨다.\n\n#### 코드 컨벤션\n\n이번에 배울 수 있었던 우리팀의 컨벤션에 대해 몇가지 정리해보면 다음과 같다.\n\n##### 이벤트 핸들러 함수 네이밍\n\n```javascript\n// 컨벤션 적용 전\n\nconst handleArrowPress = () => {\n  navigation.navigate(ScreenKeyEnum.Store, { location: \"pro_main\" })\n}\n\n// 컨벤션 적용 후\n\nconst handlePressArrow = () => {\n  navigation.navigate(ScreenKeyEnum.Store, { location: \"pro_main\" })\n}\n```\n\n이벤트 핸들러 함수를 네이밍 할 때 **handle+동사+타겟** 로 컨벤션으로 작성한다.\n\n##### 클래스 컴포넌트 내의 Render함수 방식 지양하기\n\n```tsx\n...\n renderSignupWithSearch(): ReactElement {\n        return (\n            <>\n              ...\n            </>\n        );\n    }\n```\n\n코드중에 레거시로써 클래스 컴포넌트로 작성되어 있는 부분들이 있다. 클래스 컴포넌트는 `render()`메소드를 이용해서 렌더링할 부분을 작성하는데, 내부에서만 사용할 것 같아 `renderSignupWithSearch`라는 메소드로 만들었지만 이러한 방식을 **render 함수**방식으로 우리팀 내의 안티 패턴으로 지정했다. 컴포넌트로 분리해서 사용하는 것이 컨벤션이다.\n\n#### 고민했던 Screen간의 상태변화\n\n이번 달에 혼자 스쿼드 업무를 담당하면서 가장 어려웠던 부분은 `스크린간의 상태변화`였다. A 스크린의 상태를 B 스크린에서 변화시키기 위해 set함수를 전달해야 했는데 우리가 사용하고 있는 `React Navigation`은 함수를 param으로 전달하는 것을 지양한다. 그 이유는 스크린 간에 param이 전달될 때 **Serialize**되기 때문인데 이로인해 참조관계가 깨져버릴 수 있어 이벤트를 이용하기를 추천한다. 이부분에 대해서는 챕터 위클리 미팅에서도 논의된 부분으로 고민했던 부분에 대해 공유했다. 논의에서 이야기 되었던 대안으로 **Global Event bus**와 **전역상태**에 대해 이야기했다.\n\n[React Navigation 공식 문서]\n\n![image](https://user-images.githubusercontent.com/80830981/227853570-6cd5ef75-44ed-42ae-bce9-d959d611ce74.png)\n\n**Global event bus**를 이용하면 param으로 전달하려 해 변경하려 했던 로직을 event로 등록하고 필요한 스크린에서 사용하는 event를 발생시킴으로써 스크린 간 상태 변경에 사용할 수 있었다. Global event bus의 단점으로는 `언제 event listener를 삭제해야하는 지에 대한 시점 문제`가 제기 되었고, 기존의 함수로 전달되던 모든 방식을 다 이벤트 버스로 바꾸는 것은 너무 많은 이벤트가 등록될 것 같다는 의견이 제시 되었다.\n\n**전역상태**방식은 내가 제시한 방식으로 스크린 간의 상태를 변경이 필요하다면 사용하는 게 맞지 않을까라는 고민이 되었다고 이야기 했다. 여기에 대해서 내가 합류하기 이전의 논의에서 고민했던 이야기들을 들을 수 있었는데, 모바일 특성상 같은 스크린이 stack으로 쌓이게 될 경우의 영향을 전역상태 변경으로 영향을 받는 화면이 많아지고, redux의 많은 보일러플레이트 문제도 있었다고 말씀해주셨다.\n\n- 결론은, 상태와 관련이 없는 경우에는 함수를 param으로 전달하는 방식을 유지하고, 상태 변경이 필요할 시에는 global event bus를 이용하는 것으로 이야기가 되었다.\n\n이렇게 더 좋은 방향을 고민하고 얻는 장점과 잃을 수 있는 단점에 대해 같이 고민하고 의논할 수 있는 팀이라는 점이 너무 좋았던 부분이었다.\n\n#### 내가 놓쳤던 리뷰 반영과 호되게 배운 CI\n\n내가 만든 가장 큰 사고(?) 였던 부분에 대해 이야기 해보려 한다. 기간이 긴 큰 작업을 혼자 맡게 된 것에 대한 부담 때문이었을까 기존의 작업한 부분을 수정하기 보다 기능 개발에만 너무 몰두해 7개의 PR들이 받은 리뷰를 수정하지 않은 채 병합되지 못하고 브랜치에 남아만 있게 되었다.\n\n이것의 큰 문제점은 앞서 정리한 배포 사이클에서 master는 매주 변경되고 변경된 내용들은 squad 브랜치로 당겨오게 된다. 이때 이전에 작업한 브랜치들은 변경 전 스쿼드 브랜치를 바라보고 있기 때문에 conflict이 날 수 밖에 없다. 연쇄적으로 이어지는 PR이었기 때문에 변경사항 또한 계속해서 이어졌고 기존에 예상하지 못한 conflict을 해결하는 작업으로 인해 기한 내에 병합하지 못하게 되었다. 결국 스쿼드 일정이 나로 인해 밀리게 되버렸고 내가 한 작업이 나가지 못하게 되었다.\n\n**왜 CI(Continuous Integration)가 중요한 지** 배울 수 있었고, 리뷰를 받고 다시 응답하는 과정이 얼마나 중요한 것인지 배울 수 있었다.\n\n#### let 지양과 즉시실행 함수 활용하기\n\n마지막으로 기억에 남는 부분은 let을 지양하고 즉시 실행 함수를 활용하는 부분이었다. 여러가지 조건에 맞게 다른 값을 반환해줘야할 때 단순히 let을 이용해 선언한 변수에 조건에 맞는 값을 대입해 마지막에 return하려 했다.\n\n```tsx\nconst BASE_POSTION = 16\nfunction getBottomPosition(\n  location: Location,\n  buttonHeight: number,\n  keyboardHeight: number\n) {\n  let position = BASE_POSTION\n  if (location === ScreenKeyEnum.SignUpSearchService && keyboardHeight > 0) {\n    position = keyboardHeight\n  }\n  if (location === ScreenKeyEnum.SignupGosu) {\n    position = buttonHeight\n  }\n  return position\n}\n```\n\nlet을 지양하고 내가 필요한 부분이 단 한번만 조건에 맞게 값을 받으면 되는 것이기 때문에 `즉시실행함수`를 사용할 수 있다. 리뷰를 통해 개선한 코드는 다음과 같다.\n\n```tsx\nconst bottomPosition = (() => {\n  const BASE_POSTION = 16\n  if (location === ScreenKeyEnum.SignUpSearchService && keyboardHeight > 0) {\n    return keyboardHeight\n  }\n  if (location === ScreenKeyEnum.SignupGosu) {\n    return buttonHeight\n  }\n  return BASE_POSTION\n})()\n\nreturn <View style={{ bottom: bottomPosition }}> ... </View>\n```\n\n즉시 실행함수를 사용함으로써 함수 내에서만 사용한 변수들이 선언되어 불필요한 전역변수를 줄일 수 있고, 실제 사용할 때도 함수로 사용하는 것이 아니라 값으로 사용할 수 있었다. IIFE는 클로저와 함께 사용될 수 있는 부분으로 함수형 프로그래밍에 대해 더 공부하면서 적용하면 좋을 것 같다고 생각되었다.\n\n### 😉 마치며\n\n이번 한달 동안 많은 내용을 배울 수 있었다. 아직 소화하지 못해서 적지 못한 내용 중에는 **명령형과 선언형으로 코드를 작성하는 방법의 차이**, class component에서 **set함수에 콜백함수를 전달하는 것을 대체하는 방법**이 있다. 이부분들에 대해서 4월 한달 동안 또 고민하면서 더 나은 코드를 작성하고, 내가 하는 리뷰가 우리 팀에 또 도움이 될 수 있게 역량을 키워나가야겠다.\n\n[참고]\n\n- [Jimmy Lee 블로그](https://medium.com/@jimmy_58380/%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EB%A7%A4%EC%A3%BC-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-%EA%B7%9C%EC%B9%99-%EC%A0%95%ED%95%98%EA%B8%B0-2fd03c65484)\n"},{"excerpt":"면접에서 디자인 패턴에 대해서 설명해 보라는 질문에 당황한 기억이 있다. 이후 디자인 패턴에 대해서 알아야겠다고 생각했고, 리액트 이전 글에서 MVC와 Flux패턴에 대해서 정리를 했지만, 아직 명확하지 않은 부분이 있었다. 그리고 기존에 개인 프로젝트와 다른 거대한 사이즈의 회사 프로젝트를 다루면서 Repository 패턴에 대해 새롭게 알게 되면서 이…","fields":{"slug":"/2023-03-05-디자인패턴/"},"frontmatter":{"date":"March 05, 2023","title":"MVC, MVVM, Flux패턴 그리고 Service와 Repository 패턴","tags":["디자인패턴"]},"rawMarkdownBody":"\n면접에서 디자인 패턴에 대해서 설명해 보라는 질문에 당황한 기억이 있다. 이후 디자인 패턴에 대해서 알아야겠다고 생각했고, 리액트 이전 글에서 MVC와 Flux패턴에 대해서 정리를 했지만, 아직 명확하지 않은 부분이 있었다. 그리고 기존에 개인 프로젝트와 다른 거대한 사이즈의 회사 프로젝트를 다루면서 Repository 패턴에 대해 새롭게 알게 되면서 이러한 아키텍처들에 대해 관심이 생기게 되었다. 아직 깊이 있게 이해하지 못하지만 각각에 대해서 작성하며 정리해보려 한다.\n\n## 🙄 아키텍처 패턴? 디자인 패턴?\n\n아키텍처 패턴과 디자인 패턴, 두 가지 용어 모두 패턴 (pattern)이란 단어가 들어있는 것을 통해, 반복되는 것을 정해둔 규칙 또는 방법을 떠올릴 수 있다. 두 가지에 대해서 모호함이 있는 것 같아 각각 용어에 대한 차이에 대해 먼저 알아보자.\n\n먼저 **아키텍처 패턴**이란 프로그램을 설계할 때 시스템의 구조를 어떻게 가져갈 지에 대한 청사진, 모범 예시로 설명할 수 있다. 각 시스템 별로 어떤 역할을 할 지를 정하고 시스템 간의 관계, 환경, 규칙 등이 포함되어 있다. **디자인 패턴**은 아키텍처 패턴보다는 좁은 개념으로 특정 유형의 문제를 해결하는 방법을 의미한다. 둘을 정리해보면 `아키텍처 패턴은 프로그램의 요약본, 청사진을 작성하는 것`이라고 한다면 `디자인 패턴은 아이디어를 어떻게 실행할 지 구체적인 방안`을 작성하는 것으로 볼 수 있다. 그렇기 때문에 디자인 패턴으로는 하나의 아키텍처에 여러 개의 디자인 패턴이 적용될 수 있고, 두 가지 프로젝트가 다른 디자인 패턴을 가지고 있지만 같은 아키텍처 패턴을 가질 수 있다.\n\n이러한 차이점에 대해서 알아보면서 내가 디자인 패턴으로 알고 있었던 MVC, MVP, MVVM 패턴은 엄격하게 말하면 디자인 패턴이 아니라 아키텍처 패턴에 해당되었고 디자인 패턴에는 Gang of Four로 불리는 패턴들이 존재한다는 것을 새롭게 알게 되었다.\n\n### 🔎 MVC 패턴\n\nMVC 패턴은 아키택처 패턴 중 하나로 시스템을 Model-View-Controller 세가지 역할로 구분한 개발 방법론을 의미한다. Model과 View의 결합도를 낮춤으로써 유지보수의 장점을 가지게 된다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbDpdks%2FbtrjV9EuRJ3%2FegwkkBELr5i0oYOv4t9Qy1%2Fimg.png\" width=\"300\"/>\n\n#### Model\n\n데이터와 데이터와 관련된 로직으로 웹에서 API로부터 받는 데이터, 서버에 있는 데이터 등을 포함할 수 있다. Model은 다른 컴포넌트들에 대해 알지 못하고 자기 자신의 일만 알고 있다.\n\n#### View\n\n프로그램의 UI 부분으로 웹에서 HTML, CSS 통해 만들어지는 화면을 의미한다. 모델이 처리한 데이터를 보여주기만 할 뿐 다른 컴포넌트에 대해서는 알지 못한다.\n\n#### Controller\n\nModel에게 데이터를 어떻게 처리할 지 알려 주거나, Model이 변경되면 결과를 다시 화면에 반영할 수 있게 View에 전달하는 Bridge 역할을 한다. 웹에서 데이터를 받아서 View에 나타내고, 화면의 이벤트가 발생하면 발생된 이벤트에 따라 Model을 변경하게 연결해주는 역할을 한다.\n\n프론트엔드가 발전하기 전의 MVC에서 각각에 대해 정의하면 데이터베이스를 **Model**, HTML, CSS, javascript로 만든 화면을 **View**, 라우터에 따라 데이터를 처리하고 페이지를 만들어주는 것을 **Controller**로 정의했다.\n\n이렇게 잘 나뉘어 있어서 백엔드에서 유용했던 MVC패턴은 웹이 발전함에 따라 문제점이 발생하게 된다.\n\n### 😎 프론트엔드에서 MVC의 문제점과 MVVM 패턴의 등장\n\n웹이 발전하면서 서버에서 HTML을 만들지 않게 되고, 이에 따라 MVC의 세가지 컴포넌트에 대한 적용이 달라지게 된다.\n\n서버에서 받아오는 데이터를 **Model**로 정의하고, 서버의 데이터에 따라 화면을 어떻게 바꿀지 View에서 발생한 이벤트에 따라 어떻게 데이터를 처리할 지를 **Controller**로 정의한다. 역할이 달라짐에 따라 View에 따라 Model을 바꿔야 하고 (이벤트), Model이 달라질 때 다시 View에 반영하기 위해 DOM을 업데이트 해야 하는 (서버의 데이터가 변경), View와 Model이 양방향 데이터 처리가 필요해지게 된다.\n\n![img](mvc.png)\n\n기존의 MVC 패턴을 사용해서 Model과 View의 양방향 데이터 바인딩의 문제를 해결하기 위해서는 Controller의 부담이 커지고 복잡해져 유지 보수가 어려워지게 된다.\n\n이러한 View와 Model의 양방향 데이터 처리를 해결하기 위해서 기존 서버에서 페이지를 만들 때처럼 `ejs`나 `pug`와 같이 필요한 부분에 데이터를 **템플릿에 선언적으로** 넣고 데이터가 바뀌면 바로 DOM에 반영할 수 없을까라는 고민이 시작된다. 이러한 고민들을 해결하기 위해 Angular, Vue, React와 같은 프레임워크, 라이브러리들이 나오게 된다.\n\n[React가 사용하는 단방향 데이터 바인딩, Angular가 사용하는 양방향 데이터 바인딩]\n\n![img](https://www.altexsoft.com/media/2018/10/One-and-two-way-data-bind.png)\n\n이러한 라이브러리와 프레임워크를 통해서 DOM을 직접 조작할 필요 없이 데이터의 변화를 감지해 DOM에 반영해주게 되고, View가 주축이 되어서 화면마다 필요한 **ViewModel**을 가져오는 MVVM 패턴이 나오게 된다. ViewModel은 기존의 Controller와 달리 **View에 대해서 알지 못하고**, **View에 필요한 데이터만** 다루기 때문에 ViewModel로 불리게 된다.\n\n[MVVM 아키텍처]\n\n![img](https://velog.velcdn.com/images/yunyezl/post/9abe5ca5-0655-45bd-87aa-ea2040b46033/image.png)\n\n```typescript\n// Model\nclass Contact {\n  name: string\n  email: string\n  phone: string\n}\n\n// ViewModel\nclass ContactListViewModel {\n  contacts: Contact[]\n\n  constructor() {\n    this.contacts = []\n  }\n\n  addContact(contact: Contact) {\n    this.contacts.push(contact)\n  }\n\n  removeContact(index: number) {\n    this.contacts.splice(index, 1)\n  }\n\n  editContact(index: number, contact: Contact) {\n    this.contacts[index] = contact\n  }\n}\n\n// View\nclass ContactListView {\n  viewModel: ContactListViewModel\n  contactListElement: HTMLElement\n\n  constructor(viewModel: ContactListViewModel) {\n    this.viewModel = viewModel\n    this.contactListElement = document.getElementById(\"contact-list\")\n  }\n\n  render() {\n    // clear existing contacts\n    this.contactListElement.innerHTML = \"\"\n\n    // render each contact\n    this.viewModel.contacts.forEach((contact, index) => {\n      const contactElement = document.createElement(\"div\")\n      contactElement.innerHTML = `\n        <div>Name: ${contact.name}</div>\n        <div>Email: ${contact.email}</div>\n        <div>Phone: ${contact.phone}</div>\n        <button class=\"delete-btn\" data-index=\"${index}\">Delete</button>\n        <button class=\"edit-btn\" data-index=\"${index}\">Edit</button>\n      `\n\n      const deleteButton = contactElement.querySelector(\".delete-btn\")\n      deleteButton.addEventListener(\"click\", () => {\n        this.viewModel.removeContact(index)\n        this.render()\n      })\n\n      const editButton = contactElement.querySelector(\".edit-btn\")\n      editButton.addEventListener(\"click\", () => {\n        // show edit form\n      })\n\n      this.contactListElement.appendChild(contactElement)\n    })\n  }\n\n  showEditForm(index: number) {\n    // render edit form\n  }\n}\n```\n\n위는 ChatGPT를 통해 작성한 간단한 MVVM 패턴을 이용해 만든 간단한 연락처 앱 코드 예제로 각각에 대해 살펴보자.\n\n##### Model\n\nModel의 데이터는 ViewModel과 View를 모르게 분리가 된 상태로 name, email, phone에 대한 정보를 가지고 있다.\n\n##### ViewModel\n\nViewModel은 Model에 대해 알고 있지만 Controller와 달리 View에 대해서 알지 못한다. 어플에 필요한 addContact, removeContact와 같은 메소드를 가지고 있다.\n\n##### View\n\nViewModel을 통해서 데이터를 전달 받아 DOM에 반영한다. event를 통해 변경된 데이터를 ViewModel의 메소드를 통해 Model로 전달하고, 변경된 결과를 다시 DOM에 반영한다.\n\n### 😎 단방향 데이터 바인딩과 Flux 패턴\n\n이렇게 복잡해져 가면서 기존 MVC 패턴에서 벗어나려는 움직임이 생기게 된다. 기존의 페이지 단위에서 컴포넌트 단위로 개발하려는 **Component 패턴**이 생기면서 컴포넌트 간의 데이터를 주고 받기에 어려운 **Props Driling** 문제가 생기게 된다. 각각의 컴포넌트가 다루는 데이터가 파편화 되면서 같은 레벨이지만 다른 부모 컴포넌트를 가질 경우 같은 데이터를 공유하기 어려운 문제가 생기게 된다.\n\n[ Props drilling 문제와 페이스북의 MVC 패턴 ]\n\n이러한 문제를 해결하기 위해 페이스북이 제시한 방법은 단방향 아키텍처인 **Flux 패턴**으로 Action, Dispatcher, Store, View로 구성된다.\n\n#### Action\n\nAction은 상태 변경 요청을 담은 객체로 Action의 이름(type)과 데이터(payload)를 담고 있다. Action creator함수로 같은 이름을 가지는 Action들을 편하게 추가할 수 있게 사용한다.\n\n#### Dispatcher\n\nDispatcher는 View로 부터 발생한 Action을 담아서 Store에 전달하는 역할로 Dispatcher 내부에는 상태 변경 로직을 가지고 있지 않다.\n\n#### Store\n\nStore는 전역 저장소로 Dispatcher에서 전달된 Action에 따라 상태를 변경하고 변경된 상태를 View에 반영한다. 여러 개의 Store가 존재할 수 있다.\n\n**View**\n\nView는 MVVM의 ViewModel과 같이 store로부터 변경된 데이터를 전달받아 새롭게 DOM을 렌더링하고 이벤트를 통해 Action을 발생시킨다.\n\n[Flux 패턴]\n\n![img](<https://velog.velcdn.com/images%2Fhuurray%2Fpost%2F258b2187-866f-4cf8-b207-1ffec24bf55e%2F%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%20(1).png>)\n\n이러한 Flux 패턴을 통해서 로직을 담당하는 부분과 View를 분리하면서 하나의 큰 View를 위한 **상태관리**라는 개념이 생기게 되고 Redux와 같은 라이브러리가 나와 현재도 많은 기업에서 사용되고 있다.\n\n### 📃 Service 패턴\n\nService 패턴은 이름은 몰랐지만 주로 사용했던 디자인 패턴 중 하나로 비즈니스 로직을 위한 독립적인 Layer를 만드는 패턴이다. UI와 Data Access 계층 사이에 정의해 둠으로써 해당 서비스와 관련된 비즈니스 로직을 여러 컴포넌트에서 재사용될 수 있게 하고 한 곳에 같은 수준의 로직을 모아둠으로써 유지 보수성을 향상 시킨다.\n\n```typescript\nimport { User } from \"./Authtypes\"\nimport { Jobs, Job } from \"./Jobtype\"\n\nexport interface DBService {\n  addOrUpdateJob: (job: Job, user?: User) => Promise<void>\n  getJobs: (user?: User) => Promise<Jobs>\n  removeJob: (job: Job, user?: User) => Promise<void>\n}\n\nexport class DBServiceImpl implements DBService {\n  db: Database\n  constructor(private app: FirebaseApp) {\n    this.db = getDatabase(this.app)\n  }\n\n  async getJobs(user?: User): Promise<Jobs> {\n    const dbRef = ref(this.db)\n    const query = user ? `users/${user?.id}/` : \"\"\n    return get(child(dbRef, `${query}jobs`))\n      .then(snapshot => {\n        if (snapshot.exists()) {\n          return snapshot.val()\n        } else {\n          return {}\n        }\n      })\n      .catch(error => {\n        console.error(error)\n      })\n  }\n\n  async addOrUpdateJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : \"\"\n    return set(ref(this.db, `${query}jobs/${job.id}`), job)\n  }\n\n  async removeJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : \"\"\n    return remove(ref(this.db, `${query}jobs/${job.id}`))\n  }\n}\n```\n\n위 코드는 모으잡 프로젝트을 하면서 내가 작성한 DBService 코드로 firebase를 이용해 데이터를 저장하고 수정하고 삭제하는 일을 위해 Service 층을 만들었다. 한곳에 데이터 조회, 삭제, 수정에 대한 모든 메소드를 한 곳에 정의해둠으로써 유지보수의 장점과, 코드 중복을 막을 수 있는 장점이 있다.\n\n코드를 보면 구체적으로 Firebase에 접근하는 코드가 강하게 결합되어 있기 때문에, Mocking이나 Test의 어려움이 있다. 이러한 문제를 해결하기 위한 방법이 다음 패턴인 **Repository 패턴**을 이용할 수 있다.\n\n### 🎈 Repository 패턴\n\nRepository 패턴은 데이터베이스나 API와 어플리케이션 사이에 Layer를 두는 패턴으로 Data Access Layer를 추상화함으로써 구체적으로 어떤 저장소인지, 어떤 API를 사용하는 지를 몰라도 정상 동작할 수 있게 한다. Repository 패턴의 장점은 Interface를 만족한다면 Mocking 데이터를 만들어서 적용할 수 있고 테스트를 하는데 장점을 가진다.\n\n<img src=\"https://lyz-code.github.io/blue-book/img/ddd_repository_pattern.png\" width=\"500\"/>\n\n```typescript\nexport interface JobRepository {\n  getAllJobs: (user?: User) => Promise<Jobs>\n  saveJob: (job: Job, user?: User) => Promise<void>\n  deleteJob: (job: Job, user?: User) => Promise<void>\n}\n\nexport class JobRepositoryImpl implements JobRepository {\n  db: Database\n  constructor(private app: FirebaseApp) {\n    this.db = getDatabase(this.app)\n  }\n\n  async getAllJobs(user?: User): Promise<Jobs> {\n    const dbRef = ref(this.db)\n    const query = user ? `users/${user?.id}/` : \"\"\n    return get(child(dbRef, `${query}jobs`))\n      .then(snapshot => {\n        if (snapshot.exists()) {\n          return snapshot.val()\n        } else {\n          return {}\n        }\n      })\n      .catch(error => {\n        console.error(error)\n      })\n  }\n\n  async saveJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : \"\"\n    return set(ref(this.db, `${query}jobs/${job.id}`), job)\n  }\n\n  async deleteJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : \"\"\n    return remove(ref(this.db, `${query}jobs/${job.id}`))\n  }\n}\n\n//DBService\n\nexport interface DBService {\n  addOrUpdateJob: (job: Job, user?: User) => Promise<void>\n  getJobs: (user?: User) => Promise<Jobs>\n  removeJob: (job: Job, user?: User) => Promise<void>\n}\n\nexport class DBServiceImpl implements DBService {\n  constructor(private repository: JobRepository) {}\n  async getJobs(user?: User): Promise<Jobs> {\n    return await repository.getAllJobs(user)\n  }\n\n  async addOrUpdateJob(job: Job, user?: User) {\n    await repository.saveJob(job, user)\n  }\n\n  async removeJob(job: Job, user?: User) {\n    await repository.deleteJob(job, user)\n  }\n}\n```\n\nService 패턴의 코드에 Repository 패턴을 적용한 코드로 DBService는 더 이상 Firebase 데이터 저장소에 대해 알지 못하게 된다. 이렇게 나눈 덕분에 Firebase 저장소뿐 아니라 다른 저장소를 이용해서 데이터를 전달이 가능하게 되었다.\n\n### 마치며\n\n회사 생활을 하면서 큰 프로젝트의 코드 베이스들에 대해서 공부해 가면서 새롭게 알게된 내용이 참 많다. 그중 가장 많이 느꼈던 아키텍처 부분에 대해 정리하고 싶어 한번 정리해보았다. 공부하면서 아키텍처의 중요성과 어떤 문제를 해결하기 위해 만들어 진 것인지 이해할 수 있었고, 기존 내 코드에 새로운 패턴을 적용해보는 경험이 너무 즐거웠다.\n\n[참조]\n\n- [김주엽님의 SW 아키텍처와 디자인 패턴의 차이](https://juyeop.tistory.com/28)\n- [엔디엘님의 아키텍처 패턴과 디자인 패턴의 차이점](https://dongmindevloper.tistory.com/46)\n- [Architectural Pattern vs Design Pattern](https://www.linkedin.com/pulse/architectural-pattern-vs-design-praveen-kumar-kushwaha/)\n- [테오님의 프론트엔드에서 MV\\* 아키텍쳐란 무엇인가요? ](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)\n- [Tecoble의 웹 MVC 각 컴포넌트 역할](https://tecoble.techcourse.co.kr/post/2021-04-26-mvc/)\n- [yunyezl님의 MVVM-패턴-이해해보기](https://velog.io/@yunyezl/MVVM-%ED%8C%A8%ED%84%B4-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EA%B8%B0#%EC%A0%95%EB%A6%AC)\n"},{"excerpt":"🙄 CDN이란 CDN은 Contents Delivery Network의 약자로 웹페이지, 사진, 데이터를 사용자에게 전달하는 것을 의미한다. 그렇다면 기존 서버가 있는데 왜 CDN이 필요할까? CDN의 필요성 클라이언트가 특정 페이지나 API를 요청하면 서버는 받은 요청에 알맞은 응답을 보내주는 것이 기본적인 네트워크 흐름이다. 결국은 하나의 요청당 하나…","fields":{"slug":"/2023-03-01-CDN/"},"frontmatter":{"date":"March 01, 2023","title":"CDN은 뭘까?","tags":["web","네트워크"]},"rawMarkdownBody":"\n## 🙄 CDN이란\n\nCDN은 Contents Delivery Network의 약자로 웹페이지, 사진, 데이터를 사용자에게 전달하는 것을 의미한다. 그렇다면 기존 서버가 있는데 왜 CDN이 필요할까?\n\n### CDN의 필요성\n\n클라이언트가 특정 페이지나 API를 요청하면 서버는 받은 요청에 알맞은 응답을 보내주는 것이 기본적인 네트워크 흐름이다. 결국은 하나의 요청당 하나의 응답을 받게 되는데, 만약 서비스가 엄청나게 커졌다고 가정하면, 전세계 수천만명이 동시에 요청을 하는 경우에 서버는 수천만개의 요청에 따라 응답을 해줘야하는 상황이 된다. 이렇게 될 경우 서버의 입장과 클라이언트 입장에 따라 각각의 문제가 존재하게 된다.\n\n먼저 클라이언트 입장에서 **물리적 거리**에 따른 응답속도가 느리게 된다. 요즘 네트워크가 얼마나 빠른데 물리적 거리가 중요하냐고 할 수도 있지만, 당장 외국 사이트에 접속시에 느리게 화면이 뜨고, 사진이 뜨지 않는 문제를 볼 수 있다. 네트워크 송수신 과정을 거칠 때 우리나라와 같이 네트워크 속도가 빠르다면 문제가 없지만, 우리가 접속하는 모든 사이트 지역이 빠르게 처리할 수 있는 것이 아니기 때문에, 응답속도의 문제가 생길 수 있다. 말하자면 항상 부산에 있는 본점에서 서울로 배달을 시킬 때 생길 수 있는 배달 문제와 같다.\n\n두번째로 서버의 입장에서 보면 정말 많은 요청을 받아서 처리한다고 했을 때, 당연 서버 자체의 부담이 늘어나게 된다. 하나의 요리사가 요리하는 것보다 여러 요리사를 고용해 한꺼번에 많은 주문을 처리할 수 있게 하는 것이 훨씬 효율적이고 혼자서 모든 주문을 다 처리하던 기존 요리사의 부담을 줄여줄 수 있다. 기존 서버를 본점, CDN을 체인점으로 생각해, 본점의 요리사 수를 적게 (대역폭을 적게) 유지할 수 있어 비용을 줄일 수 있는 장점을 가진다.\n\n이러한 두가지 측면의 고민을 한번에 해결할 수 있는 방법이 **CDN**이다. 클라이언트 입장에서는 실제 위치한 서버까지 요청을 전달하지 않고, 현재 위치한 지역의 CDN을 이용해 빠르게 필요한 컨텐츠를 받아올 수 있고, 서버 입장에서는 지역마다 서버를 둠으로써 컨텐츠 요청에 대한 응답을 하지 않아도 되니까 부담이 줄게 된다. 이렇게 지역마다 둔 서버를 **Edge**라고 부르는데, 모든 서버의 기능을 다 처리하는 것이 아니라 웹페이지, 이미지, 동영상과 같은 컨텐츠에 대해 캐싱하고 있다.\n\n[Cloudflare의 CDN 사진]\n\n![cloudflare](cloudfrare.png)\n\n그렇다면 클라이언트는 분명 **같은 도메인 주소로 요청을 보내게 될텐데**, 어떤 것은 직접 서버에 요청이 가야하고, 어떤 것은 CDN에서 처리할 수 있을텐데 이러한 요청에 대한 분리는 어떻게 처리되어져 있는걸까?\n\n### 다시 나오는 DNS와 발전된 GSLB\n\n클라이언트가 요청을 보내고 요청에 알맞은 응답을 받기 위해서는 해당 서버의 IP주소를 가져와야한다. 우리가 알고있는 도메인 주소를 IP주소로 매핑해주는 것을 DNS (Domain Namve System)가 담당해주는 것을 [저번 글](https://choi2021.github.io/web/google.com-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B8%B0/)을 작성하며 알 수 있었다. 여기서 CDN이 추가되면서 단순히 도메인의 서버의 IP주소를 찾는게 아니라 해당 요청이 캐싱되어 있는 콘텐츠일 경우나 지역별로 가까운 CDN에 요청할 수 있게 연결하는 일이 필요하게 되었다.\n\nDNS를 기반으로 이런 복잡한 일을 해주는 것이 바로 **GSLB** **(Global Server Load Banlancing)** 이다. GSLB는 요청하는 사용자의 위치에 따라 `알맞은 서버`를 찾아서 연결해주는데, 이때 알맞은 서버는 GSLB의 Load Balancing이란 단어가 담겨있듯, 현재 위치와 가까운 거리의 서버만을 고려하는 것이 아니라 해당 서버에 현재 사용자가 몰릴 경우 등의 서버의 상태를 고려해서 적절한 서버로 연결해준다.\n\n이렇게 서버 상태까지 고려하기 때문에 DDoS와 같은 공격으로 갑자기 많은 요청이 몰려와 해당 서버를 사용할 수 없게 되는 경우에, CDN으로 연결해두었다면 그 지역의 CDN만 공격당하고, 이후 같은 지역의 요청은 다른 서버로 자동으로 요청하게 연결해줘서 서비스 자체의 장애 대응에도 강점을 가질 수 있다.\n\n![gslb](gslb.png)\n그러면 이러한 CDN에 저장할 데이터는 어떤 시점에 가져와야 할까? 또 얼마나 보관해야 할까?\n\n### 캐싱과 TTL\n\n데이터를 얼마나 오래 존재하도록 할지에 대한 용어는 TTL (Time To Live)로 서버에 캐싱할 데이터의 유효시간을 정하는 것으로 마치 React-query에서 cache-Time을 정하고, 시간이 지나면 새롭게 요청을 보내서 데이터를 가져오는 것과 같다. 이러한 TTL설정은 브라우저에서 할 경우에는 HTTP헤더의 `Cache-Control`부분을 통해 지정해줄 수 있고, CDN을 이용한다면 해당 업체에서 알맞은 TTL을 자동화해주거나 각각 캐싱된 데이터에 알맞게 설정이 가능하다.\n\n![캐싱](fresh.jpeg)\n\n### 마치며\n\n간단하게 CDN이 어떤 문제를 해결하기 위한 기술인지, 어떻게 CDN이 동작할 수 있는지 간단하게 정리해봤다. 정리하면서 Edge 컴퓨팅에 대해서 웹개발에서 많은 관심을 가지고, CDN 서버에서 페이지를 만들 수 있게 하려는 노력이 발전되고 있는 것을 새롭게 알 수 있었다. 그래서 조금씩 Edge 컴퓨팅에 대해서도 공부하면서 해당 내용을 추가적으로 작성해 글을 업데이트하면 좋을 것 같다.\n\n[참고 자료]\n\n- Cloudfare의 CDN 소개: https://www.cloudflare.com/ko-kr/learning/cdn/what-is-a-cdn/\n- 웹서비스의 필수! CDN이 뭔가요? (얄팍한 코딩사전): https://www.youtube.com/watch?v=_kcoeK0ITkQ\n\n- Time To Live (TTL) (imperva): https://www.imperva.com/learn/performance/time-to-live-ttl/\n"},{"excerpt":"😁 Google.com 또는 naver.com을 브라우저에 검색했을 때 일어나는 일 면접 단골 질문 중 하나인 Google.com 또는 naver.com을 브라우저에 검색했을 때 일어나는 일은 우리가 서버에 요청을 보내고 응답을 단순히 받는 데에서 그치는 것이 아니라 그 사이에 숨어있는 네트워크 통신과 관련된 과정을 물어보는 질문이다. 면접 과정에서 한번…","fields":{"slug":"/2023-02-21-google.com-입력했을때-일어나는-일/"},"frontmatter":{"date":"February 21, 2023","title":"google.com를 브라우저에 검색했을 때 일어나는 일","tags":["네트워크","인터뷰"]},"rawMarkdownBody":"\n## 😁 Google.com 또는 naver.com을 브라우저에 검색했을 때 일어나는 일\n\n면접 단골 질문 중 하나인 **Google.com 또는 naver.com을 브라우저에 검색했을 때 일어나는 일**은 우리가 서버에 요청을 보내고 응답을 단순히 받는 데에서 그치는 것이 아니라 그 사이에 숨어있는 네트워크 통신과 관련된 과정을 물어보는 질문이다. 면접 과정에서 한번도 질문을 받아본 적은 없지만, 네트워크에 대해서 이해할 필요가 있을 것 같아 각 과정에 대해서 이해한 만큼 정리해보려 한다.\n\n### 🙄용어 정리\n\n하나의 질문이지만 관련된 내용에는 다양한 네트워크 관련 지식들이 연관되어 있기 때문에 먼저 용어를 정리해보려 한다.\n\n- Protocol: 정보를 주고 받는데 필요한 형식, 대표적으로 HTTP, SSH와 같은 프로토콜이 있다.\n- 패킷: 네트워크를 통해 데이터를 주고 받기 위해 형식에 맞게 쪼개진 데이터 조각\n- TCP/IP: 컴퓨터들이 네트워크로 정보를 주고 받는데 필요한 프로토콜의 집합\n- TCP (Transmission Contorl Protocol): 연결 지향 방식으로 신뢰성 보장이 필요한 데이터를 주고 받기 위한 프로토콜\n- IP (Internet Protocol): 네트워크에서 정보의 송수신에 대한 프로토콜\n- DNS (Domain Name System): 도메인과 관련된 시스템, google.com을 해당 서버의 IP주소로 mapping하기 위한 시스템\n- ARP (Address Resolution Protocol): IP주소를 물리적 네트워크 주소(MAC 주소)로 매칭하기 위한 프로토콜\n- MAC 주소: 우리가 사용하는 기기의 고유한 네트워크 주소, 물리적 주소를 의미한다.\n\n그러면 위의 용어들을 네트워크 통신 과정을 따라가며 더 자세히 알아보자.\n\n### 🎈TCP/IP 4계층\n\n우리가 보내는 요청과 서버의 응답을 받는 데에는 TCP/IP라는 **여러 개의 프로토콜에 각각의 형식에 맞는 데이터**들을 담아 주고 받게 된다. TCP/IP는 4개의 층/ 프로토콜로 구성되는데 각각에 대해 먼저 정리해보자.\n\n#### Application Layer\n\n어플리케이션끼리 주고 받을 데이터를 담는 계층으로, HTTP 프로토콜과 메일을 보낼 수 있는 SMTP 프로토콜 등이 사용된다.\n\n#### Transport Layer\n\n데이터를 보내는 송신 호스트와 데이터를 수신하는 수신 호스트 사이에 데이터가 신뢰성 있게 전달될 수 있게 하는 계층으로 포트 번호를 이용하고 TCP, UDP와 같은 프로토콜이 사용된다.\n\nTransport Layer에서 송신자 입장과 수신자의 입장에서 Transport Layer의 처리가 다르게 되는데 각각에 대해 정리하면 다음과 같다.\n\n- 송신자는 Application layer에서 전달 받은 메세지를 segment로 쪼개고, segment의 헤더에 출발지와 도착지의 포트 번호를 추가한 후 전송한다.\n\n- 수신자는 segment로 나뉜 데이터를 다시 합친 후에 header를 읽고 포트 번호를 확인해 application layer로 메세지를 전달한다.\n\n#### Internet Layer\n\n송신한 데이터를 수신할 호스트까지 전달하기 위해 사용되는 계층으로 IP 프로토콜과 ARP 프로토콜을 이용해 데이터를 전달한다.\n\n#### Network Access Layer\n\n네트워크에 직접 연결된 기기 간 전송을 할 수 있게 하는 계층으로, Ethernet 프로토콜이 이용된다.\n\n![network access](network.gif)\n\n이제 실제 브라우저에 주소를 입력했을 때 과정을 쫓아 가보자\n\n### 📡 TCP/IP의 흐름\n\n먼저 `http://www.google.com`을 브라우저에 입력하는 것은 우리가 해당 주소의 구글 서버의 80포트에 HTTP Request를 보내는 것이다. 이러한 요청을 처리하기 위해서는 우리의 데이터가 패킷에 담겨져야 하는데 이때 TCP/IP 4 계층에 맞게 데이터를 담아서 보내게 된다. 간략하게 정리하면 다음과 같다.\n\n- Application Layer: 우리가 요청할 HTTP Request 내용을 담는다.\n- Transport Layer: 내 컴퓨터의 포트 번호와 구글 서버의 80 포트 번호를 담는다. (TCP이기 때문에 더 많은 내용이 담긴다)\n- Internet Layer: 내 컴퓨터의 IP주소와 구글 서버의 IP주소를 담는다.\n- Network Access Layer: 내 컴퓨터의 MAC주소와 구글 서버의 MAC주소로 물리적 연결을 위한 정보를 담는다.\n\n여기서 중요한 점은 Internet Layer와 Network Access Layer에서 **구글 서버의 IP주소**와 **구글 서버의 MAC주소**를 알아내야 한다는 점이다. 여기서 필요한 것이 바로 **DNS**와 **ARP 프로토콜**이다. 각각에 대해서 조금 더 알아보자.\n\n#### 👉 DNS (Domain Name System)\n\nDNS는 우리가 입력한 domain주소를 이용해서 해당 서버의 IP주소를 알아내는 방법이다. 그래서 DNS는 흔히 **전화번호 북**에 많이 비유되는데 예를 들어 \"청룡반점\"이라는 중국집에 짜장면을 주문하고 싶다면 \"청룡반점\"만 알아서는 전화(네트워크 연결)를 할 수가 없기 때문에 청룡반점의 **전화번호**를 알아야 하고 이러한 전화번호가 기록되어있는 전화번호부를 이용해서 전화번호를 찾을 수 있다.\n\n![dns](dns.jpeg)\n\n위 예제에서 청룡반점을 구글 서버로, 짜장면 주문을 요청, 청룡반점이란 가게 이름을 도메인, 전화번호를 IP주소, 전화번호부를 DNS로 각각 매칭 시킬 수 있다. 이렇게 도메인을 사용하는 이유는 숫자로만 이루어진 IP 주소를 직접 입력해도 되지만, IP 주소가 바뀌는 경우가 생기고 (AWS 인스턴스를 탄력적 IP를 사용하지 않았을 때 매번 달라지는 IP주소와 도메인 주소) 숫자보다 google.come이 훨씬 기억하기 쉽기 때문이다.\n\n그러면 이제 DNS를 이용해서 도메인을 IP로 바꾸는 과정에 대해 알아보자.\n\n1. DNS를 찾는 과정에서 가장 먼저 확인하는 곳은 `로컬 DNS 서버 `로 로컬 DNS 서버에 캐싱된 정보를 확인한다. 이때 정보가 없다면 `Root DNS 서버`에 요청을 보낸다.\n\n2. Root DNS 서버는 전달받은 도메인 정보 중에서 가장 마지막 부분인 `.com`에 해당하는 DNS 서버의 IP주소를 로컬 DNS서버에 반환한다.\n3. 로컬 DNS 서버는 전달받은 IP주소로 `.com DNS 서버`에 요청을 보내면 `google.com`의 DNS 서버의 IP주소를 반환한다.\n4. 로컬 DNS 서버는 전달받은 `google.com DNS 서버`에 요청을 보내면 `google.com DNS 서버`가 가진 여러 개의 호스트 네임별 IP주소 중에서 `www.`에 해당하는 IP 주소를 반환한다.\n5. 마지막으로 전달받은 IP 주소를 로컬 DNS 서버가 브라우저에 전달한다.\n\n위와 같은 방법을 통해서 IP주소를 알아내 Internet Layer에 요청을 받을 `www.google.com`의 IP주소를 담는다.\n\n[AWS의 DNS 이미지]\n\n![aws dns](dns2.png)\n\n#### 🙂 ARP (Address Resolution Protocol)\n\nARP는 DNS를 이용해 찾아낸 IP주소를 물리적인 기기의 MAC 주소로 바꾸는 프로토콜로, 호스트, 라우팅을 해주는 장비가 가지는 논리적 주소인 IP 주소와 하드웨어, 기기별로 할당된 고유한 MAC주소를 Mapping하는 방법이다.\n\n이때 들 수 있는 의문은 **왜 IP주소를 아는데 MAC 주소까지 필요로 할까**이다. 이점을 이해할 때 중요한 것은 우리가 찾아낸 구글의 IP 주소가 구글 서버 기기가 사용하는 `Private IP`가 아니라 공유기와 같은 네트워크 주소에서 사용되는 `Public IP`였다는 점이다.\n\n예를 들어 택배를 받는데 주소까지 입력해서 우리집 건물 주소까지는 입력했지만 상세주소로 몇 호인지를 적지 않아 택배를 받을 수 없는 상황이 되는 것이다.\n\nTCP/IP 4 계층의 기준으로 보면 IP주소와 MAC 주소에 대한 정보를 **입력해야 하는 계층이 다르기 때문에** 필요하다고 할 수 있다.\n\n이렇게 각각의 IP주소와 MAC주소를 알아와 TCP/IP 계층 별 필요한 정보를 채웠으니 이제 요청을 보낼 수 있겠다라고 생각했지만, 여기서 끝나는 것이 아니라 TCP의 handShaking 과정이 필요하다.\n\n#### ✨ TCP의 3-way Handshaking과 4-way Handshaking\n\nTCP에 대해 설명하면서 데이터가 신뢰성 있게 전달될 수 있게 한다라고 설명했는데, 이러한 신뢰성을 보장할 수 있는 것은 바로 이러한 Hand-shaking과정 덕분이다. 정확하게 데이터를 전송하기 위해서 client와 server 간의 데이터 전송이 가능한 상태인지 확인이 필요하다. 이러한 과정을 `3-way Handshaking`이라고 한다. 이러한 handshaking 과정을 위해 Transport Layer에 포트정보 뿐 아니라 flag정보들을 패킷에 담아 주고 받는다. 3-way Handshaking 과정은 다음과 같다.\n\n- client에서 SYN flag를 담은 패킷을 server로 보낸다.\n- server 는 전달 받은 SYN 패킷을 받고 요청을 수락하는 ACK과 SYN flag를 담은 패킷을 client에 보낸다.\n- client는 SYN과 ACK flag를 담은 패킷을 받고 다시 ACK flag를 담은 패킷을 보낸 후에 서로 데이터를 주고 받는다.\n\n![tcp](tcp.png)\n\n데이터 전송이 끝날 때에도 handShaking이 필요한데 이때 사용되는 것을 `4-way Handshaking`이라 한다. 4-way Handshaking 과정은 다음과 같다.\n\n- client에서 FIN flag를 담은 패킷을 보낸다.\n- server는 ACK flag를 담은 패킷을 보내고 Client는 server의 Fin flag를 받고도 늦게 오는 패킷을 기다리는데 이때를 `TIME_WAIT`상태라 한다.\n- server에서 통신이 끝난 후에 FIN flag를 담은 패킷을 client에 보낸다.\n- client는 ACK flag를 담은 패킷을 보내면 연결이 종료된다.\n\n![tcp](tcp2.png)\n\n### 마치며\n\n네트워크 단에서 이렇게 복잡한 과정들을 통해서 이루어지고 있다는 것을 처음 알게 되었다. 사실 정리하지 못한 깊은 내용이 엄청 많지만 우선은 현재 이해한 만큼만 이라도 정리하고 싶어 작성하게 되었다. 브라우저에 전달 받은 HTML 페이지가 렌더링 되는 과정에 대해서는 이미 다른 글에서 다루었기 때문에 생략했다. 이 글도 공부해서 더 알게 되는 만큼 계속해서 수정하고 업데이트 해나가야 할 것 같다.\n\n[참조]\n\n- [수리의 TCP/IP (우아한 테코톡)](https://www.youtube.com/watch?v=BEK354TRgZ8&t=85s)\n\n- [DNS가 뭔가요? + 도메인, A Record, CName (얄코)](https://www.youtube.com/watch?v=6fc9NAQkcv0)\n\n- [Transport Layer responsibilities](https://www.geeksforgeeks.org/transport-layer-responsibilities/)\n\n- [DNS란 무엇입니까? (AWS)](https://aws.amazon.com/ko/route53/what-is-dns/)\n\n- [서브웨이의 ARP (우아한 테크톡)](https://www.youtube.com/watch?v=KMEPEdsK71I)\n\n- [ 네트워크 쉽게 이해하기 22편- TCP 3 Way-Handshake & 4 Way-Handshake (Mind Net)](https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake)\n"},{"excerpt":"개발자가 되기로 마음먹은 2021년 5월부터 HTML, CSS를 시작해 2023년 2월까지 프론트엔드 개발자가 되기 위해 약 1년 반 가량 준비 끝에 드디어 내 자신을 개발자라고 소개할 수 있게 되었다. 1년 반 동안 정말 많은 일이 함께 했다. 22년 2월 대학을 졸업하고, 서울로 올라올 것을 준비해 6개월 간 학원에서 풀타임 강사로 돈을 벌고, 지금까…","fields":{"slug":"/2023-02-17-취업준비-회고/"},"frontmatter":{"date":"February 17, 2023","title":"신입으로 시작하며 작성하는 취준 회고","tags":["회고","취업준비"]},"rawMarkdownBody":"\n개발자가 되기로 마음먹은 2021년 5월부터 HTML, CSS를 시작해 2023년 2월까지 프론트엔드 개발자가 되기 위해 약 1년 반 가량 준비 끝에 드디어 내 자신을 **개발자**라고 소개할 수 있게 되었다. 1년 반 동안 정말 많은 일이 함께 했다. 22년 2월 대학을 졸업하고, 서울로 올라올 것을 준비해 6개월 간 학원에서 풀타임 강사로 돈을 벌고, 지금까지 계속 공부했던 시간들에 대해 드디어 보상을 받는 기분을 누리고 있다.\n\n처음 개발자로 취업을 준비하면서 이력서와 자기 소개서를 작성하며, 면접을 보고, 합격 전화를 받기까지 과정을 기록해두고, 언젠가 또 다시 갖게 될 이 기간에 시행착오 없이 보낼 수 있기를, 또 내가 많은 분들의 도움을 받았듯 누군가에게 내 글이 도움과 힘이 되기를 바라며 취준 회고를 작성해보려 한다.\n\n### 😅 겁 없이 지원하는 신입의 패기...\n\n원티드 프리온보딩 코스를 끝낸 11월 말에 이력서를 작성하고, 12월 2일부터 원티드 프리온보딩 코스에 취업설명회를 했던 회사들부터 지원하기 시작했다. 12월 2일부터 1월 30일까지 원티드는 137개 회사, 점핏은 22개 회사, 프로그래머스와 자체 채용 플랫폼에 지원한 회사는 적어도 10개 정도라 생각되어 **약 170개** 정도의 회사를 한 달 반 동안 지원했다. (우리나라에 이렇게 스타트업이 많습니다... 😂)\n\n![원티드 지원 현황](원티드지원현황.png)\n\n![점핏 지원현황](점핏지원현황.png)\n\n우선 내가 지원하는 회사들은 대기업보다는 **스타트업**이었다. 그러다 보니 스타트업씬에 대해 이해가 필요했고 **유튜브 EO채널**과 같은 스타트업 전문 소개 채널과, **Plantum, 아웃스탠딩**과 같은 스타트업 전문 저널의 기사를 보며 어떤 스타트 업들이 있는지 조사하고, 투자를 받은 금액에 따라 나뉘는 시리즈, 회사 규모에 대해서도 이해할 수 있었다.\n\n![스타트업](https://otrade.co/img/openinsight/view/079/f044f1b6b0a47.png)\n\n스타트업 씬의 흐름을 이해하자 회사의 규모에 따라 달라지는 개발자 채용 과정에 대해서도 이해할 수 있었다. 대체로 규모가 작은 회사일 경우 바로 면접을 보는 곳도 있었고, 규모가 시리즈 B이상의 회사들은 코테나 과제를 주어 일차적으로 거르는 듯 했다. 또, 지방러인 나에게 시리즈 후반의 회사일수록 강남에 위치하는 것도 새롭게 알 수 있었다. (서울 아직 어려워..)\n\n하지만 이러한 규모 자체가 나에게 큰 기준이 되지는 않았다. 나에게 가장 중요했던 회사를 지원하는 기준은 회사가 **어떤 문제를 풀려고 하느냐, 또 어떤 서비스를 만들고 있느냐**였기 때문에 회사 서비스가 맘에 들면 무조건 지원했다. 스타트업은 신입을 잘 뽑지 않는다는 말도, 채용 시장이 얼어붙어 사람을 잘 뽑지 않는다는 말도 많이 들었지만 `내가 가능성이 보이면 무조건 나를 뽑을 것이다`는 마음으로 마음에 드는 회사들에 겁 없이 `인턴, 신입, 1년~ 3년 주니어`까지 모두 지원했다.\n\n이렇게 공격적으로 지원한 결과를 정리해보면 **서류 합격 총 17개**, **과제 4번과 코딩테스트 5번**을 봤고, **7개의 회사의 기술 면접**을 봤다. 기술 면접까지 통과해 **최종 면접에 간 회사는 5개의 회사** 그중에서도 감사하게 **4개의 회사의 최종 오퍼**를 받았다.\n\n최종 오퍼를 받은 곳들 중 한 개의 회사는 프론트엔드 인턴, 다른 하나는 프론트엔드 개발자로 지원했지만 프론트엔드는 부족해 보이지만 신입으로써 좋게봐주셔서 AI/ML 인턴을 제안해 주셨다. 두 개의 회사는 시리즈 B 회사의 1년차 React Native 개발자 포지션과 시리즈 C회사의 3년차 프론트엔드 개발자 포지션의 오퍼를 받았다.\n\n어쩌면 무모하게, 또는 찌라시(?)처럼 이력서를 지원하다 보니 초반에 지원했던 가고 싶었던 회사들을 놓친 게 후회가 되었다. \"좀 더 준비되었을 때 지원하면 좋았을텐데\" 라고 후회되는 회사들도 있었지만, 이런 공격적으로 이력서를 넣은 덕분일까 이제는 진짜 넣을 회사가 없어 쫄릴 때 즈음에 (진짜 무서웠다...😓) 드디어 합격 소식이 하나 둘 씩 들려왔고, 원하던 회사에 합격해 현재 열심히 온보딩을 하고 있다.\n\n### 😁 어딜 봐야 좋은 회사가 있을까?\n\n취업을 준비하면서 가장 먼저 들었던 조언중 하나가 **내가 관심있는 채용공고들을 보고 어필해야할 포인트를 찾아라**였다. **그럼 그 채용공고들은 어디서 봐야 할까**에 대해 알기 위해 채용 플랫폼들을 조사했다. 내가 가장 많이 지원한 원티드와 점핏과 더불어 생각보다 많은 HR 플랫폼들이 있었다. 각각에 대해 경험을 토대로 정리해보았다.\n\n#### 1. 원티드\n\n![원티드](https://contents.nextunicorn.kr/company/aaa8e834cda25835/rep-ccc417a56ad87e6e0f398d1fd24d30382518.jpeg?s=640x&t=cover&f=jpg)\n\n원티드는 스타트업에서 일하고 싶은 나에게 가장 최적의 HR 플랫폼이었다. 원티드 프리온보딩 코스에 참여했기 때문도 있지만 내가 느낀 장점들로 정리해보면 다음과 같다\n\n- **다양하고 많은 스타트업의 채용공고**\n\n130개가 넘는 회사에 지원한 만큼 프론트엔드 직무만 해도 엄청나게 많은 회사들의 채용공고들을 볼 수 있었고, 스타트업을 목표로 한 나에게 너무 좋은 HR플랫폼이었고, 개별 회사들에 대한 투자 규모, 연봉 정보도 알 수 있었다.\n\n- **기본적인 UI와 사용자를 배려하는 UX**\n\nUI가 기본적으로 잘 정리되어 있고, 각종 이력서, 자소서, 면접 관련 컨텐츠 아티클과 이벤트도 많아 좋은 정보를 얻을 수 있었다. 원티드 자체 이력서 형식만 지원하는 것이 아니라 PDF형식으로 노션 이력서, 자기소개서, 포트폴리오를 올릴 수 있어서 가장 많이 활용했다. 그리고 사용자로써 느낀 가장 큰 장점은 **채용 담당자가 이력서를 열람했는지**를 확인할 수 있어서 과정이 어떻게 진행되고 있는지 알 수 있었다. ( 덕분에 5분마다 계속 확인하게 되는 건 함정... 🤣)\n\n추가로 단점은 아니지만 AI로 이력서를 평가해 합격률을 봐주고 회사들을 추천해 주는데 크게 도움을 받지 못했다.\n\n#### 2. 프로그래머스\n\n![프로그래머스](progammers.jpeg)\n\n프로그래머스는 코딩 테스트와 과제 연습 콘텐츠와 함께 다양한 채용공고들이 올라오기 때문에 많이 지원을 해보려 했다.\n\n- 코딩 테스트와 과제 테스트를 이용한 데브 매칭\n\n아쉽게 내가 지원하는 시기 막바지에 열리게 되어서 참여하지 못했지만 실력 적으로 자신 있고 프로그래머스 자체적으로 제공하는 문제들을 통해 준비한다면 너무 좋은 기회가 되겠다는 생각이 들었다.\n\n- 깃허브와 연동가능한 이력서\n\n이력서에 깃허브 계정과 연동해 내가 한 프로젝트의 기여도와 코드들에 대해 이력서에 담기는 게 다른 플랫폼들과 다른 큰 장점이라 생각되었다.\n\n내가 느낀 아쉬운 점은 열람 여부를 확인하기 위해서는 일일이 확인해야 하고, 한달 넘게 기다려도 답이 없는 회사가 많아 어느 순간 사용하지 않았다. 이러한 이유는 한 회사의 면접에서 대표님과 면접을 보다 요즘 가장 많이 이용하는 채용 플랫폼들에 대한 이야기를 하게 되면서, 프로그래머스는 회사에서도 이력서가 들어왔는지 알림이 오지 않아서 확인하기 어려운 점이 있다고 듣게 되었다. 진실인지 아닌지는 알 수 없지만 답이 없는 회사들에 대한 이유를 유추할 수 있게 되었다.\n\n#### 3. 점핏\n\n![점핏 | 개발자 커리어 점프](https://cdn.jumpit.co.kr/jumpit/jumpit_share.png)\n\n점핏은 개발자 전용 채용 플랫폼으로 개발자에 특화된 컨텐츠들이 잘 담겨있는 플랫폼이다.\n\n- 이력서와 자기소개서에 대한 팁\n\n점핏은 원티드와 같이 커스텀된 이력서를 첨부할 수는 없지만 작성 화면에 나와있는 꿀팁들이 많은 도움이 되어서 이력서 수정할 때 참고할 수 있었다.\n\n- 주니어 개발자들 채용을 위한 개별 페이지, 더 루키\n\n다른 HR 플랫폼들과 다르게 주니어 개발자들을 위한 페이지가 따로 있어서, 일일이 필터링 하지 않고 주니어 개발자 공고를 볼 수 있게 좋은 UX를 가지고 있었다.\n\n내가 느낀 단점이라면 페이지 접속시 마다 로그인 유지가 되지 않아 매번 새로 로그인해야 하는 부분이 개발자로써 조금 불편한 부분이 있었다.\n\n#### 4. 인디스워크\n\n![IN THIS WORK · 인디스워크](https://inthiswork.com/wp-content/uploads/2022/11/logo-original-1.png)\n\n인턴 포지션이 열린 회사들을 찾는 과정에서 발견한 플랫폼이다.\n\n- 오픈 카톡방을 이용한 알림\n\n인디스워크는 직무별 오픈카톡방을 운영하고 있어서 페이지에 올라온 공고들을 카톡으로 쉽게 확인할 수 있었다.\n\n- 인턴 포지션 공고\n\n앞서 설명했던 플랫폼들은 인턴 포지션에 대한 공고가 적지만, 인디스워크는 신입, 인턴에 대해서도 많은 공고를 제공한다.\n\n사용하면서 아쉬웠던 점은 개발자 오픈 카톡방이 따로 있는 게 아니라 이공계 직무로 묶여 있다 보니 다른 직무 공고들에 묻혀서 확인을 잘 못하는 경우도 있었다.\n\n직접 사용하지는 않았지만 이외에도 [랠릿](https://www.rallit.com/positions?job=FRONTEND_DEVELOPER&jobGroup=DEVELOPER&jobLevel=IRRELEVANT,INTERN,BEGINNER,JUNIOR&pageNumber=1), [더 팀스](https://www.theteams.kr/recruit?o%5B%5D=1&o%5B%5D=2&o%5B%5D=3&o%5B%5D=5&o%5B%5D=6&o%5B%5D=7&o%5B%5D=8&o%5B%5D=9&o%5B%5D=10&o%5B%5D=44&o%5B%5D=45&o%5B%5D=11), [그룹바이](https://groupby.kr/positions), [잡플래닛](https://www.jobplanet.co.kr/job), [블라인드 하이어](https://www.blindhire.co.kr/job?jobFunctionId=4&yearOfExperience=1to2,3to5,6to9,10plus&orderBy=popularity) 등 많은 HR 플랫폼 속에서 인턴, 신입, 주니어 개발자 채용공고에 대해서 알아보려 노력했다.\n\n채용공고를 위와 같은 플랫폼에 올리지는 않았지만 그리팅과 같은 서비스를 이용한 자체 채용 사이트를 운영하는 경우도 많아서 좋은 회사들을 찾으려 노력했다. **유튜브 EO채널**과 **Plantum**과 같은 스타트업 전문 저널도 찾아보면서 소개된 회사들에 대해 검색해보고 채용 포지션이 열려 있다면 지원했다.\n\n### 🙄 글쓰기가 제일 어려워\n\n취업 준비 과정에서 가장 어려웠던 것은 어떤 이력서가 좋은 이력서인지, 어떤 포트폴리오가 좋은 포트폴리오인지 깨닫는 것이었다. 그래서 처음엔 이력서를 무작정 작성해서 제출했다. 지원하고 결과가 나오는 사이에 좋은 이력서들에 대해서 검색하고 보는데 대부분 경력자 이력서다 보니 나와 같은 신입 개발자 분들이 작성한 이력서에 대해서 찾기가 어려웠다. 그래도 좋은 이력서들과 이력서 관련 강의들을 많이 찾아보면서 어떤 점을 중요하게 어필해야 하는지 큰 그림을 이해할 수 있었다. 공개되어 있어 내가 참고한 이력서와 이력서 강의는 다음과 같다.\n\n(혹시 이 글을 보신다면 너무 많은 도움이 되었다고 감사하다고 말씀드리고 싶다.😆)\n\n#### 이력서 예시\n\n- [워니님의 이력서](https://wonny.oopy.io/)\n\n- [이동욱의 이력서](https://jojoldu.github.io/)\n\n- [김찬연님의 이력서](https://resume.chayeoi.site/_)\n\n- [김효재님의 이력서](https://www.hyojae.info/)\n\n- [오준상님의 이력서](https://www.notion.so/choi2021/Oh-Jun-Sang-cb560e11bf1742e5bfdbc00f6c4b8a35?pvs=4)\n\n- [안수진님의 이력서](https://www.notion.so/choi2021/c3e146341daf412ea4a1a19c650804c3?pvs=4)\n\n- [이건님의 이력서](https://www.notion.so/choi2021/Geon-Lee-0a2ead807ec24791b5f75a5d0974fca8?pvs=4)\n\n- [yukina1418님의 이력서 작성팁](https://velog.io/@yukina1418/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B4%EB%A0%A5%EC%84%9C-%EC%93%B0%EB%8A%94-%EB%B2%95)\n\n#### 이력서 강의\n\n- [포트폴리오를 부탁해 (원티드, 메이커 준님의 강의)](https://www.wanted.co.kr/events/vod/talk82)\n- [워니님의 인프런 이력서 강의](https://www.inflearn.com/course/%ED%95%A9%EA%B2%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EB%A0%A5%EC%84%9C-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C/dashboard)\n\n- [원티드 커리어 챌린지](https://www.wanted.co.kr/events/pre_challenge_career_1?utm_source=wanted&utm_medium=share)\n\n이력서들을 많이 보면서 어떻게 작성해야 할지, 어떤 점을 어필해야 할 지를 조금씩 알아갔지만, 실제로 내가 작성하는 것은 전혀 다른 문제였다. 운이 좋아 주변에 현직에서 일하고 있는 선배들과 친구들이 있어 좋은 피드백들을 받을 수 있었지만, 내가 부족해 말해준 여러 부분들을 직접 적용하고 어떤 것을 어필해야 하는지 100% 다 받아 들이지 못했다.\n\n![수정할 때마다 저장해둔 버전들...](이력서버전모음.png)\n\n이력서에서 받았던 피드백 중 중요했던 부분은 이력서가 **매력적이어야 한다**는 점이었다. 매력적이지 않은 이력서는 하루에도 수십 개의 이력서를 보는 채용 담당자 분들과 개발자 분들의 눈에 들어오지 않을 것이라는 뜻이었다. 물론 회사 기술 스택과 잘 맞아서 당장 사람을 뽑아야 하는 회사에서 뽑힐 수 있지만 좋은 회사일수록 기준이 높고, 우선 서류 전형에서 통과하기 위한 **내가 어필할 수 있는 이력서의 매력**은 무엇인지 고민이 필요했다.\n\n#### 🤔 내가 어필할 수 있는, 어필해야 하는 내 이력서의 매력\n\n내가 어필할 수 있는, 어필해야 하는 매력 포인트를 찾기 위해서는 다른 어떤 것보다 **경험 정리**가 필요했다.\n\n##### 1. 어떤 프로젝트를 담을까\n\n먼저 경험 정리에서는 **나의 어떤 프로젝트**를 이력서에 담을지 정해야 했다. 나는 내가 만들었던 프로젝트들 중에서 대학생 시절, 친구들과 함께 만들어 현재도 실 사용이 되고 있는 `지스트 청원서비스`와 9월부터 혼자 서비스에 대해 기획하고 만들고 있던 개인 프로젝트 서비스 `모으잡` 두 가지 프로젝트를 이력서에 담기로 결정했다.\n\n이렇게 두 가지 프로젝트를 선택했던 이유는 두 가지 프로젝트가 각각 다른 경험 포인트를 갖는다는 점과 비교적 높은 완성도 때문이었다.\n\n`지스트 청원서비스`는 프론트엔드 4명, 백엔드 4명에서 진행한 프로젝트로, 학교에서 현재도 운영하면서 피드백을 받아 반영하는 등의 협업과 하나의 서비스를 실제 배포, 운영까지 이어진 경험을 한 점을 어필할 수 있었다.\n\n`모으잡`의 경우는 직접 전체 서비스를 기획하면서 필요한 부분들을 찾아서 개발하는 과정을 하나 하나 기록으로 남겼고, Next JS를 이용해 회원 인증, CSR과 SSR, SEO, 성능에 대한 고민했던 부분들을 어필할 수 있었다.\n\n##### 2. 이력서와 포트폴리오는 다르다\n\n위의 정리한 프로젝트 별 각각의 포인트만 정리해서 이력서를 우선 작성했다. 작성한 이력서를 이용해 50개 정도 회사에 지원하고 단 한 곳의 회사의 서류 합격을 하면서 이력서가 잘못되었다고 느꼈고, 내 나름 수정하고 다시 80개 회사에 지원하고 2~3개의 회사의 서류 합격을 할 때 즈음에 신입 지원자 분들 이력서와 포트폴리오를 보면서 **이력서 만으로는 안된다**는 생각을 했다.\n\n앞서 말한 대로 채용 담당자 분들과 개발자 분들은 바쁘시다... 하루에도 몇십 개의 이력서와 포트폴리오를 봐야 한다. 그러기 위해서는 먼저 이력서에서 관심 있는 지원자를 분류하고, 이후에 프로젝트들에 대해 자세히 살펴보게 된다고 한다. 이러한 이해가 부족했던 나는 그저 내가 `뭘 했는지`에 대해서 만 줄줄이 적어 다섯 페이지나 되는 양을 채우고 있었다. 그리고 관심을 가져 주셔서 프로젝트에 대해 확인하시려 해도, 프로젝트 전체에 대해 정리된 글이 없어 불편함을 주고 있다는 것을 깨달았다.\n\n글은 읽는 사람 기준에서 작성해야 하는 점을 다시 깨닫고, 프로젝트에 **README**와 **포트폴리오**에 프로젝트 별로 이해를 도울 수 있게 전체적인 서비스 흐름, 서비스 타겟, 내가 고민한 부분들과 기술 선정 이유, 문제와 해결한 방식 등에 대해서 새롭게 작성하기 시작했다.\n\n포트폴리오를 작성하면서 가장 크게 느낀 점은 전체적인 프로젝트 흐름을 되돌아보면서 **내가 놓쳤던 경험**들에 대해 되돌아 볼 수 있었고, 각각에 페이지에 대해 설명하면서 `진짜 고민했던 부분`들을 다시 글로 담아내 풀어내면서 기존에 이력서에 축약되게 표현했던 문장들을 좀 더 배경을 담아서 설명할 수 있었다. 풀어쓴 글을 다시 이력서에 요약해서 작성하면서 좀 더 잘 `원인과 결과`를 정리해서 작성할 수 있었다. 그리고 이렇게 작성한 부분들에 대해서 프로젝트 회고와 하루하루 개발 경험을 작성한 **블로그의 글과 연결해** 신빙성을 높이고 더 많은 고민들에 대해 담아낼 수 있었다.\n\n이렇게 수정해서 제출하면서 이전과는 달리 30개 중 적어도 5개에서 7개의 회사의 서류 합격을 하게 되며 급격하게 합격률이 올라갈 수 있었고, 신기하게 원티드에 첨부해 놓은 이력서를 보시고 직접 제안을 주신 회사도 한 곳 있었다.\n\n##### 3. 숫자로 표현하면 좋다던데...\n\n많은 강의와 이력서들을 보면서 경험에 대해 `숫자로 표현해라`, `데이터로 표현해라`라는 말을 많이 들을 수 있었지만, 내가 한 경험에서 **어떤 걸 숫자로 나타낼 수 있을까** 고민이 되었다. 내가 가진 어필할 수 있었던 포인트 중 하나는 열심히 작성해 놓은 블로그 글이었다. 단순히 블로그에 글을 작성하고 있다고 표현할 수도 있지만 **총 80 여 개의 글**을 작성했다고 자기소개에 담아 표현할 수 있었다.\n\n협업 경험으로는 원티드 프리온보딩 과정에서 husky를 이용해 ESLint와 Prettier 설정을 자동화해 코드 스타일을 통일했던 적이 있었는데, 단순히 적용했다라고 할 수 있지만 결과적으로 **코드 리뷰 시간을 1시간 정도 절약**할 수 있었다고 작성했다. 이 부분은 면접에서도 어떻게 한 시간을 단축했다고 생각하는 지 질문을 받을 수도 있었다.\n\n프로젝트에서는 주로 성능 측정했던 부분에서 숫자로 표현할 수 있었다. 모으잡의 경우, Next JS를 이용해 SEO와 CSR에서 SSR로 채용공고 리스트를 받아오게 수정했었다. 이 부분도 단순히 한 일로 작성할 수도 있지만, light house를 이용해서 SEO와 SSR 적용 전의 성능을 측정하고, 각각을 적용했을 때 성능을 측정해 LCP를 **1.7초에서 0.3초로 **page 성능 점수를 **94점에서 99점** 개선한 내용을 데이터로 표현했다. 성능을 측정한 부분은 실제 면접에서 어떻게 개선했는지, 확인한 방법 등에 대해 질문을 받고 이야기할 수 있었다.\n\n데이터로 작성하라는 말에 도대체 어떻게 하는 거지라고 생각했지만 돌아보니 설명할 수 있는 포인트들이 많았다. 데이터로 표현하고 정리하는 것은 현업으로 일할 때 객관적인 지표가 되기 때문에 중요한 부분이라 생각되어, 계속해서 고민해야 할 포인트라 생각되었다.\n\n##### 4. 이력서와 포트폴리오 형식에 대한 깨알 팁\n\n각 플랫폼 별로 이력서 형식을 지원하지만, 커스텀하고 싶은 마음에 노션 이력서와 포트폴리오 형식을 사용했다. 제출 형식을 PDF로 추출할 수 있는데 글자 크기, 줄 간격 등을 고려해 이력서는 `70%`, 포트폴리오는 `60%`정도로 맞춰서 추출했다.\n\n이력서 형식의 경우 검색 시에 많이 나와 참고할 게 많았지만 포트폴리오의 경우 노션의 갤러리를 이용해 첨부하는 경우가 많았는데, 그럴 경우에 또 다른 페이지로 연결되어야 하고 해당 페이지를 PDF로 추출하게 될 때 표로 변환되어 보기 좋지 않은 문제가 있었다.\n\n그래서 포트폴리오를 위한 노션 페이지를 만들고 프로젝트들에 대한 설명과 사진을 첨부해 프로젝트의 상세 내용을 담아 제출했다. 다른 분들 중에는 노션외에 PPT로 작성하는 경우도 있다고 한다.\n\n### 😎 기본부터 챙기자 기술 면접\n\n서류 전형에서 어느 정도 통과하고 기술 면접이 관건이 되기 시작했다. 면접을 준비하면서 세 가지를 명심하고 준비하려 했다.\n\n#### 1. **최대한 많은 면접에 직접 참여하자**\n\n이력서 피드백을 해준 선배들의 이야기 중 나에게 와닿았던 말은 `첫 면접이 가장 가고 싶은 회사일 때가 가장 무서운 것`이란 말이었다. 그만큼 면접장에서 경험이 중요하다는 것을 의미하는 말이었다. 광주에서 살고 있었기 때문에 면접을 참여하기 위해 교통비, 숙박비 등의 부담이 있었지만 기회가 주어지면 최대한 많이 참여하려 했다. 서류 합격한 회사 중 처음부터 많은 관심을 갖고 지원하지는 않은 회사였지만, 이후 내가 정말 가고 싶은 회사에서 면접을 잘 보기 위해, 경험을 위해서 참여한 회사들도 있었다.\n\n상대방에게 나의 이야기를 하는 것도 어려운데, 나를 평가하는 자리에서 올바르게 내 이야기를 할 수 있게 되는 데에는 당연히 많은 시간이 걸린다. 특히 개발자 직군은 기술 면접에서 지원자의 경험 뿐 아니라, 직무 관련 지식들을 직접 물어보고 어디까지 알고 있는지 확인하는 자리이기 때문에, 받은 질문들 하나 하나가 나만의 족보가 되는 기회가 되었다. `현업에서 일하기에 내가 이런 부분이 부족하구나`, `이 회사는 이런 부분을 중요하게 생각하구나` 등을 배울 수 있었고, 초기에는 다른 분들이 정리해 주신 면접 질문들을 이용해서 공부를 했지만, 이후에는 면접 때 받았던 질문들 위주로 복기해 **나만의 면접 질문 리스트**를 만들었다.\n\n정리한 질문들은 스터디 시간의 주제로 정하고 발표하며 말하는 연습을 하고, 블로그 글로 작성하면서 완전히 이해하려 했다. 말하기 연습과 학습 경험이 쌓이면서 후반에 갈수록 기술 면접에서 최종 면접으로 이어져 갈 수 있었다.\n\n##### 😊 면접 초반 참고한 블로그\n\n- [sylagape1231님의 FE 취준생을 위한 포스트/자료모음](https://velog.io/@sylagape1231/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B7%A8%EC%A4%80%EC%83%9D%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B2%8C%EC%8B%9C%EA%B8%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C#-%EC%B7%A8%EC%97%85-%EB%B0%8F-%EC%9D%B4%EB%A0%A5%EC%84%9C--%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4-%EC%A4%80%EB%B9%84)\n\n- [realmojo님의 프론트엔드 개발자 기술면접 인터뷰 질문 모음](https://realmojo.tistory.com/300)\n\n##### 📃 내가 받았던 면접 문제\n\n내가 정리한 면접 질문 리스트는 다음과 같다. 괄호 안의 숫자는 같은 질문을 받았던 경우를 의미한다.\n\n- 인성\n\n  - 자기소개 (6)\n  - 지원 동기 또는 저희 회사를 어떻게 알게 되셨나요? (5)\n  - 화학 전공에서 개발자가 되기로 선택한 이유 (4)\n  - 프론트엔드 개발자가 되기로 선택한 이유 (3)\n  - 현재 그리는 로드맵과 방향 (2)\n  - 주변에서 말하는 나의 장점과 단점, 장점이 내가 바라는 방향인지 (2)\n  - 어떻게 공부하고 있는지 최근 본 블로그나 책 (3)\n  - 프로그래밍 언어별 차이를 느낀점\n  - 어느 정도 경력이라 생각하는지\n  - 다른 사람들로부터 영향을 받아서 바뀐 경험 또는 내가 영향을 준 경험\n  - 개발에서 내가 생각하는 중요한 3가지\n  - 어떻게 온보딩할 건지, 어려움이 발생했을 때 어떻게 해결할 지\n  - 완성도와 기간 내 마무리 중 어떤 걸 중요시 할지\n\n- 프로젝트\n\n  - 프로젝트 공통 질문\n    - 기술적으로 가장 어려웠던 부분\n    - 의도하지 않게 동작했던 경험\n    - 실제로 사용자의 피드백을 들었던 경험\n  - 모으잡\n    - Next JS와 SSR 언제 왜 썼는지\n    - Authentication 과정에 대한 설명\n    - 모으잡을 왜 기획했는지, 누굴 타겟으로 하는지\n  - 지스트 청원\n    - 프로젝트에서 가장 어려웠던 문제\n    - 현재 사용되고 있는 서비스인지 (4)\n    - authentication설계를 했다고 했는데 어떻게 보관을 했는지\n    - 지스트 청원서비스에서 인증 flow와 예외처리 방식\n    - 왜 학교 이메일을 기준으로 설계했는지\n    - 협업 과정에 대한 설명, 협업에서 맡았던 역할\n    - 협업에서 느낀 어려움과 해결해나간 방향 (3)\n    - Git flow 전략과 왜 develop브랜치만 남아있는지\n\n- 자바스크립트\n\n  - Callback, Promise Async-await 에 대해\n  - 자바스크립트가 멀티 스레드로 보이는 이유\n  - setTimeOut(callback,0)로 했을 때 처리 과정\n  - 함수에서 전달받은 인자를 왜 변경하면 안되는지\n    - call by reference, call by value\n  - 깊은 복사와 얕은 복사 (3)\n  - 오래된 라이브러리가 callback으로 되어있을 때, 어떻게 async-await으로 사용할 수 있을지\n  - 이벤트 버블링과 캡처링 (3)\n  - 함수 선언문과 arrow 함수의 차이점\n  - 클로저란\n  - 에러 처리를 어떻게 하는지\n\n- CS\n\n  - 브라우저 랜더링 과정에서 js의 역할은?\n\n  - 퍼블리싱이란\n\n  - Http/https의 차이점(3)\n\n    - 대칭키와 비대칭키 flow 과정 설명\n\n  - CORS가 뭔지, 해결 방법 (2)\n\n  - 브라우저 스토리지에 대한 설명\n\n    - Cookie, localstorage, session storage\n\n  - JWT가 어떻게 이루어져 있고 암호화 되어있는지\n\n  - RESTful API\n\n  - stack과 queue의 특징과 브라우저에서의 예\n\n  - CDN에 대해서 알고 있는지\n\n  - 렌더링 과정과 JS가 참여하는 시점은? reflow와 repaint\n\n  - 어제까지 잘되다가 갑자기 흰 화면이 나왔을 때 어떻게 해결할지\n\n  - 디자인 패턴에 대한 설명\n\n- 라이브러리, 프레임워크\n\n  - 리액트\n\n    - 리액트 성능 보장 과정, Vdom의 역할과 실제로 성능이 더 좋을까\n    - 불변성을 지켜야 하는 이유\n    - Props와 state의 차이\n    - 컴포넌트 설계 방식\n    - React 컴포넌트 업데이트 방식\n    - Data binding, 단방향과 양방향 바인딩의 차이\n    - 상태 관리의 기준,전역 상태는 어떤 걸 하는지 (3)\n    - Redux를 사용하다가 React Query와 Context API로 바꾼 이유는? (2)\n    - Dependency Array에 대한 질문\n    - React.memo, useCallback, useMemo의 역할\n    - Hook에 대한 설명\n    - useState에서 상태를 참조할 수 있는 방법\n    - Hook을 왜 조건문이나 반복문 내부에 사용할 수 없는지\n\n  - Next JS\n\n    - SEO와 CSR과 SSR의 차이, 직접 사용한 경험\n    - 왜 구글 엔진은 CSR에서도 가져갈 수 있을까\n\n  - Vite\n\n    - 왜 vite가 빠른지 (사전과제를 CRA가 아니라 Vite로 진행해서 받은 질문)\n\n#### 2. 기본에 충실하자\n\n대답하지 못해 후회되는 질문들을 복기하며 **기본에 충실하지 못 했구나**라는 생각이 많이 들었다. 위의 질문 리스트들을 보면, 개발을 하면서 마주칠 수 밖에 없는 문제들이지만, 어떤 라이브러리가 `마법처럼` 해줘서, 또는 그냥 `아무 생각 없이 사용해서` 대답할 수 없었다. 특히 이런 생각이 많이 든 부분은 리액트에 대한 질문이었다. VDOM이 뭔지, 왜 사용되는지나 useState, useEffect와 같은 hook에 대한 설명해달라는 기본적인 질문에도 당황하고 말하지 못했었다.\n\n대답하지 못했던 질문들에 대해 부끄럽고, 후회가 되서 하나,하나 주제를 잡고 블로그에 정리하거나 스터디에 발표하며 정리하기 시작했다. 이렇게 부족한 모습들을 부족한 것에 그치는 것이 아니라 정리하고 나니, 유사한 질문에도 잘 대답할 수 있었다. 더 좋았던 점은 이렇게 면접에서 부족해서 정리한 블로그 글을 면접관 분들이 읽으시고 `블로그 글을 읽었다. 최근에 받은 질문들 중에 기억남는 질문은 어떤 게 있는지` 물어보시기도 하고 블로그로 부족한 부분들에 대해 글로 정리하고 있다는 말에`부족한 부분을 채우려하는 게 신입에게 제일 중요하다`고 조언해 주시는 CTO님도 계셨다.\n\n면접에 엄청 어려운 문제들은 `정말 어디까지 알고 있는지 ` 궁금해서 물어볼 수도 있지만, 대부분 내가 경험한 것에서 대답할 수 있는 질문이었기 때문에, 이런 기본을 챙기는 게 가장 중요하다고 생각했다.\n\n#### 3. 나도 회사를 평가해야 한다\n\n최종 합격을 하고 어디를 갈 지 고민을 하면서 들었던 부분은 면접이 나만 평가 받는 자리가 아니다 라는 점이다. 어느 회사로 갈 지 고민할 때 연봉도 중요하지만, **함께 일할 사람들**이 나에게 더 중요했다. 그렇기 때문에 면접에서 나를 평가하기 위해 질문 속에서 느껴지는 함께 할 팀의 분위기와 면접관 분들의 모습, CTO님과의 면접 경험이 나에게 너무 중요한 기준이 되었다. `나라는 사람`을 궁금해 하는 회사인지 면접의 질문 속에서 느껴졌다. 정말 안 좋았던 면접 경험은 내가 한 프로젝트에 대해서 아무 질문도 없이 그저 시험 치듯 기술 질문만 1시간 동안 받았던 적도 있었다. 사람들이 왜 면접 과정이 **소개팅과 같다**고 하는지 이해가 되었다.\n\n### 🎈 마치며\n\n이제 회사를 다닌 지 3일 차가 되었다. 아직 온보딩 기간이라 어떻게 회사가 돌아가는 지 완전히 이해하지 못했고, 사수 분께 이것 저것 물어보면서 열심히 배우는 과정이지만, 내가 기대했던 모습 이상의 회사라 느껴져 더 열심히 배우고 기여하고 싶은 마음이 든다. 최근 카카오에서 채용 과정을 중단하는 사태도 발생하면서 정말 나는 `운이 좋아서` 좋은 회사와 좋은 사람들을 만나서 시작할 수 있었구나 생각이 많이 들었다. `무조건 난 개발자가 될거니까`라는 무대포로 시작했지만 여러 노력과 운이 합쳐져 좋은 결과를 만들어진 것 같다. 이제 지원을 시작하시는 분들에게 조금이라도 내 글이 도움이 될 수 있기를, 나와 같은 시행착오를 겪지 않기를 바라며 글을 마무리한다.\n\n(혹시 궁금한 부분 댓글로 달아 주시면 업데이트 하겠습니다)\n"},{"excerpt":"❤ React hooks React hooks는 리액트가 사랑 받게 된 큰 이유 중 하나로 생각된다. 기존의 주로 사용되던 에서 로 흐름을 바꿀 수 있었던 가장 큰 계기가 hooks의 도입이었다. 베타버전으로 나온 공식 문서를 읽고 그중 가장 자주 사용하는 hooks들의 역할과 내부 동작에 대해 정리해보려 한다. 😁 Rule of Hooks 각각의 Hoo…","fields":{"slug":"/2023-02-03-useState,useEffect, useRef, memo/"},"frontmatter":{"date":"February 03, 2023","title":"React Study: useState, useEffect, useRef, memo","tags":["react"]},"rawMarkdownBody":"\n## ❤ React hooks\n\n**React hooks**는 리액트가 사랑 받게 된 큰 이유 중 하나로 생각된다. 기존의 주로 사용되던 `class component`에서 `funtional Component`로 흐름을 바꿀 수 있었던 가장 큰 계기가 hooks의 도입이었다. 베타버전으로 나온 공식 문서를 읽고 그중 가장 자주 사용하는 hooks들의 역할과 내부 동작에 대해 정리해보려 한다.\n\n### 😁 Rule of Hooks\n\n각각의 Hooks에 대해 정리하기 전에 Hooks들이 지켜야 하는 규칙에 대해 먼저 정리하려 한다. 이 부분도 면접에서 질문받았던 부분으로 스코프에 대해서 쉐도잉과 오버 라이팅으로 이야기 했었는데 틀렸던 부분이라 새롭게 정리했다.\n\n#### Only Call Hooks at the Top Level\n\nhooks들은 항상 React fuction의 상위 level에서 사용되어야 한다. 규칙의 장점은 React가 hooks의 작동 순서에 대해서 보장해 줄 수 있다는 점이다.\n\n```jsx\nfunction Form() {\n  // 1. Use the name state variable\n  const [name, setName] = useState(\"Mary\")\n\n  // 2. Use an effect for persisting the form\n  useEffect(function persistForm() {\n    localStorage.setItem(\"formData\", name)\n  })\n\n  // 3. Use the surname state variable\n  const [surname, setSurname] = useState(\"Poppins\")\n\n  // 4. Use an effect for updating the title\n  useEffect(function updateTitle() {\n    document.title = name + \" \" + surname\n  })\n\n  // ...\n}\n```\n\n위 예제에서 hooks들이 총 네 개의 hooks가 매 렌더링 때마다 순서대로 진행되게 된다. 여기에 만약 조건문으로 `useEffect(persistForm)`으로 감싼다면 어떻게 될까?\n\n```jsx\nfunction Form() {\n  // 1. Use the name state variable\n  const [name, setName] = useState(\"Mary\")\n\n  // 2. Use an effect for persisting the form\n  if (name !== \"\") {\n    useEffect(function persistForm() {\n      localStorage.setItem(\"formData\", name)\n    })\n  }\n  // 3. Use the surname state variable\n  const [surname, setSurname] = useState(\"Poppins\")\n\n  // 4. Use an effect for updating the title\n  useEffect(function updateTitle() {\n    document.title = name + \" \" + surname\n  })\n\n  // ...\n}\n```\n\n`name`이 처음에 'Mary'기 때문에 `useEffect(persistForm)`은 무시된다. 그로 인해 hooks들의 순서가 바뀌게 되고 이전 렌더링과 다른 결과를 만들어 예상치 못하는 버그가 만들어 질 수 있다고 한다. 그러면 어떤 버그가 만들어 질 수 있을까? 이 부분을 이해하기 위해서는 Hook들이 어떻게 만들어졌는지를 구현해야 한다.\n\n### useState와 useEffect 구현해보기\n\nhook들이 클로저를 이용해서 구현되어 있다는 사실은 알고 있었지만, 실제로 구현해보지는 못했다. 이번 기회에 실제로 구현하는 예제 코드들을 찾아봤고 그중 가장 잘되어있는 [황준일님 블로그](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Make-useSate-hook/#_2-bottom-up-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8)와 [Philip Fabianek의 영상](https://www.youtube.com/watch?v=1VVfMVQabx0) 속 코드를 참조해서 구현했다.\n\n먼저 **useState** 를 구현해보자. `render()`함수 구현은 제외했다.\n\n```jsx\nconst React = (() => {\n  const useState = initialValue => {\n    let state = initialValue\n    const setterFn = newValue => {\n      state = newValue // 새로운 state를 할당한다\n      // render(); // 리랜더링\n    }\n    return [state, setterFn]\n  }\n  return {\n    useState,\n  }\n})()\n\nconst { useState } = ReactX\nconst Component = () => {\n  const [count, setCount] = useState(1)\n  console.log(count)\n}\nComponent() // 1\nComponent() // 1\n```\n\n위 예제에서 React 내부의 `useState`를 구현했지만 Component를 리랜더링 하게 되면 이전 값에서 불러오는 것이 아니라 초기값 1을 다시 가져오는 것을 볼 수 있다.\n\n문제를 해결하기 위해서는 state를 `useState`함수 내부에 두는 것이 아니라 상위에서 참조하는 형식으로 **클로저**를 이용해야 한다. 이때 초기 값은 처음에만 할당할 수 있게 state가 undefined일 때만 할당하게 한다.\n\n```jsx\nconst React = (() => {\n  let state\n  const useState = initialValue => {\n    if (state === undefined) {\n      state = initialValue\n    }\n    const setterFn = newValue => {\n      state = newValue // 새로운 state를 할당한다\n      // render(); // 리랜더링\n    }\n    return [state, setterFn]\n  }\n  return {\n    useState,\n  }\n})()\n\nconst { useState } = ReactX\nconst Component = () => {\n  const [count, setCount] = useState(1)\n  const [count2, setCount2] = useState(5)\n  console.log(count, count2)\n}\nComponent() // 1,1\n```\n\n다음으로 해결해야 할 문제는 여러 개의 state를 다룰 때다. count2의 초기 값을 5로 정했지만 React 함수 내부의 같은 `state`를 참조하고 있기 때문에 새로운 초기 값이 할당되지 않고 `count`에 저장된 1에서 시작하는 것을 볼 수 있다.\n\n이점을 해결하기 위해서는 state를 **배열**로 둔다. 배열로 두게 되면 state가 여러 개가 되어도 해당 index를 통해 접근하고 값을 변경할 수 있게 된다. 리랜더링 시에는 다시 처음부터 state들을 확인해야 하므로 `resetIndex`함수를 추가했다.\n\n```jsx\nconst React = (() => {\n  let state = []\n  let index = 0\n  const useState = initialValue => {\n    const localIndex = index\n    index++\n    if (state[localIndex] === undefined) {\n      state[localIndex] = initialValue\n    }\n    const setterFn = newValue => {\n      state[localIndex] = newValue\n      // render(); // 리랜더링\n    }\n    return [state[localIndex], setterFn]\n  }\n\n  const resetIndex = () => {\n    index = 0\n  }\n\n  return {\n    useState,\n    resetIndex,\n  }\n})()\n\nconst { useState, resetIndex } = ReactX\nconst Component = () => {\n  const [count, setCount] = useState(1)\n  const [count2, setCount2] = useState(5)\n\n  console.log(count, count2) // 1 5\n}\nComponent()\nresetIndex()\nComponent()\n```\n\n이제는 useState에 이어 **useEffect**를 구현해보자. useEffect는 callback 함수와 dependency 배열을 인자로 받는 특징이 있다.\n\n```jsx\nconst React = (() => {\n  let state = []\n  let index = 0\n  const useState = initialValue => {\n    const localIndex = index\n    index++\n    if (state[localIndex] === undefined) {\n      state[localIndex] = initialValue\n    }\n    const setterFn = newValue => {\n      state[localIndex] = newValue\n      // render(); // 리랜더링\n    }\n    return [state[localIndex], setterFn]\n  }\n\n  const resetIndex = () => {\n    index = 0\n  }\n\n  const useEffect = (callback, dependencyArray) => {\n    let hasChanged = true\n    if (hasChanged) {\n      callback()\n    }\n  }\n\n  return {\n    useState,\n    resetIndex,\n  }\n})()\n```\n\n위 코드에서 useEffect는 변화가 있으면 callback함수를 수행하는데 만약 dependencyArray가 없다면 항상 hasChanged가 true기 때문에 항상 수행되게 된다. 이제 dependency 비교하는 코드를 넣어보자.\n\n```jsx\nconst React = (() => {\n  let hooks = []\n  let index = 0\n  const useState = initialValue => {\n    const localIndex = index\n    index++\n    if (hooks[localIndex] === undefined) {\n      hooks[localIndex] = initialValue\n    }\n    const setterFn = newValue => {\n      hooks[localIndex] = newValue\n    }\n    return [hooks[localIndex], setterFn]\n  }\n  const resetIndex = () => {\n    index = 0\n  }\n\n  const useEffect = (callback, dependencyArray) => {\n    let hasChanged = true\n    const oldDependencies = hooks[index]\n    if (oldDependencies) {\n      hasChanged = false\n      dependencyArray.forEach((dependency, index) => {\n        const oldDependency = oldDependencies[index]\n        const areTheSame = Object.is(dependency, oldDependency)\n        if (!areTheSame) {\n          hasChanged = true\n        }\n      })\n    }\n    if (hasChanged) {\n      callback()\n    }\n    hooks[index] = dependencyArray\n    index++\n  }\n  return {\n    useState,\n    resetIndex,\n    useEffect,\n  }\n})()\n\nconst { useState, resetIndex, useEffect } = React\nconst Component = () => {\n  const [count, setCount] = useState(1)\n  useEffect(() => {\n    console.log(count)\n  }, [count])\n  setCount(2)\n}\nComponent() // 1\nresetIndex()\nComponent() // 2\nresetIndex()\nComponent() // 3\n```\n\ndependency를 비교하기 위해서는 이전 dependency에 대한 정보를 저장하고 있어야 한다. 저장하기 위해 useState에서 사용했던 state를 hooks로 바꾸고 배열에 이전 dependency 정보를 저장한다. 저장한 dependency 값이 있다면 전달 받은 새로운 dependency와 비교를 하는데 이때 `Object.is()`를 이용한 얕은 비교를 수행한다.\n\n비교 시에 하나라도 바뀌었을 때 `hasChanged`를 true로 바꾸고 callback()을 실행하며 새롭게 전달받은 dependency를 **hooks배열에 저장한다.**\n\nuseState와 useEffect를 구현하면서 hooks 배열에 관련 정보들이 저장되는 것을 보았다. 이점은 앞선 hooks의 규칙 조건문이나 반복문에서 hook이 사용되지 못하는 이유와 연결되는데, 조건문에서 사용되게 되면 **조건에 따라 hooks의 정보가 이전 순서와 다르게 저장되기 때문에** 해당하는 hook에 접근하는 게 아니라 다른 index로 접근해 버그가 발생하게 된다.\n\n직접 구현해보면서 왜 react hook이 조건문에 사용되면 안되는지 이해할 수 있었고 클로저가 어떻게 활용되어 있는지 이해할 수 있었다.\n\n## useState\n\nuseState는 **컴포넌트 내의 상태관리**를 위한 hook이다. 리액트 컴포넌트가 기본적으로 리렌더링되는 기준은 `state와 props`가 바뀌었을 때이다. 그중 state는 컴포넌트 내부에서 **변하는 데이터**로 설명할 수 있다. 단순히 변하는 값을 다룬다면 `let`으로 변수에 할당하면 되지 않을까 생각할 수 있지만, `useState`는 (1)데이터를 바꾸고 (2)컴포넌트를 리렌더링하는 두 가지 step으로 이루어져 있다.\n\n상태를 업데이트 하는 방법에는 setFunction에 (1) 값을 바로 할당하는 방법, (2)인자로 updater function을 이용하는 방법 두 가지가 있다.\n\n```jsx\nconst [name, setName] = useState('Edward');\n\nfunction handleClick() {\n  setName('Taylor');\n  setAge(a => a + 1);\n  // ...\n```\n\n#### 리액트의 상태 업데이트 방식: Batching\n\n상태를 업데이트할 때 주의할 점은 **상태 변화는 UI의 변화로 이어진다** 라는 점이다. 이점이 중요한 이유는 리액트의 상태를 반영하는 방식인 `batching`과 관련되어있다.\n\n`batching`은 UI를 업데이트할 때 setFunction이 실행될 때마다 업데이트를 하는 것이 아니라 **모든 event handler가 동작했을 때** 일어나는 것을 의미한다. 매번 setFunction을 실행할 때마다 바로 바로 변하면 동기적으로 일어나는 workflow로 더 직관적이겠지만, setFunction마다 리랜더링 할 시에는 성능 문제가 발생할 수 있기 때문에 setFunction들을 `React queue`에 모아서 순서대로 실행하고, 실제로 변해야 하는 DOM요소들을 반영한다. 이러한 동작은 마치 useState가 비동기적으로 처리되는 것처럼 느껴지게 한다.\n\n주의할 점은 같은 상태를 업데이트하는 setFunction을 여러 번 호출했을 때다.\n\n```jsx\nimport { useState } from \"react\"\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0)\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button\n        onClick={() => {\n          setNumber(number + 1)\n          setNumber(number + 1)\n          setNumber(number + 1)\n        }}\n      >\n        +3\n      </button>\n    </>\n  )\n}\n```\n\n위 코드에서 버튼을 클릭하면 state가 0에서 3으로 업데이트될 것을 기대하고 작성했지만 마지막으로 전달한 setFunction만 수행해 `number`는 1이 된다.\n\n리액트 공식 문서는 이러한 동작 방식을 같은 상태의 여러 개의 업데이트를 요구하는 고객이 있고, 고객의 마지막 주문만 받는 것과 같다고 설명한다.\n\n[React 공식 문서 사진]\n\n![img.png](img.png)\n\n이러한 모습은 마치 `debouncing`을 해 마지막 호출만 받는 것과 같이 생각되었다. 검색 API로 관련검색어를 호출할 때 매번 input에 사용자가 작성할 때마다 수행해 불필요한 API 비용을 만드는 것이 아니라 일정 시간 내의 처음과 끝의 요청만 수행하는 모습인 `debouncing`으로 원하는 시점에 맞게 해당 함수를 수행해 비용을 절약하고 있다고 생각했다.\n\n그러면 같은 상태를 업데이트하는 여러 번의 setFunction을 처리할 방법은 없을까?\n\n이 문제를 해결하기 위해서는 앞서 설명한 **updater function**을 이용할 수 있다.\n\n```jsx\nimport { useState } from \"react\"\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0)\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button\n        onClick={() => {\n          setNumber(n => n + 1)\n          setNumber(n => n + 1)\n          setNumber(n => n + 1)\n        }}\n      >\n        +3\n      </button>\n    </>\n  )\n}\n```\n\n**updater function** 방식은 앞서 직접 값을 할당하는 방식과 달리 이전 값을 참조해 함수의 인자로 전달해 함수를 실행한 다음 반환 값을 다시 인자로 사용해 우리가 원하는 상태 업데이트를 할 수 있다.\n\n| queued update | `n` | returns     |\n| ------------- | --- | ----------- |\n| `n => n + 1`  | `0` | `0 + 1 = 1` |\n| `n => n + 1`  | `1` | `1 + 1 = 2` |\n| `n => n + 1`  | `2` | `2 + 1 = 3` |\n\n그렇다면 이제 조금 더 복잡한 상황의 코드를 보자.\n\n```jsx\nimport { useState } from \"react\"\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0)\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button\n        onClick={() => {\n          setNumber(number + 5)\n          setNumber(n => n + 1)\n          setNumber(42)\n        }}\n      >\n        Increase the number\n      </button>\n    </>\n  )\n}\n```\n\n위 코드는 (1) 0+5를 할당하는 setFunction, (2) 5=>5+1을 할당하는 setFunction (3) 42를 할당하는 setFunction이 있다. 결과적으로 버튼을 클릭하면 42가 되는 것을 볼 수 있는데 이러한 흐름은 다음 표로 정리할 수 있다.\n\n| queued update       | `n`          | returns     |\n| ------------------- | ------------ | ----------- |\n| “replace with `5`”  | `0` (unused) | `5`         |\n| `n => n + 1`        | `5`          | `5 + 1 = 6` |\n| “replace with `42`” | `6` (unused) | `42`        |\n\n정리된 표를 보면 사실 값을 할당하는 방식도 결국 함수를 전달하는데 이때 이전 값을 참조하지 않고 전달하는 **setState(prev=>x)**로 진행되는 것을 새롭게 알 수 있었다.\n\n#### 함수로 초기 값 설정\n\nuseState의 초기 값을 설정할 때 값을 전달할 수도 있지만 함수를 전달할 수도 있다. 실제로 사용한 예로는 localStorage의 토큰을 initialValue로 state에 전달해야하는 상황이 있었다.\n\n```jsx\nconst getToken=()=>{\n   return localStorage.getItem(\"access_token\")\n}\nfunction TodoList() {\n  const [token, setToken] = useState(getToken());\n  // ...\n```\n\n위 코드의 문제점은 함수의 실행 후 반환 값을 useState에 전달해 useState(prev=>getToken())이 되어 컴포넌트가 리랜더링 시 매번 수행된다. 이점을 막기 위해서는 함수를 실행하게 하는 것이 아니라 함수 자체를 전달해 **초기 값**으로 반환된 값을 받아오게 할 수 있다. 위에서 봤던 updaterFunction 방식이 고차 함수로 수행된다.\n\n```jsx\nconst getToken=()=>{\n   return localStorage.getItem(\"access_token\")\n}\nfunction TodoList() {\n  const [token, setToken] = useState(getToken); // useState(prev=>()=>getToken())\n  // ...\n```\n\n#### key로 컴포넌트 바꾸기\n\n특정 컴포넌트를 새롭게 만들게 하고 싶을 때 key를 이용해서 react에게 알려 줄 수 있는데, key값이 바뀌면 리액트에서 DOM요소가 바뀌었다고 이해하기 때문에 key값에 상태를 전달해 컴포넌트를 새롭게 만들게 할 수 있다.\n\n```jsx\nimport { useState } from \"react\"\n\nexport default function App() {\n  const [version, setVersion] = useState(0)\n\n  function handleReset() {\n    setVersion(version + 1)\n  }\n\n  return (\n    <>\n      <button onClick={handleReset}>Reset</button>\n      <Form key={version} />\n    </>\n  )\n}\n\nfunction Form() {\n  const [name, setName] = useState(\"Taylor\")\n\n  return (\n    <>\n      <input value={name} onChange={e => setName(e.target.value)} />\n      <p>Hello, {name}.</p>\n    </>\n  )\n}\n```\n\n만약 내가 코드를 작성했다면 컴포넌트 밖에 `const initialValue=\"taylor\"`를 만들고 App 컴포넌트에서 `handleReset`함수에서 값을 initialValue로 초기화시키는 방식으로 진행했겠지만, 상태를 key로 컴포넌트에 전달함으로써 상태가 달라지면 key가 달라져 새롭게 Form 컴포넌트가 리랜더링 되어 `name`의 초기 값인 `Taylor`로 리셋된 것을 볼 수 있었다.\n\n### useEffect\n\nuseEffect는 리액트 공식문서에서 `외부 system에 따라 컴포넌트를 동기화 시키는 hook`이라고 표현하고 있다. **외부 system**의 예로는 `setInterval`과 같은 timer, `window.addEventListener`와 같은 event subscription이 있다.\n\nuseEffect hook은 크게 세가지 파트로 구분된다. (1) hook을 이용해 수행할 동작을 담은 `Setup 함수`, (2) 언제 수행할 지를 담는 `Dependencies`, (3) 수행하던 함수를 멈추기 위한 `cleanup`함수다.\n\n```jsx\nimport { useEffect } from \"react\"\nimport { createConnection } from \"./chat.js\"\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState(\"https://localhost:1234\")\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId) // (1)\n    connection.connect() // (1)\n    return () => connection.disconnect() // (2)\n  }, [serverUrl, roomId])\n  // ...\n}\n```\n\n위 예제를 보면 props로 `roomId`를, state로 `serverUrl`를 참조하고 있어 랜더링 이후 connection이 일어난다. dependency로 두 가지 데이터를 참조하고 있기 때문에의 변화가 있을 때, 리랜더링이 되는데 이때 기존에 connection을 하던 것을 끊고 새로운 connection과 연결해 외부와의 연결을 동기화 한다.\n\n면접에서 질문 받았던 질문 중 기억 남는 문제가 바로 `useEffect`와 관련되어 있었다. **컴포넌트 무한 랜더링** 문제를 어떻게 해결할 지에 대한 질문이었고 처음에 이해하지 못해 브라우저에서 무한 랜더링이 일어날 수 있는 상황에 대해 얘기했던 기억이 있다. 면접관님께서 친절하게 컴포넌트 **무한 랜더링** 상황을 설명해 주셨는데 다음 예제와 유사했다.\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setCount(count + 1) // infinite loop\n  }, [count])\n\n  return ...\n}\n```\n\n위 코드에서 무한 렌더링이 일어나는 이유는 랜더링 이후 useEffect로 `count` 업데이트 _→_ dependency의 `count`가 업데이트를 감지*→* useEffect로 `count`업데이트 ... 가 반복되기 때문이다.\n\n[codesandbox로 실행했을 때 나온 에러]\n\n![image-20230207193611288](../../../assets/img/2023-02-03-useState,useEffect, useRef, memo/image-20230207193611288.png)\n\n이러한 문제를 해결하기 위해서는 `count`를 useEffect의 dependency로 전달해 업데이트 하는 것이 아니라 useState의 functional Update를 이용해 해결할 수 있다.\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setCount(previousCount => previousCount + 1)\n  }, [])\n\n  return ...\n}\n```\n\n### useRef\n\n`useRef`는 리액트 공식문서에서 `랜더링이 되지 않을 값을 참조하는 hook`으로 소개하고 있다. 다양한 타입의 값을 할당할 수 있고 변경 가능한 값이다. 컴포넌트 내부에서 변경이 가능한 데이터로 state가 있는데 state와 구분되는 점은 값의 변경으로 인해 리랜더링이 되지 않는다는 점이다. 또한 일반 변수와 다른 점은 useRef로 저장된 값을 리랜더링 이후에도 같은 값을 가질 수 있다.\n\n`useRef`로 저장한 값을 변경할 때는 객체의 `current`속성을 직접 변경해야 한다.\n\n```jsx\nimport { useState, useEffect } from \"react\"\nimport { createConnection } from \"./chat.js\"\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState(\"https://localhost:1234\")\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId)\n    connection.connect()\n    return () => {\n      connection.disconnect()\n    }\n  }, [roomId, serverUrl])\n\n  return (\n    <>\n      <label>\n        Server URL:{\" \"}\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  )\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState(\"general\")\n  const [show, setShow] = useState(false)\n  return (\n    <>\n      <label>\n        Choose the chat room:{\" \"}\n        <select value={roomId} onChange={e => setRoomId(e.target.value)}>\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? \"Close chat\" : \"Open chat\"}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  )\n}\n```\n\n`useRef`를 사용하면서 주의해야 할 점은 **rendering과정에 ref 값을 쓰고 읽어서는 안된다**는 점이다.\n\n```jsx\nfunction MyComponent() {\n  // ...\n  // 🚩 Don't write a ref during rendering\n  myRef.current = 123\n  // ...\n  // 🚩 Don't read a ref during rendering\n  return <h1>{myOtherRef.current}</h1>\n}\n```\n\n`useRef`가 가장 많이 사용되는 경우는 react에서 **DOM요소를 참조할 때**다. DOM Node의 `ref` 속성으로 `useRef`로 선언한 변수를 연결하면 `useRef`객체의 `current`속성에 해당 DOM node를 참조할 수 있고, Node가 가지는 속성과 method를 사용할 수 있다.\n\n```jsx\nimport { useRef } from \"react\"\n\nexport default function CatFriends() {\n  const listRef = useRef(null)\n\n  function scrollToIndex(index) {\n    const listNode = listRef.current\n    // This line assumes a particular DOM structure:\n    const imgNode = listNode.querySelectorAll(\"li > img\")[index]\n    imgNode.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\",\n      inline: \"center\",\n    })\n  }\n\n  return (\n    <>\n      <nav>\n        <button onClick={() => scrollToIndex(0)}>Tom</button>\n        <button onClick={() => scrollToIndex(1)}>Maru</button>\n        <button onClick={() => scrollToIndex(2)}>Jellylorum</button>\n      </nav>\n      <div>\n        <ul ref={listRef}>\n          <li>\n            <img src=\"https://placekitten.com/g/200/200\" alt=\"Tom\" />\n          </li>\n          <li>\n            <img src=\"https://placekitten.com/g/300/200\" alt=\"Maru\" />\n          </li>\n          <li>\n            <img src=\"https://placekitten.com/g/250/200\" alt=\"Jellylorum\" />\n          </li>\n        </ul>\n      </div>\n    </>\n  )\n}\n```\n\n### Memo\n\nmemo는 부모로 전달받은 props가 변하지 않으면 컴포넌트의 리랜더링을 막는 방법이다. props만을 비교하기 때문에 컴포넌트 내부의 state 변화나 context API로 감싸져 있을 때 전달되는 값이 변할 때는 리랜더링이 된다.\n\nprops를 비교할 때 사용하는 방법이 `Object.is(a,b)`로 **얕은 비교**를 하기 때문에 object를 전달할 때는 useMemo나 useCallback와 같은 hook을 통해 memoization을 통해 저장해 같은 값을 전달하거나 필요한 props를 원시값 속성으로 전달할 수 있다.\n\n```jsx\nfunction Page() {\n  const [name, setName] = useState(\"Taylor\")\n  const [age, setAge] = useState(42)\n\n  const person = useMemo(() => ({ name, age }), [name, age])\n\n  return <Profile person={person} />\n}\n\nconst Profile = memo(function Profile({ person }) {\n  // ...\n})\n```\n\n면접을 통해 또 배웠던 부분은 memo를 사용 시에 두 번째 인자로 **custom comparison function**을 전달해 사용할 수 있다는 점이다. 이때 주의할 점은 모든 props들에 대해서 알고 있어야 하고 기존 얕은 복사보다 성능이 더 개선될 수 있을 때 사용해야 한다.\n\n```jsx\nconst Chart = memo(function Chart({ dataPoints }) {\n  // ...\n}, arePropsEqual)\n\nfunction arePropsEqual(oldProps, newProps) {\n  return (\n    oldProps.dataPoints.length === newProps.dataPoints.length &&\n    oldProps.dataPoints.every((oldPoint, index) => {\n      const newPoint = newProps.dataPoints[index]\n      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y\n    })\n  )\n}\n```\n\n### 마무리\n\n면접을 진행하면서 대답하지 못했던 부분들, 이상하게 답했던 부분들을 정리하면서 내가 아직 많이 부족하구나 더 많이 공부하고 더 빨리 성장하자는 맘이 생길 수 있었다. 특히 직접 react Hook 구현 코드를 따라 쳐보면서 만들자 react hook에 왜 클로저가 도입되었는지 이해할 수 있어 너무 좋은 공부가 되었다.\n\n[참조]\n\n- [황준일님 블로그: Vanilla Javascript로 React UseState Hook 만들기](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Make-useSate-hook/#_2-bottom-up-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8)\n- [리액트 공식문서](https://beta.reactjs.org/)\n"},{"excerpt":"🙋‍♂️ 타입추론 타입추론은 타입스크립트가 우리가 작성한 코드에 대해서 자동으로 타입을 추론해주는 것을 의미한다. 위 person 예제를 보면서 타입 추론이 정확하게 작동하고 있는 것을 볼 수 있다. 타입 추론을 이용했을 때 더 정확하게 타입이 정해지거나, 굳이 명시적으로 타입을 정할 필요가 없을 때에는 타입 구문을 생략하는 게 가독성을 높여준다. 위 예제에서…","fields":{"slug":"/2023-01-24-타입추론 (1)/"},"frontmatter":{"date":"January 24, 2023","title":"TS study: 타입 추론(1)","tags":["typescript"]},"rawMarkdownBody":"\n# 🙋‍♂️ 타입추론\n\n타입추론은 타입스크립트가 우리가 작성한 코드에 대해서 자동으로 타입을 추론해주는 것을 의미한다.\n\n```typescript\nconst person = {\n  name: \"so\",\n  born: {\n    where: \"asd\",\n    when: \"1233\",\n  },\n  died: {\n    where: \"asi\",\n    when: \"nov,201\",\n  },\n}\n\n// 타입스크립트로 추론된 타입\nconst person: {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n  died: {\n    where: string\n    when: string\n  }\n}\n```\n\n위 person 예제를 보면서 타입 추론이 정확하게 작동하고 있는 것을 볼 수 있다. 타입 추론을 이용했을 때 더 정확하게 타입이 정해지거나, 굳이 명시적으로 타입을 정할 필요가 없을 때에는 타입 구문을 생략하는 게 가독성을 높여준다.\n\n```typescript\ninterface Product {\n  id: string\n  name: string\n  price: number\n}\n\n// 명시적으로 타입을 다 정한 경우\nfunction logProduct(product: Product) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n  console.log(id, name, price)\n}\n\nfunction logProduct(product: Product) {\n  const { id, name, price } = product\n  console.log(id, name, price)\n}\n```\n\n위 예제에서 `Product` interface에서 타입을 이미 정의했기 때문에 굳이 함수 내부에서 정의할 필요가 없었다.\n\n그러면 항상 타입 추론에 맡기면 되는 걸까?\n\n앞서 정리했던 타입시스템을 통해 배웠던 **객체 리터럴**과 **함수의 인자와 반환값**은 명시적으로 타입을 정의해 줄 필요가 있다.\n\n먼저 객체 리터럴의 경우 명시적으로 타입을 정의하면 `잉여 속성 체크`가 동작해 작성된 타입과 비교해 오타나 오류를 잡는데 도움을 줄 수 있다.\n\n함수의 경우 반환 값을 통해 오류를 막을 수 있다. 다음 예제를 보자.\n\n```typescript\nconst cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string): Promise<number> {\n  if (ticker in cache) {\n    return cache[ticker] // Promise<number>가 아니라 에러\n  }\n  return fetch(`https://quotes.example.com/?q=${ticker}`)\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n}\n```\n\n위 코드는 이미 존재하는 값의 경우 cache 데이터를 가져오고 cache된 값이 없다면 새로 요청하는 함수다. 하지만 cache값이 없을 때 `number`로 반환되기 때문에 에러를 던져주는 것을 볼 수 있다.\n\n이처럼 반환 타입을 명시함으로써 코드 자체적으로 인자를 넣었을 때 결과 값을 예측해 문서로써 역할을 할 수 있으며, 기존의 명명된 타입을 그대로 이용할 수 있는 장점도 가진다. 아래 코드를 보자.\n\n```typescript\ninterface Vector2D {\n  x: number\n  y: number\n}\n\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y } // {x:number y:number}\n}\n\nfunction add(a: Vector2D, b: Vector2D): Vector2D {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n```\n\n반환값 타입도 동일하게 `Vector 2D`를 예상했지만 다른 타입으로 반환 값이 추론되는 것을 볼 수 있다.\n\n정리해보면 명시적 타입이 필요한 경우는 객체리터럴을 선언해 잉여속성체크가 필요하거나, 함수의 인자와 반환값에 필요하며, 대부분의 경우 타입 추론에 맡겨도 된다고 한다.\n\n## 📦 다른 타입에 다른 변수 쓰기\n\n자바스크립트는 동적 타입 언어이기 때문에 같은 변수에 다른 타입을 할당할 수 있지만 타입스크립트에서는 할당할 수 없다. 이 경우에 다른 타입을 할당하기 위해서 유니온 타입으로 타입을 더 좁힐 수 있다.\n\n```typescript\nlet id: string | number = \"12-34-56\"\nid = 123\n```\n\n하지만 이러한 경우에 오히려 string과 number의 공통 메소드만 제공해주는 등 사용하기 더 어려워진다. 차라리 **별도로 변수를 나누는 것**이 나은 방법이다.\n\n## 🎈 타입 넓히기\n\n타입스크립트가 타입을 추론할 때는 할당된 값을 통해 할당 가능한 값들의 집합을 유추한다.\n\n```typescript\ninterface Vector3 {\n  x: number\n  y: number\n  z: number\n}\n\nfunction getComponent(vector: Vector3, axis: \"x\" | \"y\" | \"z\") {\n  return vector[axis]\n}\n\nlet x = \"x\"\nlet vec = { x: 10, y: 20, z: 30 }\ngetComponent(vec, x) // Argument of type 'string' is not assignable to parameter of type '\"x\" | \"y\" | \"z\"'\n```\n\n위 예제에서 `let x= 'x'`로 선언되어 x변수에는 할당할 수 있는 타입을 고려해 string타입으로 추론했다. 그렇기 때문에 정확히 `\"x\" | \"y\" | \"z\"`가 필요한 `getComponent`함수의 인자로 전달 시 타입 에러가 발생했다.\n\n이러한 문제를 해결하기 위해서는 간단하게 `let`대신 `const`로 수정할 수 있다. `const`로 선언하면 `x`의 타입이 `'x'`가 되어 타입이 더 좁혀지기 때문에 앞서 발생한 에러를 막을 수 있다.\n\n하지만 `const`로 선언하는 방법은 객체와 배열에서는 여전히 문제가 된다. 배열의 경우의 `const x= [1,2,3]`라고 했을 때 `number[]`로 봐야할 지 `[number,number,number]`로 해야할 지 타입추론만으로는 어렵다.\n\n이러한 문제점을 해결하기 위해서는 먼저 명시적 타입을 전달해 주는 방법이 있다. 정확히 내가 원하는 타입으로 정해줄 수 있다.\n\n```typescript\nconst arr = [1, 2, 3] // number[]\nconst arr2: [number, number, number] = [1, 2, 3]\n```\n\n두 번째로는 `as const` 타입 단언을 통해 최대한 좁은 타입으로 추론하는 방법이 있다.\n\n```typescript\nconst arr = [1, 2, 3] as const // readonly [1,2,3]\n```\n\n## 🙏 타입 좁히기\n\n#### null 체크/ undefined 체크\n\n타입 좁히기를 내가 가장 많이 썼던 경우는 `null` 체크 또는 `undefined` 체크였던 것 같다. 책에서도 대표적인 예시로 null 체크를 보여준다.\n\n```typescript\nconst el = document.getElementById(\"foo\") // HTMLElement | null\nif (!el) throw new Error(\"Unable to find #foo\")\nel.innerHTML = \"Party Time\".blink()\n```\n\n위 예제에서 `el`값이 null이 될 수 있기 때문에 조건문으로 분기 처리를 해준 것을 볼 수 있다.\n\n#### instanceof와 내장 함수\n\n`instanceof`와 내장 함수를 이용해 타입을 좁힐 수 있다. `instanceof`를 이용 시에 중요했던 점은 런타임 연산자로 prototype chain에 해당 타겟이 있는지 확인하고 값을 확인하는 것을 이해하고 사용해야 한다.\n\n```typescript\nfunction contains(text: string, search: string | RegExp) {\n  if (search instanceof RegExp) {\n    search\n    return !!search.exec(text)\n  }\n  return text.includes(search)\n}\n\nfunction contains(text: string, terms: string | string[]) {\n  const termList = Array.isArray(terms) ? terms : [terms]\n  termList\n}\n```\n\n#### 속성체크와 discriminated Union Type\n\n또 다른 타입을 좁히는 방법으로 객체 타입의 경우 속성 체크를 이용해 좁힐 수 있고, 공통의 속성의 다른 값을 가지게 하는 `discriminated union` 구별된 유니온 타입을 이용할 수 있다. 실제 사용 경험은 속성 체크와 discriminated Union Type은 union Type으로 전달한 props를 분기 처리하기 위해 많이 사용했다.\n\n```typescript\ninterface A {\n  a: number\n}\ninterface B {\n  b: number\n}\n\nfunction pickAB(ab: A | B) {\n  if (\"a\" in ab) {\n    ab\n  } else {\n    ab\n  }\n  ab\n}\n\ninterface UploadEvent {\n  type: \"upload\"\n  filename: string\n  contents: string\n}\ninterface DownloadEvent {\n  type: \"download\"\n  filename: string\n}\n\ntype AppEvent = UploadEvent | DownloadEvent\n\nfunction handleEvent(e: AppEvent) {\n  switch (e.type) {\n    case \"download\":\n      e // DownloadEvent\n      break\n    case \"upload\":\n      e // UploadEvent\n      break\n  }\n}\n```\n\n#### 사용자 정의 타입 가드\n\n타입을 좁히기 위한 마지막 방법으로 함수를 이용해 내가 원하는 타입으로 좁혀줄 수 있다.\n\n```typescript\nfunction isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    el // HTMLInputElement\n    return el.value\n  }\n  el // HTMLElement\n  return el.textContent\n}\n```\n\n## 한꺼번에 객체 생성하기\n\n객체를 생성할 때 주의할 점은 동적으로 속성을 추가하기 보다 필요한 속성들을 한번에 생성해야 타입추론의 이점을 이용할 수 있다.\n\n```typescript\nconst pt = {}\npt.x = 3 // Property 'x' does not exist on type '{}'.\npt.y = 4 // Property 'y' does not exist on type '{}'.\n```\n\n위 예제에서는 처음 pt가 `{}`로 추론되기 때문에 에러가 발생했다. 이러한 원칙은 기존 객체 내용을 이용해 새로운 객체를 만들 때에도 동일하게 적용된다.\n\n```typescript\nconst pt = { x: 3, y: 4 }\nconst id = { name: \"Pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name // Property 'name' does not exist on type '{}'.\n```\n\n위 예제는 `namedPoint`는 동일하게 `{}`를 기준으로 추론이 되어 `Object.assign()`메소드를 이용해서 속성을 추가해도 에러가 발생되었다. 이점을 해결하기 위해서는 `spread operator`를 이용할 수 있다.\n\n```typescript\nconst namedPoint = { ...pt, ...id } // const namedPoint: {name: string; x: number; y: number;}\nnamedPoint.name\n```\n\n## 정리하며\n\n타입 추론은 엄청나게 편한 부분이지만, 더 정확하고 내가 원하는 타입으로 사용하기 위해서는 명시적으로 사용하거나 `as const`를 사용할 수 있다는 점을 알 수 있었다.\n"},{"excerpt":"😋 리액트의 기본 원리 면접을 통해 리액트의 기본되는 질문들을 받았을 때 라고 자신했었지만, 제대로 답변을 하지 못하는 경우도 많았다. 면접을 기회로 리액트를 더 깊이 있게 이해할 수 있도록 기본부터 다시 정리해보려 한다. 🎆 리액트란 리액트란 라고 정의할 수 있다. 또 다르게 설명하자면 으로도 말할 수 있다. 그렇기 때문에 컴포넌트의 데이터인 Props…","fields":{"slug":"/2023-01-23-리액트의-기본원리/"},"frontmatter":{"date":"January 23, 2023","title":"React study: 리액트의 기본 원리","tags":["react"]},"rawMarkdownBody":"\n# 😋 리액트의 기본 원리\n\n면접을 통해 리액트의 기본되는 질문들을 받았을 때 `안다`라고 자신했었지만, 제대로 답변을 하지 못하는 경우도 많았다. 면접을 기회로 리액트를 더 깊이 있게 이해할 수 있도록 기본부터 다시 정리해보려 한다.\n\n## 🎆 리액트란\n\n리액트란 `UI를 위한 자바스크립트 라이브러리`라고 정의할 수 있다. 또 다르게 설명하자면 `컴포넌트들의 집합`으로도 말할 수 있다. 그렇기 때문에 컴포넌트의 데이터인 **Props와 state에 대한 질문**과 컴포넌트를 **어떻게 설계하는 지**에 대해 질문을 받았었다.\n\n### ♟ 컴포넌트의 데이터: Props와 State\n\n컴포넌트는 부모로 부터 전달받아 수정할 수 없는 데이터인 **Props**와 자체적으로 가지며 업데이트 할 수 있는 데이터인 **State**가 있다. 두 가지 데이터의 변화는 **리랜더링의 Trigger**가 되어 해당 컴포넌트를 리렌더링하게 된다. 이때 중요한 것이 두 데이터의 변화를 알려주기 위해 **불변성**을 지켜야 한다는 점이다.\n\n![react flow](reactflow.png)\n\n원시형 타입의 경우 값이 변하면 새로운 메모리 주소에 값을 할당하기 때문에 `값의 변화 = 메모리 주소의 변화`로 볼 수 있다. 하지만 객체 타입인 객체, 배열, 함수 등은 실제 값이 아닌 객체를 저장하고 있는 메모리 힙의 참조값을 값에 할당하고, 속성 값이 변화한다고 해서 새로운 주소로 할당하지 않는다. 그렇기 때문에 객체 타입에서 `값의 변화 != 메모리 주소의 변화`가 된다.\n\n이점이 리액트에서 중요한 이유는 데이터 변화를 확인하기 위해 `얕은 비교`를 수행하는데, 얕은 비교는 메모리 주소에 할당된 값을 비교해 업데이트해야 할 지를 확인하기 때문이다. 원시형 타입의 경우 값의 변화가 곧 메모리 주소 값의 변화가 되지만 객체 타입은 속성 값이 변한다고 해서 메모리 주소 값의 변화가 되는 것이 아니기 때문에 직접 state를 수정해서는 안된다.\n\n객체의 속성이 바뀌면 객체 자체의 참조 값을 바꿔주기 위해서 spread operator, map, filter와 같이 원본 데이터를 수정하는 것이 아니라 새로운 객체를 만드는 방식으로 상태를 변화시켜, 리액트의 효율적인 상태 업데이트가 가능하게 된다.\n\n## 😀 제어 컴포넌트와 비제어 컴포넌트\n\n`제어 컴포넌트`와 `비제어 컴포넌트`는 면접에서 처음들은 단어였다. 각각에 대해 설명해 보라는 질문에 바로 잘 모르겠다 했지만 input과 form을 생각하면 답할 수 있을 것 같다고 힌트를 주셔서 `제어 컴포넌트`에 대해서 만 설명할 수 있었다.\n\n#### 제어 컴포넌트\n\n제어 컴포넌트는 model에 해당하는 data, 즉 상태와 바인딩되어 상태에 따라 값이 바뀌는 컴포넌트라고 할 수 있다. 예로 `input`의 경우 사용자의 입력을 통해 상태를 업데이트하고 업데이트한 상태를 `value`속성으로 전달해줘 **상태와 항상 동기화될 수 있게** 한다.\n\n```jsx\nimport { useState } from \"react\"\n\nconst App = () => {\n  const [value, setValue] = useState(\"\")\n  const handleChange = e => {\n    setName(e.target.value)\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        placeholder=\"Enter Name\"\n        value={value}\n        onChange={handleChange}\n      />\n      <button>Add</button>\n    </form>\n  )\n}\n\nexport default App\n```\n\n익숙한 위 코드 모습에서 과정을 정리해보면 1) 사용자가 입력한다. 2) 입력된 값을 `onChange`함수를 통해 상태를 변경한다. 3) 상태를 value로 반영한다 로 세가지 step으로 볼 수 있다.\n\n### 비제어 컴포넌트\n\n비제어 컴포넌트는 제어 컴포넌트와 달리 입력에 따라 상태를 업데이트 시키고 상태와 컴포넌트를 바인딩하는 것이 아니라, DOM요소에 접근해 입력된 값을 받아오는 방식이다.\n\n```jsx\nimport { useRef } from \"react\"\n\nconst App = () => {\n  const inputRef = useRef()\n\n  const handleSubmit = event => {\n    event.preventDefault()\n    const name = inputRef.current.value\n    console.log(\"Input value - \", this.inputRef.current.value)\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Uncontrolled input </label>\n        <input type=\"date\" name=\"data\" id=\"date-input\" ref={this.inputRef} />\n      </div>\n\n      <button type=\"submit\">Submit</button>\n    </form>\n  )\n}\n\nexport default App\n```\n\n위 코드에서 과정을 정리해보면 1) 사용자가 입력한다 2) 버튼을 누른다 3) `submit`이벤트가 발생하고 DOM요소에 접근해 값을 콘솔로 호출한다로 정리할 수 있다.\n\n이렇게 두 가지 과정을 비교해 보았을 때 가장 큰 차이점은 **상태와 동기화가되냐 안되냐**라는 점이다. 제어 컴포넌트의 경우 state가 바뀔 때마다 값이 바뀌기 때문에 리랜더링이 계속해서 일어나게 되는 반면 비제어 컴포넌트는 state와 상관없이 이벤트가 발생했을 때만 값을 참조한다. 그렇기 때문에 둘 중에 어떤 것을 사용할 지는 **데이터를 실시간에 맞게 UI를 보여줘야하냐 아니냐**로 구분해서 사용할 수 있다.\n\n### 🧨 리액트의 re-rendering 조건과 불필요한 re-rendering 막기\n\nRe-rendering의 조건은 크게 2가지로 볼 수 있다.\n\n- Props와 State의 변화\n- 부모 컴포넌트의 re-rendering\n\n앞서 설명한 Props는 부모로 부터 전달받은 데이터이기 때문에 전달하는 데이터가 객체타입일 경우에 부모가 re-rendering되었을 때 항상 새롭게 데이터가 만들어져 전달된다. 왜냐하면 `{}!=={}`로 자바스크립트에서 객체는 항상 새로운 값이기 때문이다. 새로운 값이 props로 전달되므로 자식 컴포넌트의 re-rendering으로 이어진다.\n\n`리액트가 성능 보장하는 방법`에 대해 정리한 이전 글처럼 불필요한 자식의 re-rendering을 막기 위해서는 props로 전달하는 변수,함수가 항상 새롭게 만들어지지 않아도 된다면 `useMemo`와 `useCallback`을 통해 메모이제이션을 하고 dependency가 바뀔 때만 새롭게 전달하는 방식을 사용할 수 있다. 또한 `Memo`를 이용해 컴포넌트로 전달되는 Props의 변화가 없다면 re-rendering을 하지 않게 성능을 개선할 수 있다.\n\n## 🕶 리액트의 데이터 바인딩과 Flux 패턴\n\n`데이터 바인딩`이란 단어는 최근 면접을 통해 처음 듣게 되었다. 처음 듣고 당황해서 `혹시 데이터 바인딩에 대해 조금만 더 알려주실 수 있을까요?`라고 다시 여쭤봤고, 면접관님께서 친절하셔서`리액트는 단방향 데이터 바인딩일까요 양방향 데이터 바인딩일까요`라고 풀어서 설명해주셨다. 데이터바인딩에 대해서 처음 들어보지는 않았지만 분명 잘 몰라서 생긴 해프닝이었다.\n\n데이터 바인딩이란 페이지에 보여질 **View와 데이터를 연결하는 것**을 의미한다. 데이터 바인딩은 단방향과 양방향으로 나뉠 수 있는데 단방향의 경우 데이터가 변경되면 템플릿과 함께 결합해 뷰를 만드는 것을 의미하고, 양방향의 경우 단뱡향과 같이 데이터의 변경을 템플릿과 함쳐 view로 반영하는 것과 함께 View 변화를 데이터에 반영하는 것을 의미한다.\n\n![flux](flux.png)\n\n리액트는 **단방향 데이터 바인딩**을 이용한다. 컴포넌트 내부의 단방향 데이터 바인딩은 useState를 통해 상태를 만들고, 만든 상태를 JSX를 통해 HTML(View)로 반영한다. UI를 통해 데이터를 갱신하기 위해서는 이벤트를 이용해 데이터를 업데이트 할 수 있다.\n\n컴포넌트 간의 단방향 데이터 바인딩은 부모 컴포넌트에서 자식 컴포넌트로 데이터가 **props**를 통해 전달되는 구조를 가지고 있다. 이때 부모의 상태를 자식 컴포넌트에서 변화시키기 위해서는 props로 부모 상태를 업데이트할 수 있는 setState를 props로 전달해 해결할 수 있다.\n\n이러한 구조를 통해 가지는 장점은 하나의 방향으로 데이터가 진행되기 때문에 코드 이해가 쉽고 디버깅이 쉬운 장점을 가진다. 단점은 변화를 감지하고 업데이트하는 코드를 항상 작성해야하는 것으로 `<input value={name}/>`에서 `onChange` 이벤트 함수를 항상 전달해줘야하는 이유를 알 수 있었다.\n\n단방향 데이터 바인딩으로 리액트가 이루어져있는 것을 이해하면서 이러한 데이터와 View를 어떻게 관리할 건지에 대해 정리한 것이 바로 `디자인 패턴`이라는 것을 깨닫게 되었다. 최근 면접에서도 디자인패턴에 대해 물어보았지만 아는게 `MVC`밖에 없어... 그것밖에 설명할 수 없었다.\n\n![mvc](mvc.png)\n\n양방향 데이터바인딩으로 MVC패턴을 사용하던 Facebook은 점점 복잡해지고 예측하지 못하는 단점을 해결하기 위해 단방향 아키택처인 **Flux 패턴**을 도입한다.\n\n![mvc-2](mvc-2.png)\n\n### Flux 패턴\n\nFlux 패턴은 사용자가 View에서 `Action`을 발생시키면 `Dispatcher`를 통해 데이터가 저장되어있는 `Store`로 전달되어 데이터가 변경되고, `View`를 업데이트하게 된다. 이러한 Flux 패턴은 당시에는 개념적인 아키텍처였지만 곧이어 이것을 구현한 **Redux**가 등장하게 된다.\n\n![flux](flux.png)\n\n### Redux\n\nRedux는 자바스크립트 라이브러리로 Flux 패턴에 **Reducer**를 더해 구현했다. Redux는 Flux와 같이 단방향 데이터 흐름을 가져가며, 하나의 `store`에 상태를 보관하고 `Reducer`를 통해 전달받은 Action에 따라 어떻게 상태를 업데이트 할지 처리한다. 각각에 대해서 좀 더 자세히 정리해보자.\n\n![redux](redux.webp)\n\n- Action: 액션은 상태에 어떤 변화가 필요할 때 발생시키는 것으로 예를 들면 버튼 클릭 시 새로운 Todo를 추가하기 위해 다음과 같은 Action을 만들 수 있다. 주로 Action을 만들 때 객체 내 type 속성이 반복되서 사용되기 때문에 액션 객체를 반환하는 `Action Creator` 함수를 이용한다.\n\n```javascript\nexport function addTodo(data) {\n  return {\n    type: \"ADD_TODO\",\n    data,\n  }\n}\n```\n\n- Reducer: Reducer는 Action과 현재 상태를 인자로 받아 새로운 상태로 반환하는 **순수 함수**다. 직접 상태를 변경하는 것이 아니라 useState와 같이 불변성을 지켜 수정된 복사본으로 상태를 업데이트 한다. 위 예제의 \"ADD_TODO\" action이 전달되었다면 Todo[]에 새로운 Todo를 추가하는 로직을 작성할 수 있다. 이렇게 Reducer를 작성하다보면 엄청나게 길어질 것이 예상된다. sub-Reducer를 만들어 각 도메인별로 구분해서 처리 로직을 작성하고 Root-reducer로 합쳐서 반영하게 할 수 있다.\n\n  ```javascript\n  function Todo(state, action) {\n    switch (action.type) {\n      case \"ADD_TODO\":\n        return [...state, action.data]\n      default:\n        return state\n    }\n  }\n  ```\n\n- Store: Store는 하나만을 가지고 Reducer를 전달해 reducer로 변경된 상태를 보관하는 역할을 한다.\n\nRedux에는 중요한 세가지 원칙이 있는데, 먼저 **Store는 단 하나**여야하며, 두 번째로 상태는 **불변성**을 지켜야한다는 점, 마지막으로 Reducer는 **순수함수**여야한다. 이중에서 순수함수라는 점은 인자를 수정하거나, 외부의 변수를 변경하거나 참조하지 않아야한다는 것을 의미한다. 이것은 불변성을 지켜야하는 것과 동일하게 state 변경 시 state의 참조값만 비교해서 업데이트하기 때문에 반환된 상태 값을 직접 변경하지 않아야 한다.\n\n## 🙄 정리하며\n\n리액트 관련된 면접 질문들을 한번에 정리하면서 여전히 모르는 점이 많지만 항상 기술은 문제를 해결하기 위해 발전되었다는 것을 느낄 수 있었다. 보다 명확하게 이야기할 수 있게 계속해서 업데이트하고 다시 작성해나갈 예정이다.\n\n[참조]\n\n- [adjh54님의 티스토리 글](https://adjh54.tistory.com/49)\n\n- [hyunmin님의 글](https://blog.hyunmin.dev/15)\n\n- [tabnine](https://www.tabnine.com/blog/angular-vs-react/)\n\n- [테오님의 글](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94#%EA%B3%A0%EC%A0%84-%EC%A4%91%EC%9D%98-%EA%B3%A0%EC%A0%84-mvc-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)\n"},{"excerpt":"🙄 Vite를 사용한 계기 CRA(Create React App)는 리액트에서 공식적으로 밀어주는(?) 보일러 플레이트이다. 기존에 잘 사용해왔기 때문에 기업 과제들을 수행하면서 사용하려 했지만, 원티드 프리온보딩 교육을 받으며 CRA보다 속도가 훨씬 빠른 라는 게 있다는 멘토님의 이야기가 떠올라 사용해보았다. Vite를 사용하면서 실제 빌드속도와 dev…","fields":{"slug":"/2023-01-23-Vite와-번들러/"},"frontmatter":{"date":"January 23, 2023","title":"Vite는 왜 빠를까, 번들러에 대한 정리","tags":["vite","번들러","javascript"]},"rawMarkdownBody":"\n## 🙄 Vite를 사용한 계기\n\nCRA(Create React App)는 리액트에서 공식적으로 밀어주는(?) 보일러 플레이트이다. 기존에 잘 사용해왔기 때문에 기업 과제들을 수행하면서 사용하려 했지만, 원티드 프리온보딩 교육을 받으며 CRA보다 속도가 훨씬 빠른 `Vite`라는 게 있다는 멘토님의 이야기가 떠올라 사용해보았다. Vite를 사용하면서 실제 빌드속도와 dev 서버가 켜지는 속도가 너무 빠르다는 것을 직접 느낄 수 있었는데, **어떻게 Vite가 기존의 CRA보다 빠를 수 있을지** 이해하기 위해 `번들러`에 대해서 먼저 알아보게 되었다.\n\n## ❓ 자바스크립트가 없는 것\n\n자바스크립트는 **자체적인 모듈 시스템이 없다**. 당시에 작은 프로젝트에 테스트 용으로 사용될 자바스크립트였기 때문에 여러 개의 파일들을 만들고 불러오는 모듈 문법이 없었다. 이러한 점을 해결하기 위해 가장 먼저 나왔던 모듈 문법이 `Common JS`방식으로 `require`과 `module.export`로 파일을 불러오고 전달할 수 있게 연결했고, `npm`을 통해서 미리 만들어 모듈로 자바스크립트 코드들을 받아 올 수 있었다. 하지만 전체 모듈의 많은 양의 코드들을 받아오다 보니 자바스크립트 파일 자체의 크기가 커지는 어려움이 생기게 되었고, 언제 어떤 모듈을 불러와야 할 지에 따른 시점의 문제점도 발생했다.\n\n### ❗ 번들러 등장\n\n두 가지 문제점을 한번에 해결하기 위한 방법으로 나온 것이 바로 `번들러`다. 번들러를 이용하게 되면 모듈 내부에서 **필요한 부분 만**을 가져와 기존의 전체를 가져왔던 용량 문제를 해결할 수 있으며, 여러 개의 파일이 아니라 하나의 JS 파일로 만들기 때문에 모듈의 순서와 언제 불러와야 할 지에 대한 고민도 동시에 해결할 수 있었다.\n\n이러한 번들러로 가장 유명한 것은 아마 `Webpack`이라 할 수 있을 것 같다. 기존에 내가 사용하던 CRA는 바로 이 `Webpack`을 번들러로 사용한다. `Webpack`은 단순히 번들러의 역할 뿐 아니라 HMR (Hot module Replacement), code splitting, CSS, HTML, asset 등 종합적으로 지원해주는 tool로 현재까지 안정적인 번들러로 사용되고 있다. CRA로 리액트 프로젝트를 실행할 때 새로 고침 없이도 코드가 반영되는 점이 webpack의 HMR 기능 덕분이라는 것을 공부하며 Webpack의 기능을 좀 더 이해하게 되었다.\n\n![webpack](webpack.png)\n\n### 📌 번들러의 문제점과 ES Build의 등장\n\n`Webpack`과 같은 번들러의 등장은 JS에 존재하지 않는 모듈 시스템의 문제점을 해결했지만 **속도**의 문제점을 가지게 되었다. 그 이유는 여러 JS파일을 하나로 항상 만들어줘야 하기 때문에 코드 수정이 있을 때마다 새롭게 빌드가 필요했고 프로젝트가 커지면 커질수록 자바스크립트 파일이 많아져 빌드에 필요한 시간이 오래 걸리게 되었다.\n\n이러한 문제점을 해결하기 위해 새로운 도구로 `ES Build`가 등장하게 된다. `ES Build`는 기존 번들러들의 속도보다 100배 이상 빠른 빌드 속도를 가졌다. 이렇게 빠른 속도를 가지고 있는 이유는 JS를 기반으로 만들어진 기존 번들러들과 달리 Go 언어로 작성되어 빠른 빌드가 가능했기 때문이었다. 하지만 번들러로써만 사용되는 것이 아니라 HMR, code splitting과 같은 기능들이 종합적으로 제공되던 `Webpack`이었기 때문에 복잡한 어플리케이션에서 ES Build가 대체할 수는 없었다.\n\n![esbuild](esbuild.png)\n\n### ✨Vite의 등장\n\n웹이 발전하면서 브라우저 자체에서 **ESM(**ES Modules)이 추가된다. `import`와 `export`로 작성된 자바스크립트 모듈화 방식을 번들러 없이 `<script type=\"module\">`을 이용할 수 있게 된다. Go 언어의 병렬 처리로 높은 성능을 가진 **ES Build**와 브라우저에서 지원해주는 **ESM**을 이용해 `Vite`가 탄생하게 된다.\n\n![vite](vite.png)\n\nVite는 개발할 때 사용하는 개발 서버를 구동할 때 빠르게 반영하기 위해 크게 `dependencies`와 `source code`로 구분해, 개발 시에 내용이 바뀌지 않을 `dependency`의 코드는 **ES Build**로 사전 번들링을 하고, 계속해서 수정해야 하는 `source code` 는 **브라우저의 ESM**을 이용해서 반영할 수 있게 처리했다. ESM은 요청받은 모듈만 전달하기 때문에 훨씬 빠르게 개발 서버에 반영이 가능하다.\n\n![devserver](devserver.png)\n\n![esm](esm.png)\n\n배포 시에는 ESM이 동작해야 하기 때문에 모던 JS를 지원하는 버전을 타겟으로 한다. 빌드 시에 아직 ESBuild가 Code splitting, CSS처리 관련 기능이 부족하기 때문에 ES Build 대신에 `Rollup`을 이용한다고 한다.\n\n## 😁 정리하기\n\nVite를 사용해서 제출한 한 기업의 면접에서 `CRA 대신 Vite를 이용해서 과제를 하셨네요. Vite가 왜 CRA보다 빠른지 아시나요? `라는 질문에 답하지 못했다... 기술을 알고 사용한다고 생각했었는데 그냥 도입한 모습이 되어버렸다. 이제는 `ES Build와 브라우저의 ESM을 이용한 번들링으로 기존 CRA의 WebPack보다 빠른 성능을 가집니다`라고 대답할 수 있었다. 앞으로도 어떠한 기술을 사용할 때 항상 `왜`를 더 고민해보자.\n\n[참조]\n\n- [Evan You와 함께 Vite 배우기 - Vue ministry](https://www.youtube.com/watch?v=DkGV5F4XnfQ)\n- [Vite 이야기 (feat. Svelte)](https://velog.io/@teo/vite)\n- [와 Vite 쓰면 리액트 10배 빨라짐 (과장아님)](https://www.youtube.com/watch?v=iX3Nu1FcZKA)\n"},{"excerpt":"😁 리액트의 성능 보장방식 저번 면접 시간에 리액트에 대한 질문이 들어왔을 때, 안다고 자신했지만 돌아보니 너무 부족했었던 모습에 리액트 문서 자체를 다시 꼼꼼히 읽고 정리해야겠다는 생각이 들었다. 그중에 이번에 기본 동작원리와 성능과 관련된 useMemo와 useCallback에 대해 정리해 보려 한다. ❓ 왜 리액트를 써야 할까? 먼저 리액트를 쓰면서…","fields":{"slug":"/2022-12-20-리액트-성능보장/"},"frontmatter":{"date":"January 23, 2023","title":"React study: 리액트가 성능을 보장하는 방법","tags":["react","performance"]},"rawMarkdownBody":"\n# 😁 리액트의 성능 보장방식\n\n저번 면접 시간에 리액트에 대한 질문이 들어왔을 때, 안다고 자신했지만 돌아보니 너무 부족했었던 모습에 리액트 문서 자체를 다시 꼼꼼히 읽고 정리해야겠다는 생각이 들었다. 그중에 이번에 기본 동작원리와 성능과 관련된 useMemo와 useCallback에 대해 정리해 보려 한다.\n\n## ❓ 왜 리액트를 써야 할까?\n\n먼저 리액트를 쓰면서 `내가 왜 리액트를 사용하는지`에 대해서 많이 고민하지 못했다.\n\n개인적으로 내가 느낀 리액트의 장점은 `자바스크립트를 적극적으로 사용한다`는 점이었다. 물론 Vue도 자바스크립트를 사용하지만 리액트는 라이브러리이기 때문에 좀 더 자유롭게 자바스크립트를 사용할 수 있고 잘 사용하기 위해서, 자바스크립트 자체를 좀 더 공부하게 되었다. 이점이 오히려 러닝 커브가 낮다는 점에서 Vue의 장점이 될 수 있지만 **하나의 언어를 정말 잘하고 싶었던** 나에게 있어서는 리액트의 장점이 되었다.\n\nVue와 React를 모두 사용해보았다면 더 잘 정리할 수 있을 것 같아, 이후에 조금씩 시도하면서 직접 느껴보고 정리해보면 좋을 주제라고 생각되었다.\n\n## ❗ 리액트가 해결하고 싶었던 문제\n\n이전에 CSR과 SSR 글과 Critical Rendering path에 대해 글을 쓰면서 정리했지만 SPA은 **MPA(Multi Page Application)의 문제점**을 해결하기 위해서 나오게 된 해결 방법이다. MPA의 문제점은 페이지 이동에 따라 HTML 전체를 새롭게 가져와야 하는 불필요한 비용이 발생한다는 점이었다.\n\n이를 해결하기 위해 하나의 html에 javascript을 이용해 동적으로 DOM요소를 변형하는` SPA (Single Page Application) 방식`이 제안되었고 여기에 대표적인 라이브러리가 바로 **리액트**이다.\n\n하지만 SPA는 DOM요소를 자바스크립트로 직접 건드리기 때문에 Critical Rendering Path에서 브라우저가 그려줘야하는`layout -paint- composite`과정이 다시 일어나야 해서 성능이 큰 문제가 될 수 있다. 이러한 성능 문제를 해결하기 위해서 리액트는 자체적인 <u>V-DOM을 이용한 Reconcilation</u>으로 해결한다. 두가지에 대해서 알아보자.\n\n## 🎈 V-DOM과 Reconcilation\n\nV-DOM은 리액트 자체의 가상의 DOM이다. 리액트는 기본적으로 UI를 업데이트 하기 위해, DOM을 변경하기 위해 **상태**를 사용한다. 이 상태에 따라 매번 DOM자체가 바뀌게 된다면 성능에 문제가 생기기 때문에 리액트는 자체적으로 `V-DOM`에 업데이트 해야할 부분을 먼저 반영한다. 이때 V-DOM을 DOM에 반영할 타이밍을 관리해주는 스케줄러가 있어, 적절한 타이밍에 V-DOM과 실제 DOM을 비교해 필요한 부분을 반영하는데 이것을 **Reconcilation**이라고 한다.\n\n이렇게 V-DOM자체로 랜더링을 하는 것이 아니기 때문에 비용이 적게 들면서 매번 DOM을 업데이트하지 않고 필요한 DOM변화를 모아서 한번에 처리해 성능을 최적화한다. 이러한 과정이 이전에 많이 쓰이던 라이브러리인 JQuery와 차이가 나는 부분으로 DOM을 직접 변경하는 JQuery와 달리 필요한 변화를 비교하고 그부분만 업데이트해 훨씬 성능이 좋다.\n\n![vdom](vdom.png)\n\n**Reconcilation**은 **V-DOM을 이용해 실제 DOM과 비교해 반영하는 과정**이라고 정의할 수 있다. 이때 중요한 점은 비교하는 것 자체에도 성능이 문제가 될 수 있다는 점이다. 리액트 홈페이지에 비교 알고리즘으로 `state of art algorithm`을 이용한다면 O(n^3)의 시간 복잡도를 갖기 때문에 성능에 큰 문제가 된다고 한다. 그렇기 때문에 리액트는 성능을 고려한 비교를 위해 두가지 가정을 한다.\n\n첫번째는 <u> element의 type이 달라지면 다른 트리를 만든다는 것</u>이고, 두번째로 개발자가 직접 child element에 <u>key</u>를 이용해 바뀌지 않을 곳을 알려줄 수 있다는 점이다. 이 두가지 가정을 통해서 reconcilation은 O(n)의 시간복잡도를 갖게 된다.\n\n각각에 대해 자세히 정리해보자\n\n### Elements Of Different Types\n\n먼저 element의 tag 자체가 달라진다면, 예를 들면 `<a>` 에서 `<button>`으로 바뀌었다고 하면 자식을 더 이상 비교하지 않고 거기서 바로 새로운 DOM 트리를 만들고 아래 자식 요소들이 업데이트된다. 이때 tag는 같지만 className과 같은 attribute가 달라질 경우에는 DOM요소는 그대로 두고 attribute만 바꿔 반영한다.\n\n### Key\n\nkey를 정해주어야 할때는 보통 배열의 요소를 mapping해줄 때 사용한다. 이때 key를 전달하지 않으면 리액트는 error를 던진다. 그 이유는 같은 tag가 반복되는 상황에서 순서만을 이용하게 되면 DOM요소가 변경되었을 때 전체를 다 변경해야하는 불필요한 비용이 발생하기 때문이다.\n\n```jsx\n// DOM\n<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n\n// VDOM\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n```\n\n위 코드와 같은 경우 react는 순서만으로 비교해 모든 요소가 다 바뀌었다고 이해하고 전체를 다 새롭게 DOM요소를 만든다. 이점을 해결하기 위해서 key를 이용한다면 내부 순서와는 상관없이 key값이 바뀐 요소만 찾아서 DOM을 업데이트해 최적화가 가능하다. 그렇기 때문에 **고유한 값**으로 key를 정해주는 것이 중요하며 key로 index를 직접 넘기면 안된다는 것이 이해가 되었다.\n\n```jsx\n<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n```\n\n## 😲 Reconcilation 피하기\n\n리액트의 기본원리는 **상태와 props가 바뀌면 해당 컴포넌트를 리랜더링**하는 것이다. 앞서 정리한 내용들은 이러한 변화로 V-DOM가 바뀌었을 때 V-DOM과 실제 DOM을 어떻게 비교해서 반영하냐에 관한 것이었다. 하지만 이렇게 최적화해서 리랜더링을 한다해도 리랜더링 자체는 비용이 드는 작업이다. 그렇기 때문에 기존의 UI자체를 재사용해, 리랜더링 자체를 줄여줄 수 있다면 더 좋은 방법이 된다.\n\n기존의 UI를 재사용할 지를 개발자가 성능을 고려할 수 있는 방법으로 리액트는 `React.Memo`와 `useCallback,useMemo API`를 지원한다.\n\n### React.Memo\n\n리액트의 기본 원리에 따라서 상태가 바뀌면 해당 컴포넌트와 자식 컴포넌트를 모두 리랜더링을 해야 하지만, 자식 요소 중에서 전달받은 props가 변하지 않아서 UI를 변화하지 않아도 되는 경우가 존재한다. 이럴 때는 이전 UI를 그대로 사용하는 것이 더 효율적인데 이때 사용할 수 있는 것이 `React.Memo`이다.\n\n```jsx\nimport { memo } from \"react\"\n\nfunction SomeComponent(props) {\n  // ...\n}\n\nconst MemoizedComponent = memo(SomeComponent)\n```\n\nReact.memo는 해당 컴포넌트를 감싸는 HOC (Higher Order Component)로 컴포넌트의 이전 props와 state 변화로 사용될 props 비교해서 차이가 있을 때에만 리랜더링을 하게한다.이때 중요한 것은 props를 비교하는 방식인데 `얕은 비교`를 통해 비교한다.\n\n#### 얕은 비교와 불변성\n\n자바스크립트의 비교는 데이터의 메모리 주소를 이용해 일치 여부를 확인한다. 원시형의 경우 값이 변경되면 새로운 메모리 주소에 변경된 데이터를 저장해 메모리 주소 자체로 비교해도 된다.\n\n하지만 객체 타입은 해당 객체의 데이터를 보관하고 있는 참조값을 메모리 주소에 할당하기 때문에 내부 데이터가 바뀌어도 메모리 주소가 동일해, 주소값만을 비교하는 것이 아니라 내부 값이 변했는지 일일이 확인해야 한다. 그렇기 때문에 리액트에서는 비교의 편의를 위해서 **객체의 불변성**을 지키는 방식을 이용한다. 객체의 불변성을 지키게 되면 내부 데이터가 바뀌기 위해서는 새로운 객체로 바꾸어야 하기 때문에 원시형 타입과 같이 주소값만으로도 비교가 가능하게 된다.\n\n그래서 리액트에서 객체상태를 변화 시키기 위해서는 state를 직접 mutate하는 게 아니라, **setState**를 구조분해할당을 이용한 방식으로 상태변화를 한다. 구조분해할당은 key로 전달된 값은 같지만 감싸고 있는 객체는 새롭게 할당하기 때문에 리액트에게 상태변화를 알려줄 수 있고, 자식으로 값을 전달했을 때 바뀐 부분만 업데이트 할 수 있게 된다.\n\n**props 자체는 매번 랜더링에 따라 새롭게 만들어져 비교가 의미가 없다**. 비교를 위해서는 props 내부의 key를 돌면서 비교를 하게 되는데 값들 중에서 하나라도 false가 나오게 된다면 리랜더링이 필요하다고 판단하고 리랜더링을 한다.\n\n![compare](compare.png)\n\n### useCallback과 useMemo\n\nReact.Memo는 컴포넌트 자체의 props를 이용해서 리랜더링을 해야할 지를 고민한다면, **컴포넌트 내부의 데이터**를 저장해두고 불필요한 업데이트를 막아 효율적으로 사용하는 방법으로, **useCallback과 useMemo**가 있다.\n\n함수형 컴포넌트는 매 리랜더링때마다 새롭게 실행되기 때문에, 그때마다 변수와 함수가 새롭게 생성되는 특징을 가진다. 만약에 이 변수들과 함수가 자식 컴포넌트에 전달된다면 React.Memo로 컴포넌트를 감싸더라도 전달되는 값이 계속해서 새로운 값으로 전달되기 때문에 결국 React.Memo로 감싸진 컴포넌트도 리랜더링이 될 수 있다.\n\n#### useMemo(callbackFunction, deps)\n\nuseMemo는 값을 저장할 수 있는 함수로 반환하는 값을 저장하게 되고, deps로 전달된 값이 변할 때만 새롭게 생성한다.\n\n```jsx\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])\n```\n\n#### useCallback(callbackFunction, deps)\n\nuseCallback은 useMemo로 저장하던 함수를 좀 더 간단하게 저장할 수 있게 도와주는 api로, useMemo와 동일하게 deps로 전달된 값이 변할 때 새롭게 생성된다.\n\n```jsx\nconst memorizedFunction = useMemo(() => () => console.log(\"Hello World\"), [])\n\nconst memorizedFunction = useCallback(() => console.log(\"Hello World\"), [])\n```\n"},{"excerpt":"🎚 타입 시스템(3) 타입시스템에 대한 정리 중 마지막으로 제네릭, 인덱스 시그니처, Array 타입과 readonly에 대해 정리해보려 한다. 🕹 제네릭 타입스크립트를 사용할 수록 느끼는 점은 타입을 다룬다는 것은 추가적인 변수와 함수를 다루는 것 같았다. 그 이유는 변수를 재 사용하고 반복되는 로직은 함수로 분리하듯 타입의 재사용성을 고려해야 했기 때…","fields":{"slug":"/2023-01-16-타입시스템-3/"},"frontmatter":{"date":"January 16, 2023","title":"TS study: 타입 시스템 (3)","tags":["typescript"]},"rawMarkdownBody":"\n# 🎚 타입 시스템(3)\n\n타입시스템에 대한 정리 중 마지막으로 **제네릭, 인덱스 시그니처, Array 타입과 readonly**에 대해 정리해보려 한다.\n\n## 🕹 제네릭\n\n타입스크립트를 사용할 수록 느끼는 점은 타입을 다룬다는 것은 추가적인 변수와 함수를 다루는 것 같았다. 그 이유는 변수를 재 사용하고 반복되는 로직은 함수로 분리하듯 타입의 재사용성을 고려해야 했기 때문이다. 코드 반복을 줄이려는 노력은 **DRY(Don't Repeat Yourself)**로 불리는 프로그래밍의 기본 원칙으로 타입에도 적용된다.\n\n### 1. 타입 네이밍\n\n중복되는 변수가 있다면 하나의 상수로 정해서 사용하듯이 타입에 이름을 붙여서 사용해 중복을 제거할 수 있다.\n\n```typescript\n// 네이밍 전\nfunction distance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\n// 네이밍 후\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction distance(a: Point2D, b: Point2D) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n```\n\n위 예제는 x, y의 타입을 정리한 오브젝트 타입이 반복되는 상황이다. 이점을 해결하기 위해 `Point2D`로 interface를 정의해 서로 다르게 정해져있던 타입을 하나로 정리해줄 수 있다. 이러한 방법은 앞서 정리한 함수 표현식으로 매개변수와 반환 값의 타입을 정리했던 것과 같다.\n\n```typescript\n// 네이밍 전\nfunction get(url: string, opts: Options): Promise<Response> {}\nfunction post(url: string, opts: Options): Promise<Response> {}\n\n// 네이밍 후\ntype HTTPFunction = (url: String, opts: Options) => Promise<Response>\nconst get: HTTPFunction = (url, opts) => {}\nconst post: HTTPFunction = (url, opts) => {}\n```\n\n### 2. extends와 intersection 연산자 (&)\n\n하나의 타입이 있고 해당 타입의 속성에 다른 속성을 추가한 타입을 만들 때 새롭게 만들기 보다 앞서 배웠던 `extends`와 `&`를 이용해 속성을 추가할 수 있다.\n\n```typescript\n// 변경 전\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\ninterface PersonWithBirthDate {\n  firstName: String\n  lastName: string\n  birth: Date\n}\n\n// 변경 후\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\ninterface PersonWithBirthDate extends Person {\n  birth: Date\n}\n\ntype PersonWithBirthDate = Person & { birth: Date }\n```\n\n### 3. 부분 타입\n\n기존에 정의한 타입의 일부분 속성을 정의할 때 새롭게 정의하고 확장해서 사용했다. 하지만 논리적으로 맞지 않다고 느낀 적이 많았는데 책에서는 `인덱싱`을 이용해 중복을 제거하는 방법을 제시한다.\n\n```typescript\ninterface State {\n  userId: string\n  pageTitle: string\n  recentFiles: string[]\n  pageContents: string\n}\n\ntype TopNavState = {\n  userId: State[\"userId\"]\n  pageTitle: State[\"pageTitle\"]\n  recentFiles: State[\"recentFiles\"]\n}\n```\n\n위 방법을 이용하면 부분 타입을 정의할 수 있다. 하지만 일일이 속성을 나열해 반복되는 부분이 있다. 이점을 해결하기 위해 `mapping`을 이용할 수 있다,\n\n```typescript\ntype TopNavState = {\n  [k in \"userId\" | \"pageTitle\" | \"recentFiles\"]: State[k]\n}\n\ntype TopNavState = Pick<State, \"userId\" | \"pageTitle\" | \"recentFiles\">\n//  type Pick<T, K extends keyof T> = {\n//     [P in K]: T[P];\n// };\n```\n\n위 예시의 첫 번째는 `mapping`을 이용해 반복되는 속성 key를 순회하며 State에 대입한 값의 타입을 받아와 코드 중복을 제거했다. 이러한 `mapping`은 유틸타입`Pick`으로 정의되어 있어 두 번째 예제로 좀 더 편하게 나타낼 수 있다. `Pick`을 사용할 때는 먼저 참조할 Type을 가져오고 해당 타입에서 가져올 key값을 두 번째 인자로 전달한 Generic을 이용해 나타낼 수 있다.\n\n`Pick` util type은 유용하지만 조심해야 할 부분은 객체 type을 정의한다는 점이다.\n\n```typescript\ninterface SaveAction {\n  type: \"save\"\n}\n\ninterface LoadAction {\n  type: \"load\"\n}\n\ntype Action = SaveAction | LoadAction\ntype ActionType = \"save\" | \"load\"\n```\n\n위 예제에서 `ActionType`은 이미 정의한 `'save'`와 `'load'`를 다시 적어 코드 중복이 발생했다. 이점을 해결하기 위해서 `Pick`을 이용하면 될 것 같지만 이때는 `mapping`을 이용하는 것이 의도에 더 맞다.\n\n```typescript\ntype ActionType = Action[\"type\"] //'save' | 'load';\n\ntype ActionRec = Pick<Action, \"type\"> // {type:'save' | 'load'}\n```\n\n### 4. keyof 와 Partial util 타입\n\n```typescript\ninterface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ninterface OptionUpdate {\n  width?: number\n  height?: number\n  color?: string\n  label?: string\n}\n\nclass UIWidget {\n  constructor(init: Options) {}\n  update(options: OptionUpdate) {}\n}\n```\n\n위 예제는 `Options`와 동일한 key를 가진 `OptionUpdate`타입을 정의하는데 선택적으로 만들기 위해 새롭게 정의한 것을 볼 수 있다.\n\n```typescript\ntype OptionsUpdate = { [k in keyof Options]?: Options[k] }\n\nclass UIWidget {\n  constructor(init: Options) {}\n  update(options: Partial<Options>) {}\n}\n\n// type Partial<T> = {\n//   [P in keyof T]?: T[P];\n// };\n```\n\n위 예제를 보면 `keyof`를 이용해 `Options`의 key들을 받아오고 새롭게 정의해 코드 중복을 제거했다. key들을 모두 선택적으로 만들기 위해 utilType `Partial`이 존재한다. `Partial`의 정의를 보면 앞서 `keyof`를 그대로 사용한 것을 볼 수 있다.\n\n### 5. typeof\n\n`typeof`는 원시값의 타입을 정의하고 재 사용할 때 요즘 가장 많이 사용하는 연산자인 것 같다. `typeof`는 원시 값 뿐만 아니라 값에 대해 알고 있을 때 해당 값의 타입을 정의할 때 간단하게 사용할 수 있다.\n\n```typescript\n// typeof 전\nconst INIT_OPTIONS = {\n  width: 640,\n  height: 40,\n  color: \"s\",\n  label: \"s\",\n}\n\ninterface OPtions {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\n// typeof 후\ntype OPtions = typeof INIT_OPTIONS // { width: number; height: number; color: string;label: string; }\n```\n\n함수의 경우 반환 값의 타입을 정의하고 싶을 때 `typeof`와 utiltype `ReturnType`을 이용할 수 있다.\n\n```typescript\nfunction getUserInfo(userId: string) {\n  return {\n    userId,\n    name,\n    age,\n    height,\n    weight,\n    favoriteColor,\n  }\n}\n\ntype UserInfo = ReturnType<typeof getUserInfo>\n// type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n```\n\n`ReturnType`의 정의의 조건부 부분이 아직 이해가 되지 않아 이후에 한번 더 볼 필요가 있을 것 같다.\n\n제네릭은 타입을 유연하게 사용할 수 있는 장점을 가지지만 유연성은 `범위`가 중요하다. 이러한 범위를 정의해주지 않는다면 타입을 정의해주기 전과 같아질 수 있으므로 `extends`와 `keyof`와 같은 연산자를 이용해 범위를 명시적으로 정해 줄 수 있다.\n\n```typescript\ntype Pick<T, K> = {\n  [k in K]: T[k] // This type parameter might need an `extends string | number | symbol` constraint.\n}\n\ntype Pick<T, K extends keyof T> = {\n  [k in K]: T[K]\n}\n```\n\n위의 예제는 k의 범위를 몰라 에러가 발생했지만 `extends`와 `keyof`를 이용해 key값의 타입으로 정의해 해결할 수 있다.\n\n## 😃 인덱스 시그니처\n\n`인덱스 시그니처`는 사용하면서 어려운 부분 중 하나였다. 구체적인 타입을 지정하지 못하기 때문에 `Object.keys`와 같이 배열로 나열하는 방식에 어려움을 겪었다. 이번 기회를 통해 좀 더 제대로 이해하고 사용하고자 했다.\n\n```typescript\ntype Rocket = { [property: string]: string }\n```\n\n위 예제에서 key를 정확히 명시하지 않기 때문에 자동 완성의 도움을 받을 수 없고, value의 타입이 string이 아니라 다른 타입을 가질 수 없는 단점을 가진다. 그렇기 때문에 보다 정확하게 type을 정의할 필요가 있다.\n\n그러면 `인덱스 시그니처`는 **어디에** 쓰여야 할까? `인덱스 시그니처`는 동적데이터를 표현할 때 사용되어야 한다. 미리 알 수 없는 데이터를 받아 와야 할 때 사용할 수 있다.\n\n```typescript\nfunction parseCSV(input: string): { [columnName: string]: string }[] {\n  const lines = input.split(\"\\n\")\n  const [header, ...rows] = lines\n  const headerColumns = header.split(\",\")\n  return rows.map(rowStr => {\n    const row: { [columnName: string]: string } = {}\n    rowStr.split(\",\").forEach((cell, i) => {\n      row[headerColumns[i]] = cell\n    })\n    return row\n  })\n}\n```\n\n실제로 사용할 값에 대해서 알 수 없을 때 사용하는 것이 `인덱스 시그니처`의 본질이므로 내가 사용했던 방식은 잘못된 방식이었음을 깨달을 수 있었다.\n\n`인덱스 시그니처`는 string타입으로 광범위하므로 대체할 수 있는 방법들이 존재한다.\n\n```typescript\ntype Vec3D = Record<\"x\" | \"y\" | \"z\", number>\n// type Record<K extends keyof any, T> = {\n//     [P in K]: T;\n// };\n```\n\n`Record` utilType은 key의 타입을 유연하게 해주면서도 범위를 정해 줄 수 있다.\n\n## 🚅 Array, Tuple, ArrayLike\n\n배열은 **오브젝트**다. 그렇기 때문에 오브젝트를 사용하듯 문자열 key로 배열 요소에 접근할 수 있다.\n\n```typescript\nconst xs = [1, 2, 3]\nconst x0 = xs[0]\nconst x1 = xs[\"1\"]\nconsole.log(x1) // 2\n```\n\n타입스크립트의 `Array`는 숫자 키만을 허용하고 문자열 키는 다르게 인식해 key type을 하나로 정해 준다.\n\n```typescript\nfunction get<T>(array: T[], k: string): T {\n  return array[k] // Element implicitly has an 'any' type because index expression is not of type 'number'.\n}\n```\n\n실제 런타임은 문자열 키로 인식하지만 타입 체크를 통해 오류를 잡을 수 있는 장점을 가질 수 있다. 책을 읽으면서 어떻게 적용하면 좋을지 고민을 해봤지만, 일단은 이러한 부분이 있구나 이해하고 넘어가서 나중에 다시 보기로 생각했다.\n\n## 😁 Readonly\n\n`Readonly`는 말 그대로 읽기만 가능하게 해줄 수 있는 연산자로 해당 변수를 변화시키는 것에 에러를 던지게 해 원본을 보존하는 데 도움을 준다. 이러한 점이 중요한 것은 `call by reference`를 고려해 객체 타입의 매개변수를 다뤄야 함수로 인한 side-effect를 막을 수 있기 때문이다. 객체의 경우에 원본의 값이 들어오는 것이 아니라 reference값이 전달되기 때문에 함수 내부에서 변화시킨다면 원본에 변화가 생기는 문제점이 생긴다.\n\n이러한 문제점을 막을 수 있는 방법이 바로 `readonly`연산자다.\n\n```typescript\nfunction arraySum(arr: readonly number[]) {\n  let sum = 0,\n    num\n  while ((num = arr.pop()) !== undefined) {\n    // Property 'pop' does not exist on type 'readonly number[]'.\n    sum += num\n  }\n  return sum\n}\n```\n\n위의 예제는 `pop`과 같이 원본 요소를 바꾸는 메소드를 호출할 수 없기 때문에 생긴 에러로 함수 내에서 매개변수 내부의 변화가 생기지 않게 막는다. `readonly`배열에 변경 가능한 배열을 할당할 수 있지만, 반대는 되지 않는 특징을 가진다.\n\n```typescript\n// 변경 전\nfunction parseTaggedText(lines: string[]): string[][] {\n  const paragraphs: string[][] = []\n  const currPara: readonly string[] = []\n\n  const addParagraph = () => {\n    if (currPara.length) {\n      paragraphs.push(currPara) //readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'\n      currPara.length = 0\n    }\n  }\n\n  for (const line of lines) {\n    if (!line) {\n      addParagraph()\n    } else {\n      currPara.push(line)\n    }\n  }\n\n  addParagraph()\n  return paragraphs\n}\n```\n\n앞서 말했던 대로 `readonly`배열은 변경 가능한 배열에 할당할 수 없어 에러가 발생한 것을 볼 수 있다. 이렇게 원본을 훼손하지 않고 사용하기 위해서는 앞서 리액트를 공부하며 정리한 `불변성`을 지켜주면 된다.\n\n```typescript\nfunction parseTaggedText(lines: string[]): string[][] {\n  const paragraphs: string[][] = []\n  let currPara: readonly string[] = []\n\n  const addParagraph = () => {\n    if (currPara.length) {\n      paragraphs.push([...currPara]) // 얕은 복사로 새로운 배열을 만들어\n      currPara = []\n    }\n  }\n\n  for (const line of lines) {\n    if (!line) {\n      addParagraph()\n    } else {\n      currPara = currPara.concat([line])\n    }\n  }\n\n  addParagraph()\n  return paragraphs\n}\n```\n\n### Readonly util 타입\n\n`Readonly` util 타입은 객체의 속성을 readonly로 만들어준다.\n\n```typescript\nconst o: Readonly<Outer> = { inner: { x: 0 } }\no.inner = { x: 1 } // Cannot assign to 'inner' because it is a read-only property.\n\n// type Readonly<T> = {\n//   readonly [P in keyof T]: T[P];\n// };\n```\n\n## 😏 Mapping된 타입을 이용해 값 동기화하기\n\n```typescript\ninterface ScatterProps {\n  xs: number[]\n  ys: number[]\n  xRange: [number, number]\n  yRange: [number, number]\n  color: string\n  onClick: (x: number, y: number, index: number) => void\n}\n\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  let k: keyof ScatterProps\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k]) {\n      if (k !== \"onClick\") return true\n    }\n  }\n  return false\n}\n```\n\n위 예제에서 `ScatterProps` interface를 이용해서 현재 Props와 newProps를 비교해 props가 변경될 경우 지도를 다시 그리는 예제를 담고 있다. 실제 리액트에서 컴포넌트가 re-rendering되는 조건 중 하나가 props나 상태가 바뀌는 경우로 기존 props와의 차이를 `얕은 비교`를 통해 비교한다.\n\n현재 정의된 shouldUpdate에서 `onClick`함수 변화는 업데이트에 영향을 주지 않게 설정되어 있다. 하지만 만약 새로운 속성이 추가되는 경우에 항상 true이기 때문에 너무 자주 새로 그려지게 된다. 이점을 막기 위해서 다음과 같은 코드로 수정할 수 있다.\n\n```typescript\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  return (\n    oldProps.xs !== newProps.xs ||\n    oldProps.ys !== newProps.ys ||\n    oldProps.xRange !== newProps.xRange ||\n    oldProps.yRange !== newProps.yRange ||\n    oldProps.color !== newProps.color\n  )\n}\n```\n\n위 코드는 일일이 속성들의 변화를 체크하는 방식으로 매번 새로운 속성이 추가될 때마다 작성해 주어야 하므로 비효율적이다.\n\n좀 더 이상적인 방법은 새로운 속성이 추가될 때 타입체커와 매핑된 타입,객체를 이용하는 코드다. 다음 예제를 보자.\n\n```typescript\nconst REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {\n  xs: true,\n  ys: true,\n  xRange: true,\n  yRange: true,\n  color: true,\n  onClick: false,\n}\n\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  let k: keyof ScatterProps\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {\n      return true\n    }\n  }\n  return false\n}\n```\n\nkeyof를 이용해 Update가 필요한 속성들에 대해 명시해두고, true로 설정해놓은 속성이 변화했을 때만 업데이트될 수 있게 정의했다. 타입과 값이 동기화 되어 있기 때문에 새로운 속성이 추가되어도 바로 에러가 발생해 알려줄 수 있다.\n"},{"excerpt":"🎚 타입 시스템(2) 타입스크립트의 타입 시스템 중 객체 래퍼 타입, 잉여 속성 체크, 함수 표현식, 타입과 인터페이스의 차이에 대해서 정리해보자 한다. 📦 객체 래퍼 타입 문자열을 입력하고 을 찍으면 객체처럼 우리는 다양한 메소드를 이용할 수 있다. 이렇게 가능한 것은 자바스크립트가 을 찍는 순간 에서  객체 래퍼로 타입변환이 이루어진다. 객체로 변환해…","fields":{"slug":"/2023-01-10-타입시스템-2/"},"frontmatter":{"date":"January 10, 2023","title":"TS study: 타입 시스템 (2)","tags":["typescript"]},"rawMarkdownBody":"\n# 🎚 타입 시스템(2)\n\n타입스크립트의 타입 시스템 중 **객체 래퍼 타입, 잉여 속성 체크, 함수 표현식, 타입과 인터페이스의 차이**에 대해서 정리해보자 한다.\n\n## 📦 객체 래퍼 타입\n\n문자열을 입력하고 `.`을 찍으면 객체처럼 우리는 다양한 메소드를 이용할 수 있다. 이렇게 가능한 것은 자바스크립트가 `.`을 찍는 순간 `string`에서 `String` 객체 래퍼로 타입변환이 이루어진다. 객체로 변환해 메소드를 사용한 후에는 객체 타입에서 다시 원시형으로 돌아간다.\n\n이렇게 유용한 객체 래퍼 타입이지만 정의된 타입을 보면 오타가 나기 쉽게 되어있다.\n\n- 원시형: `string`, 객체래퍼:`String`\n- 원시형: `number`, 객체래퍼:`Number`\n- 원시형: `boolean`, 객체래퍼:`Boolean`\n\n```typescript\nfunction getStringLen(foo: String) {\n  return foo.length\n}\n\ngetStringLen(\"hello\")\ngetStringLen(new String(\"hello\"))\n\nfunction isGreeting(phrases: String) {\n  return [\"hello\", \"good day\"].includes(phrases) // Argument of type 'String' is not assignable to parameter of type 'string'.\n}\n```\n\n크게 문제가 되지 않을 것 같아 보이지만 원시형은 객체래퍼에 할당할 수 있는 반면 객체 래퍼는 원시형에 할당할 수 없기 때문에 오타로 인한 에러가 발생한 것을 볼 수 있다. 직접 객체 래퍼를 할당하지 않게 주의해야 함을 보여주는 예제다.\n\n## ✒ 잉여 속성 체크\n\n잉여속성 체크는 우리가 정의해 준 타입의 속성들 외의 추가된 속성이 있는지 확인하는 과정을 의미한다.\n\n```typescript\ninterface Dog {\n  age: number\n  name: string\n}\n\nconst dog1: Dog = {\n  age: 1,\n  name: \"바둑이\",\n  bark() {\n    //  'bark' does not exist in type 'Dog'.\n    console.log(\"짖기\")\n  },\n}\n```\n\n위 예제에서 `Dog`타입에 bark 속성이 없기 때문에 에러가 발생했지만 앞서 배웠던 구조적 타이핑의 의미로 보았을 때는 필요한 속성인 age와 name이 있기 때문에 에러가 나지 않아야 할 것 같다.\n\n```typescript\nconst dog2 = {\n  age: 1,\n  name: \"바둑이\",\n  bark() {\n    console.log(\"짖기\")\n  },\n}\nconst r: Dog = dog2\n```\n\n같은 조건이지만 앞선 예제와는 다르게 에러가 발생하지 않았다.\n\n```typescript\ninterface Options {\n  title: string\n  darkMode?: boolean\n}\n\nfunction createWindow(options: Options) {\n  if (options.darkMode) {\n    // setDarkMode()\n  }\n}\ncreateWindow({\n  title: \"Spider\",\n  darkmode: true,\n}) // 'darkmode' does not exist in type 'Options'. Did you mean to write 'darkMode'?\n\nconst o1: Options = document\n```\n\n둘의 차이점은 뭘까?\n\n앞선 에러가 발생한 예제들은 `잉여속성 체크`가 진행되었기 때문에 에러가 발생했다. `잉여속성 체크`가 발생하는 조건은 dog1처럼 `객체 리터럴`을 할당하거나 createWindow처럼 `함수에 매개변수를 전달할 때` 적용된다.\n\n에러가 발생하지 않은 경우는 변수를 통해 값을 전달했을 때로 임시 변수를 전달하면 `잉여 속성 체크`가 이루어지지 않는다. 우리가 정의한 속성만 추가되게 하는 경우에 `잉여속성 체크`를 적용해 오류를 찾을 수 있는 장점이 있다. 하지만 `구조적 타이핑`의 관점과 충돌하기 때문에 필요할 때에 적절하게 사용할 필요가 있어 보였다.\n\n## 🎈 함수 표현식\n\n자바스크립트에서 함수를 사용하는 방법에는 함수 선언문과 함수 표현식이 있다. 타입스크립트는 함수 표현식일 때 `매개변수와 반환 값을 타입으로 선언`할 수 있는 장점을 갖고 있다.\n\n```typescript\nfunction add(a: number, b: number) {\n  return a + b\n}\nfunction sub(a: number, b: number) {\n  return a - b\n}\nfunction mul(a: number, b: number) {\n  return a * b\n}\nfunction div(a: number, b: number) {\n  return a / b\n}\n\ntype BinaryFn = (a: number, b: number) => number\n\nconst add: BinaryFn = (a, b) => a + b\nconst sub: BinaryFn = (a, b) => a - b\nconst mul: BinaryFn = (a, b) => a * b\nconst div: BinaryFn = (a, b) => a / b\n```\n\n앞선 예제는 함수 선언문을 이용해 매개변수의 타입을 정해 준 경우이고, 아래는 함수 표현식에 `BinaryFn`타입을 이용해 매개변수와 반환 값의 타입을 한번에 정의한 경우이다. 함수 선언문의 경우 일일이 매개변수의 타입을 정해 주어야 하고, 정한 타입을 재 사용할 수 없는 반면, `함수 표현식`의 경우 함수에 필요한 매개변수와 반환 값의 타입을 한번에 표현해 훨씬 간결하면서도 재 사용성도 높이는 것을 볼 수 있다.\n\n```typescript\nasync function checkedFetch(input: RequestInfo, init?: RequestInit) {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(`${response.status}`)\n  }\n  return response\n}\n\nconst checkedFetch: typeof fetch = async (input, init) => {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(`${response.status}`)\n  }\n  return response\n}\n```\n\n위의 예제는 내가 주로 쓰듯이 각각의 매개변수의 타입을 정해 준 모습이고, 아래는 내장된 `fetch` 타입으로 훨씬 간결하게 나타낸 모습이다. 이렇게 동일한 매개변수와 반환 값의 타입을 가지는 함수의 경우 함수 전체의 타입을 정해 재 사용하는 것이 효율적인 것을 새롭게 알게 되었다.\n\n## 🥊 타입 VS Interface\n\n타입과 interface는 항상 고민되는 문제다. 공통점이 많기 때문에 어떤 점을 기준으로 사용해야 할까 고민되는 경우가 많았다. 이러한 고민은 둘 다 가능한 공통점에서 시작되었다.\n\n### 공통점\n\n#### 1) 타입 정의\n\n```typescript\ntype TState = {\n  name: String\n  capital: string\n}\n\ninterface IState {\n  name: string\n  capital: string\n}\n```\n\n둘 다 동일하게 커스텀 타입을 정의할 수 있다.\n\n#### 2) Index와 함수 정의\n\n```typescript\ntype TDict = { [key: string]: string }\ninterface IDict {\n  [key: string]: string\n}\n\ntype TFn = (x: number) => string\ninterface IFn {\n  (x: number): string\n}\n```\n\n둘 다 동일하게 index와 함수를 정의할 수 있다.\n\n#### 3) Generic과 확장\n\n```typescript\ntype TPair<T> = {\n  first: T\n  second: T\n}\n\ninterface IPair<T> {\n  first: T\n  second: T\n}\n\ninterface IStateWithPop extends TState {\n  population: number\n}\n\ntype TStateWithPop = IState & { population: number }\n```\n\n둘 다 Generic을 사용할 수 있고 확장도 가능하다.\n\n#### 4) 클래스 구현\n\n```typescript\nclass StateT implements TState {\n  name: string = \"\"\n  capital: string = \"\"\n}\n\nclass StateI implements IState {\n  name: string = \"\"\n  capital: string = \"\"\n}\n```\n\n클래스를 구현하는 것도 둘 다 가능하다.\n\n### 차이점\n\n대부분이 둘 다 가능하기 때문에 차이점이 없어보이지만 interface만 가능한 것과 type만이 가능한 역할이 있다.\n\n#### 복잡한 type\n\n```typescript\ntype AorB = \"a\" | \"b\"\n```\n\nunion type이나 조건부 타입과 같이 좀 더 복잡한 type을 위해서는 interface가 사용될 수 없다. type은 활용성이 interface보다 높다고 할 수 있다.\n\n#### 보강\n\n```typescript\ninterface IState {\n  name: string\n  capital: string\n}\n\ninterface IState {\n  population: number\n}\n```\n\ninterface는 type과는 다르게 속성을 같은 이름의 interface을 선언해 확장할 수 있는 특징을 가진다. 이것을 통해서 실제로 우리가 사용하는 내장 메소드들의 정의가 버전 별로 확장되어 적용되고 있다.\n\n### 🤔 그래서 기준은 어떤 것일까?\n\n사용할 때 기준은 먼저 사용할 때 `일관성을 유지해야 한다`는 점이다. type과 interface는 공통점이 많기 때문에 둘 다 가능한 경우가 많다. 그렇지만 type을 쓰다가 interface를 쓰는 것이 아니라 하나로 정해서 일관되게 작성하는 코드스타일이 중요하다.\n\n각각의 차이점을 고려해서 복잡한 타입은 `type`을 사용하고 보강이 필요한 경우에는 `interface`를 이용해 API를 정의할 때 사용할 수 있다.\n\n[참조]\n\n[이펙티브 타입스크립트](https://search.shopping.naver.com/book/catalog/32473346832)\n"},{"excerpt":"🎚 타입시스템 타입 시스템은 타입스크립트를 사용하는 큰 이유 중 하나다. 타입을 통해 안전하고 효율적으로 코드를 작성할 수 있게 도와주기 때문에 타입스크립트를 잘한다는 것의 의미가 현재 에 있다. 그렇기 때문에 최대한 구체적으로 타입을 정의하기 위해 타입시스템에 대해 알아보자 🤔 타입 추론 타입스크립트는 똑똑하기 때문에 우리가 작성한 코드에 명시적으로 전…","fields":{"slug":"/2023-01-07-타입시스템-1/"},"frontmatter":{"date":"January 07, 2023","title":"TS study: 타입시스템 (1)","tags":["typescript"]},"rawMarkdownBody":"\n# 🎚 타입시스템\n\n타입 시스템은 타입스크립트를 사용하는 큰 이유 중 하나다. 타입을 통해 안전하고 효율적으로 코드를 작성할 수 있게 도와주기 때문에 타입스크립트를 잘한다는 것의 의미가 현재 `얼마나 타입을 잘 정의하냐`에 있다. 그렇기 때문에 최대한 구체적으로 타입을 `잘`정의하기 위해 **타입시스템**에 대해 알아보자\n\n## 🤔 타입 추론\n\n타입스크립트는 똑똑하기 때문에 우리가 작성한 코드에 명시적으로 전달하지 않아도 코드의 흐름을 통해 추론해준다. `const s=\"string\"`이라는 코드를 작성하면 자동으로 `s`에는 `string`타입이 할당된다.\n\n```typescript\nconst foo = {\n  x: [1, 2, 3], // number[]\n  bar: {\n    name: \"fred\",\n  },\n}\n```\n\n위 예제의 x는 `[1,2,3]`을 보고 `number[]`을 타입으로 추론했다. 하지만 만약에 배열의 길이가 정해져 있는 `Tuple`이었다면 위의 타입은 이후에 에러를 만들 수 있는 코드가 된다.\n\n그래서 최대한 **구체적으로** 타입을 정해주는 것이 중요하며 대부분의 라이브러리에는 사용하는 속성과 메소드에 대한 정보들이 `d.ts`로 끝나는 파일에 정리되어 있기 때문에 참고할 수 있다.\n\n[`lib.es2015.core.d.ts`의 Array interface]\n\n![d.ts](dts.png)\n\n## 🗂타입과 집합의 관계\n\n아래 그림을 통해 엄청나게 다양한 타입이 존재하는 것을 알 수 있다. 이러한 타입시스템을 이해하기 위해서 타입을 `집합`으로 이해해야 한다.\n\n![img](https://www.tektutorialshub.com/wp-content/uploads/2019/08/Relationships-between-the-various-TypeScript-data-types-1024x525.png)\n\n타입과 집합이라니... 관련이 없어 보이지만, 자바스크립트에서 프로토타입의 부모 자식 관계가 있듯이, 타입들에도 집합 관계가 있다. `unknown` type은 알 수 없기 때문에 어떤 것이든 다 될 수 있는 가장 큰 집합으로 `never`는 어떤 요소도 포함하지 않는 가장 작은 집합으로 이해할 수 있다.\n\n```typescript\nconst x: never = 12 //Type 'number' is not assignable to type 'never'.\n```\n\n### unit type\n\n하나의 값을 가리키는 타입은 `unit type` 또는 `literal type`이라고 불리는 타입이다. 값을 직접 type에 명시한다.\n\n```typescript\ntype A = \"A\"\n```\n\n### Union Type\n\n하나가 아니라 타입에 여러 값을 함께 나타내기 위해서 `union type`이 존재한다. `union type`은 여러 개의 타입을 합한 `합집합`으로 `|`으로 나타낸다.\n\n![그림 5-7 A와 B의 합집합](https://python.bakyeono.net/img/img-5-7.png)\n\n```typescript\ntype AB = \"A\" | \"B\"\nconst ab: AB = Math.random() < 0.5 ? \"A\" : \"B\"\nconst c: AB = \"C\" // Type '\"C\"' is not assignable to type 'AB'\n```\n\n위 예제에서 `ab`는 `AB` 유니온 타입으로 되어 있어 `\"A\"`나 `\"B\"`가 할당될 수 있다. `c`는 `AB`타입에 정의한 `\"A\"` 또는 `\"B\"`의 부분집합이 아니기 때문에 에러가 발생한다. 즉 타입 체크를 한다는 것은 **어떤 집합이 다른 집합의 부분집합이 될 수 있는지** 를 확인하는 것이다.\n\n### Intersection Type\n\n여러 개 타입을 동시에 만족하는 부분 집합, `교집합`을 `Intersection Type`이라고 하며 `&`으로 나타낸다.\n\n![그림 5-8 A와 B의 교집합](https://python.bakyeono.net/img/img-5-8.png)\n\n여기서 이해하기 어려웠던 부분이 \"둘 다 만족한다\"고만 생각해 `Union type`와 차이가 이해되지 않았지만 집합으로 생각해보니 이해가 쉬웠다. 동시에 만족한다는 것은 `두 집합의 조건을 모두 만족한다는 의미`를 가진다.\n\n```typescript\ninterface dogPerson {\n  loveDog: true\n}\n\ninterface catPerson {\n  loveCat: true\n}\n\ntype Both = dogPerson & catPerson\nconst person1: Both = {\n  loveDog: true,\n  loveCat: true,\n}\n```\n\n위 예제에서 강아지와 고양이를 모두 좋아하는 person1은 `loveDog`과 `loveCat`을 모두 true로 가지고 있어야 한다. 둘 다 만족한다는 것은 두 가지 type을 모두 만족해야 하는 것을 알 수 있다.\n\n집합 관계를 다양한 예제를 통해 좀 더 알아보자.\n\n#### keyof와 함께 사용하는 union type과 intersection type\n\n```typescript\ninterface dogPerson {\n  loveDog: true;\n}\n\ninterface catPerson {\n  loveCat: true;\n}\n\ninterface Both = dogPerson & catPerson;\n\ntype K = keyof (dogPerson | catPerson); //  (keyof A) & (keyof B)\ntype T= keyof(dogPerson & catPerson) //  (keyof A) | (keyof B)\n\nconst a: K = \"loveDog\"; // Type 'string' is not assignable to type 'never'.\nconst b: T = 'loveDog';\n```\n\n`K`는 합집합의 key로 교집합인 `never` type이 되고, T는 교집합의 key이기 때문에 A의 key와 B의 key의 `\"loveDog\"|'loveDog'`가 된다. 이부분은 아직 와닿지 않아서 계속해서 공부가 필요한 부분인 것 같다.\n\n#### extends\n\n```typescript\ninterface dogPerson {\n  loveDog: true\n}\n\ninterface catPerson {\n  loveCat: true\n}\n\ninterface Both extends dogPerson {\n  loveCat: true\n}\n```\n\n앞서 `intersection type`으로 정의했던 관계를 extends를 이용해 상속 관계로도 이해할 수 있다. 부모의 속성을 자식이 전달 받기 때문에 자식을 subset 부모를 superset이라고 부르는 집합 관계와 상속 관계가 일치하는 것을 알 수 있다.\n\n```typescript\ninterface Point {\n  x: number\n  y: number\n}\n\ntype PointKeys = keyof Point // \"x\"|\"y\"\n\nfunction sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {\n  // ..\n  return []\n}\n\nconst pts: Point[] = [{ x: 1, y: 1 }]\nsortBy(pts, \"x\") // T: Point[] K:\"x\"\nsortBy(pts, \"y\") // T: Point[] K:\"y\"\nsortBy(pts, \"z\") // T: Point[] K:\"z\" // Argument of type '\"z\"' is not assignable to parameter of type 'keyof Point'.\n```\n\n위의 `generic`을 이용한 예시를 보면 T에는 `point[]`타입이 K에는 \"x\", \"y\", \"z\"가 들어간다. K는 K의 key의 부분집합이어야하므로 \"z\"는 point의 `\"x\"|\"y\"` 집합에 속하지 않기 때문에 에러가 발생하는 것을 볼 수 있다.\n\n## ⁉ 값과 타입 구분하기\n\n자바스크립트에서는 값만 신경써서 이름을 정하면 됐지만 타입스크립트를 사용하면서 type에도 네이밍이 필요해졌다. 내가 정의한 것이 `값`인지 `타입`인지를 이해할 필요가 있다.\n\n```typescript\ninterface Cylinder {\n  radius: number\n  height: number\n}\n\nconst Cylinder = (radius: number, height: number) => ({ radius, height })\n// Cannot redeclare block-scoped variable 'Cylinder'.\n```\n\n같은 이름으로 타입과 값 모두 정의할 수 있기 때문에 구분할 수 있는 네이밍이 필요하다.\n\n```typescript\ninterface Cylinder {\n  radius: number\n  height: number\n}\n\nfunction calculateVolume(shape: unknown) {\n  if (shape instanceof Cylinder) {\n    // 'Cylinder' only refers to a type, but is being used as a value here.\n    shape.radius\n  }\n}\n```\n\n네이밍 문제 뿐 아니라 타입을 값처럼 사용해 오류를 만들기도 한다. `instanceof`는 런타임 연산자로 값을 확인한다. Cylinder가 타입이기 때문에 에러가 난 것을 볼 수 있다.\n\n이러한 문제를 해결할 수 있는 방법으로는 값과 타입 모두 될 수 있는 `class` 를 사용해 해결할 수 있다.\n\n```typescript\nclass Cylinder {\n  radius: number\n  height: number\n}\n\nfunction calculateVolume(shape: unknown) {\n  if (shape instanceof Cylinder) {\n    // 'Cylinder' only refers to a type, but is being used as a value here.\n    shape.radius\n  }\n}\n```\n\n### typeof\n\n`typeof`는 class처럼 타입과 값의 의미를 모두 가진다. 타입으로 쓰일 때는 해당 값의 타입을 읽고, 값으로 쓰일 때는 해당 값의 타입을 문자열로 반환한다.\n\n```typescript\nconst v = typeof Cylinder\nconsole.log(v) // function\n\ntype C = InstanceType<typeof Cylinder> // Cylinder\n\n// type InstanceType<T extends abstract new (...args: any) => any> =\n//   T extends abstract new (...args: any) => infer R ? R : any;\n```\n\n위 예제에서 typeof가 값으로 쓰여 v가 `\"function\"`문자열 값으로 반환되었고, 타입으로 쓰일 경우 Generic과 함께 쓰여 `C`의 타입이 Cylinder로 나온 것을 볼 수 있었다. 여기에 쓰인 `InstanceType`은 유틸리티 타입으로 생성자 함수 T의 instance type을 의미한다.\n\n### Branket 접근자\n\n오브젝트의 속성 접근자인 `[]`는 타입에서도 동일하게 `타입의 속성의 타입정보`를 얻을 수 있다.\n\n```typescript\ninterface Person {\n  first: string\n  last: string\n}\n\ntype PersonEl = Person[\"first\" | \"last\"]\ntype Person2 = Person.first // Cannot access 'Person.first' because 'Person' is a type, but not a namespace.\n\ntype Tuple = [string, number, Date]\ntype TupleEl = Tuple[number]\n```\n\n### 구조 분해 할당\n\n구조 분해 할당으로 자주 사용하는 경우는 react에서 전달 받은 props를 구조 할당 분해로 타입을 명시해 줄 때였다. 길어질 수 있기 때문에 type을 따로 빼서 정의하는 게 가독성에 좋았다.\n\n```tsx\ntype AdminDescriptionItemType = {\n  item: DescriptionType\n  name: DescriptionNameType\n  onDelete: (name: DescriptionNameType, id: string) => void\n  onChange: (name: DescriptionNameType, value: string, id: string) => void\n}\n\nexport default function AdminDescriptionItem({\n  item,\n  name,\n  onDelete,\n  onChange,\n}: AdminDescriptionItemType) {\n  // ...생략\n}\n```\n\n## 😁 타입 단언 보다 타입선언\n\n타입 단언 (type assertion)은 추론한 타입과 상관없이 개발자가 정의한 타입을 우선순위로 두기 때문에 오류가 발생할 확률이 높아진다.\n\n```typescript\ninterface Person {\n  name: string\n}\n\nconst alice: Person = { name: \"Alice\" }\nconst bob = {} as Person\n```\n\n`alice`의 경우 타입 선언을 이용해 타입 체크하기 때문에 명시된 값의 타입이 맞는 지를 보지만, `bob`은 내가 정의한 Person이라고 지정하게 되어 오류를 던지지 않는다.\n\n```typescript\nconst alice: Person = {\n  name: \"Alice\",\n  occupation: \"td\",\n} // Type '{ name: string; occupation: string; }' is not assignable to type 'Person'.\n\nconst bob = {\n  name: \"bob\",\n  occupation: \"js\",\n} as Person\n```\n\n이번에는 `Person`에서 정의한 속성 외의 추가 속성이 있을 때로 `alice`의 경우 기존 정의한 속성외의 다른 속성이 있음을 오류로 알려 주지만, `bob`은 Person으로 이미 타입체크를 했다고 전달하는 것과 같아 오류가 없는 것을 볼 수 있다.\n\n### 타입 선언 시 주의할 점\n\n```typescript\nconst people = [\"alice\", \"bob\", \"jan\"].map(name => ({ name })) // {name:string}[]\n```\n\n위의 경우 타입이 `Person[]`이 되기를 기대했지만 `{name:string}[]`로 type이 정해진다. 이러한 경우는 체이닝을 이어나갈 때 type 에러를 만들기 때문에 항상 예상하는 타입과 같게 만들기 위해 <u>중간 단계의 예측한 타입을 명시함</u>으로써 오류가 발생한 곳을 빠르게 찾아나갈 수 있다.\n\n```typescript\nconst people: Person[] = [\"alice\", \"bob\", \"jan\"].map(\n  (name): Person => ({ name })\n)\n```\n\n## 🙄 타입 단언은 언제 쓸까?\n\n타입 단언이 필요한 경우는 **내가 정의하는 타입이 추론하는 타입보다 더 정확할 때**다. 당연히 타입스크립트가 더 똑똑한데 내가 맞다고 할 수 있을까 싶기도 하지만 런타임에서 결정되는 경우 타입 스크립트가 접근할 수 없고, 이미 정해져 있지만 타입이 반영되어있지 않은 경우에도 사용할 수 있을 것 같다.\n\n```typescript\ndocument.querySelector(\"#myButton\")?.addEventListener(\"click\", e => {\n  e.currentTarget\n  const button = e.currentTarget as HTMLButtonElement\n  button\n})\n```\n\nevent의 currentTarget은 런타임에서 결정되므로 `null|HTMLButtonElement`중에서 `HTMLButtonElement`로 정해줘야 한다.\n\n최근 과제를 하면서 타입단언이 필요한 경우가 있었다. 영어로 오늘의 요일을 가져와야 할 때 `toLocaleDateString()`를 이용해서 사용하려 했지만 타입 정의가 `string`으로 되어있어 타입에러가 발생했다.\n\n![단언](단언.png)\n\n이점을 해결하기 위해서 고민을 하다가 정의 되어있는 타입보다 더 자세히 정해줘야 하는 상황이므로 타입단언을 사용해서 해결할 수 있었다.\n\n```typescript\nconst today = new Date()\nconst day = today.toLocaleDateString(\"en\", {\n  weekday: \"short\",\n}) as EnKeys\n\nconst Days = {\n  Mon: \"월\",\n  Tue: \"화\",\n  Wed: \"수\",\n  Thu: \"목\",\n  Fri: \"금\",\n  Sat: \"토\",\n  Sun: \"일\",\n  Temp: \"당일\",\n} as const\n\nexport type EnKeys = keyof typeof Days\n```\n\n타입 단언을 항상 사용할 수 있는 것은 아니다. `A|B type`에서 A가 B의 부분 집합일 때만 사용할 수 있다.\n\n```typescript\ninterface Person {\n  name: string\n}\nconst body = document.body\nconst el = body as Person\n// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because neither type sufficiently overlaps with the other. // If this was intentional, convert the expression to 'unknown' first.\nconst el = body as unkown as Person\n```\n\nPerson으로 타입 단언을 통해 타입을 정하려 했지만 body가 가지는 type인 `HTMLElement`와 `Person`은 서로 관계가 없기 때문에 에러가 발생한다. 하지만 `unknown`은 가장 큰 타입의 집합이므로 타입 단언이 가능한 것을 볼 수 있다.\n\n# 마치며\n\n타입 시스템을 공부하면서 타입을 `집합`이라는 시점으로 보니 좀 더 이해가 잘 되었다. 하지만 여전히 부족한 점이 많아서 여러 번 읽어야 할 부분이라 생각된다.\n\n[참조]\n[이펙티브 타입스크립트](https://search.shopping.naver.com/book/catalog/32473346832)\n"},{"excerpt":"타입스크립트로 기본적인 타입을 정하고 사용하고 있지만, 매번 막히는 문제들과 잘 사용하는 기준을 세우기 위해 이펙티브 타입스크립트를 읽고 정리해나가려 한다. 🙄 타입 스크립트란 타입스크립트의 인기는 갈수록 증가하고 있다. 왜 타입스크립트가 인기가 높아지고 있는지에 개인적으로 생각해보면 과 과  총 세 가지라고 생각한다. 타입스크립트란 어떤 언어인지, 왜 …","fields":{"slug":"/2023-01-02-타입스크립트란/"},"frontmatter":{"date":"January 02, 2023","title":"TS study: 타입스크립트란","tags":["typescript"]},"rawMarkdownBody":"\n타입스크립트로 기본적인 타입을 정하고 사용하고 있지만, 매번 막히는 문제들과 잘 사용하는 기준을 세우기 위해 [이펙티브 타입스크립트](https://search.shopping.naver.com/book/catalog/32473346832)를 읽고 정리해나가려 한다.\n\n# 🙄 타입 스크립트란\n\n타입스크립트의 인기는 갈수록 증가하고 있다. 왜 타입스크립트가 인기가 높아지고 있는지에 개인적으로 생각해보면 `타입체크를 통한 안정성`과 `자동완성을 통한 효율성`과 `타입스크립트 자체의 문법` 총 세 가지라고 생각한다. 타입스크립트란 어떤 언어인지, 왜 써야 하는 지에 대해 알아보자.\n\n[npm trends의 typescript 다운로드 수]\n![npm](npm.png)\n\n먼저 타입스크립트를 정의해보면 `자바스크립트의 superset`이라고 할 수 있다. superset이란 말은 상위 집합으로 타입스크립트가 자바스크립트를 감싸고 있는 것을 떠올릴 수 있는데, 자바스크립트의 문법들 뿐 아니라 Typescript는 타입문법을 포함하고 있기 때문이다. 이러한 특징으로 자바스크립트와 타입 스크립트는 서로 뗄 수 없는 관계고 타입스크립트를 이용해 보다 쉽게 자바스크립트에 타입을 추가할 수 있다.\n\n하지만 우리가 타입 스크립트로 작성하더라도 브라우저가 이해할 수 있는 언어는 여전히 `자바스크립트`이기 때문에 타입스크립트로 작성된 코드를 자바스크립트로 변환하는 과정을 거친다. 어차피 다시 `자바스크립트`로 변환을 해야 하는데 왜 자바스크립트 대신 타입스크립트를 사용하는 걸까?\n\n![집합](집합.png)\n먼저 자바스크립트에 없는 `타입`을 정해 줄 수 있다. `타입`을 정해 준다는 것은 어떻게 코드가 진행될 지에 대한 큰 힌트가 되며, 가독성을 높여 준다.\n\n```typescript\nlet city = \"new york city\"\nconsole.log(city.toUppercase()) //Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?\n```\n\n위 예제를 보면 자바스크립트로 작성 시에는 city에 어떤 타입이 와도 되기 때문에 알 수 없지만, 타입스크립트로 작성하면 자동으로 city가 string으로 `타입추론`이 되어 오타가 났을 때 string타입이 가지고 있는 메소드로 알려 주는 것을 볼 수 있다.\n\n타입스크립트를 편리하게 사용하려면 타입스크립트에게 개발자의 `의도`를 전달해줘야 한다. 단순히 any로만 전달된 변수보다 string로 구체적으로 전달된 변수일때 어떤 속성과 메소드를 사용할 수 있는지 정확하게 알려줄 수 있다. 다음 예시를 보자.\n\n```typescript\n// 의도를 전달해주기 전\nconst countries = [\n  { name: \"korea\", capitol: \"seoul\" },\n  { name: \"japan\", capital: \"tokyo\" },\n]\n\nfor (const state of countries) {\n  console.log(state.capitol) //seoul undefined\n}\n\n// 의도를 전달해준 후\ninterface Countries {\n  name: string\n  capital: string\n}\n\nconst countries: Countries[] = [\n  { name: \"korea\", capitol: \"seoul\" }, // Property 'capitol' does not exist on type 'Countries'. Did you mean 'capital'?\n  { name: \"japan\", capital: \"tokyo\" },\n]\n\nfor (const state of countries) {\n  console.log(state.capitol)\n}\n```\n\n위 코드를 보면 어떤 타입을 가지고 있어야 하는지를 정해주면서 이전에 찾을 수 없던 문제를 미리 알 수 있고, 어떻게 수정하면 될지 알려 주는 도움을 받을 수 있다.\n\n타입스크립트는 자바스크립트 런타임 동작을 모델링한다. 쉽게 표현하면 **자바스크립트 런타임의 오류를 찾으려 한다**는 뜻이다. 하지만 타입 체크로써 모든 런타임에러를 찾을 수는 없다.\n\n```typescript\nconst names = [\"Alice\", \"Bob\"]\nconsole.log(names[2].toUpperCase()) // TypeError: Cannot read properties of undefined (reading 'toUpperCase')\n```\n\n모든 에러를 다 찾아 줄 수는 없지만 그럼에도 불구하고 코드를 작성하는 과정에서 미리 에러를 알려줘, 안정성과 효율성을 높여 주는 큰 장점으로 타입스크립트의 인기가 늘어나고 있다.\n\n# 😁 타입스크립트의 설정\n\n아마 내가 타입스크립트로 코드를 작성하면서 가장 많이 본 에러는 `암시적 any`가 아닐까. 가장 먼저 마주한 타입스크립트의 벽과 같았다. 자바스크립트에서는 당연히 되던 코드가 자세히 써주지 않으면 바로 에러가 나타나고, 이러한 설정을 해결하기 위해 변수마다, 인자마다 타입을 맞게 써 주는 연습을 가장 먼저 했다.\n\n```typescript\nfunction add(a, b) {\n  return a + b\n}\nadd(10, null) // Parameter 'a' implicitly has an 'any' type.\n```\n\n위 코드를 자바스크립트로 동작 시키면 아무 문제가 없지만 타입스크립트에는 `noImplicitAny`라는 설정이 있어 매개변수로 정확한 타입을 전달해줘야 한다. 타입을 정해주지 않으면 암시적으로 `any`로 정해지게 되기 때문에 타입 체크의 의미가 없어진다. 함수 작성 시에는 인자의 타입에 대해 자세하게 타입을 정해줘야 한다.\n\n두 번째로 실제 사용하면서 많이 마주하는 에러는 `null체크`다. 비동기로 데이터를 불러오더라도 데이터가 받아오지 못하는 경우나 조건에 따라 값이 들어오는 경우에 꼭 마주하는 에러다.\n\n```typescript\nconst el = document.getElementById(\"status\")\nel.textContent = \"read\" // 'el' is possibly 'null'\n```\n\n위 코드에서 `el`이 `null`이 될 수 있기 때문에 에러를 던져주고 이러한 `null 체크`를 해주기 위해서 타입스크립트에는 `strictNullChecks`라는 설정이 있다.\n\n처음 타입스크립트를 사용할 때는 허들과 같지만 두 가지 설정을 통해 더 안정적으로 작성할 수 있다는 점을 느끼고 나서는 허들보다 도와주는 도우미와 같이 느껴졌다.\n\n# 💻 타입스크립트 컴파일러의 역할\n\n타입스크립트 컴파일러는 두 가지 역할을 한다.\n\n- 최신버전 타입스크립트/ 자바스크립트를 구버전 자바스크립트로 트랜스파일\n\n- 타입 오류 체크\n\n두 가지 역할을 할 때 각각 독립적으로 처리되기 때문에 타입오류가 있어도 컴파일이 가능하다. 이러한 타입스크립트 컴파일러의 특징에 대해서 예시로 알아보자.\n\n### 런타임에서 타입체크\n\n```typescript\ninterface Square {\n  width: number\n}\n\ninterface Rectangle extends Square {\n  height: number\n}\n\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    // 'Rectangle' only refers to a type, but is being used as a value here.\n    return shape.width * shape.height // Property 'height' does not exist on type 'Shape'.\n  } else {\n    return shape.width * shape.width\n  }\n}\n```\n\n위 예시 코드를 보면 `Rectangle`은 `interface`로 선언되어 있다. 런타임에서 `instanceof`로 값을 체크할 때 Rectangle은 타입이기 때문에 비교할 수 없다.\n\n위의 코드를 개선하기 위해서는 런타임에 타입정보를 유지 시켜줘야 한다.\n\n```typescript\n// 개선 코드 1\ninterface Square {\n  width: number\n}\n\ninterface Rectangle extends Square {\n  height: number\n}\n\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (\"height\" in shape) {\n    // height이 있으므로 Rectangle로 결정\n    return shape.width * shape.height\n  } else {\n    return shape.width * shape.width\n  }\n}\n```\n\n개선한 코드를 보면 타입을 이용하는 것이 아니라 `shape`이 가지고 있는 속성을 통해 타입을 유지시켜 줄 수 있다.\n\n```typescript\n// 개선 코드 2\n\ninterface Square {\n  kind: \"square\"\n  width: number\n}\n\ninterface Rectangle {\n  kind: \"rectangle\"\n  height: number\n  width: number\n}\n\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape.kind === \"rectangle\") {\n    shape\n    return shape.width * shape.height\n  } else {\n    shape\n    return shape.width * shape.width\n  }\n}\n```\n\n두 번째 개선 방법은 interface에 구분될 수 있는 key값을 주는 `tag`기법이다. `kind`값에 따라 shape의 타입을 결정할 수 있기 때문에 런타임에서 타입정보를 유지할 수 있다.\n\n```typescript\n// 개선 코드 3\nclass Square {\n  constructor(public width: number) {}\n}\n\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width)\n  }\n}\n\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    shape\n    return shape.width * shape.height\n  } else {\n    shape\n    return shape.width * shape.width\n  }\n}\n```\n\n세 번째 개선방법은 클래스를 이용하는 방법으로 클래스는 `타입`과 `값`으로 모두 사용할 수 있는 특징이 있다. interface에서 클래스로 바꿔 타입 정보를 유지해할 수있다.\n\n### 타입연산과 런타임\n\n타입연산은 런타임에 영향을 주지 않는다. 런타임은 타입스크립트 코드에서 컴파일된 자바스크립트 코드로 변환되어 실행되기 때문에 이때 코드 자체에서 타입을 정제하지 않으면 아무런 영향을 주지 못한다.\n\n```typescript\n// typescript 코드\nfunction asNumber(val: number | string): number {\n  return val as number\n}\n\n// javascript 코드\nfunction asNumber(val) {\n  return val\n}\n```\n\n타입연산 코드는 모두 제거되기 때문에 단순히 받은 인자를 반환해 주는 목적과 다른 함수가 되어버린다. 이점을 개선하기 위해서는 런타임 타입을 체크해 자바스크립트 코드 자체에서도 숫자형으로 바꿔주는 코드를 작성해야 한다.\n\n```typescript\n// typescript 코드\nfunction asNumber(val: number | string): number {\n  return typeof val === \"string\" ? Number(val) : val\n}\n```\n\n이렇게 타입스크립트 컴파일러는 개발할 때는 **타입체크**를 하고 컴파일을 통해 **타입이 제거된 자바스크립트 코드**로 변환해준다. 런타임에는 타입이 없기 때문에 런타임 성능에 영향을 끼치지 않는다.\n\n## 🎭 구조적 타이핑\n\n자바스크립트는 `duck typing`기반으로 전달된 인자가 올바르다면 타입을 신경 쓰지 않는 특징을 가진다. 다음 예시를 보자.\n\n```typescript\ninterface Vector2D {\n  x: number\n  y: number\n}\n\nfunction calculateLength(v: Vector2D) {\n  return Math.sqrt(v.x ** 2 + v.y ** 2)\n}\n\ninterface NamedVector {\n  name: string\n  x: number\n  y: number\n}\n\nconst v: NamedVector = { x: 3, y: 4, name: \"zee\" }\n\ncalculateLength(v)\n```\n\n예시를 보면 `calculateLength`함수 자체는 `Vector2D`타입을 가지는 인자로 정의되어있다. 하지만 `NamedVector`도 `Vector2D`와 같이 x, y 속성을 가지기 때문에 에러없이 호출되는 것을 볼 수 있다. `vector2D`타입인지를 체크하는 것이 아니라 x, y 키를 가지고 있는 객체가 전달되었는지만 체크한다.\n\n이러한 점은 오류를 만들기도 하는데 다음 예제를 보자.\n\n```typescript\ninterface Vector3D {\n  x: number\n  y: number\n  z: number\n}\n\nfunction normalize(v: Vector3D) {\n  const length = calculateLength(v)\n  return {\n    x: v.x / length,\n    y: v.y / length,\n    z: v.z / length,\n  }\n}\n\nconsole.log(normalize({ x: 3, y: 4, z: 5 })) // { x: 0.6, y: 0.8, z: 1 }\n```\n\n위 예제는 length를 계산할 때 z를 고려하지 않고 길이를 계산해 생긴 문제다. length를 계산할 때 전달 받은 인자의 z속성까지 고려하는 것이 아니라 `Vector2D`로 정의된 x, y 속성만으로 타입 체크를 해 연산을 진행했다. 이러한 특징을 알고 타입 체크에서 오류가 발생할 것이라고 예상하기 보다, 인자로 전달할 때 필요한 속성에 대해 이해하고 전달해야 한다.\n\n구조적 타이핑은 위와 같은 문제가 발생할 수 있지만 테스트와 같이 추상화된 인터페이스를 이용할 수 있는 장점을 가진다.\n\n```typescript\ninterface DB {\n  runQuery: (sql: string) => any[]\n}\n\nfunction getAuthors(database: DB): Author[] {\n  const authorRows = database.runQuery(`Authors`)\n  return authorRows.map(row => ({ first: row[0], last: row[1] }))\n}\n```\n\n위 코드에서 database로 전달될 DB는 runQuery를 가지고 있으면 된다. 어떤 DB가 올 지를 정해 의존성을 높이기 보다 구조적 타이핑을 통해 추상화된 인터페이스를 가지는 것을 볼 수 있다.\n\n# 🤔 any에 대해\n\nany는 말그대로 어떤 것이든 될 수 있는 타입이다. 자바스크립트에 익숙해 지스트 청원서비스를 만들면서 처음 타입스크립트를 사용할 때 홧김에 많이 사용했던 any... 왜 any를 쓰면 안되는지 알아보자.\n\n[볼때마다 공감되는 any 밈..]\n\n![any](any.jpeg)\n\n**안정성**\n\n```typescript\nfunction calculateAge(birthDate: Date): number {\n  //\n  return 30\n}\n\nlet birthDate = \"1000\"\ncalculateAge(birthDate) // Argument of type 'string' is not assignable to parameter of type 'Date'.\n\nfunction calculateAge(birthDate: Date): number {\n  //\n  return 30\n}\n\nlet birthDate: any = \"1000\"\ncalculateAge(birthDate)\n```\n\n위 함수를 보면 `Date`타입을 인자로 받아야 하지만 `string`타입 변수를 전달해 에러가 발생했다. 이때 `any`로 타입을 바꿔주게 된다면 우리가 신경써서 타입을 정해놓은 함수가 `string`인자가 들어오는데도 오류로 알려주지 못하고 정상 처리되는 것을 볼 수 있다.\n\nany로 인해 타입 체크의 안정성을 놓쳐버렸다.\n\n**효율성**\n\n```typescript\nlet me = { first: \"YJ\" }\n//person.  first를 알려줘\n\nlet me: any = { first: \"YJ\" }\n// person. 아무것도 알려줄 수 없어\n```\n\n위 객체는 first라는 속성을 가지는 것을 알 수 있지만, any로 타입을 정한 후로는 어떤 속성과 메소드를 가지는 지 타입스크립트는 알려 줄 수 없다. 속성과 메소드를 맞게 썼는지 다시 체크해 코드 작성시 효율성을 떨어뜨리고 없는 속성과 메소드를 사용할 수도 있는 위험성을 가진다.\n\n내가 생각하는 타입스크립트의 장점 안정성과 효율성을 모두 놓칠 수 있기 때문에 `any는 꼭 지양하도록 하자`.\n\n[참조]\n\n- [기술서적 리뷰, 이펙티브 타입스크립트 - 1. 타입스크립트 알아보기](https://yhancsx.github.io/js/effective-typescript-ch1/)\n- [이펙티브 타입스크립트](https://search.shopping.naver.com/book/catalog/32473346832)\n"},{"excerpt":"🕶서버사이드 랜더링을 이용한 성능 개선 모으잡 프로젝트 기획과 디자인을 수정하고 나서 그다음 작업으로 성능 개선을 목표로 잡았다. 다른 기능을 추가하기 보다 Next 자체를 좀 더 잘 쓰는 방법에 대해 고민했고 그 방법으로 Next의 장점을 살리려 고민했다. Next의 장점은 이미지 최적화나 코드 스플릿팅 등을 자동으로 지원해 주는 장점도 있지만 가장 큰…","fields":{"slug":"/2022-12-25-모으잡-서버사이드-랜더링을-이용한-성능개선/"},"frontmatter":{"date":"December 25, 2022","title":"모으잡-서버사이드 랜더링을 이용한 성능 개선","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 🕶서버사이드 랜더링을 이용한 성능 개선\n\n모으잡 프로젝트 기획과 디자인을 수정하고 나서 그다음 작업으로 성능 개선을 목표로 잡았다. 다른 기능을 추가하기 보다 Next 자체를 좀 더 잘 쓰는 방법에 대해 고민했고 그 방법으로 **Next의 장점**을 살리려 고민했다. Next의 장점은 이미지 최적화나 코드 스플릿팅 등을 자동으로 지원해 주는 장점도 있지만 가장 큰 장점은 react에서 **서버 사이드 랜더링** 가능하다는 점이다. 서버 사이드 랜더링은 기존 SPA에서는 구현하기 힘든 <u>SEO 문제</u>를 쉽게 해결할 수 있고, 먼저 페이지를 보여 줌으로써 <u>사용자 경험을 향상</u>시킬 수 있다. 서버 사이드 렌더링을 적용해 해결해나간 과정을 정리해보려 한다.\n\n## ⛳ 모으잡 SEO 최적화\n\n**SEO** 는 Search Engine Optimization의 약자로 말 그대로 검색엔진 최적화를 의미한다. 검색엔진을 최적화 시킨다는 것은 구글이나 네이버와 같은 검색 사이트를 이용할 때 해당 키워드에 대해서 우선순위가 높게 나오게 만드는 것을 의미한다. 실제로 우리가 정보를 찾을 때 무조건 구글과 같은 검색 사이트를 통해 찾게 되는데 이러한 검색 사이트에서 높은 순위로 먼저 보인다는 것은 엄청난 마케팅 효과를 가진다.\n\n그렇기 때문에 SEO는 서비스의 중요한 부분이 되었기 때문에 SEO 최적화는 중요한 성능 지표 중 하나가 되었다. SEO 최적화를 위해 먼저 검색엔진이 동작하는 방식을 정리해보자\n\n1. 크롤링: 웹 크롤러가 사이트를 방문해 컨텐츠를 복사해서 검색엔진으로 가져온다.\n2. 인덱싱: 가져온 컨텐츠를 주제 별로 색인해서 보관한다.\n3. 랭킹: 검색 요청에 따라 색인된 컨텐츠에 순위를 부여해서 결과로 제공한다.\n\n<img src=\"https://lh6.googleusercontent.com/d_mF-4gS_inHDlP2GKpu87w0FzW8R4tfcThdwmNm8F730hHnCOoXwdgAFsdDu5fGJb-sgzZU2hj1JURZKty7uhmxdYNpJZQ-8Jo9N-1oV4NgDLIAZXAKXzV7tXB74OymG3KG2t5a\" width=\"600\"/>\n\n여기서 CSR이 SEO의 단점을 가지는 이유는 크롤링 과정에서 크롤러가 방문했을 때 비어있는 html문서만 복사하게 되기 때문이다. 이때 SSR을 통해 만들어진 페이지라면 먼저 컨텐츠가 있는 html을 크롤러가 복사해서 가져간다면 높은 순위로 보이게 된다.\n\nCSR로 무조건 SEO 최적화를 못하는 것은 아니다. [원티드 프리온보딩 과제](https://choi2021.github.io/posts/%EC%9B%90%ED%8B%B0%EB%93%9C-%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9-2-1-%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0/)로 SNS의 공유시 이미지와 설명을 담을 수 있는 기능이 필요해 CSR로 `react-helmet`과 `react-snap`을 이용해 구현을 했었다. 하지만 오랜 시간 걸렸고 `react-snap`은 2년이나 업데이트가 되고 있지 않는 라이브러리라는 문제점도 있었다.\n\n그렇기 때문에 이번에는 SSR를 이용해 모으잡 프로젝트에 SEO 최적화를 적용해보려 한다.\n\n### 기존 상황\n\n작업 전 상황은 일부 페이지에 간단한 title정보만 `<Head/>`태그 내에 작성되어 있는 상태였다. 개선하고 나서 비교를 위해 검색엔진 최적화 점수를 light house를 이용해 측정했을 때 아래와 같은 결과가 나타났다.\n\n[수정 전 light house 검색엔진 점수]\n\n![검색엔진](검색엔진점수.png)\n\n### Next-seo 적용과 OG 문제점\n\n개선을 위해서 `head`내용을 더 간편하게 사용할 수 있는 `Next-SEO`라이브러리를 이용해 meta태그와 SNS공유를 위한 Open Graph 내용을 추가했다. `Next-seo`는 `DefaultSeo`라는 컴포넌트가 있어 공통되는 부분을 한 곳에서 정의할 수 있다.\n\n```tsx\n// _app.tsx\nconst defaultSEO = {\n  defaultTitle: \"모으잡\",\n  titleTemplate: \"%s | 모으잡\", // %s로 페이지마다 title을 전달해줄 수 있어\n  description: \"원하는 회사의 채용공고를 모으고 비교해보자\",\n  canonical: \"https://moejob.vercel.app/\",\n  keywords: [\"moejob\", \"choi2021\", \"모으잡\"],\n  icon: \"/favicon.ico\",\n  openGraph: {\n    type: \"website\",\n    locale: \"ko_KR\",\n    url: \"https://moejob.vercel.app\",\n    title: \"모으잡\",\n    site_name: \"모으잡\",\n    description: \"원하는 회사의 채용공고를 모으고 비교해보자\",\n    images: [\n      {\n        url: \"/banner.jpg\",\n        width: 285,\n        height: 167,\n        alt: \"이미지\",\n      },\n    ],\n  },\n}\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const [queryClient] = useState(() => new QueryClient())\n  const dbService = new DBServiceImpl(firebaseApp)\n  return (\n    <>\n      <DefaultSeo {...defaultSEO} />\n      ...\n    </>\n  )\n}\nexport default MyApp\n```\n\n각 페이지마다 내용을 `NextSeo`컴포넌트의 props로 전달해 성능을 다시 검사했을 때 간단하게 SEO 최적화를 할 수 있었다.\n\n```tsx\n// pages/login.tsx\nconst Login = (...\n) => {\n  return (\n    <>\n      <NextSeo\n        title=\"로그인\"\n        description=\"원하는 회사의 채용공고를 모으고 비교해보자\"\n        openGraph={% raw %}{{\n          type: 'website',\n          url: `${process.env.NEXT_PUBLIC_BASE_URL}/login`,\n          title: '로그인 | 모으잡',\n          description: '원하는 회사의 채용공고를 모으고 비교해보자',\n        }}{% endraw %}\n      />\n     ...\n    </>\n  );\n};\n\n// pages/jobs/[id]\nfunction Index() {\n    ...\n  return (\n    <>\n      <NextSeo\n        title={job?.name}\n        openGraph={% raw %}{{\n          title: `${job?.name}`,\n          url: `${process.env.NEXT_PUBLIC_BASE_URL}/jobs/${job?.id}`,\n          images: [\n            {\n              url: job?.img || '',\n              width: 285,\n              height: 167,\n              alt: '상세 이미지',\n            },\n          ],\n        }}{% endraw %}\n      />\n    \t...\n    </>\n  );\n}\n\nexport default Index;\n```\n\n[Next-seo를 적용하고 검색엔진 최적화 점수]\n![검색엔진최적화](검색엔진최적화.png)\n\n하지만 SNS로 공유했을 때 상세 페이지에서도 `Default SEO`에 설정했던 이미지와 description이 공유되는 문제가 있었다. 카카오 톡, 페이스북, 슬랙 모두 기본 내용이 전달되는 것을 확인했고, 개발자 도구로 브라우저 상의 head를 보았을 때는 문제가 없었다.\n\n[상세페이지에서도 나오는 default 이미지와 description]\n![og](./og.png)\n문제를 해결하기 위해 고민을 하다가 상세 페이지에 전달되는 `job` 을 `<u>CSR에서 불러와</u>` 내용이 전달이 되지 않은 것 같다고 생각이 들었다. 그래서 서버 사이드로 내용을 prefetching을 해서 전달해주면 바로 header에 전달해 줄 수 있겠다고 예상했다.\n\n### SSR을 이용한 data fetching\n\ndata fetching은 처음 프로젝트를 기획부터 고민했던 부분이었다. 서버에서 데이터를 받아오기 때문에 별도의 loading없이 보여줄 수 있지만 당장 필요한 부분일까 고민이 되어서 미뤄뒀었다. 이번 기회에 next의 data fetching에 대해 공부하고 적용할 수 있었다.\n\nNext에서 data fetching은 SSG, SSR, CSR 다 지원한다. 이중에서 기존에 사용하고 있던 방식은 CSR이었고, 프로젝트에 필요한 방식은 SSR이라고 생각되었다. SSG를 next에서 먼저 추천해 주기도 하고 이미 빌드에서 만든 페이지를 응답하기 때문에 더 빠른 페이지 로딩 속도를 가지지만, 모으잡 프로젝트 특성 상 계속해서 채용공고 데이터를 추가, 삭제, 수정하기 때문에 **SSR**을 적용하는 게 알맞은 선택이라 생각했다.\n\nSSR을 적용하기 위해서는 react-query에서 SSR을 적용하는 방법을 공부해야 했다. React query는 두 가지 방법을 지원한다.\n\n- initialState\n- hydration\n\n**initialState**는 SSR에서 getServersideprops로 데이터를 불러온 후에 직접 props로 전달하기 때문에 보다 직관적이고 추가적인 코드 량이 적었다. 하지만 `useQuery`자체가 깊은 자식이 이용 시 inital data 자체를 전달해야 하기 때문에 prop-driliing이 생기고, 여러 곳에서 `useQuery`를 사용해야 할 경우에도 다 전달해줘야 하는 단점이 있었다.\n\n```tsx\n// react-query 공식홈페이지 예시\n\nexport async function getStaticProps() {\n  const posts = await getPosts()\n  return { props: { posts } }\n}\n\nfunction Posts(props) {\n  const { data } = useQuery({\n    queryKey: [\"posts\"],\n    queryFn: getPosts,\n    initialData: props.posts,\n  })\n\n  // ...\n}\n```\n\n그래서 확장성과 유지보수를 고려했을 때 내가 선택한 방식은 두 번째 **Hydration** 방식이었다. prefetch한 데이터를 전달해줘 마크 업을 한 후에 hydrate(수분공급, 이벤트를 연결하는 과정)하는 것을 의미한다. 이것을 하기 위해서는 앞선 initialData보다는 조금 더 복잡한 별도의 세팅이 필요하다.\n\n```tsx\n// react-query 공식홈페이지 예시\n\n// _app.jsx\nimport {\n  Hydrate,\n  QueryClient,\n  QueryClientProvider,\n} from \"@tanstack/react-query\"\n\nexport default function MyApp({ Component, pageProps }) {\n  const [queryClient] = React.useState(() => new QueryClient())\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Hydrate state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </Hydrate>\n    </QueryClientProvider>\n  )\n}\n\n// pages/posts.jsx\nimport { dehydrate, QueryClient, useQuery } from \"@tanstack/react-query\"\n\nexport async function getStaticProps() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery([\"posts\"], getPosts)\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n```\n\n위의 예시를 참고해서 `_app.tsx` 적용했을 때 아래 코드와 같이 된다.\n\n```tsx\n// _app.tsx\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: 1000 * 60,\n          },\n        },\n      })\n  );\n\t...\n  return (\n    <>\n      <DefaultSeo {...defaultSEO} />\n      <QueryClientProvider client={queryClient}>\n        ...\n           <Hydrate state={pageProps.dehydratedState}>\n             <Component {...pageProps} />\n           </Hydrate>\n         ...\n        <ReactQueryDevtools initialIsOpen={false} />\n      </QueryClientProvider>\n    </>\n  );\n}\nexport default MyApp;\n\n\n```\n\n`_app.tsx`는 추가하기만 하면 되었지만, 페이지에서 직접 datafetching을 적용하면서 문제가 생겼다. 우선은 데이터를 받아올 때 기존의 경우는 `jobList`컴포넌튼 내부에서 session을 전달받아 데이터를 불러오고 있었다. 페이지에서 data-fetching을 한다면 컴포넌트는 data-fetching에 대해서는 모르고 **주입받은 데이터를 보여주기 만** 하게 할 수 있지 않을까 생각되어 수정했다.\n\n```tsx\n// 기존 Joblist 컴포넌트\nexport default function JobList({ session }: { session: Session | undefined }) {\n  const { pathname } = useRouter()\n  const isUser = pathname === \"/user\" || pathname === \"/user/[id]\"\n  const user = session?.user\n  const { getFilteredJobs } = useJobs(isUser ? user : undefined)\n  const { isLoading, data: jobs } = getFilteredJobs\n  const vacantJobs = jobs?.length === 0\n  if (isLoading) {\n    return <GuideBox>채용공고를 불러오는 중입니다...</GuideBox>\n  }\n  if (vacantJobs) {\n    return <GuideBox>채용공고가 비어있습니다😉</GuideBox>\n  }\n\n  return (\n    <Wrapper>\n      {jobs && jobs.map(job => <JobItem key={job.id} job={job} />)}\n    </Wrapper>\n  )\n}\n\n// 수정한 Joblist 컴포넌트\n\nexport default function JobList({ jobs }: JobListProps) {\n  const vacantJobs = jobs?.length === 0 || !jobs\n  if (vacantJobs) {\n    return <GuideBox>채용공고가 비어있습니다😉</GuideBox>\n  }\n\n  return (\n    <Wrapper>\n      {!vacantJobs && jobs.map(job => <JobItem key={job.id} job={job} />)}\n    </Wrapper>\n  )\n}\n```\n\n최대한 컴포넌트는 로직에 대해서 모르게 하고 페이지에서 필요한 데이터를 넘겨주는 방식으로 수정해, 훨씬 의존성을 낮출 수 있었다.\n\n```tsx\n// pages/index.tsx\n\nfunction Home() {\n  const { getJobs } = useJobs()\n  const { data } = getJobs\n  return (\n    <MainLayout>\n      <JobSection jobs={data} />\n    </MainLayout>\n  )\n}\n\nexport default Home\n\nexport const getServerSideProps = async () => {\n  const queryClient = new QueryClient()\n  const dbService = new DBServiceImpl(firebaseApp)\n  await queryClient.prefetchQuery<Jobs, AxiosError, Jobs, [string, string]>(\n    [JOBS_KEY, \"all\"],\n    () => dbService.getJobs()\n  )\n\n  return {\n    props: { dehydratedState: dehydrate(queryClient) },\n  }\n}\n\n// pages/jobs/[id].tsx\n\nfunction Index() {\n  const { getFilteredJobs, getJobById } = useJobs()\n  const { data: job } = getJobById\n  const { data: allJobs } = getFilteredJobs\n\n  return (\n    <>\n      ...\n      <MainLayout>\n        {!job && <NotFound />}\n        {job && (\n          <>\n            <DetailJob job={job} />\n            <JobSection jobs={allJobs} />\n          </>\n        )}\n      </MainLayout>\n    </>\n  )\n}\n\nexport default Index\n\nexport const getServerSideProps = async (context: NextPageContext) => {\n  const query = context.query\n  const id = query.id?.toString()\n  const queryClient = new QueryClient()\n  const dbService = new DBServiceImpl(firebaseApp)\n  if (!id) {\n    return {\n      redirect: {\n        destination: \"/\",\n      },\n    }\n  }\n\n  await queryClient.prefetchQuery<Jobs, AxiosError, Jobs, [string, string]>(\n    [JOBS_KEY, \"all\"],\n    () => dbService.getJobs()\n  )\n\n  return {\n    props: { dehydratedState: dehydrate(queryClient) },\n  }\n}\n```\n\n이렇게 서버 사이드 렌더링 data-fetching으로 수정하고 다시 확인했을 때 정상적으로 카카오 톡, 페이스북, slack 모두 잘 나오는 것을 볼 수 있었다.\n\n![sns](./sns.png)\n\ngoogle 자체에도 등록하기 위해 [Google Search Console](https://search.google.com/search-console/about) 에 사이트를 등록하고 확인했을 때 아직은 실제로 검색이 되지 않는다. 시간이 걸리는 부분이라 계속해서 확인을 해볼 예정이다.\n\n## 🙄 SSR로 진짜 성능이 개선되었을까?\n\nSSR을 이용해 data-fetching으로 수정을 하고 나서 코드 적으로 더 가독성이 높아지고, 로딩 창을 보여주지 않고 한번에 화면이 보여 더 UX가 체감 상 좋아졌다. 하지만 정말 좋아졌는지 확인하기 위해서 google의 [page speed insights](https://pagespeed.web.dev/)을 이용해 측정해 보기로 했다. 기존과 비교하기 위해서 EC2로 배포되어있는 CSR을 이용하는 배포 버전과 vercel로 SSR이 적용되어있는 버전의 성능을 측정했다.\n\n측정을 하고 분석하는데 필요한 6가지 요소에 대해서 정리하고 요소들을 분석해보았다.\n\n### FCP\n\nFCP는 First Contentful Paint로 페이지가 로드되고 페이지 콘텐츠 일부가 화면에 렌더링 될 때 까지의 시간을 측정한다.\n\n### TTI\n\nTTI는 사용자와 상호작용하기 위해 준비된 시점으로, 이벤트 헨들러가 작동할 수 있는 시점을 의미한다.\n\n### Speed Index\n\nSpeed index는 컨텐츠가 시각적으로 표시되는 진행속도를 의미한다.\n\n### LCP\n\nLCP는 Largest Contentful Paint로 로딩 성능을 측정하는 지표로 처음 로드를 시작하고 ViewPort 내에서 가장 큰 이미지나 텍스트 블럭의 렌더링 시간을 측정한다.\n\n### FID와 TBT\n\nFID는 First Input Delay로 상호작용을 측정하는 지표로 사용자의 처음 상호작용부터 이벤트 핸들러가 처리를 시작하기까지 시간을 측정한다.\n\n검사에 사용한 page speed insights은 FID 대신에 **TBT**(Time Blocking Time)를 측정했다. TBT는 FCP부터 TTI 까지의 시간을 측정해 사용자 입력에 페이지가 응답하지 못하게 차단된 시간을 의미한다.\n\n### CLS\n\nCLS는 Cumulative Layout Shift로 사용자가 예상하지 못한 레이아웃 이동을 경험하는 것에 대한 지표다.\n\n[왼쪽은 CSR로 측정한 성능, 오른쪽은 SSR로 측정한 성능]\n![성능비교](./성능비교.png)\n\n각 지표들 중에서 크게 차이가 난 부분은 `TTI`와 `LCP`로 TTI는 이전보다 증가했고 LCP는 83% 감소한 결과를 보여주었다. 이전에는 가장 큰 컨텐츠인 이미지가 로딩 이후에 보여주었지만, 서버에서 데이터를 받아서 먼저 렌더링을 한 후에 이벤트를 붙여 주는 hydration 과정이 일어나기 때문에 TTI는 증가하고 LCP는 감소한 결과를 보여주었다.\n\n결과적으로는 전보다 개선이 된 결과를 얻을 수 있었다. 여기서 더 개선을 한다면 이미지 자체를 react-query를 통해 어떻게 캐싱을 해 렌더링 횟수를 관리할 지가 된다고 생각한다. 단순히 느낌적으로 좋아졌다고 생각하는 데서 그치지 않고 직접 측정함으로써 객관적인 데이터를 얻을 수 있는 좋은 경험이 되었다.\n\n[참조]\n\n- SEO (검색엔진최적화) 완벽 가이드 총정리 (2022년): https://www.ascentkorea.com/seo-complete-guide-2022/\n- webvitals: https://web.dev/vitals/\n"},{"excerpt":"👓 Class 자바스크립트 자체는 프로토타입을 기반으로 객체지향을 지원하는 언어다. 클래스는 클래스에 익숙한 개발자들을 위한 프로토타입의 이라고 불린다. 하지만 클래스가 자바스크립트 내에서 동작하는 방식에 차이점이 존재한다. 클래스에 대해서 알아보자 🙄 클래스의 정체와 호이스팅 먼저 클래스는 자바스크립트에서 다. 자바스크립트에서 함수는 이므로 매개변수, …","fields":{"slug":"/2022-12-23-class/"},"frontmatter":{"date":"December 23, 2022","title":"클래스","tags":["javascript","문법"]},"rawMarkdownBody":"\n# 👓 Class\n\n자바스크립트 자체는 프로토타입을 기반으로 객체지향을 지원하는 언어다. 클래스는 클래스에 익숙한 개발자들을 위한 프로토타입의 `문법적 설탕`이라고 불린다. 하지만 클래스가 자바스크립트 내에서 동작하는 방식에 차이점이 존재한다. 클래스에 대해서 알아보자\n\n## 🙄 클래스의 정체와 호이스팅\n\n먼저 클래스는 자바스크립트에서 `함수`다. 자바스크립트에서 함수는 `일급객체`이므로 매개변수, 반환 값으로 사용이 가능하고 변수에 저장할 수도 있다. 이렇게 생성자 함수와 같이 함수지만 차이점이 존재한다. 생성자 함수는 new가 없이 호출 시에 함수로써 동작하지만, 클래스는 new 키워드없이 호출할 수 없다.\n\n```javascript\nclass Cat {\n  constructor() {\n    this.name = \"야옹이\"\n  }\n  call() {\n    console.log(this.name)\n  }\n}\n\nconsole.log(Cat()) //TypeError: Class constructor Cat cannot be invoked without 'new'\n```\n\n위 코드에서 new없이 호출시 에러가 발생한 것을 볼 수 있다.\n\n클래스는 함수이기 때문에 호이스팅이 발생하지만, const, let으로 함수표현식과 같이 초기화 전까지 호출이 불가능한 TDZ에 빠지는 특징을 가진다.\n\n```javascript\nconst Cat = \"\"\n{\n  console.log(Cat) // ReferenceError: Cannot access 'Cat' before initialization\n  class Cat {}\n}\n```\n\n위 코드에서 호이스팅되지 않았다면 전역에서 만든 Cat 변수가 있기 때문에 `\" \"`로 콘솔에 나와야한다. 하지만 호이스팅이 일어나 에러가 난 것을 확인할 수 있다.\n\n## 😎 클래스의 메소드\n\n클래스는 생성자 함수와 같이 인스턴스 메소드, 정적 메소드, 프로토타입 메소드, 총 세가지 메소드 영역을 가진다. 각각에 대해 알아보자.\n\n### constructor\n\nconstructor 메소드는 class로 만들 인스턴스를 **생성**하고 **초기화**하기 위한 메소드다. 클래스는 함수이기 때문에 프로토타입을 가지는데 이때 프로토타입의 constructor는 클래스 자신을 가리키고 있다.\n![constructor](constructor.png)\n그렇기 때문에 클래스 자체로 인스턴스를 만들 수 있고, constructor 내부의 this는 인스턴스를 가리켜 만들어질 인스턴스의 초기값을 정할 수 있다. 이때 constructor메소드 내부에서 암묵적으로 return this를 자동으로 처리해주고 있다. 생성자함수에서 this로 인스턴스의 속성을 정해주던 것과 동일하다.\n\n이때 this대신 다른 객체를 return하면 결과가 달라지기 때문에 return을 생략하는 게 좋다.\n\n```javascript\nclass Cat {\n  constructor(name) {\n    this.name = name\n    return {}\n  }\n}\n\nconst cat = new Cat(\"양옹\")\nconsole.log(cat) // {}\n```\n\n클래스로 만들어진 인스턴스도 생성자함수가 만든 인스턴스와 동일하게 프로토타입 체인에 들어가게 된다. 결국 정리하면 프로토타입 체인에서 클래스는 인스턴스를 생성하는 생성자 함수와 같은 역할을 한다고 생각할 수 있다.\n\n![class](class1.png)\n\n### 프로토타입 메소드\n\n생성자함수에서는 인스턴스들이 공통으로 참조할 함수를 만들 때, 프로토타입에 함수를 전달했지만 클래스에서는 클래스 내부의 메소드를 선언하면 자동으로 프로토타입의 메소드가 된다.\n\n```javascript\nclass Cat {\n  constructor(name) {\n    this.name = name // 인스턴스 메소드\n  }\n  call() {\n    //프로토타입 메소드\n    console.log(\"야옹\")\n  }\n}\n\nconst cat = new Cat(\"야옹이\")\ncat.call() // 야옹\ncat.__proto__.call(\"야옹\")\n```\n\n### 정적 메소드\n\n정적 메소드는 생성자함수에서 생성자함수객체 자체가 갖는 속성으로, 클래스에서는 static을 붙여 정적 메소드를 정한다. class 자체가 갖는 메소드로 절댓값이나 랜덤한 수를 얻을 때 사용하던 `Math.abs()`가 static 함수의 예가 될 수 있다. 정적 메소드는 인스턴스에게 상속되지 않는 메소드로 별도의 인스턴스를 만들지 않고 사용해서 유틸리티 함수를 만들 때 사용된다.\n\n```javascript\nclass Cat {\n  static shout = () => console.log(\"야옹\") // 정적 메소드\n}\n\nCat.shout() //야용\n```\n\n## 🥚 인스턴스 생성과정\n\n클래스의 인스턴스를 만드는 과정을 정리하면 생성자 함수와 동일하게 동작한다. 가장 먼저 new 키워드로 빈 객체를 만들고 this를 바인딩한다. constructor 내부코드를 통해 초기화한 후에 생략된 `return this`로 인스턴스를 만든다. 클래스 내부의 인스턴스 메소드는 프로토타입을 통해 상속되기 때문에 자체적으로는 가지고 있지 않다.\n\n```javascript\nclass Cat {\n  static shout = () => console.log(\"야옹\")\n\n  constructor(name) {\n    this.name = name\n  }\n  call() {\n    console.log(\"하이\")\n  }\n}\n\nconst cat = new Cat(\"야옹\")\n\nconsole.log(cat.hasOwnProperty(\"call\")) //false\nconsole.log(cat.__proto__.hasOwnProperty(\"call\")) //true\n```\n\n## 🩸 클래스의 getter와 setter\n\n클래스는 **getter와 setter**를 이용해 데이터 속성 값을 읽거나 변경할 수 있다. getter와 setter는 모두 함수지만 사용할 때는 다른 속성과 동일하게 사용한다. getter는 해당 속성에 접근할 때 수행되는 함수이며 항상 값을 반환해줘야 하고, setter는 해당 속성을 변경할 때 실행되는 함수이므로 항상 인자가 필요하다. getter와 setter가 필요한 상황에 대해 알아보자.\n\n```javascript\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n  fullName() {\n    return `${this.firstName} ${this.lastName}`\n  }\n}\n\nconst person1 = new Person(100, 90)\nconsole.log(person1.averageScore()) //함수를 이용해야해\n```\n\n위의 코드의 점수의 평균 값을 얻고 싶은 상황에서 메소드로 평균 점수를 받을 수 있지만 averageScore를 속성으로 만들고 싶다. 그래서 우선은 초기 값으로 먼저 받아올 때 계산해서 속성으로 추가할 수 있다.\n\n```javascript\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = `${this.firstName} ${this.lastName}`\n  }\n}\n\nconst me = new Person(\"Youngjun\", \"Choi\")\nconsole.log(me.fullName) // Youngjun Choi\nme.firstName = \"hi\"\nconsole.log(me.fullName) // Youngjun Choi\n```\n\n하지만 문제점은 초기화로 값이 정해져버려 수학 점수를 수정했을 때 평균값은 반영이 안되고 있다. 이때 사용할 수 있는 것이 Getter와 Setter다.\n\n```javascript\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`\n  }\n\n  set fullName(value) {\n    this.fullName = value\n  }\n}\n\nconst me = new Person(\"Youngjun\", \"Choi\")\nconsole.log(me.fullName)\nme.fullName = \"yj Choi\" // RangeError: Maximum call stack size exceeded\n```\n\ngetter와 setter는 내부적으로 함수이기 때문 속성에 접근해 값을 반환해주고 변경할 수 있지만 사용 시에는 속성으로 사용할 수 있어 우리가 원하는 결과를 얻을 수 있다. 하지만 이때 주의할 점은 setter가 변경하는 속성의 이름과 접근하는 속성의 이름이 같을 경우 계속해서 **재귀적으로 호출**해 에러가 발생한다. 이를 해결하기 위해서는 값을 setter 속성을 직접 변경하는 것이 아니라 내부 속성을 이용해서 수정해야 한다.\n\n```javascript\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`\n  }\n\n  set fullName(name) {\n    ;[this.firstName, this.lastName] = name.split(\" \")\n  }\n}\n\nconst me = new Person(\"Youngjun\", \"Choi\")\nconsole.log(me.fullName) // Youngjun Choi\nme.fullName = \"yj Choi\"\nconsole.log(me.fullName) // yj Choi\n```\n\ngetter와 setter는 클래스 레벨의 접근자이기 때문에 프로토타입의 속성이 된다.\n\n![class3](class2.png)\n\n## 🗺 클래스의 필드\n\n클래스의 필드에 constructor 함수로 초기화하지 않아도 되는 인스턴스 속성을 정의할 수 있다. 이때 this는 사용해서는 안되고 초기 값이 없다면 undefined로 할당된다. 인스턴스 속성은 항상 public이지만 최신 자바스크립트는 `#`으로 private 필드, 클래스 내부에서만 참조 가능한 속성을 만들 수 있다.\n\n```javascript\nclass Person {\n  #name = \"비밀\"\n  get name() {\n    return this.#name\n  }\n}\n\nconst me = new Person()\n\nconsole.log(me.name)\nconsole.log(me.#name) // SyntaxError: Private field '#name' must be declared in an enclosing class\n```\n\n클래스 필드에 `static`을 이용하면 앞서 클래스 레벨의 메소드를 만든 것처럼 속성도 추가할 수 있다.\n\n```javascript\nclass Person {\n  #name = \"비밀\"\n  static male = \"남자\"\n  get name() {\n    return this.#name\n  }\n}\n\nconst me = new Person()\nconsole.log(Person.male) // 남자\n```\n\n## 🐔 클래스의 상속\n\n프로토 타입을 정리하면서 자바스크립트는 프로토 타입을 이용해 상속을 지원한다고 했었다. 클래스는 생성자 함수보다 편하게 `extends`키워드를 이용해 상속을 할 수 있다. 부모의 속성과 메소드를 상속을 받아 사용하기 위해 필요한 `super`키워드 에 대해 먼저 알아보자\n\n### Super\n\n`super`는 부모 클래스의 constructor를 호출하거나, 부모의 메소드를 참조할 때 사용한다. 각각의 경우에 대해 알아보자.\n\n먼저 `super`를 호출할 때는 중요한 세 가지 규칙이 있다. 이러한 규칙은 자식 클래스로 인스턴스를 만들면서 먼저 부모 클래스에게 인스턴스 생성을 위임하기 때문에 지켜져야 한다.\n\n1. 자식 클래스에서 constructor를 호출하는 경우에는 반드시 super를 호출해야 한다.\n\n```javascript\nclass Parent {}\n\nclass Child extends Parent {\n  //ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n  constructor() {}\n}\n\nconst child = new Child()\n```\n\n2. 자식 클래스의 constructor에서 super를 호출하기 전에 this를 참조할 수 없다.\n\n```javascript\nclass Parent {}\n\nclass Child extends Parent {\n  constructor() {\n    //ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n    this.a = 1\n    super()\n  }\n}\n\nconst child = new Child()\n```\n\n3. 자식의 constructor 함수에서만 super가 호출될 수 있다.\n\n```javascript\nclass Parent {}\n\nclass Child extends Parent {\n  constructor() {\n    this.a = 1\n    super()\n  }\n\n  foo() {\n    super() // SyntaxError: 'super' keyword unexpected here\n  }\n}\n\nconst child = new Child()\n```\n\n두 번째로 `super`를 이용해 부모 클래스의 메소드를 참조할 수 있다.\n\n```javascript\nclass Parent {\n  constructor(name) {\n    this.name = name\n  }\n\n  sayHi() {\n    return `${this.name}`\n  }\n}\n\nclass Child extends Parent {\n  sayHi() {\n    return `${super.sayHi()}` //parent.sayHi()\n  }\n}\n\nconst child = new Child(\"yj\")\nconsole.log(child.sayHi())\n```\n\n위 예제는 super를 통해 Parent 클래스의 프로토타입의 sayHi를 참조했다. 이때 this는 인스턴스를 가리키고 있기 때문에 name을 참조할 수 있다.\n\n이렇게 super를 참조할 수 있는 것은 메소드가 내부 슬롯 `[[HomeObject]]`를 가져, 바인딩하고 있는 객체의 프로토타입을 가리키고 있다. `sayHi()`메소드의 `[[HomeObject]]`에는 `Child.prototype`이 바인딩되고 super를 참조해 `child.prototype`의 프로토타입인 `Parent.prototype`을 가리킬 수 있다.\n\nsuper를 자식 클래스의 정적 메소드에서 이용하면 부모의 정적메소드를 참조할 수 있다.\n\n```javascript\nclass Parent {\n  static sayHi() {\n    return `Hi `\n  }\n}\n\nclass Child extends Parent {\n  static sayHi() {\n    return `${super.sayHi()}`\n  }\n}\n\nconsole.log(Child.sayHi()) // hi\n```\n\n이제 실제로 상속을 통해 객체를 만드는 과정에 대해 알아보자.\n\n```javascript\nclass Circle {\n  constructor(radius) {\n    this.radius = radius // 반지름\n  }\n\n  getPerimeter() {\n    return 2 * Math.PI * this.radius\n  }\n\n  getArea() {\n    return Math.PI * this.radius ** 2\n  }\n}\n\n// 자식 클래스\nclass Cylinder extends Circle {\n  constructor(radius, height) {\n    super(radius)\n    this.height = height\n  }\n\n  getArea() {\n    return this.height * super.getPerimeter() + 2 * super.getArea()\n  }\n\n  getVolume() {\n    return super.getArea() * this.height\n  }\n}\n\nconst cylinder = new Cylinder(2, 10)\n\nconsole.log(cylinder.getPerimeter())\n\nconsole.log(cylinder.getArea()) // 150.79644737231007\n\nconsole.log(cylinder.getVolume()) // 125.66370614359172\n```\n\n위의 예제로 인스턴스 cylinder가 만들어지는 과정을 순서대로 정리하면 다음과 같다.\n\n1. Cylinder 클래스의 super 호출\n\n   먼저 Cylinder 클래스의 constructor가 호출되는데 이때 super를 통해 **Cylinder 클래스에서 Circle클래스로 인스턴스 생성이 위임**된다. 그래서 실제로 인스턴스를 만드는 곳은 Circle 클래스이기 때문에 앞서 super를 먼저 호출하지 않으면 에러가 발생한다.\n\n2. Circle 클래스의 인스턴스 생성과 this 바인딩\n\nsuper호출로 Circle클래스는 인스턴스를 생성하기 위해 먼저 `{}`빈 객체를 만들고 this를 바인딩한다. 이때 this는 인스턴스를 가리키고 인스턴스의 프로토타입은 `Circle.prototype`이 아니라 `Cylinder.prootype`이 된다.\n\n3. Circle 클래스의 인스턴스 초기화\n\n   Circle클래스의 constructor함수로 인스턴스를 초기화한 후에 Cylinder클래스로 다시 전달한다.\n\n4. Cylinder 클래스의 this바인딩\n\n   Cylinder클래스에서는 별도의 인스턴스를 만드는 것이 아니라 전달받은 인스턴스를 this에 바인딩한다. 그렇기 때문에 super를 호출하기 이전에 this를 참조할 수 없다.\n\n5. Cylinder 클래스의 초기화\n\n   Cylinder 클래스의 constructor함수로 인스턴스의 초기화를 진행한 후에 this가 반환된다.\n\n이러한 과정을 통해 만들어 진 인스턴스의 프로토타입 체인은 다음 그림과 같이 표현된다.\n\n![class](class3.png)\n\n이때 `getArea` 메소드는 프로토타입 체인에서 Cylinder 클래스에 의해 override되면서 `Circle.prototype` 의 `getArea`가 아닌 `Cylinder.prototype`의 `getArea`로 호출되어 결과가 `4π`가 아니라 `48π`에 해당하는 `150.79644737231007`로 나타난다.\n\n## 마치며\n\n생성자 함수와 프로토타입을 이해하고 클래스를 다시 보면서 공통점과 차이점을 새롭게 알게 되었다. 이후에 타입스크립트에서 좀 더 강력한 객체 지향 요소들을 함께 정리할 예정이다.\n\n[참조]\n\n- [모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n- [프로토타입](https://poiemaweb.com/es6-class)\n"},{"excerpt":"📋 기획 수정 기존의 모으잡으로 약 6명 정도 지인들에게 보여주고 피드백을 받았다. 피드백들 덕분에 보다 객관적으로 프로젝트를 볼 수 있었다. 먼저 는 점이었다. 맨 처음 볼 수 있는 화면이 로그인 화면이었기 때문에 사용자 경험이 좋지 않다는 피드백을 들었고, 적극 공감했다. 내가 만든 서비스가 어떤 것인지도 모르는데 먼저 회원가입 하라는 것은 설득력이 …","fields":{"slug":"/2022-12-23-모으잡-기획-디자인 수정/"},"frontmatter":{"date":"December 23, 2022","title":"모으잡-기획, 디자인 수정","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 📋 기획 수정\n\n기존의 모으잡으로 약 6명 정도 지인들에게 보여주고 피드백을 받았다. 피드백들 덕분에 보다 객관적으로 프로젝트를 볼 수 있었다.\n\n먼저 `로그인을 해야 채용공고를 볼 수 있다`는 점이었다. 맨 처음 볼 수 있는 화면이 로그인 화면이었기 때문에 사용자 경험이 좋지 않다는 피드백을 들었고, 적극 공감했다. 내가 만든 서비스가 어떤 것인지도 모르는데 먼저 회원가입 하라는 것은 설득력이 전혀 없는 순서였다.\n\n두 번째로는 UI적으로 너무 비어 보인다는 점이었다. 채용공고가 많으면 그나마 괜찮지만 메인 페이지가 너무 휑해 보인다는 점이었다. 이점도 공감했던 부분이었다. 채용 서비스들의 경우 다양한 이벤트들을 하고 있어서 `배너`로 보여 주지만 현재 나는 어떤 걸 먼저 띄워줘야 할 지 고민이 되는 상태다. 대신에 전체적인 UI를 좀 더 발전 시켜보려고 채용공고 사이트들의 예시들을 참조했다.\n\n### ⛏ 서비스 work flow 수정하기\n\n먼저 메인 페이지에서 채용공고들을 보여주기 위해서는 기존 데이터베이스와 사용자 별 권한을 정리할 필요가 있었다.\n\n전체 공고는 메인 페이지에서 바로 볼 수 있어야 하므로 데이터베이스의 `jobs/`안의 객체로써 담겨있으면 좋겠다는 생각을 했다. 배열로 정리해도 되지만 디테일 페이지에서 상세 내용을 보여줘야 하므로, 전체 내용 중 원하는 상세 내용을 찾을 때 **배열보다 객체에서 찾는 것이 성능이 더 좋기 때문에** 객체로 저장하기로 했다. 전체 공고는 서비스를 사용하는 모든 사람이 볼 수 있어야 하지만 수정, 삭제, 추가는 인증된 사용자나 관리자 권한에서만 가능하게 구상했다.\n\n로그인만 하면 모든 공고를 마음대로 할 수 있는 것이 걱정이 되기도 했지만, 서비스의 방향을, **서로 정리한 관심 있는 회사들의 채용공고 내용을 정리하고 공유할 수 있는 서비스로** 구상했으므로 인증된 사람들이 관리자 권한도 있게 하는 것이 좋아 보였다.\n\n[권한 별 가능한 CRUD]\n\n|                권한                 | 일반 사용자 |     인증된 사용자      |\n| :---------------------------------: | :---------: | :--------------------: |\n|        전체 공고 ( `jobs/`)         | GET만 가능  | GET, POST, DELETE, PUT |\n| 유저별 공고 ( `Users/[user]/jobs` ) |   불가능    | GET, POST, DELETE, PUT |\n\n전체공고와 유저별 공고에 따라 다른 API를 구현하려 했지만 서버 사이드에서 처리해서 받아오는 user를 먼저 받아올 수 있으므로 **user의 유무**로 각각을 구현할 수 있을 것 같다고 생각되었다. 그래서 기존 `DBService interface`를 수정한 후에 react query 커스텀 훅에 반영했다. 그리고 updateJob과 addJob의 함수가 똑같은 firebase의 set으로 만들기 때문에 둘을 하나의 함수로 합쳤다.\n\n```typescript\n// DBType.ts\n\nexport interface DBService {\n  addOrUpdateJob: (job: Job, user?: User) => Promise<void>;\n  getJobs: (user?: User) => Promise<Jobs>;\n  removeJob: (job: Job, user?: User) => Promise<void>;\n}\n\n//DBService.ts\n\n  async getJobs(user?: User): Promise<Jobs> {\n    const dbRef = ref(this.db);\n    const query = user ? `users/${user?.id}/` : '';\n    return get(child(dbRef, `${query}jobs`))\n      .then((snapshot) => {\n        if (snapshot.exists()) {\n          return snapshot.val();\n        } else {\n          return {};\n        }\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n  }\n\n  async addOrUpdateJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : '';\n    return set(ref(this.db, `${query}jobs/${job.id}`), job);\n  }\n\n  async removeJob(job: Job, user?: User) {\n    const query = user ? `users/${user?.id}/` : '';\n    return remove(ref(this.db, `${query}jobs/${job.id}`));\n  }\n}\n\n```\n\n```tsx\n//useJobs.tsx\n\nconst JOBS_KEY = \"jobs\"\n\nexport const useJobs = (user?: User) => {\n  const dbService = useDBService()\n  const queryClient = useQueryClient()\n  const { query } = useRouter()\n  const { id } = query\n  const jobId = typeof id === \"string\" ? id : id?.join() || \"\"\n\n  const getJobs = useQuery([JOBS_KEY, user], async () => {\n    return dbService.getJobs(user)\n  })\n  const addOrUpdateJob = useMutation(\n    async (job: Job) => {\n      return dbService.addOrUpdateJob(job, user)\n    },\n    {\n      onSuccess: () => {\n        !user && queryClient.invalidateQueries([JOBS_KEY])\n        user && queryClient.invalidateQueries([JOBS_KEY, user])\n      },\n    }\n  )\n\n  const deleteJob = useMutation(\n    async (job: Job) => {\n      return dbService.removeJob(job, user)\n    },\n    {\n      onSuccess: () => {\n        !user && queryClient.invalidateQueries([JOBS_KEY])\n        user && queryClient.invalidateQueries([JOBS_KEY, user])\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            console.log(response)\n          }\n        }\n      },\n    }\n  )\n\n  const getFilteredJobs = useQuery(\n    [JOBS_KEY, user],\n    () => dbService.getJobs(user),\n    {\n      select: (data: Jobs) => {\n        return Object.values(data).filter(item => item.id !== id)\n      },\n      onError: error => {\n        console.error(error)\n      },\n    }\n  )\n\n  const getJobById = useQuery([JOBS_KEY, user], () => dbService.getJobs(user), {\n    select: (data: Jobs) => {\n      return data[jobId]\n    },\n    onError: error => {\n      console.error(error)\n    },\n  })\n\n  return { getJobs, addOrUpdateJob, deleteJob, getJobById, getFilteredJobs }\n}\n```\n\nuseJobs에서는 user가 있을 경우 따로 받아 와야 하므로 react-query API의 key값으로 user를 포함 시켰다. 결과적으로 user의 유무로 처리하다 보니 기존의 user가 undefined일 때를 위해 따로 처리해주던 로직을 제외해 깔끔하게 나타낼 수 있었다.\n\n권한에 따라 어떻게 데이터베이스를 처리할 지를 정하고 나서 `routing`에 대해서도 정리가 필요했다.\n\n먼저 전체 공고의 CRUD는 `/` 와 `/admin` 두 가지 페이지로 나눴다. `/`에서는 전체 공고를 먼저 보여주고, 로그인한 유저는 공고를 추가할 수 있게 구상했다. `/admin`에서는 새로운 공고를 추가할 수 있고 전체 공고를 수정, 삭제할 수 있게 하려 했다.\n\n유저 별 공고의 CRUD는 앞서 정리한 `/` 에서 추가 기능을 하기 때문에, `/user`에서는 모은 공고를 보여주고 공고를 수정, 삭제하는 기능을 처리할 수 있게 구상했다.\n\n전체 공고와 유저 별 공고는 모두 동일한 JobSection 컴포넌트를 통해서 보여주고 있기 때문에 getServerSideProps로 전달된 user의 유무가 아니라 path가 `/user`인지 아닌 지를 기준으로 useJobs에 user를 전달해줘야 했다.\n\n```tsx\n// JobSection.tsx\nexport default function JobSection({\n  session,\n}: {\n  session: Session | undefined;\n}) {\n  const { pathname } = useRouter();\n  const isAdmin = pathname === '/admin';\n  const title = getTitle(pathname);\n  return (\n    <Wrapper>\n      <header>\n        <Title>{title}</Title>\n        {isAdmin && (\n          <Btn href={'/admin/new'}>\n            <AiOutlinePlusCircle />\n          </Btn>\n        )}\n      </header>\n      {/* <Filters /> */}\n      <JobList session={session} />\n    </Wrapper>\n  );\n}\n\n// JobList.tsx\n\nexport default function JobList({ session }: { session: Session | undefined }) {\n  const { pathname } = useRouter();\n  const isUser = pathname === '/user' || pathname === '/user/[id]';\n  const user = session?.user;\n  const { getFilteredJobs } = useJobs(isUser ? user : undefined);\n  const { isLoading, data: jobs } = getFilteredJobs;\n    ...\n  return (\n    <Wrapper>\n      {jobs && jobs.map((job) => <JobItem key={job.id} job={job} />)}\n    </Wrapper>\n  );\n}\n```\n\n또한 JobItem은 일반 사용자는 추가, 삭제 버튼을 보여주지 않지만 로그인한 유저의 경우 `/`에서는 추가 버튼, `/user`와 `/admin` 에서는 삭제 버튼이 추가해야 했기 때문에 페이지 위치와 함께 로그인을 했는지 유무를 고려해서 UI로 나타내 주어야 했다. 로그인 유무는 getServersideProps로 전달받은 session을 전달해주기 보다 useSession hook을 이용해 CSR에서 받아와 확인했다.\n\n- `/` 에서 일반 사용자: 버튼이 보이지 않음\n- `/` 에서 로그인한 사용자: 추가 버튼이 보여\n- `/user`와 `/admin`에서 로그인한 사용자: 이미 리다이렉션으로 로그인한 사용자는 확인이 가능하기 때문에 `/`페이지가 아니면 삭제 버튼이 보여\n\n```tsx\nexport default function JobItem({ job }: { job: Job }) {\n  const { name, platform, img, checkPercentage } = job\n  const { pathname, push } = useRouter()\n  const isHome = pathname === \"/\"\n  const [message, setMessage] = useState(\"\")\n  const { data: session } = useSession()\n  const user = session?.user\n  const isLoggedin = !!session\n  const { addOrUpdateJob, deleteJob } = useJobs(user)\n  const handleDelete = () => {\n    deleteJob.mutate(job, {\n      onSuccess: () => {\n        setMessage(\"성공적으로 제거했습니다\")\n      },\n      onSettled: () => {\n        setTimeout(() => setMessage(\"\"), 4000)\n      },\n    })\n  }\n  const handleAdd = () => {\n    addOrUpdateJob.mutate(job, {\n      onSuccess: () => {\n        setMessage(\"성공적으로 추가했습니다\")\n      },\n      onSettled: () => {\n        setTimeout(() => setMessage(\"\"), 4000)\n      },\n    })\n  }\n\n  const handleClick = () => {\n    const link = redirectPath(pathname, job.id)\n    push(link)\n  }\n  const over50Percent = checkPercentage >= 0.5\n\n  return (\n    <>\n      <Wrapper>\n        {over50Percent && <Badge>50% 이상</Badge>}\n        {!isHome && (\n          <Btn onClick={handleDelete}>\n            <MdRemove />\n          </Btn>\n        )}\n        {isHome && isLoggedin && (\n          <Btn onClick={handleAdd}>\n            <AiOutlinePlus />\n          </Btn>\n        )}\n        <ImgBox onClick={handleClick}>\n          <Img\n            src={img}\n            alt=\"job\"\n            sizes='(max-width: 768px) 100vw,\n              (max-width: 1200px) 50vw,\n              33vw\"'\n            fill\n            priority\n          />\n        </ImgBox>\n        <MetaBox>\n          <h1>{name}</h1>\n          <h3>{platform}</h3>\n        </MetaBox>\n      </Wrapper>\n      {message && <Modal message={message} />}\n    </>\n  )\n}\n```\n\n### ✒ 전체 공고를 추가,삭제할 수 있는 adminForm\n\n기존의 크롤링 방식을 아예 제거하면서 새롭게 추가, 수정할 수 있는 form 페이지가 필요했다. form 페이지에는 기존 채용공고의 데이터 schema를 모두 작성할 수 있어야 했다. schema의 내용은 회사명, URL, 이미지, 플랫폼, 주요 업무, 자격 요건, 우대사항으로 수동으로 적어줘야 했다. 우선은 일일이 적는 방향으로 정했다. 이후에 새로운 추가하는 경우에는 input에서 textArea로 변경해 복사-붙여넣기가 좀 더 쉽게 될 수 있는 방향으로 고민하고 있다.\n\n새로운 공고를 추가하는 페이지는 `/admin/new`로 수정할 때는 `/admin/[id]`로 수정이 될 수 있게 routing을 결정했다. AdminForm 컴포넌트 내에 함수들이 많아 커스텀 hook으로 분리했다. message 상태 같은 경우 mutate와 항상 같이 따라 다니기 때문에 여러 컴포넌트에 동일하게 나타나, 어떻게 하면 반복을 줄일 수 있을지 좀 더 고민이 필요하다.\n\n```tsx\nexport default function AdminForm({ isNew, initialValue }: AdminFormProps) {\n  const { job, onAdd, onChange, onDelete, onUpdateDescription } =\n    useForm(initialValue)\n  const [message, setMessage] = useState(\"\")\n\n  const DescriptionList: DescriptionListType[] = [\n    {\n      name: JOB_SCHEMA.MAIN_WORK,\n      title: \"주요 업무\",\n      value: job.mainWork,\n    },\n    {\n      name: JOB_SCHEMA.QUALIFICATION,\n      title: \"자격 요건\",\n      value: job.qualification,\n    },\n\n    {\n      name: JOB_SCHEMA.PREFERENTIAL,\n      title: \"우대 사항\",\n      value: job.preferential,\n    },\n  ]\n\n  const title = isNew ? \"새로운 공고 추가하기\" : \"공고 수정하기\"\n  const BtnText = isNew ? \"추가하기\" : \"수정하기\"\n\n  const { addOrUpdateJob } = useJobs()\n  const { mutate } = addOrUpdateJob\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n    const { dataset } = e.currentTarget\n    if (dataset.tag !== \"form\") {\n      return\n    }\n    mutate(job, {\n      onSuccess: () => {\n        setMessage(\n          isNew ? \"성공적으로 추가되었습니다\" : \"성공적으로 수정되었습니다\"\n        )\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            setMessage(`${response.statusText} 에러가 발생했습니다`)\n          }\n        }\n      },\n      onSettled: () => {\n        setTimeout(() => {\n          setMessage(\"\")\n        }, 4000)\n      },\n    })\n  }\n\n  return (\n    <Wrapper>\n      ...\n      <form data-tag=\"form\" onSubmit={handleSubmit}>\n        <AdminFormItem\n          name={JOB_SCHEMA.NAME}\n          title=\"회사 명\"\n          type=\"text\"\n          value={job.name}\n          onChange={onChange}\n        />\n        <AdminFormItem\n          name={JOB_SCHEMA.URL}\n          title=\"URL\"\n          type=\"text\"\n          value={job.url}\n          onChange={onChange}\n        />\n        <AdminFormItem\n          name={JOB_SCHEMA.IMG}\n          title=\"이미지\"\n          type=\"text\"\n          value={job.img}\n          onChange={onChange}\n        />\n        <Select onChange={onChange} platform={job.platform} />\n        {DescriptionList.map(item => (\n          <AdminDescriptionList\n            name={item.name}\n            title={item.title}\n            value={item.value}\n            onAdd={onAdd}\n            onDelete={onDelete}\n            onChange={onUpdateDescription}\n          />\n        ))}\n        <Btn>{BtnText}</Btn>\n      </form>\n      {message && <Modal message={message} />}\n    </Wrapper>\n  )\n}\n\n//useForm.tsx\n\nexport const useForm = (initialValue: Job) => {\n  const [job, setJob] = useState<Job>(initialValue)\n  const onAdd = (name: DescriptionNameType) => {\n    setJob(prev => {\n      const list = prev[name]\n      const newItem: DescriptionType = { text: \"\", checked: false, id: uuid() }\n      return { ...prev, [name]: [...list, newItem] }\n    })\n  }\n  const onDelete = (name: DescriptionNameType, id: string) => {\n    setJob(prev => {\n      const list = prev[name].filter(item => item.id !== id)\n      return { ...prev, [name]: list }\n    })\n  }\n  const onChange = (\n    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>\n  ) => {\n    const { name, value } = e.currentTarget\n    setJob(prev => ({ ...prev, [name]: value }))\n  }\n\n  const onUpdateDescription = (\n    name: DescriptionNameType,\n    value: string,\n    id: string\n  ) => {\n    setJob(prev => {\n      const updated = prev[name].map(item => {\n        if (item.id === id) {\n          return { ...item, text: value }\n        }\n        return item\n      })\n      return { ...prev, [name]: updated }\n    })\n  }\n\n  return { job, onAdd, onDelete, onChange, onUpdateDescription }\n}\n```\n\n위와 같이 기획을 수정한 후에 홈페이지를 구성했을 때 다음과 같이 나타났다.\n\n[홈페이지 ( `/`) , 전체 공고의 상세 페이지 (`/jobs/:id`) ]\n![홈페이지, 전체공고 상세 페이지](./페이지1.png)\n\n[유저 별 페이지 ( `/user` ), 유저별 상세 페이지 (`/user/:id`) ]\n\n![유저별 페이지, 유저별 상세 페이지](./페이지2.png)\n\n[admin 페이지 ( `/admin` ), admin 상세 페이지 (`/admin/:id`) ]\n\n![admin](./페이지3.png)\n\n## 🎨 디자인 수정\n\n디자인에 대한 피드백을 받고 처음에는 잘 해뒀다고 생각했었는데 비어 보인다는 생각이 많이 들었다. 먼저 생각이 든 부분은 배경과 컨텐츠의 색이 똑같기 때문에 비어 보이는 게 크다는 생각이 들어서 컨텐츠와 배경 색을 구분하고 기존 메인 페이지부터 순서대로 손보기 시작했다.\n\n### 메인 페이지\n\n기존의 메인 페이지는 크롤링을 할 수 있는 form이 있어서 컨텐츠가 많이 없어도 괜찮았지만 form이 사라지고 난 뒤에는 허전함이 더 커 보였다. 그래서 우선은 필요 없는 배너는 없애고 각 jobItem의 크기를 키워서 보다 공고가 잘 보이게 수정했다. 여기서 홈페이지 디자인을 추가한다면 모든 공고로 페이지를 분리하고 메인 페이지에서 사용법에 대해서 나타내 주면 좀 더 좋지 않을까 생각도 들었다. 공고가 많아지면 페이지네이션이나 무한 스크롤을 추가해서 기능적인 보충도 필요할 것 같다.\n\n[메인 페이지]\n![메인페이지](./메인페이지.png)\n\n### 상세 페이지\n\n기존 상세 페이지의 문제점은 사진과 채용공고의 주요업무를 한 줄에 나타내다 보니 사진의 크기나 주요 업무의 양에 따라 레이아웃에 문제가 생겼다. 이것을 해결하기 위해서 우선은 모두 세로로 레이아웃을 변경했고, 이미지 크기도 고정 시켜두었다. 이렇게 나타내면 가로로 너무 비게 되는 게 문제가 생겼는데, 이점은 프로그래머스와 원티드 페이지를 참고해 Sidebox 컴포넌트를 추가했다. Sidebox는 sticky를 이용해 사용자의 스크롤 위치와 상관없이 계속해서 보여 주면 좋을 것 같은 회사이름과 추가 버튼을 담았다.\n\n[프로그래머스 채용공고 페이지]\n![프로그래머스](./프로그래머스.png)\n\n[수정한 상세 페이지 ]\n![수정한 상세페이지](./수정한상세페이지.gif)\n\n### AdminForm\n\nAdminForm으로 몇 개의 채용공고를 직접 올리면서 현재 디자인은 공고의 내용을 담기에 가독성도 떨어지고 일일이 옮겨야 하는 불편함도 있었다. 이점을 해결하기 위해서 디자인을 상세 페이지 때와 같이 세로로 레이아웃을 바꾸고, 항목 하나하나를 담던 `<input/>`이 아니라 통으로 복사, 붙여넣기 할 수 있게 `<textarea/>`로 태그를 바꿔서 편의성을 높였다. 기존 input으로 타입과 모든 함수를 짜놨기 때문에 상태를 따로 추가해서 이후에 submit할 때 normalize시키는 방향으로 작업을 진행했다.\n\nvalue값이 textArea는 string이고 기존 데이터는 배열이어서 type을 이용해 로직을 구분 시킬 수 있었다.\n\n```tsx\n// AdminDescriptionList.tsx\nexport default function AdminDescriptionList({\n  name,\n  title,\n  value,\n  onAdd,\n  onDelete,\n  onChange,\n  onNewDescriptionChange,\n}: AdminDescriptionListProps) {\n  const isString = typeof value === \"string\"\n  return (\n    <Wrapper>\n      ...\n      {isString && (\n        <TextArea\n          text={value}\n          name={name}\n          onChange={onNewDescriptionChange}\n        ></TextArea>\n      )}\n      {!isString && (\n        <ul>\n          {value.map(item => (\n            <AdminDescriptionItem\n              key={item.id}\n              name={name}\n              item={item}\n              onChange={onChange}\n              onDelete={onDelete}\n            />\n          ))}\n        </ul>\n      )}\n    </Wrapper>\n  )\n}\n\n// TextArea.tsx\nexport default function TextArea({ name, text, onChange }: TextAreaType) {\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const { value } = e.currentTarget\n    onChange(name, value)\n  }\n  return <Wrapper required value={text} onChange={handleChange}></Wrapper>\n}\n```\n\n크롤링으로 문자열을 처리할 때는 너무 많은 제약이 있었지만 직접 복사, 붙여 넣기를 한다고 했을 때는 해당 부분의 내용만 가져오면 되서, `•` 와 `-`를 제거해주고 띄어쓰기로 split만 하면 간단하게 데이터를 가공할 수 있었다. 이렇게 가공된 데이터를 기존 handleSubmit과 연결할 때, normalize한 데이터를 다시 setJob으로 업데이트 시키는 게 아니라 그대로 값을 사용해서 API를 호출했다. 이렇게 처리한 이유는 setState로 상태를 업데이트하고 mutate를 하면 동기적 코드지만 **setState가 비동기적으로 처리**될 수 있기 때문이었다.\n\n```typescript\n// normalizeDescription.ts\n\ntype RawDescriptionsType = {\n  mainWork: string;\n  qualification: string;\n  preferential: string;\n};\n\ntype NormalizedDescriptionsType = {\n  mainWork: DescriptionType[];\n  qualification: DescriptionType[];\n  preferential: DescriptionType[];\n  [index: string]: DescriptionType[];\n};\n\nexport const normalizeDescriptions = (\n  descriptions: RawDescriptionsType\n): NormalizedDescriptionsType => {\n  const result: NormalizedDescriptionsType = {\n    mainWork: [],\n    qualification: [],\n    preferential: [],\n  };\n  const reg = /[•-]/gi;\n  for (const [key, value] of Object.entries(descriptions)) {\n    const text = value.replace(reg, '').trim();\n    const items = text.split('\\n');\n    const normalizedItems = items.map((item) => {\n      return { id: uuid(), text: item, checked: false };\n    });\n    result[key] = normalizedItems;\n  }\n  return result;\n};\n\n\n// AdminForm.tsx\n\n const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const { dataset } = e.currentTarget;\n    if (dataset.tag !== 'form') {\n      return;\n    }\n    let targetJob = job;\n\n    if (isNew) {\n      const normalizedDescriptions = normalizeDescriptions(descriptions);\n      targetJob = { ...job, ...normalizedDescriptions };\n    }\n    mutate(targetJob, {...})\n  };\n```\n\n[수정한 전체공고 추가 페이지 (`/admin/new`)]\n![수정한 전체공고 추가 페이지](./수정한전체공고추가페이지.gif)\n\n## 마치며\n\n아직 하고 싶은 것도 부족한 것도 많은 프로젝트라 매번 새로운 시도들을 할 때 즐겁다. 물론 현실은 이력서를 쓰고 떨어지는 날들의 연속이지만 `무조건 개발자가 된다`는 생각으로 지금 내가 있는 자리에서 더 잘할 수 있는 방법들을 반영하다 보면 정말 원하는 회사에서 내가 원하는 서비스를 만들고 있지 않을까. 내일 나를 한번 더 믿어보겠다는 맘으로 개발을 즐기며 이 시간을 버텨나가려 한다.\n"},{"excerpt":"🔓 SSR을 이용한 인증/인가 도입 이번에 프로젝트를 고민하면서 항상 답답했던 부분이었던 페이지 redirection과 인증 과정에 대해 더 깊이 공부했다. CSR로 처리하던 인증 방식을 SSR로 수정하기까지 과정을 정리해 보려 한다. 😅 Firebase의 API를 이용한 User 상태 관리 기존 Authentication은 firebase Auth를 이…","fields":{"slug":"/2022-12-17-모으잡-인증인가/"},"frontmatter":{"date":"December 17, 2022","title":"모으잡-SSR을 이용한 인증,인가 도입","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 🔓 SSR을 이용한 인증/인가 도입\n\n이번에 프로젝트를 고민하면서 항상 답답했던 부분이었던 페이지 redirection과 인증 과정에 대해 더 깊이 공부했다. CSR로 처리하던 인증 방식을 SSR로 수정하기까지 과정을 정리해 보려 한다.\n\n## 😅 Firebase의 API를 이용한 User 상태 관리\n\n기존 Authentication은 firebase Auth를 이용해 받아온 user정보의 **token을 localstorage에 저장**해서 확인했다. localstorage에 token을 저장하는 방식은 보안에 취약하다는 얘기를 많이 들어, 새로운 방법을 고민하고 있었다. 고민과정에서 firebase의 API로 `onAuthStateChanged`가 있다는 것을 알게 되었고, API를 이용한다면 별도의 토큰과 쿠키를 직접 저장하지 않아도 될 것이란 예상이 되어 적용했다.\n\n```tsx\n//AuthService.ts\nexport class AuthServiceImpl implements AuthService {\n  googleProvider: GoogleAuthProvider;\n  githubProvider: GithubAuthProvider;\n  auth: Auth;\n\n  constructor(private app: FirebaseApp) {\n    this.googleProvider = new GoogleAuthProvider();\n    this.githubProvider = new GithubAuthProvider();\n    this.auth = getAuth(this.app);\n  }\n    ...\n  onUserStateChanged(callback: Dispatch<SetStateAction<User | null>>) {\n    return onAuthStateChanged(this.auth, callback);\n  }\n}\n\n//AuthContext.tsx\n\ntype InitialValue = {\n  authService: AuthService;\n  user: User | null;\n};\n\nconst AuthContext = createContext<InitialValue | null>(null);\nexport const AuthProvider = ({ children, authService }: AuthProviderProps) => {\n  const [user, setUser] = useState<User | null>(null);\n  useEffect(() => {\n    authService.onUserStateChanged((user) => {\n      setUser(user);\n    });\n  }, []);\n\n  return (\n    <AuthContext.Provider value={{ user, authService }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuthService = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('Not under AuthProvider');\n  }\n  return context;\n};\n\n```\n\n<br/>\n\n이렇게 수정하고 API를 이용해 login상태를 확인해서 페이지 이동을 하다 보니 다른 문제가 생겼다. 랜더링을 하고 API로 user상태를 바꾸기 전, 초기 값이 null로 되어있어 API 호출시 **user가 없는 상태로 호출**되어 에러가 나타났다. 우선 useJobs 훅 내부에 useEffect로 user상태가 달라지면 refetch해 받아올 수 있게 해결했다.\n\n```typescript\nexport const useSpecificJobs = () => {\n  const { user } = useAuthService();\n  const { query } = useRouter();\n  const { id } = query;\n  const dbService = useDBService();\n\n  const getFilteredJobs = useQuery(\n    [JOBS_KEY],\n    () => {\n      if (!user) {\n        return {};\n      }\n      return dbService.getJobs(user);\n    },\n    {\n      select: (data: ModifiedJobsType) => {\n        if (!data) {\n          return [];\n        }\n        return Object.values(data).filter((item) => item.id !== id);\n      },\n      onError: (error) => {\n        console.log(error);\n      },\n    }\n  );\n  useEffect(() => {\n    getFilteredJobs.refetch();\n  }, [user]);\n\t...\n};\n```\n\n채용공고들을 받아오는 과정이 늘어나게 되어 **같은 API를 두번 호출하는 과정에서 시간이 더 오래 걸리게 되었다**.\n\n[호출 과정]\n\n1. 메인 페이지 렌더링\n1. API호출\n1. User상태 업데이트\n1. API 재호출\n\n해결방법으로 user를 먼저 받고 API콜을 하는 방법과, auth를 server-side로 먼저 받아오는 방법 두가지 방법이 떠올랐다. 그중 먼저 현재 진행하고 있는 CSR에서 해결방법을 찾아보았다.\n\n## 💻 CSR에서의 해결법: Protected Route 도입\n\nCSR에서 해결하기 위해서는 fetch로 user를 받아온 후에 api를 호출할 수 있게 해야 했다. 검색해서 새롭게 알게 된 것은 Protected Route라는 HOC를 이용하는 방법이었다.\n\n### 1) 로그인 flow 수정하기\n\n먼저 가장 시급한 문제는 로그인 후에 메인 페이지 이동시에 User가 없는 상태로 API가 호출된다는 점이었다. 이것을 막기 위해서는 먼저 user상태를 관리해 줄 수 있는 component가 필요했고, AuthStateChanged라는 컴포넌트를 만들어 컴포넌트가 마운트되면 먼저 User를 받아오고, 이후에 메인 페이지가 렌더링 될 수 있게 했다.\n\n```tsx\n// AuthStateChanged.tsx\n\nimport React, { useEffect, useState } from 'react';\nimport { useAuthService } from '../context/AuthContext';\n\nexport default function AuthStateChanged({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const { authService, setUser } = useAuthService();\n\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    authService.onUserStateChanged((user) => {\n      setUser(user);\n      setLoading(false);\n    });\n  }, []);\n\n  if (loading) {\n    return <h1>로딩중</>;\n  }\n\n  return <>{children}</>;\n}\n\n// _app.tsx\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n    ...\n  return (\n    <>\n      <QueryClientProvider client={queryClient}>\n        <DBProvider dbService={dbService}>\n          <AuthProvider authService={authService}>\n            <AuthStateChanged>\n              <ThemeProvider theme={theme}>\n                <GlobalStyle />\n                <Component {...pageProps} />\n              </ThemeProvider>\n            </AuthStateChanged>\n          </AuthProvider>\n        </DBProvider>\n      </QueryClientProvider>\n    </>\n  );\n}\nexport default MyApp;\n\n```\n\nUser가 있어야만 다음 컴포넌트들로 넘어가 동작하기 때문에 이전 가장 큰 문제였던 API를 정상적으로 한번만 호출하게 해결할 수 있었다.\n\n하지만 여전히 살짝 문제가 남아있었던 것은 AuthStateChanged에서 User를 받아오는 동안 **화면에 로딩을 보여줘야 한다**는 점이었다. 로딩을 안 보여주기 위해 loading이 true일 때 `<></>` 리액트 fragment로 반환한다 해도 여전히 불러오는 동안의 빈 페이지가 보였다.\n\n[AuthStateChanged 컴포넌트를 추가한 후 새로고침한 모습]\n\n![새로고침](./새로고침.gif)\n\n### 2) Protected Route\n\n두 번째로 로그인하지 않고 메인 페이지에 접속하는 경우와 로그인 후에도 로그인 페이지에 접속하려는 경우를 막기 위한 리다이렉션 로직이 필요했다. 이것을 위해서 AuthStateChanged 컴포넌트와 유사하게 조건에 따라 렌더링을 해줄 수 있는 ProtectedRoutes 컴포넌트를 추가했다. Protected Route는 필요한 페이지에 맞게 사용되어야 했기 때문에 type을 정할 때 Generic을 이용해 정해 줄 수 있었다.\n\n```tsx\n//ProtectRoute.tsx\n\nimport { useRouter } from \"next/router\"\nimport React, { ComponentType } from \"react\"\nimport { useAuthService } from \"../context/AuthContext\"\nexport function withPublic<T>(Component: ComponentType<T>) {\n  return function WithPublic(props: T) {\n    const auth = useAuthService()\n    const router = useRouter()\n    if (auth.user) {\n      router.replace(\"/\")\n      return <></>\n    }\n    return <Component auth={auth} {...props} />\n  }\n}\n\nexport function withProtected<T>(Component: React.ComponentType<T>) {\n  return function WithProtected(props: T) {\n    const auth = useAuthService()\n    const router = useRouter()\n    if (!auth.user) {\n      router.replace(\"/login\")\n      return <></>\n    }\n    return <Component auth={auth} {...props} />\n  }\n}\n\n// pages/login.tsx\nfunction Login() {\n  // ...\n}\n\nexport default withPublic(Login)\n\n// Pages/register.tsx\nfunction Register() {\n  // ...\n}\n\nexport default withPublic(Register)\n\n// pages/index.tsx\nfunction Home() {\n  // ...\n}\n\nexport default withProtected(Home)\n\n// pages/job/[id].tsx\n\nfunction Index() {\n  // ...\n}\n\nexport default withProtected(Index)\n```\n\nProtected Route를 이용해 로그인을 한 후에 home에서 login으로 이동하거나 로그인을 하지 않고 login에서 home으로의 이동을 막을 수 있었다. 하지만 여전히 앞서 문제가 되었던 페이지 이동시간동안 **로딩을 보여줘야 하는 문제**가 있었다.\n\nProtected Routes를 알기 전에 해결방법으로 떠올렸던 **서버사이드에서 auth를 미리 받아와** 렌더링 전에 체크한 후에, 해당 페이지에서 auth를 바로 받아볼 수 있다면 좀 더 로직도 간단해지고, next를 잘 활용하는 방법이 되지 않을까라는 생각이 들어 다시 찾아보기 시작했다.\n\n## 💾 Next-auth를 이용한 SSR로 전환\n\nSSR을 이용하기 위한 방법을 찾기위해 Next JS 공식 사이트를 찾아보니, 제시된 방법으로 `with-iron-session`과 `next-auth`라는 라이브러리를 이용하는 방법이었다. 그중에서 기존 지원했던 OAuth를 이용한 로그인 방식을 그대로 사용할 수 있는 **next-auth**를 선택했다.\n\n[next auth]\n![next auth](./next-auth.png)\n\nNext-auth는 Next js에서 쉽게 인증과정을 구현해 줄 수 있는 라이브러리로, API Routes를 이용해 서버단에서 session과 토큰을 만들고 확인해 client에서 필요했던 확인로직을 줄여줄 수 있다. Next Auth를 공부하면서 굉장히 다양한 Provider들을 OAuth로 제공해준다는 점이 놀라웠다. 특히, 카카오톡과 네이버도 지원해준다는 점이 신기했고, 다양한 DB와도 연동해서 사용할 수 있어 좋았다.\n\nSSR을 Next-auth로 적용할 수 있다는 사실을 알게 된 후에, 라이브러리를 잘 사용하기 위해 **인증, 인가 과정**과 앞서 사용했던 방식인 **local storage에 두는 방식이 왜 안 좋은지**에 대해 이해하고, **Next-auth가 해결책이 될 수 있는지** 고민했다.\n\n### 😖 토큰을 localStorage에 두면 안되는 이유\n\nlocal storage는 브라우저가 닫혀도 유지되기 때문에 로그인을 유지할 수 있는 간편한 방법으로 사용해왔다. 하지만 이러한 방식은 ` XSS (Cross-Site Scripting) 공격`에 취약한 단점을 가진다.\n\n#### XSS (Cross-site scripting)\n\nXSS 공격은 웹사이트에 **악성 스크립트를 주입하는 방식**으로 주로 페이지의 input이나 form을 이용해 공격하는 방식이다. 주입해놓은 사이트에 사용자가 로그인하게 될 경우에 사용자의 토큰, 쿠키 등의 정보를 빼낼 수 있게 된다. 그렇기 때문에 자바스크립트로 접근할 수 있는 localstorage나 별도의 옵션이 없는 쿠키에 토큰을 저장하게 될 경우에는 XSS 공격에 취약하게 된다.\n\n<img src=\"https://cdn.inflearn.com/public/files/courses/327087/fbade0da-7961-4789-b25b-106f68ba9abb/blob\" width=\"800\" />\n\n이것을 막기 위해서는 `in-memory에 저장하는 방식`과 `http only 쿠키`를 이용하는 방식이 있다. in-memory에 저장할 경우에는 관리는 쉽지만 로그인을 유지할 수가 없는 단점이 있어, 보통 http only 쿠키로 서버에서 토큰을 보내주면 브라우저에 저장하고 자동으로 요청시 담아서 보내는 방식을 적용할 수 있다. 하지만 http only 쿠키로 토큰을 저장하는 방법도 `CSRF 공격`에 약한 단점이 존재한다.\n\n#### CSRF(Cross-site Request Forgery)\n\nCSRF공격은 사용자가 원하지 않은 action을 하게하는 해킹 방법으로, 로그인한 사용자의 정보를 이용해 사용자 몰래 브라우저에 저장되어있는 쿠키를 이용해 요청을 보내는 방식이다. http only로 된 쿠키이기 때문에 해킹범이 쿠키를 직접 빼올 수는 없지만, 대신 자신이 원하는 요청에 사용자의 토큰을 이용해 사용할 수 있다. 그렇기 http only 쿠키만 사용하는 것이 아니라 추가적인 인증방식이 필요한데, 이때 사용할 수 있는 방법이 `CSRF 토큰`이다.\n\n<img src=\"https://velog.velcdn.com/images%2Fgwanuuoo%2Fpost%2F7f926efe-4b52-49d9-8dfd-78b26c0c1bb1%2FScreen%20Shot%202021-06-27%20at%202.15.28%20PM.png\" width=\"500\" />\n\nCSRF 토큰은 서버에서 발급하는 인증용 토큰으로, 클라이언트는 받은 토큰을 in-memory에 저장해 두고 이후 요청에 토큰을 함께 보낸다. 만약에 해킹범이 CSRF공격을 한 후에 사용자의 쿠키를 이용해 요청을 보내더라도, 사용자가 직접보내는 것이 아니라면 토큰이 없기 때문에 서버가 확인할 수 있게해 공격을 막을 수 있다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F993D89425DFDDDD614\" width=\"500\" />\n\n그러면 Next-auth를 이용한 인증방식은 어떻게 이루어지고 있을까?\n\n### Next-auth의 보안 방식과 적용\n\nNext-auth는 OAuth와 JWT를 지원하고, 무엇보다 고민했던 보안 문제를 한번에 해결해 줄 수 있었다. `CSRF토큰`을 POST 요청에 적용하고, 인증을 위한 토큰과 세션들을 `server-readable-only cookie`로 자동으로 관리해준다. 두가지 덕분에 앞서 알아보았던 XSS공격과 CSRF 공격을 방어하면서 인증을 편하게 할 수 있다는 것을 확인했다.\n\n![next-auth](./next-auth.png)\n\nNext auth에 대해 공부하면서 기본적으로 password를 사용하지 않는 방향을 지향한다는 것을 알게 되었다. 비밀번호는 보통 하나의 비밀번호가 여러 곳에 사용되기 때문에 보안에 민감한 사항이라고 생각해, 기존 회원가입-로그인 로직 대신에 \"이메일 인증\"으로 교체하고, OAuth로 \"구글\"과 \"Github\"를 이용한 총 세가지 방식의 인증과정을 진행하기로 했다.\n\nOAuth를 이용할 때도 고려해야할 점은, 다른 플랫폼이지만 같은 email을 사용하는 경우이다. 고민을 해보았을 때 다른 플랫폼이지만 같은 email로 접속했을 때 같은 채용공고들을 보여줘도 괜찮을 것 같아 이부분은 provider 옵션에 `allowDangerousEmailAccountLinking`을 추가해서 처리했다.\n\n### 사용 방법\n\nNext-auth를 사용하기 위해서는 우선 `pages/api/auth/[...nextauth].ts`를 만들어야한다. 내가 사용한 `[...nextauth].ts`파일 내용은 아래와 같고, 코드의 이해를 돕기 위해서 공통 부분을 설명하고 각각의 provider들의 연결을 정리해보려 한다.\n\n```typescript\nimport GoogleProvider from \"next-auth/providers/google\"\nimport GithubProvider from \"next-auth/providers/github\"\nimport EmailProvider from \"next-auth/providers/email\"\nimport NextAuth from \"next-auth\"\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\"\nimport prisma from \"../../../prisma/prisma\"\nimport nodemailer from \"nodemailer\"\nimport { html, text } from \"../../../src/utils/emailFormat\"\n\nexport default NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID || \"\",\n      clientSecret: process.env.GOOGLE_SECRET || \"\",\n      allowDangerousEmailAccountLinking: true,\n    }),\n    GithubProvider({\n      clientId: process.env.GITHUB_ID || \"\",\n      clientSecret: process.env.GITHUB_SECRET || \"\",\n      allowDangerousEmailAccountLinking: true,\n    }),\n    EmailProvider({\n      server: process.env.EMAIL_SERVER,\n      from: process.env.EMAIL_FROM,\n      async sendVerificationRequest({\n        identifier: email,\n        url,\n        provider: { server, from },\n      }) {\n        const { host } = new URL(url)\n        const transport = nodemailer.createTransport(server)\n        await transport.sendMail({\n          to: email,\n          from,\n          subject: `Sign in to ${host}`,\n          text: text({ url, host }),\n          html: html({ url, host, email }),\n        })\n      },\n    }),\n  ],\n\n  session: {\n    strategy: \"jwt\",\n  },\n  adapter: PrismaAdapter(prisma),\n  pages: {\n    signIn: \"/login\",\n  },\n  secret: process.env.JWT_SECRET,\n  debug: true,\n  callbacks: {\n    async session({ session, token, user }) {\n      session.user.id = user.id\n      return session\n    },\n  },\n})\n```\n\n### 공통 부분\n\n- secret: 배포 때, JWT를 만드는데 사용될 secret으로 터미널에 `openssl rand -base64 32` 을 입력해 만들어진 키를 env에 추가해 연결했다.\n\n- debug: 연결된 provider의 토큰 내용이나 에러들을 볼 수 있는 옵션으로 터미널로 내용들을 확인할 수 있다.\n\n- callbacks: 인증과정에서 필요한 내용들을 커스텀하는 부분으로 API에 필요한 id를 값을 기본적으로 `session/user`에 담겨있지 않아 추가해주었다.\n\n- pages: custom 로그인 페이지를 연결할 url을 전달해 줄 수 있다.\n\n- session: database와 연결하게 되면 사용자 정보가 세션으로 관리되기 때문에 jwt로 변경했다. database를 연결하지 않으면 기본적으로 jwt가 된다.\n\ncallbacks에서 추가할 부분은 타입도 추가해줘야하기 때문에 `next-auth.d.ts`에서 정의해주었다.\n\n```typescript\n// types/next-auth.d.ts\n\nimport { DefaultUser } from \"next-auth\"\ndeclare module \"next-auth\" {\n  interface Session {\n    user: DefaultUser & {\n      id: string\n    }\n  }\n}\n```\n\n### Adapter\n\n사용자정보들을 저장할 DB를 연결하는 부분으로, next-auth는 다양한 DB를 지원한다. 그중에서 기존에 사용하던 firebase 대신에 prisma를 이용해 연결했다. Firebase를 사용하려했지만 현재 next-auth가 version 4로 업데이트 하면서 지원하지 않는 것을 확인했다.\n\n그래서 새로운 Database를 찾다가 `prisma`를 사용했다. `Prisma`는 ORM으로 SQL DB와 함께 사용되지만 현재 MongoDB까지 지원해줘, 데이터의 schema를 기입해서 안전하게 관리할 수 있고, 다양한 database를 지원하는 장점들로 선택했다.\n\n#### Prisma를 이용한 DB 연결\n\nprisma를 이용해 MongoDB를 연결하기 위해서 next-auth의 공식 홈페이지를 참고하면 되지만 주의할 부분이 있었다.\n\n공식 홈페이지의 schema의 VerificationToken 부분의 id가 없기 때문에 에러가 발생하는데, 이것을 해결하기 위해서는 다음과 같이 추가해 해결할 수 있었다.\n\n```typescript\n// ...\n\nmodel VerificationToken {\n  id         String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  identifier String\n  token      String   @unique\n  expires    DateTime @map(\"expiresAt\")\n\n  @@unique([identifier, token])\n  @@map(\"verification_tokens\")\n}\n\n```\n\n### OAuth\n\nOAuth로 사용한 Google과 Github에 연결하기 위해서는 각각 ID와 Secret을 전달해주어야한다. 이때 많이 에러가 났던 부분은 인증이 끝나고 돌아갈 `callback`을 설정해주는 부분이었다. 배포를 하면서 에러가 많이 난 부분이라 미리 로컬과 배포용 두개의 OAuth 인증 정보를 만들고, 각각 구분된 key와 secret으로 `.env.local`과 `.env.production`으로 해두었다면 헷갈리지 않았을텐데라는 아쉬움이 든다.\n\n#### Google\n\nGoogle의 경우는 GCP(Google Cloud Platform)에 들어가 사용자 인증정보- OAuth Client ID를 만들면 되는데 이때 주의할 점은 url주소를 잘 적어주어야했다.\n\n- 개발: url=`http://localhost:3000`, 승인된 리디렉션 URI= `http://localhost:3000/api/auth/callback/google`\n- 배포: url= `http://moejob.shop`, 승인된 리디렉션 URI= `http://moejob.shop/api/auth/callback/google`\n\n#### Github\n\nGithub은 Github 본인계정의 settings-왼쪽 메뉴 가장하단의 developer settings-OAuth Apps를 이용해 추가하면 된다. 이때도 url주소를 주의해서 적어야했다. 특히 Github은 한번 인증된 계정의 url을 바꾸어도 잘 적용이 안되 새롭게 배포용 계정을 만들어서 인증했다.\n\n- 개발: Homepage URL=`http://localhost:3000`, Authorization callback URL= `http://localhost:3000/api/auth/callback/github`\n\n- 배포: Homepage URL=`http://moejob.shop`, Authorization callback URL= `http://moejob.shop/api/auth/callback/github`\n\n### Email\n\n이메일을 연결하는 부분이 가장 힘들었던 부분중 하나다. Next-auth와 검색의 대부분은 `sendGrid`의 SMTP를 이용해 이메일을 보낼 수 있게 소개했지만, 가입을 해도 계정이 pending상태로 남아있어서 `Gmail`을 이용한 방법으로 바꾸었다.\n\n우선 next-auth자체에 `nodemailer`가 없기 때문에 nodemailer를 설치한 후에 연결해주었다. Gmail페이지에서 설정에 들어가 IMAP을 사용으로 수정하고, google계정의 앱비밀번호를 추가해 환경변수로 전달했다.\n\n- `EMAIL_SERVER =smtp://<email>:<app password>@smtp.gmail.com:587`\n\n- `EMAIL_FROM=moejob@gmail.com`\n\n이렇게 설정만 하면 기본 이메일 포맷으로 나오기 때문에 추가적인 포맷을 위해 EmailProvider option으로 sendVerificationRequest로 필요한 내용들을 전달 할 수 있다.\n\n### \\_app.tsx\n\n각각의 Provider를 연결한 후에 컴포넌트에 적용하기 위해서는 next-auth가 제공하는 `SessionProvider`을 감싸주면 컴포넌트 내부에서 `useSession` hook을 이용해 session정보를 전역 상태로 사용할 수 있다. 덕분에 기존에 CSR에서 사용하고 있던 AuthService를 이용해 user를 따로 관리하지 않아도 되었다.\n\n```tsx\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const dbService = new DBServiceImpl(firebaseApp)\n  return (\n    <>\n      <QueryClientProvider client={queryClient}>\n        <DBProvider dbService={dbService}>\n          <SessionProvider basePath={process.env.NEXTAUTH_URL}>\n            ...\n          </SessionProvider>\n        </DBProvider>\n      </QueryClientProvider>\n    </>\n  )\n}\n```\n\n### Proteceted Route\n\ngetServerSideProps로 session을 받아와 로그인 된 사용자인지 먼저 체크해 주는 방식을 통해 현재 로그인된 유저인지 먼저 확인할 수 있었다. 먼저 서버에서 사용자정보를 이용해 리다이렉션 시키기 때문에 페이지를 랜더링을 하지 않고, 리다이렉션이 가능하게 되었다.\n\n```tsx\nexport default function User({\n  session,\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\n  return (\n    <MainLayout>\n      <JobSection session={session} />\n    </MainLayout>\n  )\n}\n\nexport const getServerSideProps = async (context: NextPageContext) => {\n  const session = await getSession(context)\n  if (!session) {\n    return {\n      redirect: {\n        destination: \"/login\",\n      },\n    }\n  }\n  return {\n    props: { session },\n  }\n}\n```\n\n### Custom Login\n\nNext auth를 이용하게 되면 기본적으로 제공해 주는 login 페이지가 있지만 이미 만들어둔 페이지가 있었기 때문에 custom 페이지와 연결했다. custom 페이지에서 provider를 이용하기 위해서는 서버로 해당 provider정보를 전달해 주어야 한다.\n\n```tsx\nconst Login = ({\n  providers,\n}: InferGetServerSidePropsType<typeof getServerSideProps>) => {\n  return (\n    <>\n      <SEO title=\"로그인\" />\n      <AuthLayout providers={providers} />;\n    </>\n  )\n}\n\nexport default Login\n\nexport const getServerSideProps = async ({ req }: NextPageContext) => {\n  const session = await getSession({ req })\n  if (session) {\n    return {\n      props: {},\n      redirect: {\n        destination: \"/\",\n      },\n    }\n  }\n\n  return {\n    props: {\n      providers: await getProviders(),\n    },\n  }\n}\n```\n\n## 👓성능 비교\n\n크롬의 개발자도구를 이용해 완료 (페이지를 모두 불러오는데 까지 걸리는 시간)를 기준으로 CSR을 이용해 인증을 했을때 시간과 SSR을 이용해 인증을 했을 때 시간을 비교해보았다.\n\n![성능비교](./페이지성능측정.png)\n\n위 사진과 같이 CSR은 총 1.52s, SSR은 955ms로 SSR이 CSR에 비해 38%정도 로딩속도를 개선된것을 알 수 있었다.\n\n## 마치며\n\n이렇게 서버사이드 렌더링을 이용해서 인증을 적용하면서 전체적으로 컴포넌트들이 간단해졌고, **빈페이지를 보여주지 않고 페이지 이동**이 이루어져 성능 개선도 이루어진 점이 너무 좋았다. 이후에는 페이지마다 권한을 정하고 페이지 개선을 한 후에 SEO와 HTTPS를 적용하는 작업을 할 예정이다.\n\n<br/>\n\n[참조]\n\n- [모의해킹 실무자가 알려주는, XSS 공격 기법](https://www.inflearn.com/course/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9-xss-%EA%B3%B5%EA%B2%A9%EA%B8%B0%EB%B2%95?inst=29e33bf1)\n- [CSRF를 1분 만에 해결하는 방법](https://doctorson0309.tistory.com/605)\n"},{"excerpt":"🧨 이벤트 이벤트는 말 그대로 을 의미한다. 언제 어떤 순서로 발생할 지 모르기 때문에 이벤트를 감지할 수 있어야 하고, 감지하고 나서 어떻게 처리 할지에 대해 정해야 한다. 우리가 사용할 때 브라우저에게 이벤트 핸들러를 등록함으로써 이벤트를 위임해 브라우저가 이벤트를 감지하면 해당 핸들러에 등록한 함수를 실행함으로써 이벤트를 처리할 수 있다. 적절한 이…","fields":{"slug":"/2022-12-30-이벤트/"},"frontmatter":{"date":"December 15, 2022","title":"이벤트","tags":["javascript"]},"rawMarkdownBody":"\n# 🧨 이벤트\n\n이벤트는 말 그대로 `사건`을 의미한다. 언제 어떤 순서로 발생할 지 모르기 때문에 **이벤트를 감지**할 수 있어야 하고, 감지하고 나서 **어떻게 처리 할지**에 대해 정해야 한다. 우리가 사용할 때 브라우저에게 이벤트 핸들러를 등록함으로써 이벤트를 위임해 브라우저가 이벤트를 감지하면 해당 핸들러에 등록한 함수를 실행함으로써 이벤트를 처리할 수 있다. 적절한 이벤트로 더 다양한 기능을 구현하기 위해 이벤트에 대해 정리해 보고자 한다.\n\n## 🙂 이벤트 타입\n\n이벤트는 사용자와 다양한 interaction이 가능하기 때문에 풍부한 사용자 경험을 만들어 줄 수 있다. 하지만 제대로 이해하지 않고 사용한다면 너무 많은 이벤트로 성능을 떨어뜨리거나, 원하지 않은 곳에 이벤트가 발생하기도 한다. 그래서 이벤트 자체에 대해서도 이해가 필요하다.\n\n예를 들어 같은 마우스 이벤트더라도 `mouseenter`와 `mousemove`는 해당 요소에 마우스가 들어갔을 때와 움직일 때로 동작을 보면 크게 다르지 않아 보이지만, 만약 api fetching하는 함수가 등록되어 있다면 `mouseenter` 의 경우 엄청나게 많은 비용이 들게 된다. 그렇기 때문에 목적에 맞게 이벤트와 연결하는 것이 너무나 중요하다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <button>sensor</button>\n\n    <script>\n      const btn = document.querySelector(\"button\")\n      // btn.addEventListener('mousemove', () => {\n      //   console.log('move');\n      //   console.log('data fetching'); // 센서 안에서 마우스가 움직일 때마다 호출\n      // });\n      btn.addEventListener(\"mouseenter\", () => {\n        console.log(\"enter\")\n        console.log(\"data fetching\") // 센서로 마우스가 들어갈 때마다 호출\n      })\n    </script>\n  </body>\n</html>\n```\n\n적절한 이벤트를 붙여줘서 해결할 수도 있지만 `무한 스크롤`과 스크롤 이벤트에 api 호출을 연결해야 하는 경우도 있다. 이럴 때는 Throttle과 Debounce 두 가지 방법을 이용해 이벤트를 제어할 수 있다.\n\n### Debouncing\n\n디바운싱은 연속적으로 호출되는 이벤트 핸들러 중에서 처음 또는 마지막에 호출되는 함수만 호출되는 것을 의미한다.\n\n예를 들어 검색 창에 사용자가 입력한 결과에 따라 api를 호출해 결과를 받아온다면 input의 `onchange`로 그냥 호출하게 되면 사용자가 입력하는 한 글자, 한 글자 모두에 api 호출이 되기 때문에 불필요한 비용이 발생한다.\n\n```html\n<body>\n  <input id=\"input\" />\n  <script>\n    document.querySelector(\"#input\").addEventListener(\"input\", function (e) {\n      console.log(\"여기에 ajax 요청\", e.target.value)\n    })\n  </script>\n</body>\n```\n\n![디바운싱전](디바운싱전.png)\n\n이것을 막기 위해서 디바운싱을 이용해 입력하는 중에 200ms동안 입력이 없다면 입력이 끝났다고 간주하고 api를 호출하게 한다면, api 호출 비용을 아낄 수 있다. 이벤트 핸들러는 입력이 될 때마다 timer에 함수가 있는지 체크하고, 있다면 초기화 시켜 새롭게 입력한다. 200ms 동안 입력이 없다면 timer의 callback 함수가 실행된다.\n\n```html\n<html lang=\"en\">\n  <body>\n    <input id=\"input\" />\n    <script>\n      let timer\n      document.querySelector(\"#input\").addEventListener(\"input\", function (e) {\n        if (timer) {\n          clearTimeout(timer)\n        }\n\n        timer = setTimeout(function () {\n          console.log(\"api 요청\", e.target.value)\n        }, 200)\n      })\n    </script>\n  </body>\n</html>\n```\n\n![디바운싱후](디바운싱후.png)\n\n### Throttling\n\nThrottling은 일정 시간 동안 발생할 수 있는 실행 횟수에 제한을 거는 방식이다. 앞서 언급했던 무한 스크롤과 같이 스크롤 이벤트로 api를 호출해야 한다면 계속해서 내릴 때마다 서버로부터 데이터를 받아 와야 한다. 이때 Throttling을 이용한다면 일정 시간 당 한번만 api가 호출되기 때문에 성능을 개선할 수 있다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body style=\"height: 150vh\">\n    <script>\n      let waiting = false\n      document.querySelector(\"body\").addEventListener(\"wheel\", function (e) {\n        if (!waiting) {\n          console.log(\"API 호출\")\n          waiting = true\n          setTimeout(() => {\n            waiting = false\n          }, 200)\n        }\n      })\n    </script>\n  </body>\n</html>\n```\n\n## 📍 이벤트 핸들러 등록과 제거\n\n이벤트 핸들러는 브라우저가 이벤트가 발생했을 때 호출하기 위해 등록해놓은 함수다. 이벤트 핸들러를 등록하는 방법에는 3가지가 존재한다.\n\n### 1. 이벤트 핸들러 attribute\n\nAttribute의 경우 on접두사에 이벤트 타입을 붙여서 등록하는 방식으로 리액트에서 주로 사용한 방법이다. html에서 할당할 때는 함수를 직접 전달해 줄 수 없기 때문에 문자열로 연결하는데 암묵적으로 attribute값을 이벤트 핸들러의 함수 몸체로 파싱해서 할당해준다. vanilla JS에서 프로젝트를 진행한다면 javascript에서 이벤트를 처리하는 게 더 적절하지만 리액트에서는 jsx문법으로 javascript로 html을 만들기 때문에 attribute로 전달해 준다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <button onclick=\"sayhi()\">sensor</button>\n\n    <script>\n      function sayhi() {\n        console.log(\"hi\")\n      }\n    </script>\n  </body>\n</html>\n```\n\n```javascript\nfunction onclick(event) {\n  sayhi() // 할당된 함수\n}\n```\n\n### 2. 이벤트 핸들러 속성\n\nDOM 노드에는 이벤트 핸들러 속성을 가지고 있다. 앞서 정리한 attribute처럼 on접두사에 이벤트 타입을 붙인 후에 함수를 바인딩 해 이벤트 핸들러를 등록할 수 있다. 이때 속성으로 등록한 이벤트 핸들러는 하나만 등록될 수 있다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <button>sensor</button>\n\n    <script>\n      const btn = document.querySelector(\"button\")\n      btn.onclick = function () {\n        console.log(\"클릭\") // 없어져\n      }\n      btn.onclick = function () {\n        console.log(\"클릭2\") // 재할당되어 실행\n      }\n      btn.onclick = null\n    </script>\n  </body>\n</html>\n```\n\nDOM element의 속성이기 때문에 없앨 때는 간단하게 `btn.onclick=null`로 해당 속성을 없애 줄 수 있다.\n\n### 3. addEventListener\n\naddEventListner 메소드는 첫 번째 인자로 이벤트 타입, 두 번째 인자로 이벤트 핸들러, 세 번째 인자로 캡처링단계에서 이벤트를 캐치할 지를 정할 수 있다. 이벤트 핸들러 속성과는 달리 여러 개의 이벤트 핸들러를 연결할 수 있고 순서대로 호출된다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <button>sensor</button>\n\n    <script>\n      const btn = document.querySelector(\"button\")\n      const click = () => {\n        console.log(\"클릭\")\n      }\n      btn.addEventListener(\"click\", click)\n      btn.addEventListener(\"click\", () => {\n        console.log(\"클릭2\")\n      })\n      btn.removeEventListner(\"click\", click)\n    </script>\n  </body>\n</html>\n```\n\n삭제할 때는 `removeEventListner`를 이용하면 되는데 이때 `addEventListenr`에 등록한 함수와 동일한 함수를 참조하게 해야 한다.\n\n## ✨ 이벤트의 흐름\n\nDOM 요소에 이벤트가 발생하면 DOM 트리를 따라 연쇄적인 반응이 일어나는데 이것을 `event propagation`이라 하고 window에서 event target으로 전파되는 것을 `event capturing`이라 부르고 event target에서 window로 전파되는 것을 `event bubbling`이라고 부른다. 항상 이벤트가 발생했을 때 별도의 처리가 없다면 캡처링과 버블링이 순차적으로 발생한다.\n\n<img src=\"https://poiemaweb.com/img/eventflow.svg\" width=\"600\" />\n\n`addEventListener`에서 세번째 인자를 true로 하게 되면 **캡처링**에서 event를 캐치할 수 있고, false거나 생략시에는 **타겟 단계와 버블링**에서 event를 캐치할 수 있다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <p>버블링과 캡처링<button>버튼</button></p>\n    <script>\n      document.body.addEventListener(\"click\", () => {\n        console.log(\"body\")\n      })\n      document.querySelector(\"p\").addEventListener(\n        \"click\",\n        () => {\n          console.log(\"pagragraph\")\n        },\n        true\n      )\n      document.querySelector(\"button\").addEventListener(\"click\", () => {\n        console.log(\"button\")\n      })\n    </script>\n  </body>\n</html>\n\n// 결과: // paragraph // button // body\n```\n\n위 코드를 보면 두 번째 이벤트 핸들러의 세번째 인자가 true여서 캡처링 과정에서 이벤트를 캐치하고, 나머지는 타겟이나 버블링 과정에서 이벤트를 캐치하는 상황이다. 그렇기 때문에 캡처링에서 이벤트를 캐치하는 `paragraph`가 먼저 호출되고 두 번째로 타겟 단계인 `button`, 마지막으로 버블링 과정에서 `body`가 호출되는 순서로 나타난다.\n\n캡처링, 타겟, 버블링의 이벤트 흐름을 이해하면서 이벤트가 상위 DOM요소에서 캐치될 수 있다는 것을 알 수 있다. 이점을 활용하여 일일이 모든 자식에게 이벤트핸들러를 연결하는 것이 아니라 부모요소에 이벤트 핸들러를 연결하는 `이벤트 위임`에 대해 알아보자.\n\n## 이벤트 위임\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <style>\n      #fruits {\n        display: flex;\n        list-style-type: none;\n        padding: 0;\n      }\n      #fruits li {\n        width: 100px;\n        cursor: pointer;\n      }\n      #fruits .active {\n        color: red;\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n  <body>\n    <nav>\n      <ul id=\"fruits\">\n        <li id=\"apple\" class=\"active\">Apple</li>\n        <li id=\"banana\">banana</li>\n        <li id=\"orange\">orange</li>\n      </ul>\n    </nav>\n    <div>선택된 아이템: <em class=\"msg\">apple</em></div>\n    <script>\n      const $fruits = document.getElementById(\"fruits\")\n      const $msg = document.querySelector(\".msg\")\n\n      function activate({ target }) {\n        ;[...$fruits.children].forEach($fruit => {\n          $fruit.classList.toggle(\"active\", $fruit === target)\n          $msg.textContent = target.id\n        })\n      }\n\n      document.getElementById(\"apple\").onclick = activate\n      document.getElementById(\"banana\").onclick = activate\n      document.getElementById(\"orange\").onclick = activate\n    </script>\n  </body>\n</html>\n```\n\n위 코드를 보면 activate라는 함수를 `li`태그마다 이벤트 핸들러로 연결해주고 있다. 하지만 요소가 동적으로 정해지거나 여러 개가 된다면 일일이 자식 요소에 이벤트 핸들러를 붙여 주는 것은 비효율적이다. 이를 해결하기 위해서 부모인 `ul`에 이벤트 핸들러를 등록해 해결할 수 있다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <style>\n      #fruits {\n        display: flex;\n        list-style-type: none;\n        padding: 0;\n      }\n      #fruits li {\n        width: 100px;\n        cursor: pointer;\n      }\n      #fruits .active {\n        color: red;\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n  <body>\n    <nav>\n      <ul id=\"fruits\">\n        <li id=\"apple\" class=\"active\">Apple</li>\n        <li id=\"banana\">banana</li>\n        <li id=\"orange\">orange</li>\n      </ul>\n    </nav>\n    <div>선택된 아이템: <em class=\"msg\">apple</em></div>\n    <script>\n      const $fruits = document.getElementById(\"fruits\")\n      const $msg = document.querySelector(\".msg\")\n\n      function activate({ target }) {\n        if (!target.matches(\"#fruits > li\")) return\n\n        ;[...$fruits.children].forEach($fruit => {\n          $fruit.classList.toggle(\"active\", $fruit === target)\n          $msg.textContent = target.id\n        })\n      }\n      $fruits.onclick = activate\n    </script>\n  </body>\n</html>\n```\n\n위코드에서는 activate가 `ul`에만 등록이 되었다. 상위 DOM요소에서 자식 요소의 event를 처리하기 위해서는 해당 이벤트가 자식에서 발생한 이벤트가 맞는지 우선 체크해야 하기 때문에 ` if (!target.matches('#fruits > li')) return;`로 먼저 확인하고 각 자식 요소에 처리해 줄 수 있다. 버블링을 이용한 이벤트 위임을 이용하면 코드 중복을 줄일 수 있다.\n\n## 🙅‍♂️ 이벤트 멈춰 PreventDefault()와 StopPropagation()\n\n`preventDefault()`는 이벤트의 메소드로 DOM요소의 기본 동작을 막는 역할을 한다. 주로 form으로 POST요청을 보낼 때 새로 고침이 일어나게 되는데, SPA에서는 새로고침을 할 필요가 없기 때문에 이러한 기본 동작을 막기 위해 `preventDefault()`를 사용한다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <a href=\"https://google.com\">go</a>\n    <input type=\"checkbox\" />\n    <form><button>제출</button></form>\n    <script>\n      document.querySelector(\"a\").onclick = e => {\n        e.preventDefault()\n      }\n      document.querySelector(\"input[type=checkbox]\").onclick = e => {\n        e.preventDefault()\n      }\n      document.querySelector(\"form\").onsubmit = e => {\n        e.preventDefault()\n      }\n    </script>\n  </body>\n</html>\n```\n\n위 코드에서 a태그의 기본 동작인 페이지 이동을 막고, checkbox input의 기본 동작인 체크,해제를 막는다.\n\n`stopPropagation`은 이벤트 전파를 중지 시키는 방법으로 해당 이벤트를 부모 요소로 버블링 되지 않게 막는다. 타겟 과정에서만 이벤트를 캐치하고 싶을 때 사용할 수 있지만 이벤트 흐름을 막는 것이기 때문에 예상치 못한 에러가 발생할 수 있어 조심해서 사용해야 한다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"container\">\n      <button class=\"btn1\">button1</button>\n      <button class=\"btn2\">btn2</button>\n      <button class=\"btn3\">btn3</button>\n    </div>\n    <script>\n      document.querySelector(\".container\").onclick = ({ target }) => {\n        if (!target.matches(\".container>button\")) return\n        target.style.color = \"red\"\n      }\n\n      document.querySelector(\".btn2\").onclick = e => {\n        e.stopPropagation()\n        e.target.style.color = \"blue\"\n      }\n    </script>\n  </body>\n</html>\n```\n\n위 코드를 보면 btn1,2,3 모두 클릭 시 글자색이 빨간색으로 변해야 하지만 btn2의 `stopPropagation()`으로 btn2의 이벤트는 부모로 버블링되지 않아 위임이 되지 않고 파란색으로 처리되는 것을 볼 수 있다.\n\n## 💡 Event 핸들러의 this\n\n이벤트 핸들러 속성으로 전달되거나 `addEventListener()`로 등록된 함수 선언식의 this는 이벤트를 바인딩한 요소, `event.currentTarget`와 같다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <button>click me</button>\n    <script>\n      const btn = document.querySelector(\"button\")\n      const handleClick = e => {\n        console.log(e.currentTarget) // <button>click me</button>\n        console.log(this) // <button>click me</button>\n        console.log(this === e.currentTarget) // true\n      }\n      btn.onclick = handleClick\n\n      btn.addEventListener(\"click\", handleClick)\n    </script>\n  </body>\n</html>\n```\n\n하지만 함수 선언식이 아닌 화살표 함수의 this는 화살표 함수 자체적으로 this를 가질 수 없기 때문에 상위스코프의 this를 참조한다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <button>click me</button>\n    <script>\n      const btn = document.querySelector(\"button\")\n      const handleClick = e => {\n        console.log(e.currentTarget) // <button>click me</button>\n        console.log(this) // Window\n        console.log(this === e.currentTarget) // false\n      }\n      btn.onclick = handleClick\n      btn.addEventListener(\"click\", handleClick)\n    </script>\n  </body>\n</html>\n```\n\n이러한 차이는 클래스의 이벤트 핸들러에서 this를 바인딩을 할 때 주의해야 할 점이다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <button class=\"btn\">0</button>\n    <script>\n      class App {\n        constructor() {\n          this.$btn = document.querySelector(\".btn\")\n          this.count = 0\n          // this.$btn.onclick = this.increase.bind(this);\n          this.$btn.onclick = this.increase\n        }\n        increase() {\n          console.log(this) // <button class=\"btn\">0</button>\n          this.$btn.textContent = ++this.count // Uncaught TypeError: Cannot set properties of undefined (setting 'textContent')\n        }\n      }\n      new App()\n    </script>\n  </body>\n</html>\n```\n\n위 코드에서 increase는 이벤트 핸들러로 등록되어있기 때문에 this가 class로 만들어질 instance를 가리키는 게 아니라 이벤트를 바인딩한 DOM 요소 ``this.$btn`를 가리킨다. 그렇기 때문에 ` this.$btn.textContent`는 `this.$btn.$btn.textContent`와 같아서 에러가 발생한다.\n\nthis를 인스턴스로 바인딩 시켜주기 위해서는 함수에 직접 bind로 명시적으로 정해주거나 arrow function을 이용해서 class field의 this를 메소드에 참조하게 할 수 있다.\n\n[bind로 this 바인딩]\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <button class=\"btn\">0</button>\n    <script>\n      class App {\n        constructor() {\n          this.$btn = document.querySelector(\".btn\")\n          this.count = 0\n          this.$btn.onclick = this.increase.bind(this)\n        }\n        increase() {\n          console.log(this) // App\n          this.$btn.textContent = ++this.count\n        }\n      }\n      new App()\n    </script>\n  </body>\n</html>\n```\n\n[arrow function]\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <button class=\"btn\">0</button>\n    <script>\n      class App {\n        constructor() {\n          this.$btn = document.querySelector(\".btn\")\n          this.count = 0\n          this.$btn.onclick = this.increase\n        }\n        increase = () => (this.$btn.textContent = ++this.count)\n      }\n      new App()\n    </script>\n  </body>\n</html>\n```\n\n## 마치며\n\n이벤트를 공부하면서 이전에 마주했던 이벤트 핸들러 내부의 this 바인딩 문제를 제대로 이해할 수 있었고, 이벤트 전파와 위임에 대해서도 바르게 알 수 있는 시간이었다.\n\n[참조]\n\n- [Throttling과 debouncing](https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa)\n\n- [모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n\n- [이벤트](https://poiemaweb.com/js-event)\n"},{"excerpt":"🎈 생성자 함수과 프로토타입 this를 공부하고 나서 생성자 함수, 프로토타입, 클래스에 대해 한번 정리할 필요성을 느꼈다. 생성자 함수를 시작으로 자바스크립트의 객체지향에 대해 정리해보고자 한다. ✏ 객체를 만드는 방법 생성자 함수도, 클래스도 결국에는 객체를 만드는 방법이다. 그래서 가장 먼저 자바스크립트에서 객체를 만드는 방법에 대해서 정리해 보고자…","fields":{"slug":"/2022-12-12-생성자함수-프로토타입/"},"frontmatter":{"date":"December 12, 2022","title":"생성자 함수, 프로토타입","tags":["javascript","객체지향"]},"rawMarkdownBody":"\n# 🎈 생성자 함수과 프로토타입\n\nthis를 공부하고 나서 생성자 함수, 프로토타입, 클래스에 대해 한번 정리할 필요성을 느꼈다. 생성자 함수를 시작으로 자바스크립트의 객체지향에 대해 정리해보고자 한다.\n\n## ✏ 객체를 만드는 방법\n\n생성자 함수도, 클래스도 결국에는 **객체를 만드는 방법**이다. 그래서 가장 먼저 자바스크립트에서 객체를 만드는 방법에 대해서 정리해 보고자 한다.\n\n### 1) 객체 리터럴\n\n객체 리터럴은 가장 쉽게 객체를 만드는 방법으로 `{}`로 내부에 넣을 속성과 메소드를 담아 만들 수 있다.\n\n```javascript\nconst position = {\n  x: 1,\n  y: 2,\n}\n```\n\n### 2) 생성자 함수\n\n생성자 함수는 new연산자를 이용해 객체, 인스턴스를 생성하는 함수를 의미한다. 객체 리터럴보다는 상대적으로 복잡하게 객체를 만드는 방법이다.\n\n#### 2-1) Object 생성자 함수\n\nObject 생성자 함수와 new 키워드를 이용하면 빈 객체를 생성한다. 이후에 객체를 만들고 내부에 속성과 메소드를 추가할 수 있다.\n\n```javascript\nconst person = new Object()\n\nperson.name = `lee`\nperson.sayHello = function () {\n  console.log(this.name)\n}\n```\n\nObject 생성자 함수 외에 빌트인 객체들도 new와 함께 생성할 수 있다.\n\n```javascript\nconst strObj = new String(\"youngjun\")\nconsole.log(strObj)\n\nconst numObj = new Number(123)\nconsole.log(numObj)\n\nconst boolObj = new Boolean(true)\nconsole.log(boolObj)\n\nconst func = new Function(\"x\", \"return x*x\")\nconsole.log(func)\n\nconst arr = new Array(1, 2, 3)\nconsole.log(arr)\n\nconst regExp = new RegExp(/ab+c/i)\nconsole.log(regExp)\n```\n\n#### 2-2) 사용자 정의 생성자 함수\n\n함수 내부에 인스턴스에 추가할 속성과 메소드를 정의한 후에 new 키워드로 인스턴스를 만들 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person)\n```\n\n### 3) Object.create()\n\n프로토타입의 상속을 이용해 객체를 만드는 방법으로 자체적으로는 빈 객체를 만들지만, prototype으로 전달 받은 속성과 메소드를 사용할 수 있다.\n\n```javascript\nconst obj1 = { a: 1, b: 2 }\nconst obj2 = Object.create(obj1)\n\nconsole.log(obj2) // {}\nconsole.log(obj2.a) // 1\n```\n\n## 😁 생성자 함수의 필요성과 동작방식\n\n객체를 만드는 방법들 중에 왜 생성자 함수가 쓰이는지와 동작 방식을 알아보자.\n\n### 생성자 함수의 필요성\n\n위의 세가지 방식 중 객체 리터럴이 가장 편하게 객체를 만들 수 있는 방법이다. 객체에 필요한 값을 직접 정의해줄 수 있어 커스텀하기도 쉽다. 하지만 **똑같은 속성과 메소드를 가지는 여러개의 객체**가 필요하다면 객체 리터럴로 일일이 만드는 것은 비효율적이다.\n\n```javascript\nconst person1 = {\n  name: \"youngjun\",\n  sayHello() {\n    console.log(this.name)\n  },\n}\n\nconst person2 = {\n  name: \"minjae\",\n  sayHello() {\n    console.log(this.name)\n  },\n}\n```\n\n이렇게 여러 개의 유사한 객체가 필요할 때, **템플릿을 만들고 필요한 부분만 주입받아서 사용하면 편하지 않을까**라는 생각이 든다. 이럴 때 사용할 수 있는 것이 바로 생성자 함수다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person)\n```\n\n### 동작방식\n\n생성자 함수를 이용해 객체를 만들 때 **1) 인스턴스생성 2) 인스턴스 초기화 3) 인스턴스 반환** 세 가지 과정으로 진행된다. 위의 예제를 다시 살펴보자.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person)\n```\n\n#### 1) 인스턴스 생성\n\n생성자 함수는 암묵적으로 빈 객체를 생성하고, 생성자 함수의 this와 바인딩이 된다.\n\n```javascript\nfunction Person(name) {\n  // 1) 인스턴스 생성, this와 바인딩\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person)\n```\n\n#### 2) 인스턴스 초기화\n\nthis에 바인딩 되어있기 때문에 이후에 this를 이용해 초기화 과정을 진행할 수 있다.\n\n```javascript\nfunction Person(name) {\n  // 1) 인스턴스 생성, this와 바인딩\n  // 2) 인스턴스 초기화\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person)\n```\n\n#### 3) 인스턴스 반환\n\n초기화 과정이 끝나면 return으로 적지 않아도 암묵적으로 this가 반환된다. 이때 다른 객체를 return하면 명시한 객체가 반환되고, 원시값으로 반환하면 암묵적으로 this가 반환된다.\n\n```javascript\nfunction Person(name) {\n  // 1) 인스턴스 생성, this와 바인딩\n  // 2) 인스턴스 초기화\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n  // 3) 인스턴스 반환\n}\n\n// 명시적으로 다른 객체 반환\nfunction Person(name) {\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n  return {}\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person) // {}\n\n//명시적으로 원시값 반환\nfunction Person(name) {\n  this.name = name\n  this.sayHello = function () {\n    console.log(this.name)\n  }\n  return \"hi\"\n}\nconst person = new Person(\"youngjun\")\nconsole.log(person) // Person { name: 'youngjun', sayHello: [Function (anonymous)] }\n```\n\n## ⛏ 내부 메소드\n\n생성자 함수는 일반함수와 동일하게 작성했지만 다르게 동작하는 것처럼 보인다. 어떤 차이가 있는지 생성자 함수의 내부 동작을 캐보자.\n\n### 함수 객체의 [[call]]과 [[Construct]]\n\n함수는 객체다. 객체이기 때문에 기존에 우리가 사용하던 객체의 특성을 이용할 수 있다.\n\n```javascript\nfunction bar() {}\nbar.a = 1\nconsole.log(bar.a) // 1\n```\n\n하지만 함수 객체는 일반 객체와 다르게 호출할 수 있고 생성자 함수로도 작동할 수 있다. 그이유는 함수 객체에는 일반 객체의 내부 메소드뿐만 아니라 **[[call]]과 [[construct]]**가 있기 때문이다. 이때 중요한 부분은 모든 함수는 [[call]]을 가지고 있어 호출이 가능하지만, `모든 함수가 [[construct]]를 가지는 것은 아니다`라는 것이다. 이렇게 [[construct]]를 가지는 함수를 constructor라고 부르고 [[construct]]를 가지지 않는 함수는 non-constructor라고 부르며 다음과 같이 정리된다.\n\n- constructor: 함수 선언문, 함수 표현식, 클래스\n\n- non-constructor: 메소드 축약, 화살표 함수\n\n이렇게 내부적으로 [[construct]]를 가지고 있다면 new와 함께 사용하면 언제든 생성자 함수로 작동할 수 있다. 그렇기 때문에 생성자 함수로 사용하지 않을 거라면 화살표함수와 객체 내부에서는 메소드 축약을 사용하는 게 더 좋다고 생각된다.\n\n```javascript\n// 일반함수를 생성자함수로\nfunction add(x, y) {\n  return x + y\n}\n\nlet inst = new add()\nconsole.log(inst) //add{}\n\nfunction createUser(name, role) {\n  return { name, role }\n}\n\ninst = new createUser(\"lee\", \"admin\")\nconsole.log(inst) // { name: 'lee', role: 'admin' }\n\n//생성자함수를 일반함수로\nfunction Circle(radius) {\n  this.radius = radius\n  this.getDiameter = function () {\n    return 2 * this.radius\n  }\n}\n\nconst circle = Circle(5)\nconsole.log(circle) // undefined\nconsole.log(radius) // 5\nconsole.log(getDiameter()) //10\n```\n\n위 코드에서 일반함수를 생성자함수로 사용할 수 있는 것을 볼 수 있고, 생성자 함수를 일반 함수로 사용하는 경우에서는 this가 window가 되어 전역객체의 속성과 메소드로 등록된 것을 볼 수 있다.\n\n## 🎚 생성자 함수 구분\n\n위의 코드처럼 일반함수와 생성자함수는 구분하기 힘들기 때문에, 생성자 함수는 `대문자로 시작하는 Pascal표기법`을 이용한다. 하지만 단순히 명명법으로 구분하기 어렵기 때문에 `new.target`을 이용해 new를 이용해 생성자 함수로 함수가 호출되었는지 확인할 수 있다.\n\nnew.target은 new연산자와 함께 호출되면 함수 자신을 가리키고, 일반함수로 호출되었을 때는 undefined로 나타나기 때문에 각각에 따른 처리가 가능하다.\n\n```javascript\nfunction Circle(radius) {\n  if (!new.target) {\n    return new Circle(radius)\n  }\n  this.radius = radius\n  this.getDiameter = function () {\n    return 2 * this.radius\n  }\n}\n\nconst circle = Circle(5)\nconsole.log(circle.getDiameter())\n```\n\n위 코드에서 new 키워드 없이 호출되었지만 new.target을 이용해 생성자함수로 다시 호출시켜 객체를 만든 것을 볼 수 있다.\n\n# ✨ 프로토타입\n\n자바스크립트는 멀티패러다임 언어로 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 여기서 먼저 프로토타입 기반의 객체지향 프로그래밍에서 `객체지향 프로그래밍`이란 대상의 상태과 동작을 하나로 묶은 객체들의 집합으로 프로그램을 표현하려는 프로그래밍 방식을 의미한다. 객체지향 프로그래밍을 이해했으니 다음으로 프로토타입은 어떤 것인지 알아보자.\n\n## 🙋‍♀️ 프로토타입이란\n\n프로토타입은 우리가 앞서 알아본 생성자 함수로 객체를 생성했을 때, 만들어 진 객체의 부모와 같이 **상위 객체** 역할을 하는 객체를 의미한다. 즉 자바스크립트가 <u>상속</u>을 구현하는 방식이다. 만들어 진 객체는 프로토타입 객체를 상속하고 있기 때문에, 프로토타입 객체의 메소드들을 사용할 수 있다.\n\n![prototype](prototype.jpeg)\n\n그러면 프로토타입이 어떻게 만들어지는 지 정리해보자\n\n### 함수 선언\n\n함수에는 내부 슬롯에`[[call]]`과 `[[construct]]`과 같이 `[[prototype]]`이 존재하는데 이는 함수를 선언할 때, 해당 함수로 만들어 질 인스턴스가 상속할 프로토타입을 가리키고 있다. prototype객체는 `[[construct]]`로 생성자함수를 가리키고 있다. 이렇게 프로토타입과 생성자함수는 단독으로 존재하는 것이 아니라 서로 prototype과 constructor속성으로 함께 존재한다.\n\n![function](function.jpeg)\n\n```javascript\nfunction Foo() {}\nconsole.log(Foo.prototype) // {}\nconsole.log(Foo.prototype.constructor) // [Function: Foo]\n```\n\n### 인스턴스 생성\n\n생성자함수에 new 키워드를 이용해 인스턴스를 만들면 인스턴스는 프로토타입의 메소드를 상속 받아 사용할 수 있다. 생성자함수와 다르게 `[[prototype]]`에 직접 접근할 수는 없지만 `__proto__`를 이용해서 간접적으로 접근할 수 있다.\n\n![instance](instance.jpeg)\n\n```javascript\nfunction Foo() {}\nFoo.prototype.val = \"hi\"\nconsole.log(Foo.prototype) // { val: 'hi' }\nconsole.log(Foo.prototype.constructor) // [Function: Foo]\n\nconst obj1 = new Foo()\nconsole.log(obj1) // Foo {}\nconsole.log(obj1.val) // hi\n```\n\nobj1의 생성자 함수에서 val 속성을 정의한 적이 없지만 프로토타입에 정의한 것을 상속받아 obj1에서도 사용이 가능한 것을 알 수 있다.\n\n## 🙄 `__proto__`와 `prototype`\n\n앞서 생성자 함수, 프로토 타입, 인스턴스 세 가지의 관계를 이해하기 위해 `__proto__`와 `[[prototype]]` 를 이용해 설명했다. 동일하게 프로토 타입을 가리키는 비 두 가지 속성을 헷갈리지 않게 먼저 정리해 보고자 한다.\n\n먼저 `__proto__`는 **모든 객체**가 프로토타입에 접근할 수 있는 방법이다. `__proto__` 는 객체가 직접 가지고 있는 게 아니라 프로토타입을 이용한 상속으로 Object.prototype의 접근자 속성을 사용하는 것이다. `__proto__`를 이용해서 프로토타입을 접근할 수 있게 한 이유는 상호 참조에 의해 프로토타입 체인이 생기지 않게 방지하기 위해서다. 서로 상속해 자식이자 부모가 되는 상황이 되지 않게, 검색 과정이 무한 순회가 되지 않게 막을 수 있다.\n\n하지만 `__proto__` 속성이 존재하지 않는 경우도 있기 때문에 프로토타입을 접근할 때 `Object.getPrototypeof`를, 프로토타입을 교체할 때는 `Object.setPrototypeOf`를 사용하는 것이 좋다.\n\n```javascript\nconst obj = Object.create(null) // 상속을 이용해 만든 객체\nconsole.log(obj.__proto__) // undefined\n\nconsole.log(Object.getPrototypeOf(obj)) //null\n\nconst child = {}\nconst parent = { x: 1 }\n\nObject.setPrototypeOf(child, parent)\nconsole.log(obj2.x) // 1\n```\n\n`prototype`은 **함수**가 가지는 속성으로 생성자 함수가 만들 인스턴스의 프로토타입을 가진다. 그렇기 때문에 생성자 함수가 되지 못하는, [[construct]]가 없는 화살표함수나 메소드 축약표현은 `prototype`속성을 가지지 않고, 프로토타입을 생성하지 않는 것을 알 수 있다.\n\n```javascript\nconst Person = name => {\n  this.name = name\n}\n\nconsole.log(Person.hasOwnProperty(\"prototype\")) //false\n```\n\n둘을 정리하면 `__proto__`는 **모든 객체**가 가지고 있지만 `prototype`은 **생성자 함수만** 가지고 있는 차이를 가진다.\n\n## ⛏ 생성자 함수와 프로토타입\n\n앞선 설명에 생성자함수와 프로토타입은 항상 함께 생성된다고 설명했다. 생성자 함수는 사용자 정의 생성자함수와 빌트인 생성자함수로 구분할 수 있다. 이 두가지 방식에서 생성자함수가 언제 생성되는지 알아보자.\n\n### 사용자 정의 생성자 함수\n\n```javascript\nconsole.log(Foo.prototype) // {}\nfunction Foo(name) {\n  this.name = name\n}\n```\n\n위 코드에서 Foo함수는 평가 단계에서 전역 스코프에 등록되면서 함수 객체가 바로 초기화가 된다. 이때 프로토타입도 함께 생성되어 바인딩 된다. 그렇기 때문에 `Foo. prototype`을 먼저 호출해도 에러가 나지 않고 값이 나오는 것을 볼 수 있다. 그리고 중요한 것은 \"모든 객체는 프로토타입을 가지기 때문에\" 바인딩된 프로토타입도 자신의 프로토타입을 Object.Prototype으로 가지게 된다.\n\n### 빌트인 생성자 함수\n\n빌트인 생성자함수는 `Object, String, Number`등 과 같은 함수로 전역 객체(브라우저: Window, NodeJS: Global) 가 생성될 때 함께 생성된다. 이때 사용자 정의 생성자 함수와 마찬가지로 생성자함수가 만들어질 때 함께 프로토타입도 만들어져 빌트인 생성자함수의 prototype에 바인딩된다.\n\n## 👓 객체 생성 방식에 따른 프로토타입\n\n생성자 함수를 정리하면서 먼저 객체를 생성하는 네 가지 방식을 설명했다. 네 가지 방식에 따라 어떻게 프로토타입이 정해지는지 알아보자.\n\n### 1) 객체 리터럴\n\n객체 리터럴은 **Object.Prototype**을 프로토타입으로 갖는다.\n\n```javascript\nconst obj = {}\nconsole.log(obj.constructor === Object)\n```\n\n### 2) Object 생성자 함수\n\nObject 생성자함수도 객체 리터럴과 동일하게 **Object.Prototype**을 프로토 타입으로 갖는다.\n\n```javascript\nconst Obj = new Object()\nconsole.log(obj.constructor === Object)\n```\n\n### 3) 생성자 함수에 의해 생성된 객체\n\n생성자함수는 생성될 때 프로토타입이 바인딩 되어 있어, 생성자 함수로 만들어지는 객체는 **생성자함수의 prototype 속성에 바인딩된 프로토타입**을 갖는다. 위 두 가지 방식과 다른 점은 Object.Prototype은 다양한 메소드가 있지만 생성자함수와 바인딩된 프로토타입은 constructor 속성만 가지고 있는 특징을 가진다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype.sayHello = function () {\n  console.log(`${this.name}`)\n}\n\nconst me = new Person(\"Lee\") // Lee\nconst you = new Person(\"Kim\") // Kim\nme.sayHello()\n\nconsole.log(me.hasOwnProperty) // [Function: hasOwnProperty]\n```\n\nme와 you는 프로토타입의 sayHello를 상속 받아 사용할 수 있다. 하지만 분명 바인딩된 Person.Prototype에는 새로 추가한 sayHello와 constructor만 속성으로 가지고 있어야하는데 <u>어떻게 Object.Prototype의 hasOwnProperty도 상속 받을 수 있을까?</u>\n\n## 🖇 프로토타입 체인\n\n앞선 예제에서 Person.Prototype에는 constructor만 있어야 하지만 hasOwnProperty도 사용할 수 있다. 이처럼 객체에서 접근하려는 속성이 없을 때에는 [[prototype]]을 이용해, 상속받은 부모의 프로퍼티들을 순차적으로 검색한다. 이렇게 프로토타입으로 계속해서 연결되어있는 것을 **프토토타입 체인**이라고 한다.\n\n이렇게 체이닝이 가능한 이유는 모든 객체가 프로토타입을 가지기 때문에 계속해서 타고 올라갈 수 있다. 프로토타입 체인의 가장 끝은 항상 Object.prototype으로 Object.Protype의 프로토타입은 null로 탐색이 종료된다.\n\n```javascript\nfunction Person(name, gender) {\n  this.name = name\n  this.gender = gender\n  this.sayHello = function () {\n    console.log(\"Hi! my name is \" + this.name)\n  }\n}\nconst foo = new Person(\"Lee\", \"male\")\n\nconsole.log(foo.__proto__ === Person.prototype) // true\nconsole.log(Person.prototype.__proto__ === Object.prototype) // true\nconsole.log(Person.__proto__ === Function.prototype) // true\nconsole.log(Function.prototype.__proto__ === Object.prototype) // true\n```\n\n위 코드를 보면 첫번째 호출에서 생성자함수와 인스턴스가 같은 프로토타입을 가리키는 것을 알 수 있고, Person 생성자 함수의 프로토타입의 프로토타입이 Object.prototype이라는 것을 알 수 있다. 또한 빌트인 생성자함수인 Function의 프로토타입도 Object.Prototype인 것을 알 수 있다.\n\n![chain](chain.png)\n\n## ✏ 오버라이딩과 쉐도잉\n\n프로토타입 체이닝으로 상속을 구현하면 인스턴스에 정의하지 않은 속성들도 사용할 수 있다는 것을 알게 되었다. 하지만 인스턴스에서 같은 이름의 속성으로 다른 내용을 담고 싶을 때가 있다. 이때 일어나는 일이 **오버라이딩과 쉐도잉**이다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype.sayHello = function () {\n  console.log(`Prototype ${this.name}`)\n}\n\nconst me = new Person(\"lee\")\nme.sayHello = function () {\n  console.log(`instance ${this.name}`)\n}\n\nme.sayHello() // instance lee\n\ndelete me.sayHello\n\nme.sayHello() // Prototype lee\n```\n\nsayHello를 프로토타입 체인에서 찾을 때 가장 먼저 인스턴스에서 속성을 찾기 때문에 먼저` instance lee`가 호출된 것을 볼 수 있고, 인스턴스의 sayHello를 제거한 후에는 없기 때문에 프로토타입 체인을 이용해 Person.prototype의 sayHello를 이용해 `Prototype lee`가 호출된 것을 볼 수 있다.\n\n스코프체인에서 같은 이름의 식별자를 사용할 수 있는 것처럼 프로토타입 체인도 동일하게 작동한다.\n\n## 👉 프로토타입 바꾸기\n\n앞서 `prototype` 과 `__proto__`를 이용해 접근할 수 있다는 것을 알았다. 이제는 직접 접근해서 프로토타입을 바꿔보자\n\n### 1) 생성자함수로 프로토타입 바꾸기\n\n생성자함수에서 프로토타입에 접근하기 위해서는 `prototype`을 이용하면 된다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayHello() {\n    console.log(this.name)\n  },\n}\n\nconst me = new Person(\"lee\")\n\nconsole.log(me.constructor === Person)\n```\n\n### 2) 인스턴스로 프로토타입 바꾸기\n\n인스턴스에서 프로토타입에 접근하기 위해서는 `__proto__`를 이용할 수 있지만 앞서 정리한 것처럼 `__proto__`로 접근할 수 없는 객체도 있으므로 `Object.getPrototypeOf`와 `Object.setPrototypeOf`를 이용할 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nconst me = new Person(\"lee\")\n\nconst parent = {\n  sayHello() {\n    console.log(this.name)\n  },\n}\n\nObject.setPrototypeOf(me, parent)\nme.sayHello()\n\nconsole.log(me.constructor === Person) // false\nconsole.log(me.constructor === Object) // true\n```\n\n위 코드에서 me의 프로토타입이 바뀌면서 기존의 Person.Prototype이 constructor가 아니라 parent의 constructor인 Object.Prototype이 constructor가 되는 것을 볼 수 있다.\n\n위 두 가지의 차이점은 <u> 생성자함수의 prototype이 새롭게 연결된 프로토타입을 가리키고 있냐</u>로 볼 수 있다. 이렇게 직접 프로토타입을 바꿔서 상속관계를 바꿀 수 있지만, 위험하다고 생각된다. 자식이 부모를 바꾸다 보면 관계가 꼬일 수도 있기 때문에 동적으로 바꾸지 않는 것이 더 좋을 것 같다.\n\n그러면 프로토타입을 바꾸지 않고, 상속받은 속성을 사용하기 위해서 어떤 프로토타입이 프로토타입 체인에 있는지 알고 싶을 수 있다. <u>프로토타입에 해당 객체가 있는 지</u> 어떻게 확인할 수 있을까?\n\n## 😉 Instanceof\n\nInstanceof 키워드는 **객체의 프로토타입 체인에 생성자함수의 프로토타입이 존재하는지** 확인할 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nconst me = new Person(\"Choi\")\n\nconsole.log(me instanceof Person) // true\nconsole.log(me instanceof Object) // true\n\nconst parent = {}\nObject.setPrototypeOf(me, parent)\nconsole.log(me instanceof Person) // false\nconsole.log(me instanceof Object) // true\n```\n\n위 코드에서 `Object.setPrototypeOf`을 이용해 me의 prototype이 바뀐 것을 볼 수 있다. 바뀌고 난 후에 `instanceOf`를 이용해 확인했을 때, 기존 프로토타입이었던 Person.Prototype이 프로토타입 체인에서 사라지게 되어 false로, 새롭게 부모가 된 객체 리터럴의 Prototype인 Object.Prototype은 true 나오는 것을 볼 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nconst parent = { x: 1 }\nPerson.prototype = parent\n\nconst me = new Person(\"hi\")\n\nconsole.log(parent.constructor === Person) //false\nconsole.log(me) // { name: 'hi' }\nconsole.log(me instanceof Person) //true\n```\n\n이 부분을 정리하면서 헷갈렸던 것은 생성자 함수의 프로토타입을 parent로 바꾼다고 해서 생성자 함수를 이용해 만들어진 인스턴스의 모습에 영향을 주지 않는다는 것이었다. 인스턴스의 프로토타입만 바뀔 뿐, me자체가 `{ x: 1 }`이 되는 것이 아니다. 그리고 새롭게 바꾼 프로토타입의 constructor가 인스턴스의 생성자함수를 가리키고 있지 않아도 프로토타입 체인에 존재한다면 instanceOf는 true를 반환한다.\n\n## 👆 Object.create\n\n객체를 만드는 방법 중 마지막 방법이었던 `Object.create()`는 프로토타입을 직접 정해서 새로운 객체를 생성한다. 직접 상속을 정해 주는 것이기 때문에 new 키워드 없이도 객체를 만들 수 있고, 객체 리터럴도 상속받을 수 있다.\n\n```javascript\nconst obj1 = Object.create(null)\nconsole.log(obj.toString()) // TypeError: obj.toString is not a function\n\nconst parent = { x: 1 }\nconst child = Object.create(parent)\nconsole.log(child.x) // 1\nconsole.log(Object.getPrototypeOf(child) === parent) // true\n```\n\n위 코드에서 null을 프로토타입으로 만든 객체는 프로토타입의 종점에 해당하기 때문에 Object.Prototype의 내부 메소드를 사용할 수 없는 것을 볼 수 있다. Object.create에 Parent를 이용해 child를 만들면, child는 parent의 x속성을 상속 받고 parent를 프로토타입으로 가지고 있는 것을 볼 수 있다.\n\n## 🎮 정적 속성/메소드\n\n정적 속성/메소드는 **생성자 함수 자체가 소유하는 속성과 메소드**이기 때문에 인스턴스에서 참조할 수 없는 특징을 가진다.\n\n```javascript\nfunction Person(name) {\n  this.name = name\n}\n\nPerson.prototype.sayHello = function () {\n  console.log(this.name)\n}\n\nPerson.staticProp = `static Prop`\nPerson.staticMethod = function () {\n  console.log(\"static method\")\n}\n\nconst me = new Person(\"choi\")\nPerson.staticMethod() // static method\nme.staticMethod() // TypeError: me.staticMethod is not a function\n```\n\n위 코드에서 생성자 함수 자체가 가지는 속성과 메소드는 인스턴스에서 사용할 수 없는 것을 볼 수 있다. 앞서 본 그림에서 상속은 프로토타입 체인을 이용해 이루어지기 때문에 생성자 함수 자체가 가지고 있는 static 속성과 메소드는 상속받을 수 없다는 것을 알 수 있다.\n\n![static](static.png)\n\n## 🤗 객체 속 속성 존재 여부 확인과 나열\n\n### 1) 속성 존재 여부\n\n객체의 속성이 존재하는지 확인하는 방법으로 `in`을 사용할 수 있다. 이때 프로토타입으로 상속되는 속성들도 다 확인할 수 있는 특징을 가진다.\n\n```javascript\nconst Person = {\n  name: \"choi\",\n}\n\nconsole.log(\"name\" in Person) // true\nconsole.log(\"hasOwnProperty\" in Person) // true\n```\n\n만약 객체가 가지고 있는 고유 속성만 확인하고 싶다면 hasOwnProperty를 이용해서 확인할 수 있다.\n\n```javascript\nconst Person = {\n  name: \"choi\",\n}\n\nconsole.log(Person.hasOwnProperty(\"name\")) // true\nconsole.log(Person.hasOwnProperty(\"hasOwnProperty\")) //false\n```\n\n### 2) 나열하기\n\n객체 프로퍼티를 순회하며 나열하는 방법으로 for~in 구문이 있다. 이때 주의할 점은 고유 속성 뿐 아니라 상속 받은 속성 중 `[[Enumerable]]`이 true인 값들도 열거한다.\n\n```javascript\nconst Person = {\n  name: \"choi\",\n}\n\nObject.setPrototypeOf(Person, { x: 1 })\n\nfor (const key in Person) {\n  console.log(key)\n}\n// name\n// x\n```\n\n객체가 가진 속성들만 나열하려 한다면 `Object.keys()`,`Object.values()`,`Object.entries()`와 같은 메소드를 이용할 수 있다.\n\n```javascript\nconst Person = {\n  name: \"choi\",\n}\n\nObject.setPrototypeOf(Person, { x: 1 })\n\nconsole.log(Object.keys(Person)) // [\"name\"]\nconsole.log(Object.values(Person)) // [\"choi\"]\n```\n\n[참고]\n\n- [모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n- [프로토타입](https://poiemaweb.com/js-prototype)\n"},{"excerpt":"이번에 핀테크 기업의 면접을 처음으로 보면서 네트워크 통신에 대해 잘 모른다는 것을 많이 느꼈다. 가장 기본적인 http/https부터 쿠키와 로컬스토리지, 세션스토리지 등을 주제로 하나씩 정리해 보고자 한다. 🔓 http와 https  면접의 첫 질문이었다. 내 대답은 http와 https의 가장 큰 차이점은 보안에 있습니다 였다. 면접관님께서 주신 다…","fields":{"slug":"/2022-12-10-http와https/"},"frontmatter":{"date":"December 10, 2022","title":"http와 https","tags":["네트워크"]},"rawMarkdownBody":"\n이번에 핀테크 기업의 면접을 처음으로 보면서 네트워크 통신에 대해 잘 모른다는 것을 많이 느꼈다. 가장 기본적인 http/https부터 쿠키와 로컬스토리지, 세션스토리지 등을 주제로 하나씩 정리해 보고자 한다.\n\n# 🔓 http와 https\n\n`http와 https의 차이점이 뭔가요?` 면접의 첫 질문이었다. 내 대답은 http와 https의 가장 큰 차이점은 **보안**에 있습니다 였다. 면접관님께서 주신 다음 질문은 그럼 \"어떤 보안 방식으로 처리가 되나요?\"였다. 분명히 보안이 좋아지는 것은 알지만 어떤 방식을 이용해서 보안이 좋아지는 지는 몰라 모르겠다고 답할 수 밖에 없었다.\n\nhttp와 https는 보안에 차이점이 있다. 각각에 대해 정의하고 내가 뭘 대답하지 못했는지 그 차이점을 좀 더 파헤쳐 보자.\n\n![Http,https](http.png)\n\nhttp는 `HyperText Transfer Protocol`의 약자로 웹에서 다른 컴퓨터, 서버와 통신할 때 따라야 하는 통신 규약, 형식이다. 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜로 요청에 필요한 정보들을 형식에 넣어서 요청하면, 응답으로 필요한 내용을 이 형식에 맞게 담아서 전달해 준다. 쉽게 말해 컴퓨터가 전송된 데이터가 **어떤 형식으로 적혀있는지 이해할 수 있게 알려 주는 것**이라고 생각할 수 있다.\n\n![request](request.png)\n\nhttps는 `HyperText Transfer Protocol Secure `의 약자로 http에 보안을 강화한 프로토콜이다라고 이해할 수 있다. https가 가지는 장점은 세 가지가 있다.\n\n첫 번째로, https는 제 3자가 봐도 이해할 수 없게 **암호화**를 시켜 데이터를 주고 받는다. http의 문제점은 내가 전송한 정보를 제 3자가 봤을 때 이해할 수 있는 형식으로 전달된다는 점이다. 이렇게 암호화가 되지 않는 상태로 전송하게 되면 내 개인정보가 노출되는 문제가 생기기 때문에, https는 우리가 보낼 http통신의 body부분을 암호화해 해결한다.\n\n![해커가 봀 ㅜ 없어](http3.png)\n\n두 번째로는 **신뢰할 수 있는 사이트**인지 판별해 준다. https를 기관에서 검증된 사이트만 허가 받기 때문에 url주소가 유사한 피싱 사이트를 판별하는 데에도 도움을 준다.\n\n세 번째로 검색엔진의 SEO의 장점을 가진다. 구글의 검색엔진은 https를 검색 순위 결정 요소에 반영한다. https로 더 나은 UX와 사이트 체류 시간 등의 장점을 고려해 반영되어 있다. 그렇기 때문에 https는 SEO자체에도 큰 장점을 가지게 된다.\n\n그러면 https가 어떻게 구현되는지를 알아보기 위해 먼저 대칭키와 비대칭키를 알아보자\n\n### 🔑 대칭키와 비대칭키\n\n먼저 키는 우리가 보내고 받을 데이터를 암호화하는 알고리즘을 의미한다. 대칭키는 서버와 클라이언트 **모두가 같은 키**를 가지고 있는 경우를, 비대칭키는 **서로 다른 2개의 키가 한 쌍**으로 사용되기 때문에 비대칭 키라고 한다.\n\n#### 대칭키\n\n대칭키는 서버와 클라이언트가 `같은 키`를 갖고 있기 때문에, 클라이언트에서 암호화해서 보낸 정보를 서버가 바로 복호화할 수 있어 빠르게 처리가 가능하다. 하지만 문제점은 서버와 클라이언트 모두 같은 키를 갖기 위해서 최소한 한번의 전송이 필요한데, 이때 해킹된다면 해킹한 곳에서도 같은 키를 가져 애써 암호화한 데이터가 해킹되는 문제를 가진다.\n\n![symmetric](symmetic.webp)\n\n이러한 문제를 해결하기 위해 나온 것이 **비대칭 키**이다.\n\n#### 비대칭 키\n\n비대칭 키는 **서로 다른 한 쌍의 키**를 사용한다. 두 키를 각각 A키와 B키라고 부른다고 하면, A키로 암호화를 하면 B키로만 복호화를 할 수 있고, B키로 암호화를 하면 A키로만 복호화가 가능하다. 이런 비대칭 키는 `공개키`라고도 불리는데 그 이유는 서버가 개인키로 A키를 보관하고, B키는 공개키로 누구나 알 수 있게 공개한다.\n\n![asymmetric](asymmetric.png)\n\n우리가 원하지 않는 제 3자도 공개키를 갖게 되지만 오직 서버의 개인키로만 복호화가 가능해 대칭키의 제 3자가 같은 키로 복호화할 수 있는 문제점을 해결할 수 있다.\n\n이렇게 좋은 비대칭 키 방식을 이용하면 될 것 같지만 비대칭키 알고리즘은 `시간이 오래 걸린다`는 단점을 가지고 있다. 클라이언트와 서버가 주고받는 모든 파일을 비대칭키 방식으로 암호화/복호화 과정을 진행할 수 없다.\n\n정리하면 대칭키는 전송의 문제점을 가지고 있지만 빠르고, 비대칭 키는 대칭키의 전송의 문제점을 해결하지만, 오래 걸리는 단점을 가지고 있다. 실제로 https를 구현할 때는 대칭키와 비대칭키를 `혼합하는 방식`으로 사용된다. 그럼 이제 실제 https가 어떻게 이루어지는지 알아보자\n\n### 🔓 SSL과 통신과정\n\nSSL은 Secure Sockets Layer로 http통신의 모든 요청과 응답 데이터를 보내지기 전에 암호화하는 프로토콜이다. SSL에서 앞서 설명한 대칭키와 비대칭키를 혼용해서 사용한다.\n\n#### 1) 공개키와 대칭키의 혼합한 통신과정\n\nSSL 통신과정을 대칭키와 공개키를 중심으로 설명하면 다음과 같이 진행된다.\n\n1. 서버는 자신의 공개키를 클라이언트로 전달하고, 클라이언트는 받은 `공개키로 대칭키를 암호화`해서 서버에게 다시 전달한다.\n2. 암호화된 대칭키를 서버가 가지고 있는 개인 키로 복호화를 하면 결과적으로 서버와 클라이언트가 `같은 대칭키`를 가지게 된다.\n3. 서버와 클라이언트가 같은 대칭키를 가지고 있기 때문에 `대칭키`를 이용해, 빠르고 안전하게 데이터를 전송할 수 있게 된다.\n\n위 과정으로 부족한 점은 https가 가지는 **신뢰할 수 있는 사이트를 판별하는 부분**이다. 이 부분은 아래 인증서를 추가한 통신 과정으로 설명하려 한다.\n\n#### 2) 인증서를 추가한 통신과정\n\n인증서를 추가한 통신과정을 이해하기 위해 CA (Certificate Authority)를 이해해야하는데, CA의 역할은 https로 인증하는 인증서를 발급해주고 해당 인증서가 유효한지 판별해주는 역할을 한다.\n\n##### 통신 전\n\n통신 전 상황은 서버는 CA로부터 인증서를 받기 위해 **서버 정보와 서버의 공개키**를 전달하고, CA의 개인키로 서명된 인증서를 받아서 보관하고 있고, 클라이언트의 브라우저에는 해당 CA의 공개키가 내장되어 인증서를 받으면 유효한지 확인할 수 있다.\n\n##### handshake\n\n이제 준비가 된 후에 클라이언트와 서버가 랜덤한 데이터를 이용한 요청과 응답을 하는데 이것을 `handshake`라고 부른다. 클라이언트가 랜덤한 데이터를 서버에 보내면 서버도 랜덤한 데이터를 만들어 `인증서`와 함께 전달한다.\n\n![ssl](ssl.png)\n\n##### handShake 이후\n\nhandshake가 끝난 후에 클라이언트는 받은 인증서를 인증기관의 공개키로 복호화해서 확인한다. 공개키로 복호화가 가능한 것은 CA의 개인키로 암호화가 된 인증서이기 때문에 유효여부를 확인할 수 있다. 확인 후에 인증서를 통해 전달 받은 서버 공개키로 자신의 대칭키를 암호화하고, 서버에 전달한다. 서버는 자신의 개인키로 사용자가 클라이언트의 대칭키를 복호화해서 얻는다. 이때 대칭키는 앞서 handshake에서 주고 받았던 랜덤데이터를 처리해서 만들게 된다.\n\n![ssl2](ssl2.png)\n\n이렇게 CA의 비대칭 키를 이용한 인증 방식으로 유효한 사이트인지도 https를 이용해 알 수 있게 된다.\n\n## 마치며\n\nhttp,https를 안다고 생각했지만 공부하면 공부할 수록 더 복잡하고 어려운 내용들이 있었다. 우선은 내가 이해할 수 있는 만큼 정리했다. 이후에 계속해서 업데이트하고 더 잘 설명하려고 수정해 나가야겠다.\n\n[참고자료]\n\n- [우아한테크코스 테코톡](https://www.youtube.com/watch?v=wPdH7lJ8jf0)\n\n- [얄팍한 코딩사전](https://www.youtube.com/watch?v=H6lpFRpyl14)\n\n- [http vs https](https://seopressor.com/blog/http-vs-https/)\n"},{"excerpt":"🔏 Cookie,Session, JWT 모으잡의 Next-auth를 고려하면서 Cookie,Session, JWT에 대해 다시 정리할 필요성을 느꼈다. 각각의 문제점과 해결과정들을 정리하고 보안을 어떻게 고려해서 각각을 사용할 수 있을지 정리해보았다. 인증과 인가란 인증과 인가, 단어 만으로는 구분이 잘 안 가서 먼저 정리가 필요했다. 인증은 정보를 이용…","fields":{"slug":"/2022-12-09-쿠키-session-jwt/"},"frontmatter":{"date":"December 09, 2022","title":"Cookie,Session과 JWT","tags":["웹","보안"]},"rawMarkdownBody":"\n# 🔏 Cookie,Session, JWT\n\n모으잡의 Next-auth를 고려하면서 Cookie,Session, JWT에 대해 다시 정리할 필요성을 느꼈다. 각각의 문제점과 해결과정들을 정리하고 보안을 어떻게 고려해서 각각을 사용할 수 있을지 정리해보았다.\n\n## 인증과 인가란\n\n인증과 인가, 단어 만으로는 구분이 잘 안 가서 먼저 정리가 필요했다. **인증**은 정보를 이용해 신원을 확인하는 과정이고, **인가**는 사용자가 해당 리소스에 대해 접근할 수 있는 권한이 있는지 확인하는 과정이다.\n\n예를 들어 커뮤니티에 들어가 글을 작성한다고 가정하자. 아이디와 비밀번호를 정하고 만든 `회원정보를 이용해 서비스 이용자라는 권한`을 얻고 들어갈 수 있는 것, 바로 `인증과정`이다. 로그인 후에 마음에 들지 않는 다른 사람의 글을 지우고 싶어졌다. 하지만 내가 쓰지 않은 글은 지울 수 없다. 왜냐하면 다른 사람의 글을 수정할 수 있는 권한이 없기 때문이다. 이게 바로 `인가과정`이다.\n\n이러한 인증, 인가과정을 처리하기 위한 인증방식으로 \"cookie와 session을 이용한 방법\"과 \"JWT를 이용하는 방법\"이 있다. 먼저 각각에 대해서 정리해 보고자 한다.\n\n### Cookie와 Session\n\n두 가지 방식을 이해하기 전에 이전에 정리했던 HTTP의 특징 중 stateless를 이해해야 한다. stateless는 클라이언트와 서버사이의 http 통신들간의 연관성이 없다는 의미이다. 먼저 어떠한 통신을 보내야 다음 통신을 보내는 것이 아니라 항상 독립적인 통신을 유지한다. 그렇기 때문에 우리가 이전에 인증했는지를 http 통신 자체는 알 수 없다.\n\n#### Cookie\n\n쿠키는 웹사이트에 방문 시에 서버를 통해 **클라이언트 브라우저에 설치되는 key와 value 형태를 가진 데이터 파일**을 의미한다. HTTP로 해당 사이트에 로그인 요청을 하게 되면 서버는 인증 정보를 쿠키에 담아 응답을 보내주게 되는데, 이때 받은 쿠키는 **브라우저에 자동으로 저장**되고 클라이언트가 직접 넣어서 요청을 보내지 않아도 브라우저가 자동으로 request header에 넣어서 서버에 전달한다. 인증이 필요할 때마다 로그인을 하지 않아도 인증을 할 수 있는 장점을 가진다.\n\n![cookie](cookie.png)\n\n이렇게 쿠키는 HTTP의 stateless 특성을 지키면서 인증을 할 수 있다. 하지만 인증 정보가 클라이언트의 브라우저에 저장되어 자바스크립트로 접근이 가능한 상태로 보관 시 보안에 위험한 단점을 가진다. 이점을 해결하기 위한 방법이 `session`이다.\n\n#### Session\n\n세션은 쿠키로 담아서 보냈던 인증 정보를 클라이언트에 보관하는 것이 아니라 **서버가 보관하는 방법**이다. 로그인 요청이 들어오면 해당하는 사용자 정보를 담은 세션ID를 만들어 서버에 저장한 후에 해당 세션ID를 쿠키에 담아 브라우저에 보내게 된다. 이때 브라우저에 보낼 때 cookie를 그냥 보내는 것이 아니라 **httpOnly**로 보내 자바스크립트로 접근할 수 없고 브라우저만 읽을 수 있게 보낸다.\n\n이렇게 세션을 이용하게 되면 클라이언트는 같은 사용자 정보로 login을 했을 때, 별다른 처리를 하지 않아도 request Header에 전달 받은 쿠키를 넣어서 보내게 되고, 서버는 **서버에 저장해둔 세션 정보와 일치하는지**를 확인해 인증 과정을 진행한다.\n\n![session](session.png)\n\n이렇게 세션을 이용하게 되면 서버가 관리하고 있기 때문에 쿠키를 그냥 발급할 때보다는 느리지만, 보안을 강화할 수 있다. 하지만 서버 자체가 세션을 관리해야 하면서 서버가 stateful해지는 단점을 가진다.\n\n그리고 이렇게 stateful 해진 서버는 **session을 어떻게 관리해야 할 지**에 대한 문제를 가지게 된다.\n\n먼저 만약 서버 로컬에 저장한다면 서버가 꺼지게 된 사고가 발생한다면 이전의 모든 사용자의 정보를 잃어 버리게 된다. 두 번째로는 확장성이 떨어지게 된다. 여러 대가 되었을 때 각각 서버에 저장한다면 서버1에서 인증한 사용자가 서버3으로 접속했을 때 같은 정보지만 인증 받지 못하는 단점을 갖게 된다.\n\n![server](server1.png)\n\n이러한 문제점을 해결하기 위해 session을 이용할 때는 **Session DB를 두어 서버와 분리해 관리**한다. 서버가 꺼져도 DB가 살아있다면 사용자 정보가 날라가지 않고, 서버가 여러 대가 되어도 한 곳에서 세션을 관리하기 때문에 인증을 받을 수 있게 된다.\n\n![server](server2.png)\n하지만 여전히 정보를 그대로 가지고 있는 stateful한 단점을 가지고 있으며, 서버가 여러 대로 분산해 요청들을 처리해도 여전히 세션 DB는 한 곳에서 인증해주어야 하기 때문에 성능의 문제점도 가지고 있다. 이것을 해결하기 위해 나온 것이 `JWT`다.\n\n### JWT\n\nJWT (Json Web Token)은 JSON 객체 구조의 인증 정보를 secret 키를 이용해 암호화 시킨 토큰으로 header, payload, signature 세 가지로 구성되어 있다.\n\n- Header: 암호화를 위해 사용한 알고리즘과 type\n- Payload: 전송할 인증 정보\n- Signature: Base64방식으로 header, payload 인코딩하고 secret 키로 암호화 되어있는 문자열로, payload의 내용 변화를 체크하기 위해 사용된다.\n\n![jwt](jwt.png)\nJWT는 이렇게 암호화가 되어있어서 안전하구나 싶지만, JWT 자체는 json이 base 64로 인코딩되어있는 것이기 때문에 **누구나 jwt를 디코딩해 header와 payload의 값을 알 수 있다**. 그렇기 때문에 노출되어도 크게 위험하지 않은 username과 같은 최소한의 정보를 담아서 인코딩해 담는다.\n\n그러면 보안에 취약한 것 아닐까 싶지만, signature부분은 header와 payload **서버에 보관할 개인 키**를 이용해서 암호화되어있기 때문에 안전하다. 서버만이 복호화할 수 있는 개인 키가 있기 때문에 서버는 JWT 토큰을 전달한 클라이언트에 전달해주고 전달받은 토큰으로 이후에 쿠키를 사용하듯이 인증이 필요한 요청에 담아서 서버에 요청한다. 요청에 들어있는 JWT의 signature부분을 서버에 저장되어 있는 secret으로 복호화해 header와 payload를 확인해 인증하게 된다.\n\n![jwtflow](jwtflow.webp)\n\n서버는 더 이상 인증을 위해 session을 가지고 있지 않아도 되고, 각각의 서버에 secret 키를 두고 확인하면 되기 때문에 성능 문제도 해결할 수 있는 장점을 가진다. 하지만 토큰 stateless한 장점은 session과 다른 보안의 허점을 만든다. 토큰을 노출된 경우 해당 사용자로 로그인한 사람이 서버에서는 누구인지 알 수가 없다. 이때문에 **토큰을 어떻게 관리할 지**에 대해서 새로운 문제점을 가진다.\n\n#### Access Token과 Refresh Token\n\n토큰 관리를 위해 주로 만료 기간이 짧은 `Access 토큰`과 만료 기간이 긴 `refresh 토큰`을 두고 관리한다. 유효기간이 짧은 access Token만 보내게 되면 유저는 계속해서 로그인 과정을 거쳐야 하기 때문에 유효 기간이 긴 refresh 토큰을 함께 보내 로그인 유지가 될 수 있게 한다.\n\n과정을 보면 먼저 토큰을 발급할 때 두 가지 토큰을 다 전달한다.\n\n![token](token1.png)\n\n사용자는 전달 받은 access token으로 유효 기간 동안 인증을 진행하고, 이후 유효 기간이 다되게 되면 refresh 토큰을 이용해 새롭게 access token을 받아 인증을 진행할 수 있다.\n\n![token](token2.png)\n\nAccess 토큰은 유효 기간이 짧지만 여전히 그사이에 해킹의 위험이 있고, Refresh Token 유효 기간이 길기 때문에 더욱 보안에 신경을 써야 한다. 그러므로 **프론트엔드 입장에서 어디에 보관하냐**는 여전히 문제가 된다.\n\n### 그래서 토큰은 어디에 보관해야 할까?\n\n가장 먼저 고려된 것은 내가 자주 사용해온 방식인 브라우저의 **localstorage**이다. local storage는 브라우저가 닫혀도 유지되기 때문에 자바스크립트로 접근해 request header의 Authorization에 해당 토큰을 담아 주는 방식으로 사용할 수 있다. 가장 간단하고 쉽기 때문에 프로젝트의 토큰을 로컬스토리지로 관리했다. 하지만 이러한 방식은 ` XSS (Cross-Site Scripting) 공격`에 취약한 단점을 가진다.\n\n#### XSS (Cross-site scripting)\n\nXSS 공격은 웹사이트에 **악성 스크립트를 주입하는 방식**으로 주로 페이지의 input이나 form을 이용해 공격하는 방식이다. 주입해놓은 사이트에 사용자가 로그인하게 될 경우에 사용자의 토큰, 쿠키 등의 정보를 빼낼 수 있게 된다.\n\n![xss](xss.png)\n\n그렇기 때문에 자바스크립트로 접근할 수 있는 localstorage나 별도의 옵션없이 쿠키에 토큰을 저장하게 될 경우에는 XSS 공격에 취약하게 된다. 이것을 막기 위해서는 `클라이언트 메모리에 저장하는 방식`과 `http only 쿠키`를 이용하는 방식이 있다. 클라이언트의 메모리에 저장할 경우에는 관리는 쉽지만 로그인을 유지할 수가 없는 단점이 있어 보통 http only 쿠키로 서버에서 토큰을 보내주면 브라우저에 저장하고 자동으로 요청시 담아서 보내는 방식을 적용할 수 있다.\n\n하지만 http only 쿠키로 토큰을 저장하는 방법도 CSRF 공격에 약한 단점이 존재한다.\n\n#### CSRF(Cross-site Request Forgery)\n\nCSRF공격은 사용자가 원하지 않은 action을 하게하는 해킹 방법으로, 로그인한 사용자의 정보를 이용해 사용자 몰래 브라우저에 저장되어있는 쿠키를 이용해 요청을 보내는 방식이다. http only로 된 쿠키이기 때문에 직접 빼올 수는 없지만 계좌이체나 물건을 구입하는 요청을 보내는 등의 요청을 할 수 있다. 그렇기 때문에 http only 쿠키만을 이용해서 토큰을 관리한다면 CSRF공격에 취약할 수 있어, 추가적인 방식이 필요한데 이때 사용할 수 있는 방법이 `CSRF 토큰`이다.\n\n![csrf](csrf.png)\n\nCSRF 토큰을 서버에서 발급하면 클라이언트의 메모리에 저장해 두고 요청을 보낼 때마다 함께 보내서, http only 쿠키와 CSRF토큰을 서버가 확인 후에 요청이 처리될 수 있게 함으로써 공격을 막을 수 있다.\n\n![토큰과정](token과정.png)\n\n### 마치며\n\n인증이란 과정은 굉장히 복잡한 과정들이 숨어있고 고려해야할 점이 많다. 프론트엔드에서나 백엔드에서만 잘 처리한다고 해결되는 것이 아니라 두가지 측면을 모두 생각해야 보안을 고려한 인증방식이 될 수 있다.\n\n[참고]\n\n- [인증방식: Cookie & Session vs JWT](https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/)\n\n- [쿠키와 세션 그리고 토큰 JWT](https://velog.io/@gloom/%EC%BF%A0%ED%82%A4-%EC%99%80-%EC%84%B8%EC%85%98%EA%B7%B8%EB%A6%AC%EA%B3%A0%ED%86%A0%ED%81%B0JWT)\n\n- [쿠키와 세션 개념](https://interconnection.tistory.com/74)\n\n- [세션 불일치시 해결방법들](https://velog.io/@dailyzett/%EC%84%B8%EC%85%98-%EB%B6%88%EC%9D%BC%EC%B9%98-%EC%8B%9C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95%EB%93%A4)\n"},{"excerpt":"👉 This 자바스크립트에서 this는 \"동적\"으로 정해진다라고 한다. 기존 객체지향 언어들과는 다르게 작동하는 자바스크립트의 this에 대해 정리해 보려 한다. 🙋‍♂️ This란 this는 자신이 속한 객체 또는 만들어 질 인스턴스를 가리키는 변수이다. 이해를 위해 다음 코드를 보자 square 객체의 getArea 메소드는 distance를 이용해 넓이를…","fields":{"slug":"/2022-12-09-this/"},"frontmatter":{"date":"December 09, 2022","title":"this","tags":["javascript","문법"]},"rawMarkdownBody":"\n# 👉 This\n\n자바스크립트에서 this는 \"동적\"으로 정해진다라고 한다. 기존 객체지향 언어들과는 다르게 작동하는 자바스크립트의 this에 대해 정리해 보려 한다.\n\n## 🙋‍♂️ This란\n\nthis는 **자신이 속한 객체 또는 만들어 질 인스턴스를 가리키는 변수**이다. 이해를 위해 다음 코드를 보자\n\n```javascript\nconst square = {\n  distance: 5,\n  getArea() {\n    return square.distance ** 2\n  },\n}\n\nconsole.log(square.getArea())\n```\n\nsquare 객체의 getArea 메소드는 distance를 이용해 넓이를 계산한다. 이때 중요한 것은 square가 가지고 있는 속성인 `distance`값이 필요하다는 점이다. 객체를 선언한 변수 square를 입력하면 distance를 사용할 수는 있지만, 항상 객체를 선언한 식별자를 이용한다면 오직 square라는 이름의 객체에서만 사용이 가능해 재사용성이 떨어지게 된다.\n\n이러한 재사용성을 고려해 객체가 어떻게 선언되는지에 상관없이, 어떤 이름의 인스턴스인지 상관없이 **항상 자기 자신을 참조할 수 있는 변수**가 바로 this라고 이해할 수 있다.\n\n위를 객체 리터럴, 생성자함수, class로 다음과 같이 표현할 수 있다.\n\n```javascript\nconst square1 = {\n  distance: 5,\n  getArea() {\n    return this.distance ** 2\n  },\n}\n\nfunction ProtoSquare(distance) {\n  this.distance = distance\n}\nProtoSquare.prototype.getArea = function () {\n  return this.distance ** 2\n}\n\nconst square2 = new ProtoSquare(5)\nconsole.log(square2.getArea())\n\nclass ClassSquare {\n  constructor(distance) {\n    this.distance = distance\n  }\n  getArea() {\n    return this.distance ** 2\n  }\n}\n\nconst square3 = new ClassSquare(5)\nconsole.log(square3.getArea())\n```\n\n이러한 this는 \"어떻게\" 결정되는 걸까?\n\n## 👍 this가 결정되는 방식\n\nthis는 함수가 어떻게 `호출되느냐`에 따라 동적으로 결정되는데, this 바인딩에는 4가지 규칙이 있다. 4가지 규칙에 대해 알아보자.\n\n### 1) 기본바인딩\n\n객체의 메소드나 생성자 함수를 제외한 함수들, 일반함수로 함수 내부에서 this를 호출하면 `전역객체`를 얻을 수 있다. 전역객체는 브라우저냐 Node.js냐에 따라 각각 window와 global을 의미한다. 브라우저 기준으로 전역객체는 window로 설명을 진행하려 한다.\n\n```javascript\nfunction hi() {\n  console.log(this) //window 또는 global\n}\nhi()\n```\n\n이때 메소드 내부 중첩 함수나 콜백함수가 일반함수로 호출될 경우에도 동일하게 전역 객체로 this 바인딩이 된다.\n\n```javascript\nvar value = 1\n\nconst obj = {\n  value: 100,\n  foo() {\n    setTimeout(function () {\n      console.log(this) // window\n      console.log(this.value) // 1\n    }, 100)\n  },\n  too() {\n    function bar() {\n      console.log(this) // window\n      console.log(this.value) // 1\n    }\n    bar()\n  },\n}\n\nvar value = 1\n\nconst obj = {\n  value: 100,\n  too() {\n    \"use strict\"\n    function bar() {\n      console.log(this) // undefined\n      console.log(this.value) // Uncaught TypeError: Cannot read properties of undefined\n    }\n    bar()\n  },\n}\n\nobj.too()\n```\n\n이때 use strict로 엄격모드를 적용하면 전역객체는 기본 바인딩에서 제외되어 this.value는 에러를 던지게 된다.\n\n### 2) 암시적 바인딩\n\n호출할 때의 객체의 존재 여부에 따라, this는 만들어진 객체에 속해지지 않고, `호출한 객체, 컨텍스트 객체`에 바인딩된다. 이것을 **암시적 바인딩**이라 하는데 이해를 위해 다음 예제를 보자.\n\n```javascript\nconst person = {\n  name: \"lee\",\n  getName() {\n    return this.name\n  },\n}\n\nconsole.log(person.getName()) //lee\n\nconst anotherPerson = {\n  name: \"kim\",\n}\n\nanotherPerson.getName = person.getName\nconsole.log(anotherPerson.getName()) //kim\n\nconst getName = person.getName\nconsole.log(getName()) // window\n```\n\n위의 코드를 보면 getName이 **함수가 사용되는 곳에 따라 this가 달라진다**. 객체에서 선언된 this라면 해당 객체와 binding이 되어야 하지만, 호출하는 객체가 누구냐에 따라 달라지는 결과를 보여준다. 그렇기 때문에 함수가 가리키는 객체는 독립적인 `컨텍스트 객체`라고 볼 수 있다. 이러한 결과는 함수의 컨텍스트는 함수가 실행될 때 만들어지고, 만들어지는 과정에서 this가 바인딩되기 때문에 그때의 컨텍스트 객체가 this에 바인딩된다.\n\n```javascript\nfunction foo() {\n  console.log(this.text)\n}\n\nvar name = {\n  text: \"영준\",\n  foo: foo,\n}\n\nvar person = {\n  text: \"가영\",\n  name: name,\n}\n\nperson.name.foo()\n```\n\n만약 중첩된 상태에서 호출하게 된다면 가장 가까운 객체, name을 암시적으로 컨텍스트 객체로 바인딩한다.\n\n이렇게 어디서 호출하냐에 따라 달라지면 예측하기 어렵고 에러가 발생할 수 있다. this binding을 우리가 정하는 방법은 없을까?\n\n### 3) 명시적 바인딩\n\nthis binding을 명시적으로 정해주는 방식에는 apply, call, bind 메소드를 사용하는 방법이 있다.\n\n#### apply와 call\n\n두 가지 메소드는 사용 시 전달한 객체를 this에 바인딩하고, 호출한다. 두가지 메소드의 차이점은 함수에 인자를 전달하는 방식에 있다. apply는 배열로 인자를 전달하고 call은 하나 하나씩 전달하고 호출한다.\n\n```javascript\nfunction getThisBinding() {\n  console.log(arguments)\n  return this\n}\n\nconst thisArg = { a: 1 }\nconsole.log(getThisBinding())\nconsole.log(getThisBinding.apply(thisArg, [1, 2, 3])) //[1, 2, 3]\nconsole.log(getThisBinding.call(thisArg, 1, 2, 3)) //[1,2,3]\n```\n\n#### bind\n\nbind는 this만 바인딩하고 호출은 하지 않는다. 콜백함수나 중첩함수가 일반함수로 호출되었을 때, this가 달라지는 문제를 명시적으로 해결해 줄 수 있다.\n\n```javascript\nconst person = {\n  name: \"lee\",\n  foo(callback) {\n    setTimeout(callback.bind(this), 100)\n  },\n}\n\nperson.foo(function () {\n  console.log(this.name) //lee\n})\n```\n\n### 4) new 바인딩\n\n생성자함수 내부의 this는 인스턴스가 바인딩된다.\n\n```javascript\nfunction foo() {\n  this.name = \"영준\"\n  this.callName = function () {\n    console.log(this.name)\n  }\n}\n\nconst bar = {\n  name: \"주희\",\n}\n\nconst x = new foo()\nx.callName.bind(bar)\nx.callName() // 영준\n```\n\n생성자 함수를 이용해 만든 x 객체에 명시적 바인딩인 bind로 bar를 바인딩하려했지만, new 바인딩이 우선순위가 높아 \"영준\"으로 나온 것을 볼 수 있다.\n\n### 🔼 예외적인 바인딩: 화살표 함수\n\n앞서 설명한 this 바인딩과는 다르게 작용한다.화살표 함수는 함수 자체가 this를 갖지 않아 함수 선언 시의 **상위 스코프의 this를 바인딩**한다. 항상 this를 보장하기 때문에 callback함수에서 주로 사용된다.\n\n```javascript\nfunction foo() {\n  setTimeout(() => {\n    console.log(this.name)\n  }, 1000)\n}\n\nconst bar = {\n  name: \"영준\",\n}\n\nfoo.call(bar) // 영준\n```\n\n위의 예시를 보면 setTimeOut 콜백함수의 this는 foo의 this를 참조하는데 현재 call을 이용해 bar로 바인딩되어 결과가 철수로 나타난 것을 볼 수 있다.\n\n```javascript\nconst foo = {\n  name: \"영준\",\n  bar: () => console.log(this.name),\n}\n\nfoo.bar() // undefined\n\nconst boo = {\n  name: \"영준\",\n  far() {\n    console.log(this.name)\n  },\n}\n\nboo.far() //영준\n```\n\n하지만 주의할 점은 메소드를 화살표함수로 만들게 되면 foo 객체가 아니라 상위 스코프의 this인 전역객체를 binding하게 된다. 그렇기 때문에 메소드는 메소드 축약으로 정의하는 게 낫다는 것을 알 수 있다. 여기서 헷갈렸던 것은 bar라는 메소드를 함수 스코프로 생각해야 하는지 여부였다. 메소드는 결국 객체의 키와 연결된 함수의 참조값이므로 이것 자체가 함수 스코프를 가지진 않아 위와 같은 결과를 갖는 것을 볼 수 있다.\n\n## 마치며\n\nthis 바인딩은 예상치 못하는 에러를 만들 수 있기 때문에 꼭 한번 정리를 하고 넘어가야 했다. 아직 화살표 함수에서 마지막 부분이 왜 전역객체를 바인딩하는지 잘 이해가 되지 않아 생성자함수와 prototype에 대해서 정리하고 다시한번 확인을 해보려고 한다.\n\n[참고]\n\n[모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n[this 바인딩](https://doqtqu.tistory.com/307#2.2.%20Binding%20%EA%B7%9C%EC%B9%99)\n"},{"excerpt":"☝ 호이스팅 자바스크립트 엔진은 변수와 함수의 선언을 선언단계와 초기화 단계, 두 단계로 나누어 처리한다. 이렇게 두 가지 단계로 나누어 처리하다 보니, 마치 선언을 스코프 최상단으로 올려서 하는 것처럼 보이게 되는데, 이것을 호이스팅이라고 한다. 변수와 함수 두가지를 나눠서 앞서 정리했던 실행 컨텍스트와 함께 호이스팅을 정리해보려 한다. 🙋‍♂️선언이란 먼저…","fields":{"slug":"/2022-12-05-호이스팅/"},"frontmatter":{"date":"December 05, 2022","title":"호이스팅","tags":["javascript","문법"]},"rawMarkdownBody":"\n# ☝ 호이스팅\n\n자바스크립트 엔진은 변수와 함수의 선언을 선언단계와 초기화 단계, 두 단계로 나누어 처리한다. 이렇게 두 가지 단계로 나누어 처리하다 보니, 마치 선언을 스코프 최상단으로 올려서 하는 것처럼 보이게 되는데, 이것을 **호이스팅**이라고 한다.\n\n변수와 함수 두가지를 나눠서 앞서 정리했던 실행 컨텍스트와 함께 호이스팅을 정리해보려 한다.\n\n## 🙋‍♂️선언이란\n\n먼저 **선언**에 대해 정리해보면, 변수와 함수를 선언한다는 것은 해당 변수와 함수에 대한 정보를 저장할 수 있는 <u> 메모리를 할당하고 할당한 메모리와 변수를 연결하는 과정</u>이다. 이러한 선언은 다음과 같이 두 단계로 나눌 수 있다.\n\n1. 선언 단계: 해당 변수와 함수를 등록하는 것\n2. 초기화 단계: 해당 변수와 함수에 메모리를 할당하고 값을 저장하는 과정\n\n이러한 두 단계가 변수와 함수에서 어떻게 다르게 작동하는지에 대해 알아보자.\n\n### 변수 선언의 호이스팅\n\n변수 선언은 \"var\"와 \"const와 let\"으로 구분할 수 있다. 모두 동일하게 선언 단계에서 변수 이름을 등록하지만, var의 경우 선언 단계와 초기화 단계가 동시에 진행되는 특징을 가진다. 이때 var는 암묵적으로 `undefined`으로 할당된다. const와 let은 다르게 선언 단계만 진행되기 때문에 값을 가져올 수 없어 `referenceError`가 발생한다. 이렇게 const와 let의 경우, 변수 선언문을 자바스크립트 엔진이 읽을 때까지 값을 불러올 수 없는 구간이 생기는데 이것을 \"TDZ(Temporal Dead Zone)\"라 부른다.\n\n정리하면 둘 다 선언 단계에서 변수를 등록하기 때문에 호이스팅이 일어나지만, var는 const/let과 다르게 초기화단계도 함께 진행하기 때문에 변수 선언문 전에 참조가 가능하다는 특징을 가진다.\n\n```javascript\nconsole.log(first) //undefined\nconsole.log(second) //ReferenceError: Cannot access 'second' before initialization\nvar first = 80\nconst second = 90\n```\n\n### 함수 선언의 호이스팅\n\n함수 선언은 \"함수 선언문\"과 \"함수 표현식\"으로 구분할 수 있다. 함수 선언도 동일하게 선언 단계와 초기화 단계로 나뉘는데, 함수 선언문은 변수 선언의 var와 같이 선언 단계와 초기화 단계가 동시에 진행된다. 이때 함수 선언문은 var와는 다르게 undefined가 아니라 `함수 객체`로 초기화되어 함수를 바로 사용할 수 있다.\n\n함수 표현식은 변수에 함수를 할당하는 것이므로 \"변수 선언과 동일하게\" 진행된다. var 함수 표현식은 var 변수 선언과 동일하게 undefined로 초기화 단계가 선언단계와 함께 진행되고, const와 let 함수 표현식은 함수 선언문을 자바스크립트 엔진이 읽을 때까지 값을 불러올 수 없다.\n\n```javascript\nconsole.log(multiply(1, 2)) // 2\nconsole.log(sum) // undefined\nconsole.log(sub) // ReferenceError: Cannot access 'sub' before initialization\nvar sum = (a, b) => a + b\nconst sub = (a, b) => a - b\nfunction multiply(a, b) {\n  return a * b\n}\n```\n\n이때 var 함수 표현식은 var 변수 선언과 동일해, 함수 객체가 할당되긴 전이기 때문에, 함수로 실행하면 typeError가 발생한다.\n\n```javascript\nconsole.log(sum(1, 2)) // TypeError: sum is not a function\nvar sum = (a, b) => a + b\n```\n\n이제 실행 컨텍스트를 이용해 자세한 내부 동작을 정리해보자\n\n## 📰 실행 컨텍스트\n\n실행 컨텍스트는 \"코드가 실행되기 위한 환경\"을 의미한다. 자바스크립트 코드를 자바스크립트 엔진이 읽을 때 항상 먼저 해당 스코프에 해당하는 실행 컨텍스트를 만든 후에, 평가 과정과 실행 과정을 진행한다. 이 두 가지 과정 중 \"평가 과정이 변수와 함수 선언의 선언 단계\"를 포함하고, \"실행 과정이 변수와 함수 선언의 초기화 단계\"를 포함한다.\n\n평가 과정을 다시 정리해보면, 실행 컨텍스트가 생성되고 lexical 환경을 만들어 실행 컨텍스트와 바인딩을 한다. 이때 lexical 환경의 구성 요소로 <u>환경 레코드</u>와 <u>외부 렉시컬 환경에 대한 참조</u> 두 가지가 있는데, 여기서 환경 레코드가 우리가 선언한 \"변수와 함수가 저장되는 곳\"이다.\n\n환경레코드는 다시 \"객체 환경 레코드\"와 \"선언적 환경 레코드\"로 나뉘어, var로 된 변수와 표현식, 함수 선언문은 \"객체 환경 레코드\"에 저장되고 const와 let으로 선언된 변수와 표현식은 \"선언적 환경 레코드\"로 구분되어 등록된다. 위에서 정리한 것처럼 평가 과정에서 var로 된 변수와 표현식은 초기화 단계를 함께 진행해 undefined으로 초기화가 되고, 함수 선언문은 함수 객체로 초기화가 된다.\n\n이후 실행 과정에서 각각 할당할 값이 있을 경우에 새로운 값으로 재 할당이 되고, 이때 const와 let의 초기화 단계가 진행된다. 이렇게 선언 과정이 실행 컨텍스트의 진행 과정에 어떻게 정리되어있는지 알아보았다.\n\n## 😁 한마디\n\n정리하면 **모든 변수와 함수선언에 호이스팅이 일어난다**. 하지만 선언 단계 이후에 초기화 단계가 바로 일어나냐에 따라서 참조를 할 수 있냐 없냐로 다른 결과를 가지는 것을 알 수 있다.\n"},{"excerpt":"🛠 리팩토링 프로토타입을 만들고, 프로토타입에 대한 리드미 작성까지는 끝났다. 하지만 급하게 진행하다 보니 아직 손봐야 할 곳이 많이 보였다. 주변에 피드백을 받아서 고쳐야 할 부분들을 수정하고 수정 과정을 담아보려 한다. 🎃 느린 check 박스 checkbox 기능은 해당 공고의 자격 조건과 우대 사항에 얼마나 해당되는지 기록하고, 50%이상일 경우 …","fields":{"slug":"/2022-12-03-모으잡-리팩토링/"},"frontmatter":{"date":"December 03, 2022","title":"모으잡-check box 수정, react-query 커스텀 훅, 크롤링 이슈","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 🛠 리팩토링\n\n프로토타입을 만들고, 프로토타입에 대한 리드미 작성까지는 끝났다. 하지만 급하게 진행하다 보니 아직 손봐야 할 곳이 많이 보였다. 주변에 피드백을 받아서 고쳐야 할 부분들을 수정하고 수정 과정을 담아보려 한다.\n\n## 🎃 느린 check 박스\n\ncheckbox 기능은 해당 공고의 자격 조건과 우대 사항에 얼마나 해당되는지 기록하고, 50%이상일 경우 합격 가능성이 높은 공고이므로 따로 표시하기 위해 추가한 기능이었다. 각 체크 상태를 반영하기 위해서 직접 데이터베이스에 업데이트가 될 수 있게 로직을 구성했다. 데이터베이스에 저장된 상태를 받고 react-query로 UI와 상태를 동기화 시키는 방식으로 짜서, 별도의 상태를 두지 않으려 노력했다. 하지만 주변의 피드백을 받았을 때 클릭하고 약 0.5초 뒤에 반응해서 답답함을 느꼈다는 의견이 있었다. 이를 해결 위한 과정을 정리해 보려 한다.\n\n우선 handleChange의 내부 로직이 같은 로직이 중복되는 문제가 있어 중복을 제거하려 했다. kind 자체를 key로 전달해서 해당하는 값에 맞는 배열을 수정하는 방식으로 변경했다. 하는 과정에 kind 타입 자체의 문제로 인해서 내부 곳곳에 수정을 했지만, 전반적으로 훨씬 깔끔해진 결과를 얻을 수 있었다.\n\n```tsx\n// 수정 전\n\nconst handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n  const { name } = e.currentTarget\n  let modifiedJob\n  if (job) {\n    if (kind === Kinds.qualification) {\n      const qualification = [...job?.qualification].map(item => {\n        if (item.text === name) {\n          return { ...item, checked: !item.checked }\n        }\n        return item\n      })\n      modifiedJob = { ...job, qualification }\n    } else {\n      const preferential = [...job?.preferential].map(item => {\n        if (item.text === name) {\n          return { ...item, checked: !item.checked }\n        }\n        return item\n      })\n      modifiedJob = { ...job, preferential }\n    }\n    mutate(calculateChecks(modifiedJob))\n  }\n}\n\n// 수정 후\nconst handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n  const { name } = e.currentTarget\n  if (job && !isMainJob) {\n    const targetList = [...job[kind]].map(item => {\n      if (item.text === name) {\n        return { ...item, checked: !item.checked }\n      }\n      return item\n    })\n    const modifiedJob = { ...job, [kind]: targetList }\n    mutate(calculateChecks(modifiedJob))\n  }\n}\n```\n\n다음으로는 메인 이슈였던 느린 체크박스 반응을 해결하기 위해서 UI를 위한 상태를 따로 놔둬서 UI 상태와 DB를 동시에 업데이트하는 방식으로 사용자가 느낄 수 있는 답답함을 해결할 수 있었다. 하지만 조금 더 나아가서, 이렇게 UI상태로 관리한다면 DB를 업데이트하는 횟수를 페이지를 떠날 때 해서 API 호출 비용을 줄이는 방향으로 개선하면 어떨까라는 추후 방향도 고민했다.\n\n```tsx\nexport default function DescriptionItem({\n  text,\n  isMainJob,\n  checked,\n  kind,\n}: DescriptionItemProps) {\n  const [isChecked, setIsChecked] = useState(checked)\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { name } = e.currentTarget\n    if (job && !isMainJob) {\n      const targetList = [...job[kind]].map(item => {\n        if (item.text === name) {\n          return { ...item, checked: !item.checked }\n        }\n        return item\n      })\n      const modifiedJob = { ...job, [kind]: targetList }\n      mutate(calculateChecks(modifiedJob))\n    }\n    setIsChecked(!isChecked)\n  }\n  return (\n    <S.Wrapper>\n      {isMainJob && <RiCheckboxBlankCircleFill />}\n      {!isMainJob && (\n        <input\n          type=\"checkbox\"\n          name={text}\n          checked={isChecked}\n          onChange={handleChange}\n        />\n      )}\n      <span>{text}</span>\n    </S.Wrapper>\n  )\n}\n```\n\n## Custom Hook\n\nreact-query를 이용해 전역 상태로 캐쉬된 서버데이터를 편하게 받아올 수 있지만, 데이터를 불러오기 위한 로직이 계속해서 반복되기 때문에 따로 custom hook으로 분리하는 게 어떨까라는 생각에 따로 모아두기로 했다. 불러오는 키를 상수로 정해서 안전하게 관리가 가능했고, 컴포넌트 내부 로직이 깔끔해져서 좋았다. 하지만 아쉬운 점은 hook은 hook내부에서만 정리할 수 있기 때문에 hook안에서 dbService나 useRouter와 같은 반복되는 로직은 어떻게 다시 정리할 수 있을까 고민도 되었다. 이후에 좀 더 리팩토링이 필요하다.\n\n```tsx\nconst JOBS_KEY = \"jobs\"\n\nexport const useGetJobs = () => {\n  const dbService = useDBService()\n  const { data: jobs, isLoading } = useQuery([JOBS_KEY], () =>\n    dbService.getJobs()\n  )\n  return { jobs, isLoading }\n}\n\nexport const useGetFilteredJobs = () => {\n  const { query } = useRouter()\n  const { id } = query\n  const dbService = useDBService()\n  const { data: jobs, isLoading } = useQuery(\n    [JOBS_KEY],\n    () => dbService.getJobs(),\n    {\n      select: (data: ModifiedJobsType) => {\n        return Object.values(data).filter(item => item.id !== id)\n      },\n    }\n  )\n  return { jobs, isLoading }\n}\n\n//binding이 강해서 좀더 연결성을 떨어뜨려야 재사용 가능\nexport const useCreateJob = (\n  setMessage: React.Dispatch<React.SetStateAction<string>>,\n  setUrl: React.Dispatch<React.SetStateAction<string>>\n) => {\n  const dbService = useDBService()\n  const queryClient = useQueryClient()\n  const { mutate, isLoading } = useMutation(\n    async (url: string) => {\n      const { data } = await axios.post(\n        `${process.env.NEXT_PUBLIC_HOST}/api/job`,\n        {\n          url,\n        }\n      )\n      const job = modifyJob(data)\n      dbService.addJob(job)\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries([JOBS_KEY])\n        setMessage(\"\")\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            setMessage(response.data.message)\n          }\n        }\n      },\n      onSettled: () => {\n        setUrl(\"\")\n      },\n    }\n  )\n  return { mutate, isLoading }\n}\n\nexport const useUpdateJob = () => {\n  const dbService = useDBService()\n  const queryClient = useQueryClient()\n  const { mutate } = useMutation(\n    async (job: ModifiedJobType) => {\n      return dbService.updateJob(job)\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries([\"jobs\"])\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            console.log(response)\n          }\n        }\n      },\n    }\n  )\n  return mutate\n}\n\nexport const useDeleteJob = () => {\n  const queryClient = useQueryClient()\n  const dbService = useDBService()\n  const { mutate } = useMutation(\n    async (job: ModifiedJobType) => {\n      return dbService.removeJob(job)\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries([\"jobs\"])\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            console.log(response)\n          }\n        }\n      },\n    }\n  )\n  return mutate\n}\n\nexport const useGetJobById = () => {\n  const { query } = useRouter()\n  const dbService = useDBService()\n  const { id } = query\n  const jobId = typeof id === \"string\" ? id : id?.join() || \"\"\n  const { data, isLoading } = useQuery(\n    [JOBS_KEY],\n    () => {\n      return dbService.getJobs()\n    },\n    {\n      select: (data: ModifiedJobsType) => {\n        return data[jobId]\n      },\n    }\n  )\n  return { data, isLoading }\n}\n```\n\n# 😥 크롤링의 문제\n\n이전에 크롤링에 대해 조사하면서 저작권의 문제가 생길 수 있다는 것을 인지하고는 있었다. 웹에 존재하는 정보를 받아오고 그것을 정제하는 방법이지만 데이터가 재산인 기업들의 입장에서는 예민하고 중요한 문제임은 분명했다. 이번에 원티드에서 채용공고들을 보면서 채용공고 아래 다음과 같은 문구가 적혀있는 것을 확인했다.\n\n![원티드](./원티드.png)\n시작 전에도 학습 용도로 만들려는 서비스였기에 크게 문제가 되지 않을 것이라 생각하고 제작했지만, 먼저 확인이 필요할 것 같아 원티드 측에 직접 문의해보았다. 문의 결과는 크롤링 자체를 금지하고 있다는 답변을 받을 수 있었다.\n\n![원티드 답변](./문의결과.png)\n실제로 크롤링은 저작권 문제로 많은 법적 공방이 진행 중이다. 채용공고 플랫폼 사이에서 법적 공방도 있었다는 것을 찾아보면서, 어떤 방향으로 수정하면 좋을까 라는 고민이 되었다.\n\n[[실제 법적 공방에 대한 ZDNET Korea 뉴스기사](https://zdnet.co.kr/view/?no=20170927180839)]\n![법적 공방](./법적공방.png)\n\n지금까지 해왔던 방식의 기본은 크롤링을 이용해 데이터를 자동화해서 정리하는 방식이었다. 작업을 계속하면서 자동화라는 방식이 좋기는 하지만 크롤링 자체를 정확하게 하는 방법의 한계를 느끼기도 했고, **플랫폼에 없는 회사들도 정리할 수 있게** 하고 싶기도 했다.\n\n이번 계기로 다른 방향으로 서비스를 수정해야 했고, 보다 사용자가 쉽게 정리할 수 있는 방법이 어떤 게 있을까 라는 고민과 채용 플랫폼 시장에 대한 조사가 부족했다는 것도 느꼈다. 프로젝트를 어떻게 수정할 지 앞으로 어떻게 발전시켜나갈지 좀 더 고민해서 수정이 필요하다.\n"},{"excerpt":"💎 제너레이터와 Async-Await EO 채널의 시니어 개발자분들의 이력서 관련 팁을 말씀해 주시는 영상을 본 적이 있다. 그때 한 시니어 개발자분께서 \"skill란에 자바스크립트를 잘한다고 하면서 제너레이터를 물어보면 제대로 설명 못하는 사람을 있다\"라고 말씀하셨다. 그 말씀에 \"제너레이터? 이터러블 객체를 편하게 만들 수 있는 것 아닌가\"라고 나는 …","fields":{"slug":"/2022-12-02-제너레이터와-async-await/"},"frontmatter":{"date":"December 02, 2022","title":"제너레이터와 Async-Await","tags":["javascript","문법"]},"rawMarkdownBody":"\n# 💎 제너레이터와 Async-Await\n\nEO 채널의 시니어 개발자분들의 이력서 관련 팁을 말씀해 주시는 영상을 본 적이 있다. 그때 한 시니어 개발자분께서 \"skill란에 자바스크립트를 잘한다고 하면서 제너레이터를 물어보면 제대로 설명 못하는 사람을 있다\"라고 말씀하셨다. 그 말씀에 \"제너레이터? 이터러블 객체를 편하게 만들 수 있는 것 아닌가\"라고 나는 알고 있다고 생각했다. 하지만 공부하면서 왜 제너레이터가 중요한 지, 어떻게 쓰이고 있는지를 보니 나는 제너레이터를 몰랐다는 사실을 깨달을 수 있었다.\n\n이제는 제대로 이해하고 설명할 수 있게 제너레이터와 제너레이터가 어떻게 활용되고 있는지 정리해 보고자 한다.\n\n## 🎈 제너레이터\n\n제너레이터는 \"이터러블 객체\"를 만든다. 그러면 이터러블 객체는 무엇인지 먼저 정리해 보고자 한다.\n\n### 이터러블 객체\n\n이터러블 객체 (iterable object)는 이전에 iteration에 대해 공부하면서 정리한 적이 있지만, 아직 완전히 받아 들여지지 않아 다시 한 번 정리 해보려 한다.\n\n이터러블 객체는 이터러블 프로토콜과 이터레이터 프로토콜 두 가지를 만족해야 한다.\n\n<img src=\"https://poiemaweb.com/img/iteration-protocol.png\" width=\"800px\"/>\n\n먼저 이터러블 프로토콜은 위 그림의 왼쪽의 조건으로 객체 내의 [Symbol.iterator]를 키로 한 메소드가 존재하는 것을 의미한다. 이때 [Symbol.iterator] 메소드의 반환값이 next를 메소드를 가지는 객체여야하는데 이것을 이터레이터 프로토콜이라고 부른다. next메소드는 순회하며 value,done 속성을 갖는 객체를 반환한다.\n\n이렇게 두 가지 조건을 만족한 이터러블 객체는 for-of로 순회가 가능한 특징을 가지며, 대표적인 예로 배열이 있다.\n\n```javascript\nconst fibonacci = {\n  [Symbol.iterator]() {\n    let [pre, cur] = [0, 1]\n    const max = 10\n    return {\n      next() {\n        ;[pre, cur] = [cur, pre + cur]\n        return { value: cur, done: cur >= max }\n      },\n    }\n  },\n}\n\nfor (const num of fibonacci) {\n  console.log(num)\n}\n```\n\n### 이터러블 객체와 제너레이터\n\n위의 언급한 대로 제너레이터는 이터러블 객체를 만들 수 있다. 제너레이터는 선언시, function\\* 로 시작하고 yield 문을 하나 이상 포함한다. yield는 제너레이터로 만들어진 이터러블 객체의 next 메소드의 호출에 따라 **함수 내부의 실행을 중지하거나 반환한다**. 여기서 중요한 점은 제너레이터로 함수 내부 실행을 제어할 수 있다는 점이다.\n\n앞서 만들었던 이터러블 객체 fibonacci를 제너레이터로 다시 만들면 다음과 같다.\n\n```javascript\nconst fibonacciGen = (function* () {\n  let [pre, cur] = [0, 1]\n  const max = 10\n  while (pre + cur <= max) {\n    ;[pre, cur] = [cur, pre + cur]\n    yield cur\n  }\n})()\n\nfor (const num of fibonacciGen) {\n  console.log(num)\n}\n```\n\n이제 제너레이터가 \"어떻게 함수 내부 실행을 제어하는지\" 두 가지 예제로 알아보자. 첫 번째 예제 코드를 보면 generator는 제너레이터로 만든 이터러블 객체를 반환 받는다. next 메소드를 이용하면 value,done을 key로 하는 객체가 반환되는데, 여기서 중요한 점은 next가 호출될 때마다 \"yield문까지 진행되고 멈춘다는 점\"이다. yield문이 더 이상 없을 때는 value로 undefined, done은 true로 반환해 준다.\n\n```javascript\nfunction* genFunc() {\n  try {\n    yield 1\n    yield 2\n    yield 3\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nconst generator = genFunc()\nconsole.log(generator.next()) // { value: 1, done: false }\nconsole.log(generator.next()) // { value: 2, done: false }\nconsole.log(generator.next()) // { value: 3, done: false }\nconsole.log(generator.next()) // { value: undefined, done: true }\n```\n\n두번째 예제는 yield를 이용해 값을 할당한 예제다. 실행 과정을 정리하면 다음과 같다.\n\n1. res 첫 번째 호출: yield 1까지 실행하고 진행을 멈춘다. `{ value:1, done:false }`를 반환한다.\n2. res 두 번째 호출: next(10)으로 전달 받은 10을 x에 할당하고, x+10까지 실행하고 멈춘다. `{ value: 20, done: false }`를 반환한다.\n3. res 세 번째 호출: next(20)으로 전달 받은 20을 y에 할당하고, `{ value: 30, done: true }`를 반환한다.\n\n```javascript\nfunction* genFunc() {\n  const x = yield 1\n  console.log(\"x\", x) // x 10\n  const y = yield x + 10\n  console.log(\"y\", y) // y 20\n  return x + y\n}\n\nconst generator = genFunc(0)\n\nlet res = generator.next()\nconsole.log(res) // { value: 1, done: false }\nres = generator.next(10)\nconsole.log(res) // { value: 20, done: false }\nres = generator.next(20)\nconsole.log(res) // { value: 30, done: true }\nconsole.log(generator.next()) // { value: undefined, done: true }\n```\n\n제너레이터가 어떻게 함수 내부 실행을 제어하는지에 대해 알아봤다. 그러면 제너레이터를 <u>어디에</u> 사용해야 할까?\n\n## 🧨 제너레이터의 활용: Async-Await\n\n제너레이터는 사실 이미 많이 사용되고 있었다. 바로 async- await 구문이다. async-await은 먼저 정리했던 프로미스를 동기적으로 코드를 작성할 수 있게 해주고 반환할 때는 프로미스로 반환해주는 기능을 가진다. 이렇게 가능했던 것은 async-await이 내부적으로 **제너레이터를 이용해 구현되어** 있었기 때문이다.\n\n아래는 간단한 async-await을 구현한 코드이다. 제너레이터가 가지는 특징, next와 yield로 함수 호출자와 함수의 상태를 알 수 있는 점을 이용했다. 함수 동작을 간단하게 정리하면 다음과 같다.\n\n1. async함수는 전달 받은 generator함수로 이터러블 객체를 등록한 후에, generator의 next의 값을 반환하는 클로저 함수 onResolved를 반환한다.\n2. 즉시 실행 함수로, 반환된 onResolved를 실행하고, 첫번째 yield문의 fetch(url)을 진행해 result로 결과를 반환받는다.\n3. 아직 fetchTodo함수의 끝까지 진행되지 않아 result의 done이 false이므로 다시 onResolved를 실행한다.\n4. 두 번째 onResolved실행으로 fetchTodo의 response값을 할당하고, 두 번째 yield문의 response.json()을 진행해 result로 결과를 반환받는다.\n5. 아직 fetchTodo함수의 끝까지 진행되지 않아 result의 done이 false이므로 다시 onResolved를 실행한다.\n6. 세 번째 onResolved실행으로 fetchTodo의 todo값을 할당하고 console에 호출한 뒤에 result로 결과를 반환받는다.\n7. fetchTodo가 끝났기 때문에 result.done은 true가되어 undefined를 반환하며 종료한다.\n\n```javascript\nconst async = generatorFunc => {\n  const generator = generatorFunc()\n  const onResolved = arg => {\n    const result = generator.next(arg)\n    return result.done\n      ? result.value\n      : result.value.then(res => onResolved(res))\n  }\n  return onResolved\n}\n\nasync(function* fetchTodo() {\n  const url = \"https://jsonplaceholder.typicode.com/todos/1\"\n  const response = yield fetch(url)\n  const todo = yield response.json()\n  console.log(todo)\n})()\n```\n\n### Async- Await\n\nasync,await은 위의 예제보다 훨씬 가독성이 좋게 이용될 수 있게 추가된 문법으로 비동기 로직을 동기적으로 작성이 가능하게 도와준다. 주의할 점은 **항상 반환값은 Promise**라는 점이다. Typescript로 작업하면서 async-await을 이용하면 동기적으로 작성하다 보니 잘못 타입을 전달해 준 경우가 있었다. async- await의 장점은 promise chaining에서 then,catch,finally로 연결하다 보면 callback hell처럼 가독성이 떨어지게 될 수 있을 때, 가독성을 높여줘 실행 순서를 예측할 수 있는 장점을 가지게 된다. 또 다른 장점으로 동기적 코드처럼 try-catch구문으로 에러핸들링이 가능하다.\n\n위의 예제를 실제 async-await으로 고쳐보면 다음과 같다. 훨씬 간단하게 구현된 것을 알 수 있다.\n\n```javascript\nasync function fetchTodo() {\n  const url = \"https://jsonplaceholder.typicode.com/todos/1\"\n  const response = await fetch(url)\n  const todo = await response.json()\n  console.log(todo)\n}\n```\n\nawait은 promise가 settled된 상태(성공,실패와 상관없이 처리가 끝난 상태)가 됐을 때 resolve한 결과를 반환한다. 그렇기 때문에 연관되지 않은 여러 promise를 사용해야 할 때 모두 await을 붙여서 사용하면 시간이 오래걸리는 단점을 갖는다. 앞서 정리한 Promise.all을 이용해 병렬 처리로 한번만 await 사용해 해결가능하다.\n\n```javascript\n//수정 전\nasync function foo() {\n  const a = await new Promise(resolve => setTimeout(() => resolve(1), 3000))\n  const b = await new Promise(resolve => setTimeout(() => resolve(2), 2000))\n  const c = await new Promise(resolve => setTimeout(() => resolve(3), 1000))\n  console.log([a, b, c])\n}\n\nfoo() // 6초 뒤 [1,2,3]\n\nasync function foo() {\n  const res = await Promise.all([\n    new Promise(resolve => setTimeout(() => resolve(1), 3000)),\n    new Promise(resolve => setTimeout(() => resolve(2), 2000)),\n    new Promise(resolve => setTimeout(() => resolve(3), 1000)),\n  ])\n  console.log(res)\n}\n\nfoo() // 3초 뒤 [1,2,3]\n```\n\n[참고]\n\n[모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n[제너레이터와 async/await](https://poiemaweb.com/es6-generator)\n"},{"excerpt":"🙋‍♂️ 지스트 청원서비스 지스트 청원서비스는 8명으로 이루어진 Better IT팀이 2021년 7월에 팀빌딩을 시작해 2022년 3월 14일에 런칭, 현재는 학교에서 운영되고 있는 프로젝트다. 나는 2021년 11월부터 참여해 4월까지 참여했고, 코딩 공부를 시작하고 처음으로 참여한 팀 프로젝트였다. 그때 배웠던 많은 것들이 토대가 되어, 혼자 프로젝트를 할…","fields":{"slug":"/2022-11-30-지스트-청원-서비스-회고/"},"frontmatter":{"date":"November 30, 2022","title":"지스트 청원서비스 회고","tags":["회고","사이드프로젝트"]},"rawMarkdownBody":"\n# 🙋‍♂️ 지스트 청원서비스\n\n지스트 청원서비스는 8명으로 이루어진 Better IT팀이 2021년 7월에 팀빌딩을 시작해 2022년 3월 14일에 런칭, 현재는 학교에서 운영되고 있는 프로젝트다. 나는 2021년 11월부터 참여해 4월까지 참여했고, 코딩 공부를 시작하고 처음으로 참여한 팀 프로젝트였다. 그때 배웠던 많은 것들이 토대가 되어, 혼자 프로젝트를 할 때, 프리온보딩 코스에 참여하면서도 적용해 나갔다. 개발 공부를 하면서 중요한 전환점이 되었던 지스트 청원서비스를 회고해보려 한다.\n\n## 🙄 같이 해도 괜찮을까..?\n\n내가 참여하기 전 Better IT 팀은 원래 7명 이었다. 팀은 학교 알고리즘 공부를 위한 동아리에서 시작되어, 컴퓨터 공학 전공생 7명이 함께해 있었다. 운이 좋았던 나는, 그 당시에는 몰랐지만 그중에 친한 친구 2명이 참여하고 있었고, 룸메이트였던 친구에게 개발 공부를 시작하면서 '어떻게 공부하면 좋을지 모르겠다'는 이런저런 고민을 얘기하다가 '그러면 내가 이런 걸 하고 있는데 같이 하는 건 어때' 라고 먼저 제안해주었다. 혼자 공부하면서 투두리스트 페이지를 만들고 '나는 개발자가 될 거야' 하던 한참 부족한 시절의 나였지만, 고마운 친구들은 나에게 먼저 같이 해보자는 제안을 해주었다.\n\n제안을 받고 내가 짐이 되지는 않을까 고민도 많이 되었다. 팀의 목표가 확실해 보였고, 나는 아직 부족하다는 생각이 너무 많아 더 자신감이 없었다. 친구가 그래도 팀으로 해보는 경험이 중요하다고 설득해줘서 **도전**해 보기로 마음 먹었다. 그렇게 Better IT팀의 프론트엔드 개발자로 참여하게 되었다.\n\n## 🚩 학교야, 우리 얘기 좀 들어줘\n\n당시 우리 팀이 정의한 문제는 <u>학교와 학생의 소통 부재</u>였다. 당시에 대학원에는 학생회가 활발히 활동하고 있었던 것에 반해, 대학교의 학생회는 없는 상태여서 학교에 대학생들의 의견을 건의할 방법이 없었고, 그로 인해 학생들의 불만은 에브리타임과 같은 곳에 올라오고 있는 상황이었다. 에브리타임에 올라온 의견들 중에 개인적인 일들도 있지만 많은 사람들의 동의를 받고, 공감 가는 건의사항들이 많았기 때문에 이런 **학생들 공공의 문제들을 직접 학교에 전달할 수 있는 방법이 없을까**하는 고민에서 시작했다.\n\n학교에 학생들의 문제를 전달하는 방법이 어떤 것이 있을지 고민했고, 당시 청와대의 국민 청원 페이지가 있어 사람들의 많은 공감과 동의를 받고 있었고, 우리도 **학교 내의 청원 페이지를 만들어 보는 게 어떨까**라는 생각으로 이어졌다. 당시 아직 학교가 우리의 서비스를 이용할 지 정해지지 않은 상태였지만 학교와 학생들 사이의 소통 창구가 될 수 있기를 바라는 마음으로, 그렇게 지스트 청원서비스가 시작되었다.\n\n<img src=\"image-20221130154414471.png\" width=\"800px\"/>\n\n## 🎨 서비스의 얼굴, 디자인의 시작\n\n문제 정의와 문제 해결 방식에 대해 팀이 동기화가 되고 나서 프론트엔드 개발자로써 가장 처음 참여한 일은, 다같이 디자인을 구상하고 계획하는 일이었다. 당시 프론트엔드 팀에서 Figma를 이용해서 디자인한 후에 화면으로 옮기기로 해, 먼저 Figma로 디자인을 했다. 내가 참여한 시점에서는 홈페이지와 청원페이지의 디자인이 끝난 상태였고, 회원가입과 로그인 페이지부터 디자인에 참여했다. 4명의 팀원들이 모두 모여서 기획하고 어떤 디자인이 더 적절할 지, 청와대 국민 청원, 국회의 국민 청원, 그리고 학교의 홈페이지를 참고해 서비스의 디자인을 입혀갔다. 디자인을 하면서 어떤 게 더 좋을지 너무 고민될 때는 옆에서 회의하고 있는 백엔드 팀의 의견을 구하기도 하면서, 팀원들 모두가 동의한 디자인을 만들어 갔다.\n\n[ Figma에 함께 디자인한 청원 서비스 페이지 ]\n\n<img src=\"image-20221130155536454.png\" width=\"800px\"/>\n\n## 👓 디자인했으니 이제 만들자, 페이지 스타일링\n\n구체적인 디자인을 만든 이후에 실제로 서비스에 반영하는 일은 생각보다 어려운 일이었다. 팀 내 스타일링 라이브러리로 styled-components와 chakra-ui를 이용하기로 정해, 처음으로 CSS-IN-JS를 공부하고 사용해보았다. 자바스크립트에서 css를 하다니 너무 신기하면서도, css module을 이용해 스타일링하던 나에게는 너무 어려워 며칠을 고생하기도 했다. 그래도 역시 시간이 흐르니 익숙해지면서, 컴포넌트 내에 존재하는 style 코드들 때문에 코드 양이 많아져 로직을 구분하기 어려우니 style.ts로 따로 분리하는 건 어떨까 제안하기도 하고, 내부적으로 공용으로 사용되는 css속성들을 전역변수로 바꾸고 고정 px단위로 되어있는 스타일 코드들을 rem과 em으로 바꾸는 작업을 제안해서 수정하기도 했다.\n\n[issue로 등록하고 작업해서 올린 PR]\n\n<img src=\"image-20221130163000959.png\" width=\"800px\"/>\n\n## 🔑 내가 담당한 회원가입/ 회원정보 변경 페이지\n\n스타일링에 대해 먼저 공부한 이후에 내가 담당한 페이지는 회원가입, 로그인, 비밀번호 변경 페이지였다. 처음으로 백엔드 팀에서 만들어 준 swagger API문서를 보면서 사용하는 게 쉽지 않았지만, 조금씩 익숙해지면서 API를 연결하는데 큰 문제는 없었다. 아래에서 각각의 페이지마다 가졌던 인증 로직들을 정리해 보고자 한다.\n\n### 회원가입와 비밀번호 변경 페이지\n\n청원 서비스는 학교 구성원을 타겟으로 하기 때문에 학교 내부 구성원임을 인증할 수 있는 방법이 필요했고, 그 방법으로 \"학교 자체 이메일\"을 이용해서 인증하는 방식을 선택했다. 우선 개인정보를 보관해야 하기 때문에 해당 약관을 동의를 받고 회원가입을 진행할 수 있게 했다. 약관부분에 어떤 내용을 담아야 할지는 개인정보와 관련되어 있다 보니 조심스러워 국민청원이나 다른 서비스들의 약관들을 참고해서 작성했다. 이용약관에 동의하고 나면 지스트 이메일을 입력 받고, 입력 받은 이메일로 인증 메일을 보낸다. 보낸 인증메일를 이용해 인증하면 이후에 개인정보를 입력해 회원가입이 성공하는 workflow를 가지고 있다.\n\n[회원가입 성공 과정]\n\n<img src=\"회원가입형식.png\" width=\"800px\"/>\n\n작업하면서 중요했던 건 각 과정 사이 사이에 필요한 \"예외 처리\"를 어떻게 할 지였다. 과정마다 발생할 수 있는 에러에 따라서 다음 스텝을 어떻게 가져가야 할 지 백엔드팀과 회의를 하면서 발생할 수 있는 에러 내용들을 모두 대응할 수 있게 처리했다.\n\n<img src=\"예외처리.png\" width=\"800px\"/>\n\n만약 혼자서 프로젝트를 했다면 이메일 인증 코드 유효시간이 만료된 이후에 인증 코드를 입력할 때나, 이메일 인증 코드를 입력하고 나서 회원가입을 하지 않고 시간이 흘러 인증 코드 유효 시간을 넘겼을 때와 같은 세부적인 내용들은 놓칠 수 있었을 것 같다. 함께 작업을 해서 더 디테일하게 발생할 수 있는 예외상황들을 처리할 수 있었다.\n\n작업의 편의성을 위해 백엔드 팀에게 부탁해 인증 코드의 유효시간을 1분으로, 인증코드 입력 이후의 유효시간을 5분으로 설정해서 진행했고, 계속해서 새로운 계정을 만들 수 없는 상황이었기에 만든 계정을 삭제할 수 있는 개발 전용 api도 부탁해서 협업하는 과정이 있었다.\n\n회원가입 하나의 페이지이지만 PR을 통해 작업에 대한 프론트 팀의 리뷰를 받고, 백엔드팀과 회의로 API를 결정하고 협업하는 과정은 팀으로써 동료로써 일하는 법을 배우는 좋은 경험이 되었다.\n\n### 비밀번호 찾기\n\n회원가입 페이지를 만들고 나서, 만든 페이지는 비밀번호 변경 페이지로 거의 동일한 예외처리와 UI 가지기 때문에 간단하게 제작할 수 있었다.\n\n[비밀번호 찾기 성공 과정]\n\n<img src=\"비밀번호찾기-1669802715041-12.png\" width=\"1000px\"/>\n\n### 회원정보변경\n\n회원가입과 비밀번호 찾기 페이지를 만든 이후에 담당한 페이지는 회원정보 변경 페이지로 회원정보 변경에는 회원탈퇴와 비밀번호 변경 기능을 담고 있었다. 만든 후에 회원 탈퇴 기능이 꼭 필요한 지에 대한 팀 회의를 거쳐 회원탈퇴 기능은 빼기로 결정되었지만, 회원가입을 하면서 연결했던 계정 삭제 API를 이용해 간단하게 회원탈퇴 페이지를 만들었다.\n\n[개발 버전의 회원정보변경 페이지와 회원탈퇴 성공 과정]\n\n<img src=\"회원탈퇴.png\" width=\"1200px\" height=\"300px\"/>\n\n비밀번호 변경 페이지는 간단하게 현재 비밀번호와 바꿀 비밀번호를 입력해서 재설정이 가능할 수 있게 백엔드팀과 회의로 정했다. 로그인 시에 받아오는 쿠키에 현재 로그인한 사용자의 세션 키가 담겨 있어서 다른 사용자 정보를 기입하지 않아도 비밀번호만을 이용해 재 설정이 가능하게 했다. 사용자의 입장을 더 고민해서 작업한 부분이라 더 의미 있는 경험이었다.\n\n[배포 버전의 회원정보변경 페이지와 비밀번호 변경 성공 과정]\n\n<img src=\"비밀번호 변경-1669803371912-15.png\" width=\"1000px\"/>\n\n## 📣 드디어 출시, 그리고 이후 작업\n\n출시 전에 우리 팀은 대학원 학생회와 학교 측 담당 선생님들과 계속해서 미팅을 가지고, 우리가 만든 개발 버전의 페이지를 보여드리면서 학교 측의 지원을 약속을 받을 수 있었다. 미팅을 계속 가지면서 실제로 사용될 때를 고려한 피드백을 받아 사전 청원의 기준 (동의 수 5개)과 정식 청원의 기준(동의 수 50개)을 조율하는 등 서비스에 중요한 원칙들을 조정해나갔다. 그렇게 기다리던 목표로 3월 14일에 테스트 버전을 런칭하고 학교 곳곳에 직접 홍보를 위해 포스터를 붙이는 등 홍보 활동을 함께 하고, 학교에서도 적극적으로 홍보에 참여해 주셨다.\n\n[홍보 포스터(좌)와 학교소통마당페이지에 추가된 우리 서비스(우)]\n\n<img src=\"image-20221130224922564.png\" width=\"800px\"/>\n\n팀 내에서 홍보를 위한 한가지 아이디어로, 국민 청원처럼 학교의 대표이신 총장님께서 직접 영상을 통해 약속을 해주시는 것이 어떤지에 대한 의견이 나왔다. 영상을 통해 직접 답변을 해주신다면 우리 서비스에 대한 학교 측의 공식적인 지원을 드러내게 되면서 홍보 효과와 공신력을 가질 수 있겠다는 기대를 가질 수 있었다. 총장님과 미팅을 진행했고, 흔쾌히 참여해주시겠다는 답변을 받을 수 있었다.\n\n기존의 답변된 청원 페이지에는 영상을 보여주기 보다는 학교 측에 제공할 관리자 페이지에서 답변 내용만 작성하려 했기 때문에 새롭게 영상을 담을 수 있는 방법이 필요했다. 그때 유튜브로 영상을 받아오고 보여 주는 프로젝트를 했던 경험이 있어, 유튜브로 학교에서 영상을 찍어서 올려주면 영상 컴포넌트를 추가해서 답변의 가장 위에 담으면 될 것 같다고 내가 의견을 제시해, 관리자 페이지를 맡은 팀원과 같이 전담해서 진행했다. 진행하면서 관리자 페이지에서 어떻게 url을 전달해서 받아올 지 등을 같이 회의했고, embed형식의 youtube url을 받아와, 우리 팀의 가장 첫 번째 응답을 영상으로 보여 줄 수 있었다.\n\n[첫번째 청원에 대한 총장님의 답변을 담은 페이지]\n\n   <img src=\"image-20221130225807786.png\" width=\"800px\"/>\n\n이후에도 학교 측과 회의를 하면서 이미 학교 내 담당 부서가 있어서, 청원보다 학교 내 관련 부서와 연락하는 게 더 빠른 해결 방안이 될 수 있는 경우에는 \"반려된 청원\"으로 새로 분류하면 좋겠다는 의견이 있었다. 기존의 정식 청원의 분류는 진행 중인 청원/만료된 청원 두 가지로 하고 있었는데 반려된 청원을 추가하기 위해 담당해서 작업했다. 기존의 진행중인 청원과 만료된 청원의 디자인이 있었기 때문에 크게 어렵지 않게 확장할 수 있었다.\n\n[지스트 청원의 반려된 청원페이지]\n\n<img src=\"image-20221130230835496.png\" width=\"800px\"/>\n\n처음 홍보했을 때는 가입자 수가 50명도 되지 않아서 걱정하고 있었지만, 갑자기 회원 수가 늘어 현재는 304명의 회원수, 27개의 정식 청원 중 7개의 답변된 청원과 594개의 총 동의 수를 갖는 학교의 서비스로 계속해서 사용되고 있다.\n\n## 📔 마치며\n\n처음 팀에 들어갈 때는 자바스크립트만 조금 알고 시작한 정도여서, 프로젝트를 위해서 리액트, 리덕스, 타입스크립트 등을 실전으로 부딪히면서 배웠다. 새로운 것을 배우는 게 어렵고 힘들기도 했고, git을 어떻게 써야 하는지 등 모든 게 다 처음이라 어려웠다. 하지만 너무 좋은 팀을 만나서, 모르면 물어볼 수 있었고 어려운 부분을 직접 이끌어주고 페어 프로그래밍도 하면서 한 명의 팀원으로 성장해서, 나중에 내 의견도 제시할 수 있었다.\n\n[처음 typescript를 쓰면서 너무 답답해서 쓴 any....]\n\n<img src=\"image-20221130232114278.png\" width=\"800px\"/>\n\n이때 배운 좋은 코드 컨벤션, git을 다루는 법 등의 경험이 이후에 프리온보딩 코스를 하면서, 프로젝트를 좀 더 적극적으로 참여하고, 이제는 팀원들을 오히려 도와줄 수도 있는 사람으로 성장할 수 있었다.\n"},{"excerpt":"✨ vercel로 간단하게 배포... 라고 할 뻔 누가 그랬다... next js는 vercel에서 만들었으니까 vercel을 이용하면 배포가 뚝딱이라고. 나의 경우에는 그게 안되었다.. 어제 28일 오후 8시부터 새벽 5시까지의 사투를 작성해보려 한다. Vercel 무료이고, CI/CD가 자동화되었고, next js를 만든 회사이기 때문에 연동이 잘될 …","fields":{"slug":"/2022-11-30-모으잡-배포/"},"frontmatter":{"date":"November 30, 2022","title":"모으잡-vercel부터 aws까지 배포과정","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n## ✨ vercel로 간단하게 배포... 라고 할 뻔\n\n누가 그랬다... next js는 vercel에서 만들었으니까 vercel을 이용하면 배포가 뚝딱이라고. 나의 경우에는 그게 안되었다.. 어제 28일 오후 8시부터 새벽 5시까지의 사투를 작성해보려 한다.\n\n### Vercel\n\n무료이고, CI/CD가 자동화되었고, next js를 만든 회사이기 때문에 연동이 잘될 것 같다는 기대감으로 가장 먼저 시도했다. 처음에는 문제없이 동작하는 듯 했다. 하지만 api 서버를 수정하고 다시 배포하려고 재배포를 했을 때, 이상한 에러를 만나게 되었다..\n\n[serverless function error]\n![serverless function error](./serverless-error.png)\n\n\"serverless function\"이라는 난생 처음 보는 단어부터 만나고 찾아보니, 내가 추가한 크롤링 프로그램의 api 함수의 용량이 50MB를 넘기 때문에 배포 에러가 난 것이었다. api/job.ts 자체는 크게 용량을 차지할 부분이 없지만 크롤링 프로그램에서 하는 게 많아서 문제가 되었나 라는 생각으로 puppeteer vercel을 검색한 결과, 나와 똑같은 문제를 겪고 있는 사람들을 vercel/issues에서 찾을 수 있었다.\n\n[링크: https://github.com/vercel/community/discussions/124]\n\n![vercel issue](./vercel-issue.png)\n20개의 discussion을 다 읽고 제시한 방법들을 다 시도했다. node를 14버전으로 낮추고 패키지들을 조정하는 방법, 아예 다른 크롤링 프로그램을 쓰는 방법 등을 해보았지만 node 14로 낮출경우 styled-components와 의존성 문제가 발생했고, 크롤링 프로그램을 바꿔도 여전히 에러가 있었다.\n\n지금으로써는 vercel로는 방법이 더 이상 없겠다는 생각에 다른 배포 방법을 찾아 나섰다.\n\n### Netlify\n\nvercel과 같이 무료로 배포가 가능한 netlify를 찾아보고, 가장 먼저 serverless function을 확인했더니... vercel과 동일하게 50MB 제한을 두고 있었다.\n배포해봤자 동일한 에러로 배포가 되지 않을 것을 알게 되고 결국 찾은 곳은 AWS의 ec2였다.\n\n[netlify issue]\n![netlify issue](./netlify.png)\n\n### AWS EC2\n\nEC2는 클라우드 컴퓨팅 서비스를 공부하면서 컴퓨터 한대를 빌리는 것과 같다는 것을 알고 있었다. 컴퓨터를 커스텀할 수 있다는 장점이 있지만, 나에게는 장점이 아닌 두려움이었다. 보안이나 AWS 설정들을 잘못해두거나 사용 중에 잘못해서 과금이 되는 경우들도 찾아보다 보니 어려워 보였다.\n\n하지만 프로젝트를 그냥 로컬에서 \"헤헤 잘돌아간다\" 하고 사람들에게 보여줄 수 없다면 무슨 의미겠나 라는 생각으로 간절하게 AWS EC2로 배포를 시작했다. 다행히 자세히 설명해놓으신 블로그를 발견해서 따라했다. 고마워요... (https://iborymagic.tistory.com/103)\n\n실제 컴퓨터를 설정하는 것이기 때문에 OS부터 설정해야 했다. Ubuntu 18.04를 선택하고 t2.micro로 인스턴스를 선택했다. 키페어는 pem을 이용해 ssh로 접속이 가능하게 설정했다. 그리고 내 로컬 폴더의 root에 .pem 파일을 추가한 후에 예로 되어있는 부분을 이용해 접속할 수 있었다.\n\n[참고 블로그의 예시]\n\n<img src=\"https://blog.kakaocdn.net/dn/oQQ9A/btrg3qH1dZC/7hoFcpqi69UBR9LGRqhk2K/img.png\"/>\n\n여기까지 괜찮다고 생각했지만 어려움은 Linux를 이용한 실행 과정에 시작되었다. 예시 블로그에서는 내부 설정 과정이 삭제되어있지만 EC2에 접속한 후에 설치할 패키지들이 있다. 그때 처음 써보는 Linux 명령어들에 멘붕이 오기도 했지만... 역시 좋은 분들이 써놓은 블로그의 도움으로 해결했다.\n\n가장 먼저 해야 할 일은 node js, npm, yarn을 설치하는 일이었다. 여기서 어려웠던 것은 분명 블로그에`sudo apt-get install <패키지>` 를 이용하면 된다고 되어 있는데 내가 사용하는 환경에서는 되지 않았다. 그 이유는 linux 배포판에서 apt-get을 지원하지 않아서 생긴 에러였고, 대신 apt-get 대신 `sudo yum install <package이름>`를 이용하면 되었다. 진행 중에 그냥 `yum install <package이름>`으로 해보았지만, 권한 문제가 생겨 실행되지 않는 것을 보고, `sudo`가 관리자 권한으로 실행하는 것을 새로 알게 되었다.\n\n이렇게 나름 명령어에 익숙해지고 난 후에 드디어 npm과 node, yarn을 성공적으로 설치할 수 있었다. 이렇게 친숙한 패키지들을 설치하고 나니 수월하게 git clone으로 레포를 가져와 실행할 수 있었다. 레포를 가져온 후에 환경변수를 설정하기 위해 `vim.env`로 들어가 직접 써서 추가한 후에 yarn build와 yarn start를 진행해서 드디어 페이지에 접속할 수 있었다.\n\n페이지에 접속하고 나서 여러 기능을 체크하는 와중에 크롤링을 이용해 새로운 공고를 받아오는 기능을 체크하다가 `Error: Failed to launch the browser process!` 에러를 발견하게 되었다. puppeteer 에러라는 것을 확인하고 관련 puppeteer의 troubleShooting부분을 보았다. 페이지에서는 노드 14 버전에서 실행 시 생길 수 있는 문제라고 했지만, ec2에 설치한 노드 버전은 16이기 때문에 해당되지 않았다. 그럼 문제가 뭔지 고민 끝에 `puppeteer의 동작 방식이 로컬의 chrome을 이용한다`는 것을 생각해냈다. 그렇기 때문에 chrome과 관련된 패키지가 깔려있지 않을 경우 에러가 발생할 수도 있을 것 같아, 관련 패키지들을 찾아 설치했다.\n\n(참고한 Ubuntu에 chrome 설치하는 방법 https://frugalisminds.com/how-to-setup-puppeteer-in-centos-7/)\n\n다행히 예측한 원인이 맞아서 정상 작동되는 것을 확인했다.\n\n![정상배포](./정상배포.png)\n이후에 ec2 접속을 종료해도 계속해서 서버가 동작할 수 있게, 무중단 배포를 적용했다. pm2를 이용해 무중단 배포를 실행해 배포를 완료할 수 있었다.\n"},{"excerpt":"📁DB연결 개인 별 채용공고들의 정보를 저장하기 위해서 Firebase의 realtime database를 추가해 연결했다. firebaseApp은 이미 인증/인가 기능을 추가하면서 만들어 두었기 때문에 DBService의 interface를 이용한 class를 추가해 구현했고, 해당 api를 이용할 때는 react-query를 이용했다. DB는 이전 채…","fields":{"slug":"/2022-11-29-모으잡 DB연결과-크롤링-기능-연결/"},"frontmatter":{"date":"November 29, 2022","title":"모으잡-DB연결과 크롤링 기능 연결","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n## 📁DB연결\n\n개인 별 채용공고들의 정보를 저장하기 위해서 Firebase의 realtime database를 추가해 연결했다. firebaseApp은 이미 인증/인가 기능을 추가하면서 만들어 두었기 때문에 DBService의 interface를 이용한 class를 추가해 구현했고, 해당 api를 이용할 때는 react-query를 이용했다.\n\nDB는 이전 채용공고들을 받아오는 getJobs, 새로운 채용공고를 추가하는 addJob, 채용공고를 삭제하는 deleteJob, 채용공고를 변경할 수 있는 updateJob 4가지를 interface로 만들었다.\n\n원래 updateJob은 생각하지 않았지만, 이후 해당 공고에 체크 기능을 추가하고 체크된 비율을 공고에 담아줘야 하기 때문에 추가하게 된 기능이다. updateJob과 addJob을 합쳐서 setJob으로 처리해도 되지 않을까라는 생각을 했지만 우선은 나눠서 처리했다.\n\n```typescript\nexport interface DBService {\n  addJob: (job: ModifiedJobType) => Promise<void>\n  getJobs: () => Promise<ModifiedJobsType>\n  removeJob: (job: ModifiedJobType) => Promise<void>\n  updateJob: (job: ModifiedJobType) => Promise<void>\n}\n\nexport class DBServiceImpl implements DBService {\n  db: Database\n  constructor(private app: FirebaseApp) {\n    this.db = getDatabase(this.app)\n  }\n\n  addJob(job: ModifiedJobType) {\n    const userId = localStorage.getItem(UserId)\n    return set(ref(this.db, `users/${userId}/jobs/${job.id}`), job)\n  }\n\n  updateJob(job: ModifiedJobType) {\n    const userId = localStorage.getItem(UserId)\n    return set(ref(this.db, `users/${userId}/jobs/${job.id}`), job)\n  }\n\n  async getJobs(): Promise<ModifiedJobsType> {\n    const userId = localStorage.getItem(UserId)\n    const dbRef = ref(this.db)\n    return get(child(dbRef, `users/${userId}/jobs`))\n      .then(snapshot => {\n        if (snapshot.exists()) {\n          return snapshot.val()\n        } else {\n          return []\n        }\n      })\n      .catch(error => {\n        console.error(error)\n      })\n  }\n\n  removeJob(job: ModifiedJobType) {\n    const userId = localStorage.getItem(UserId)\n    return remove(ref(this.db, `users/${userId}/jobs/${job.id}`))\n  }\n}\n```\n\n### 1. getJobs\n\ngetJobs를 사용하는 곳은 JobList 컴포넌트로 메인페이지와 상세페이지에서 채용공고들을 보여주기 위해 필요하다. 상세 페이지의 경우 보여주고 있는 페이지는 제외해 주어야 하기 때문에 react-query의 select를 이용해서 filtering을 한 data를 전달하게 로직을 구성했다. react-query를 이용해 별도의 hook을 만들지 않고 loading 상태를 관리할 수 있어서 더 편하게 작업할 수 있었다.\n\n```tsx\nexport default function JobList() {\n  const { query } = useRouter()\n  const { id } = query\n  const dbService = useDBService()\n  const { data: jobs, isLoading } = useQuery(\n    [\"jobs\"],\n    () => dbService.getJobs(),\n    {\n      select: (data: ModifiedJobsType) => {\n        return Object.values(data).filter(item => item.id !== id)\n      },\n    }\n  )\n\n  if (isLoading) {\n    return <div>채용공고를 불러오는 중입니다...</div>\n  }\n  return (\n    <Wrapper>\n      {jobs && jobs.map(job => <JobItem key={job.id} job={job} />)}\n    </Wrapper>\n  )\n}\n```\n\n### 2. removeJob\n\ndeleteJob은 JobList로 불러온 공고들의 삭제버튼에 연결되어야 할 기능으로 react-query의 useMutation을 이용해 연결했고, UI상의 변화와 불러온 서버 데이터를 동기화 시키기 위해서 onSuccess로 invalidtateQueries로 새로 DB에서 채용공고들을 받아오게 했다.\n\n```tsx\nexport default function JobItem({ job }: { job: ModifiedJobType }) {\n  const { name, platform, img, checkPercentage } = job\n  const queryClient = useQueryClient()\n  const dbService = useDBService()\n  const { mutate } = useMutation(\n    async (job: ModifiedJobType) => {\n      return dbService.removeJob(job)\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries([\"jobs\"])\n      },\n      onError: error => {\n        if (error instanceof AxiosError) {\n          const { response } = error\n          if (response) {\n            console.log(response)\n          }\n        }\n      },\n    }\n  )\n  const handleDelete = () => {\n    mutate(job)\n  }\n  const over50Percent = checkPercentage >= 0.5\n\n  return (\n    <Wrapper>\n      {over50Percent && <Badge>50% 이상</Badge>}\n      <DeleteBtn onClick={handleDelete}>\n        <MdRemove />\n      </DeleteBtn>\n      <Link href={`/jobs/${job.id}`}>\n        <Img src={img} alt=\"job\" width=\"200\" height=\"180\" priority />\n        <Box>\n          <h1>{name}</h1>\n          <h3>{platform}</h3>\n        </Box>\n      </Link>\n    </Wrapper>\n  )\n}\n```\n\n### 3. addJob\n\naddJob은 새로운 채용공고를 받아올 때 연결이 필요한 부분으로, jobForm 컴포넌트에서 서버로 url을 전달하고 크롤링한 데이터를 채용공고로 가져왔을 때 채용공고를 추가하기 위한 기능이다. useMutation을 이용해 서버로 api호출을 보낸 결과를 받아와 추가했다. 이때 체크 기능을 위해서 데이터의 format이 필요했고 addCheckToJob을 이용해 string[]이었던 preferential과 qualification을 체크된 여부를 담은 오브젝트의 배열로 변환하고, 체크된 비율을 추가해주었다.\n\n```tsx\n//setChecks.ts\n\nconst addCheckToJob = (job: JobType): ModifiedJobType => {\n  const preferential = job.preferential.map((item) => ({\n    text: item,\n    checked: false,\n  }));\n  const qualification = job.qualification.map((item) => ({\n    text: item,\n    checked: false,\n  }));\n  const checkPercentage = 0;\n  return { ...job, preferential, qualification, checkPercentage };\n};\n\n//JobForm.tsx\n\nexport default function JobForm() {\n  const [url, setUrl] = useState('');\n  const dbService = useDBService();\n\n  const queryClient = useQueryClient();\n  const { mutate, isLoading } = useMutation(\n    async (url: string) => {\n      const { data } = await axios.post(\n        `${process.env.NEXT_PUBLIC_HOST}/api/job`,\n        {\n          url,\n        }\n      );\n      const job = addCheckToJob(data);\n      dbService.addJob(job);\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries(['jobs']);\n      },\n      onError: (error) => {\n        if (error instanceof AxiosError) {\n          const { response } = error;\n          if (response) {\n            setUrl('');\n            setMessage(response?.data.message);\n          }\n        }\n      },\n    }\n  );\n\t...\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (!url) {\n      return;\n    }\n    mutate(url);\n  };\n\n  return (\n   \t...\n  );\n}\n\n```\n\n### 4. updateJob\n\nupdateJob은 상세 페이지에서 해당 공고의 check여부를 바꿔주기 위해 useMutaion을 이용해 연결되었다. updateJob에서 해당 job을 통으로 넘겨줘야하기 때문에 캐쉬된 채용공고들을 받아 id로 찾는 로직이 필요했다. 정리하면서 아쉬웠던 점은 handleChange의 코드를 보면 자격 조건의 DescriptionItem인지 우대 사항의 DescriptionItem인지를 알려 주는 kind를 전달 받기 때문에, 로직을 kind에 따라 수정할 수 있을 것 같은데 동일한 로직을 두번 사용한 부분이다. 이후에 리팩토링이 필요해 보였다.\n\n```tsx\nexport default function DescriptionItem({\n  text,\n  isMainJob,\n  checked,\n  kind,\n}: DescriptionItemProps) {\n  const queryClient = useQueryClient();\n  const dbService = useDBService();\n  const { query } = useRouter();\n  const { id } = query;\n  const jobId = typeof id === 'string' ? id : id?.join() || '';\n  const { data: job } = useQuery(\n    ['jobs'],\n    () => {\n      return dbService.getJobs();\n    },\n    {\n      select: (data: ModifiedJobsType) => {\n        return data[jobId];\n      },\n    }\n  );\n  const { mutate } = useMutation(\n    async (job: ModifiedJobType) => {\n      return dbService.updateJob(job);\n    },\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries(['jobs']);\n      },\n      onError: (error) => {\n        if (error instanceof AxiosError) {\n          const { response } = error;\n          if (response) {\n            console.log(response);\n          }\n        }\n      },\n    }\n  );\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { name } = e.currentTarget;\n    let modifiedJob;\n    if (job) {\n      if (kind === Kinds.qualification) {\n        const qualification = [...job?.qualification].map((item) => {\n          if (item.text === name) {\n            return { ...item, checked: !item.checked };\n          }\n          return item;\n        });\n        modifiedJob = { ...job, qualification };\n      } else {\n        const preferential = [...job?.preferential].map((item) => {\n          if (item.text === name) {\n            return { ...item, checked: !item.checked };\n          }\n          return item;\n        });\n        modifiedJob = { ...job, preferential };\n      }\n      mutate(calculateChecks(modifiedJob));\n    }\n  };\n  return (\n  \t...\n  );\n}\n\n```\n\n이렇게 4개의 기능을 각각의 컴포넌트에 연결해 제대로 작동하는 것을 확인했지만, useMutation이나 useQuery를 반복해서 사용했기 때문에 hook으로 따로 분리하는 리팩토링이 필요해 보였다.\n\n## 🗃 서버 로직 수정\n\n기존에는 서버를 express을 이용해 따로 분리해서 사용했지만, firebase를 이용한 인증/인가 기능과 데이터베이스를 처리하면서 프론트 단에서 하는 일이 많아져 굳이 서버를 분리해서 사용해야 할까란 고민이 되었고, next js로 migration을 진행하면서 next js 자체가 가지는 장점인 api routes기능을 이용해서 처리해보자는 결론을 내렸다.\n\n기존 서버 로직을 pages/api 내부로 가져왔는데, express를 사용하지 않고 node.js와 next내부 기능을 이용해서 서버 로직을 구성했다.\n\n```typescript\nimport { NextApiRequest, NextApiResponse } from \"next\"\nimport Crawler from \"./service/CrawlerService\"\n\nconst crawler = new Crawler()\nconst POST = \"POST\"\n\nconst JobAPI = async (req: NextApiRequest, res: NextApiResponse) => {\n  if (req.method === POST) {\n    const url = req.body.url\n    try {\n      const job = await crawler.createJob(url)\n      res.status(201).json(job)\n    } catch (error) {\n      const Err = error as { message: string }\n      res.status(400).json({ message: Err?.message })\n    }\n  } else {\n    res.status(404).json({ message: \"잘못된 접근입니다\" })\n  }\n}\n\nexport default JobAPI\n```\n\napi에서 크롤링 프로그램을 진행하기 위해서는 내부 파일로 crawlerService를 만들어야 해서 간단히 추가했다. 기존 원티드 채용공고를 크롤링을 하면서 가진 문제점은 '•'을 기준으로 자르다 보니 \"-\"로 정리해놓은 채용공고가 처리가 안되는 문제점이 있었다. 그리고 보다 세부적인 분석을 위해서 JQuery의 selector를 어떻게 처리하는지를 조금 더 공부해 원티드 채용공고에서 필요한 정보가 특정 class Name의 section 안에 다 있다는 것을 확인했다.\n\n개선한 방법은 다음과 같다.\n\n1. className으로 좀 더 세부적인 시작 포인트를 잡는다.\n2. 보통 하나의 채용공고 내부 설명이 '•' 나 \"-\"로 구분되기 때문에 포함여부를 확인하고 기준으로 잡는다.\n3. 간혹 우대 사항 아래에 여러 부가 적인 설명이 있는 경우가 있어, html 정보중 `<br/><br/>`를 기준으로 endpoint로 자른 다음에 해당 정보를 가져온다.\n\n```typescript\nimport cheerio from 'cheerio';\nimport { JobType } from '../../../types/Jobtype';\nimport Chrome from 'chrome-aws-lambda';\nimport puppeteer from 'puppeteer';\n\ntype TargetType = {\n  [key: number]: 'mainWork' | 'qualification' | 'preferential';\n};\nconst MAINWORK = '주요업무';\nconst QUALIFICATION = '자격요건';\nconst PREFERENTIAL = '우대사항';\nconst DOT_BASE = '•';\nconst HYPHEN_BASE = '-';\n\nconst DotRegex = /(?<=• )(.*?)(?=<br/>)/gm;\n\nconst WANTED_URL = 'https://www.wanted.co.kr/wd';\n\nexport default class Crawler {\n  constructor(private wantedURL: string = WANTED_URL) {}\n\n  checkUrl(url: string) {\n    return url.startsWith(this.wantedURL);\n  }\n\n  async createJob(url: string) {\n    if (!this.checkUrl(url)) {\n      throw new Error('url 에러');\n    }\n    const browser = await puppeteer.launch({\n      args: [...Chrome.args, '--hide-scrollbars', '--disable-web-security'],\n      defaultViewport: Chrome.defaultViewport,\n      executablePath: await Chrome.executablePath,\n      headless: true,\n      ignoreHTTPSErrors: true,\n    });\n    const page = await browser.newPage();\n    await page.goto(url);\n\n    const content = await page.content();\n    const $ = cheerio.load(content);\n    const imgLists = $('img');\n    const name = $('h6');\n    const result: JobType = {\n      name: $(name[0]).text(),\n      platform: 'wanted',\n      id: Date.now().toString(),\n      mainWork: [],\n      qualification: [],\n      preferential: [],\n      url,\n      img: '',\n    };\n\n    imgLists.each((idx, node) => {\n      if (idx === 1) {\n        result.img = $(node).attr('src') || '';\n      }\n    });\n\n    const titleList = $('.JobDescription_JobDescription__VWfcb > h6');\n    if (titleList.length === 0) {\n      throw new Error('Content 에러');\n    }\n    const contentList = $(\n      '.JobDescription_JobDescription__VWfcb > h6+p > span'\n    );\n\n    const target: TargetType = {};\n\n    titleList.each((idx, node) => {\n      const text = $(node).text();\n      switch (text) {\n        case MAINWORK:\n          target[idx] = 'mainWork';\n          break;\n        case QUALIFICATION:\n          target[idx] = 'qualification';\n          break;\n        case PREFERENTIAL:\n          target[idx] = 'preferential';\n          break;\n        default:\n      }\n    });\n\n    contentList.each((idx, node) => {\n      if (idx in target) {\n        const html = $(node).html()!;\n        const isDot = !!html.match(DotRegex);\n        const base = isDot ? DOT_BASE : HYPHEN_BASE;\n        const endPoint = html.search('<br/><br/>');\n        const data = html\n          .slice(0, endPoint)\n          .split(base)\n          .join('')\n          .split('<br/>')\n          .filter((item) => !!item);\n        result[target[idx]] = data;\n      }\n    });\n\n    await browser.close();\n    return result;\n  }\n}\n```\n\n수정을 했지만 여전히 문제는 아직 남아 있었다. 공고 중에서 '•'와 \"-\"를 동시에 사용하는 공고가 있는 것이다.... (둘 중 하나만 써주세요 ㅜㅜ) 그리고 기존의 틀을 유지 않고 주요업무/ 자격조건/ 우대사항으로 나누지 않고 비교적 자유롭게 작성된 공고도 있었다. 지금에서는 더 처리할 수 없을 것 같아 우선은 이슈로 남기고 점점 세부적인 처리를 추가해나갈 예정이다.\n\n## 마치며\n\n2일 동안 나름의 고민과 사투를 하면서 프로토타입을 만들었다. 아직 해야 할 일들이 너무 많지만, 이번 한번 만들고 끝낼 프로젝트가 아니라 계속해서 수정하고 고도화 시키고 확장시킬 아이디어들이 떠오르고 있다는 점이 설렌다. 배포 후 스터디에서 피드백으로 부족한 점들, 칭찬도 들으니 더 기쁜 맘으로 계속 발전시킬 것 같다. 정말 내 목표대로 나와 같은 취준생 분들이 사용할 수 있는 서비스가 될 수 있기를 기대해본다.\n"},{"excerpt":"💡 비동기와 프로미스 \"동기다, 비동기다\", 자바스크립트를 사용하면서 많이 들어온 말이다. 비동기와 프로미스를 이해한다는 것은 프로그램의 흐름을 이해하고 성능 최적화, 에러 핸들링 등을 처리할 수 있는 아주 중요한 요소이기 때문에 정리해 보고자 한다. 먼저 동기와 비동기란 뭘까? 📂동기와 비동기 위 그림의 동기적인 과정은 하나의 일이 끝날 때까지 기다렸다…","fields":{"slug":"/2022-11-27-비동기와-프로미스/"},"frontmatter":{"date":"November 27, 2022","title":"비동기와 프로미스","tags":["javascript","문법"]},"rawMarkdownBody":"\n# 💡 비동기와 프로미스\n\n\"동기다, 비동기다\", 자바스크립트를 사용하면서 많이 들어온 말이다. 비동기와 프로미스를 이해한다는 것은 프로그램의 흐름을 이해하고 성능 최적화, 에러 핸들링 등을 처리할 수 있는 아주 중요한 요소이기 때문에 정리해 보고자 한다.\n\n먼저 <u>동기와 비동기란 뭘까?</u>\n\n## 📂동기와 비동기\n\n위 그림의 동기적인 과정은 하나의 일이 끝날 때까지 기다렸다가 다음 일을 처리하는 것을 의미하고, 아래 그림은 비동기 과정으로 하나의 일을 끝날 때까지 기다리는 것이 아니라 일을 동시에 처리하고 있다. 비동기 처리 과정은 여러 일을 같이 하고 있기 때문에 훨씬 시간이 적게 걸리는 것을 알 수 있다.\n\n이렇게 하나의 일을 처리하는데 오랜 시간이 걸려 이후 작업을 막게 되는 경우, 비동기 처리를 통해 효율을 높일 수 있다.\n\n![sync](sync.png)\n![async](async.png)\n\na,b,c 라는 변수를 간단하게 호출하고 있는 예시를 보자.\n\n```javascript\nconst a = 1\nconst b = 2\nconst c = 3\n\nconsole.log(a)\nconsole.log(b)\nconsole.log(c)\n\n//결과: 1,2,3\n\n//비동기\nconsole.log(a)\nsetTimeout(() => {\n  console.log(b)\n}, 0)\nconsole.log(c)\n\n//결과: 1,3,2\n```\n\n동기 코드인 위의 예시는 결과가 일의 순서대로 1,2,3이란 결과를 나타내고, 비동기 코드인 아래의 예시는 1,3,2라는 코드를 적은 순서와 다른 결과를 갖게 되었다.\n\nconsole.log(b)를 console.log(c)보다 먼저 자바스크립트 엔진이 읽었지만, 비동기 처리에 의해 순서대로 진행하는 것이 아니라 <u>b를 다른 곳에서 처리한 후에 가져오는 것</u>처럼 보인다. 만약 b가 처리하는데 엄청 오래 걸리는 과정이라고 가정한다면, 동기적 코드에서는 오랜 시간 뒤에 c가 호출이 가능하다. 비동기 처리로 인해 오래 걸리는 b라는 일을 넘겨서 처리하는 동안 c를 처리하면 훨씬 효율적으로 일을 처리할 수 있다.\n\n그러면 이렇게 보내진 비동기 처리는 <u>어디서, 어떻게</u> 이루어지는 걸까?\n\n## ⏰ 모든 일의 순서를 관리하는 스케줄러, Event loop\n\n자바스크립트는 싱글 스레드로 일이 처리된다. 여러 개의 일을 한번에 처리하는 것이 아니라, **한번의 하나의 일만 처리할 수 있다**는 의미다. 그러면 앞서 보았던 비동기 처리는 어디서 이루어지는 의문이 든다. 비동기는 여러 개의 일을 동시에 처리하는 것이고, 우리가 브라우저를 이용할 때 여러 개의 일을 동시에 하는 것처럼 느껴지는데 어떻게 된 걸까?\n\n이것을 이해하기 위해서는 먼저 자바스크립트 엔진과 브라우저의 역할을 이해할 필요가 있다.\n\n먼저 자바스크립트 엔진에는 힙과 콜스택으로 구성되어 있다. 콜스택은 실행 컨텍스트 스택과 같은 것으로, 실행 컨텍스트의 순서를 기억하고 있다. 힙에는 객체가 저장되는 메모리 공간으로 동적으로 생기는 변수들, 크기를 정할 수 없는 객체들을 저장하고 실행 컨텍스트는 힙에 저장된 객체들을 참조하고 있다. 그렇기 때문에 앞서 말한 대로 자바스크립트 자체는 싱글 스레드로 콜스택에 쌓여있는 순서로 코드를 평가하고 실행하는 기능만 갖고 있다.\n\n비동기 처리를 위해서는 자바스크립트 엔진이 작동하는 **Node Js나 브라우저**가 도와줘야 한다. 앞선 코드에서 사용된 setTimeout과 같은 브라우저/Node API를 사용하면 자바스크립트 엔진은 평가하고 실행하는데, 호출되는 시점과 콜백함수의 등록은 브라우저와 Node.js가 해 준다. 이렇게 등록할 콜백함수를 보관하는 곳은 Task Queue다. Task Queue에 저장된 callback함수는 <u>하나씩</u> event loop이 callstack이 비어 있을 때 가져와 자바스크립트 엔진이 처리할 수 있게 한다.\n\n이렇게 다른 역할을 갖고 있는 자바스크립트 엔진과 브라우저를 연결해 자바스크립트의 동시성을 지원하는 것이 **Event loop**이다.\n\n![eventloop](eventloop.gif)\n\n앞선 비동기 예제를 다시 설명하면 다음과 같다.\n\n```javascript\nconst a = 1\nconst b = 2\nconst c = 3\n\nconsole.log(a)\nsetTimeout(() => {\n  console.log(b)\n}, 0)\nconsole.log(c)\n\n//결과: 1,3,2\n```\n\n1. 전역컨텍스트가 만들어지고 콜스택에 들어간다.\n2. 평가 과정을 통해 변수 a,b,c가 등록되고 실행 과정에서 WebAPI인 SetTimeOut은 함수 컨텍스트를 만들어 콜스택에 추가된다.\n3. SetTimeOut 내부 콜백 함수는 브라우저로 넘어가고 함수 컨텍스트는 종료되어 콜스택에서 제거된다.\n4. 타이머가 완료되면 taskQueue에 콜백 함수가 등록되는데, 이 과정에서 자바스크립트 엔진은 다음 실행 코드인 console.log(c)가 처리한다.\n5. call stack이 다 비면 taskQueue에 있던 콜백 함수를 가져와 console.log(c)를 수행한다.\n\n이러한 과정 때문에 결과가 1,3,2로 처리되었던 것이다.\n\n주의할 점은 자바스크립트 엔진은 싱글 스레드이지만 브라우저는 멀티스레드로 여러가지 일을 동시에 처리해 줄 수 있다.\n\n그러면 <u>모든 비동기 처리</u>를 콜백함수로 하면 되는걸까?\n\n## ❗ 콜백 함수의 한계\n\n콜백함수는 **콜백함수 내부 결과를 외부로 반환할 수 없다**. 앞서 사용한 setTimeOut을 예로 설명해보면 콜백 함수가 실행되는 시점에는 setTimeOut의 함수 컨텍스트가 존재하지 않는다. 그렇기 때문에 상위 스코프의 변수에 값을 할당하거나 결과를 반환하는 것이 불가능하다. 그렇기 때문에 try-catch문으로 에러 처리를 하려해도 에러가 발생하는 시점에서의 에러는 잡히지 않는다.\n\n실행 결과에 따라 다음 과정을 전달하기 위해서는 콜백 함수 내부에서 처리되어야 하고, 이 과정이 중첩되게 되면서 가독성이 떨어지는 \"Callback hell\"이 된다.\n\n아래 코드는 Callback hell의 예제로 로그인 과정을 구현한 코드다. 이렇게 코드가 짜여져 있다면 가독성이 떨어지고, 유지 보수에도 어려운 단점을 갖는다.\n\n```javascript\nclass UserStorage {\n  loginUser(id, password, onSuccess, onError) {\n    setTimeout(() => {\n      if (\n        (id === \"seul\" && password === \"123\") ||\n        (id === \"kim\" && password === \"456\")\n      ) {\n        onSuccess(id)\n      } else {\n        onError(new Error(\"error\"))\n      }\n    }, 2000)\n  }\n\n  getRoles(user, onSuccess, onError) {\n    setTimeout(() => {\n      if (user === \"seul\") {\n        onSuccess({ name: \"seul\", role: \"admin\" })\n      } else {\n        onError(new Error(\"error\"))\n      }\n    }, 1000)\n  }\n}\n\nconst userStorage = new UserStorage()\nconst id = prompt(\"아이디를 입력해 주세요!\")\nconst password = prompt(\"비밀번호를 입력해 주세요!!\")\n\nuserStorage.loginUser(\n  id,\n  password,\n  user => {\n    userStorage.getRoles(\n      user,\n      userWithRole => {\n        alert(\n          `hello ${userWithRole.name}, you have a ${userWithRole.role} role`\n        )\n      },\n      error => {\n        console.log(\"에러2\")\n      }\n    )\n  },\n  error => {\n    console.log(\"에러1\")\n  }\n)\n```\n\n그러면 <u>callback함수의 한계를 어떻게 극복할 수 있을까?</u>\n\n## 🎈 callback 함수의 한계를 극복하기 위한, Promise\n\nPromise는 말 그대로 약속, 이후에 약속된 결과를 주겠다는 의미를 가지며, 비동기 처리 상태와 결과를 관리하는 객체다.\n\npromise의 비동기 처리 상태는 pending (수행되지 않은 상태), fulfilled (성공), rejected (실패), 세 가지가 있고, 상태 정보는 promise를 만들 때 전달 받은 인자인 resolve와 reject를 호출하면서 변경된다. resolve는 성공 시에 수행할 함수, reject는 실패 시에 수행할 함수이다.\n\n비동기 처리 결과에 따라 다음 후속 처리를 위해서 then, catch, finally 내장 메소드를 이용할 수 있으며, then은 성공했을 때를, catch는 실패했을 때, finally는 성공,실패와 상관없이 처리할 수 있다. 각각은 promise를 반환하기 때문에 체이닝이 가능하다.\n\n체이닝에서 주의할 점은 성공 시 반환한 값은 다음 then의 인자로 전달 되고, promise로 계속해서 처리가 된다는 점이다. promise를 처음 배울 때 가장 어려운 부분이었다. catch는 어느 곳에서 에러가 나도 받아오기 때문에 then의 두 번째 인자로 에러처리를 하지말고, 항상 catch를 사용하는 것이 효율적이다.\n\n```javascript\nfunction getData(state) {\n  return new Promise(function (resolve, reject) {\n    if (state === \"성공\") {\n      resolve(\"성공\")\n    } else {\n      reject(new Error(\"Request is failed\"))\n    }\n  })\n}\n\ngetData(\"성공\")\n  .then(console.log) //성공\n  .catch(function (err) {\n    console.log(err)\n  })\n\ngetData(\"실패\")\n  .then(console.log)\n  .catch(function (err) {\n    console.log(err) // Error: Request is failed\n  })\n```\n\n그러면 이번엔 앞서 보았던 callback hell 예제를 promise로 해결해보자\n\n```javascript\nclass UserStorage {\n  loginUser(id, password) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (\n          (id === \"seul\" && password === \"123\") ||\n          (id === \"kim\" && password === \"456\")\n        ) {\n          resolve(id)\n        } else {\n          reject(new Error(\"에러1\"))\n        }\n      }, 2000)\n    })\n  }\n\n  getRoles(user) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (user === \"seul\") {\n          resolve({ name: \"seul\", role: \"admin\" })\n        } else {\n          reject(new Error(\"에러2\"))\n        }\n      }, 1000)\n    })\n  }\n}\n\nconst userStorage = new UserStorage()\nconst id = prompt(\"아이디를 입력해 주세요!\")\nconst password = prompt(\"비밀번호를 입력해 주세요!!\")\n\nuserStorage\n  .loginUser(id, password)\n  .then(userStorage.getRoles)\n  .then(user => alert(`hello ${user.name}, you have a ${user.role} role`))\n  .catch(console.log)\n```\n\n클래스 내부는 크게 달라진 것은 없지만, 사용할 때 복잡도가 크게 줄어 가독성이 향상된 것을 알 수 있다. 이렇게 프로미스를 통해 callback함수의 한계인 후속처리와 에러처리를 해결할 수 있다는 것을 알 수 있었다.\n\n### Promise의 메소드\n\npromise의 또다른 장점은 promise 자체적으로 제공하는 다양한 메소드다.\n\n#### 1. Promise.all\n\n여러개의 promise를 동시에 병렬적으로 이용할 때, 사용할 수 있는 메소드로, 인자로 프로미스의 이터러블을 전달받는다. 전달된 이터러블의 순서가 보장되어 반환되며, 요소중 하나라도 rejected상태가 되면 바로 종료되며 가장 먼저 rejected된 결과를 catch로 전달한다.\n\n아래의 예제에는 세가지 서로 의존되지 않는 promise가 수행되는데. chaining을 이용해 총 6초 정도가 걸리는 상황이다.\n\n```javascript\nconst requestData1 = () =>\n  new Promise(resolve => setTimeout(() => resolve(1), 3000))\nconst requestData2 = () =>\n  new Promise(resolve => setTimeout(() => resolve(2), 2000))\nconst requestData3 = () =>\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))\n\nconst res = []\nrequestData1()\n  .then(data => {\n    //3초뒤 받아와\n    res.push(data)\n    return requestData2()\n  })\n  .then(data => {\n    //2초뒤 받아와\n    res.push(data)\n    return requestData3()\n  })\n  .then(data => {\n    //1초뒤 받아와\n    res.push(data)\n    console.log(data) //총 6초 뒤 호출\n  })\n  .catch(console.log)\n```\n\npromise.all을 이용하면 가장 오래 걸리는 requestData1이 fulfilled 상태가 될 때, 총 3초 정도가 지나고 then으로 처리 결과를 전달되어 더 효율적으로 처리가 가능하다.\n\n```javascript\nconst requestData1 = () =>\n  new Promise(resolve => setTimeout(() => resolve(1), 3000))\nconst requestData2 = () =>\n  new Promise(resolve => setTimeout(() => resolve(2), 2000))\nconst requestData3 = () =>\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))\n\nPromise.all([requestData1(), requestData2(), requestData3()])\n  .then(console.log) //[1,2,3]\n  .catch(console.error)\n```\n\n#### 2. Promise.race\n\nPromise.race는 말 그대로 경주하듯이, 전달 받은 promise 중 가장 먼저 fulfilled된 promise의 처리결과를 resolve하는 promise를 반환한다. 에러 처리는 Promise.all과 동일하게 요소 중 하나라도 rejected상태가 되면 바로 종료되며 가장 먼저 rejected된 결과를 catch로 전달한다.\n\n```javascript\nconst requestData1 = () =>\n  new Promise(resolve => setTimeout(() => resolve(1), 3000))\nconst requestData2 = () =>\n  new Promise(resolve => setTimeout(() => resolve(2), 2000))\nconst requestData3 = () =>\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))\n\nPromise.race([requestData1(), requestData2(), requestData3()])\n  .then(console.log) //3\n  .catch(console.error)\n```\n\n#### 3. Promise.allSettled\n\nsettled은 fulfilled이나 rejected로 비동기 처리가 된 상태를 의미해 성공/실패 여부와 상관없이 결과를 반환해 주는 메소드다.\n\n```javascript\n\nPromise.allSettled([\n  new Promise((resolve) =>\n    setTimeout(() => {\n      resolve(1);\n    }, 2000)\n  ),\n  new Promise((_, reject) =>\n    setTimeout(() => {\n      reject(new Error('error'));\n    }, 1000)\n  ),\n]).then(console.log);\n\n//결과:\n[\n  { status: 'fulfilled', value: 1 },\n  {\n    status: 'rejected',\n    reason: Error: error\n        at Timeout._onTimeout (C:\\Users\\juni2\\projects\\js study\\DeepDive\\main.js:32:14)\n        at listOnTimeout (node:internal/timers:559:17)\n        at processTimers (node:internal/timers:502:7)\n  }\n]\n\n```\n\n## Promise 처리는 microtask Queue\n\nevent loop을 설명하면서 callback은 task queue에 저장된다. promise는 callback함수와 달리 task Queue가 아닌 micro-task Queue에 저장된다.\n\n![promise](promise.gif)\n\nmicrotask queue는 task queue보다 우선순위가 높아 callstack이 비게 되면, event loop이 microtask queue의 promise를 **다 가져와** 처리한다. 이때 microtask Queue가 비지 않으면 다음으로 event loop이 이동하지 않고 계속해서 머물러서 브라우저가 죽어버리는 것을 볼 수 있다.\n\n```javascript\nfunction handleClick() {\n  Promise.resolve(0).then(() => {\n    handleClick() //재귀로 계속해서 promise를 추가해\n  })\n}\n\nhandleClick()\n```\n\n## 마치며\n\n새롭게 알게 된 것은 promise의 then에게 두 번째 인자로 에러 처리를 담아 줄 수 있다는 점이었다. 하지만 catch로 에러 처리하는 것이 더 직관적이고 효율적이라는 점도 알게 되었다. promise를 여러 개 동시에 처리한 적이 없어서 promise의 메소드를 사용해본 적이 없는 아쉬움이 있었는데, 필요할 때 떠올릴 수 있게 공부한 것이 좋은 경험이었다.\n\n[참조]\n\n- [Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript](https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd)\n\n- [모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n\n- [Callback Hell (콜백 지옥)](https://velog.io/@seul06/JavaScript-%EC%BD%9C%EB%B0%B1-%EC%A7%80%EC%98%A5)\n\n- [자바스크립트 Promise 쉽게 이해하기](https://joshua1988.github.io/web-development/javascript/promise-for-beginners/#promise%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94)\n"},{"excerpt":"🔑 회원가입/로그인 페이지 회원가입과 로그인을 통해서 개인 별로 채용공고를 관리하기 위해서 회원가입/로그인 페이지를 만들었다. 페이지를 만들면서 고민했던 과정을 정리해보았다. 🎨 디자인 디자인은 원티드의 로그인/회원가입 페이지를 참고했는데 컨텐츠를 모바일 사이즈인 400px를 기준으로 만들어 모바일과 데스크 탑에서 동일하게 보일 수 있게 했다. 이것을 참…","fields":{"slug":"/2022-11-25-모으잡-회원가입로그인-로직/"},"frontmatter":{"date":"November 25, 2022","title":"모으잡-firebase를 이용한 회원가입 로직 구현","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 🔑 회원가입/로그인 페이지\n\n회원가입과 로그인을 통해서 개인 별로 채용공고를 관리하기 위해서 회원가입/로그인 페이지를 만들었다. 페이지를 만들면서 고민했던 과정을 정리해보았다.\n\n## 🎨 디자인\n\n디자인은 원티드의 로그인/회원가입 페이지를 참고했는데 컨텐츠를 모바일 사이즈인 400px를 기준으로 만들어 모바일과 데스크 탑에서 동일하게 보일 수 있게 했다. 이것을 참고해 똑같이 400px를 기준으로 디자인했고, OAuth를 연결해 간편하게 이용할 수 있게 해당 플랫폼들을 아래에 추가했다.\n\n[원티드의 회원가입/로그인 페이지]\n\n![원티드의 회원가입/로그인 페이지](./회원가입로그인페이지.png)\n\n[모으잡의 회원가입/로그인 페이지]\n![모으잡 회원가입/로그인 페이지](./모으잡회원가입로그인페이지.png)\n\n## 💊Firebase의 Auth 기능\n\n로그인/회원가입을 아직 직접 구현하기 위해서는 node js에 대한 공부가 더 필요해, 우선은 firebase로 구현했다. firebase 문서를 참고해서 email/password, google, github 세 가지 방식을 이용해 기능을 구현했다.\n\n### AuthService 모듈 제작\n\n먼저 firebase를 이후에 database에도 이용할 예정이기 때문에, 공통으로 전달할 수 있게 \\_app.tsx에서 firebaseApp을 만들고 각각의 모듈에 전달할 수 있게 했다.\n\n```tsx\nconst config: ConfigType = {\n  apiKey: process.env.NEXT_PUBLIC_API_KEY || \"\",\n  authDomain: process.env.NEXT_PUBLIC_AUTH_DOMAIN || \"\",\n  projectId: process.env.NEXT_PUBLIC_PROJECT_ID || \"\",\n  storageBucket: process.env.NEXT_PUBLIC_STORAGE_BUCKET || \"\",\n  appId: process.env.NEXT_PUBLIC_APP_ID || \"\",\n  measurementId: process.env.NEXT_PUBLIC_MEASUREMENT_ID || \"\",\n}\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const app = initializeApp(config)\n  const authService = new AuthServiceImpl(app)\n  const { push } = useRouter()\n\n  return (\n    <>\n      <AuthProvider authService={authService}>\n        <Component {...pageProps} />\n      </AuthProvider>\n    </>\n  )\n}\nexport default MyApp\n```\n\n회원가입/로그인 로직을 담는 모듈인 Authservice는 아래와 같이 interface와 interface를 실행하는 AuthserviceImpl class를 만들었다.\n\n```typescript\n/Authtypes.ts\nexport interface AuthService {\n  signIn: (email: string, password: string) => Promise<UserCredential>;\n  signUp: (email: string, password: string) => Promise<UserCredential>;\n  OAuthSignIn: (platfrom: OAuthType) => Promise<UserCredential>;\n  signOut: () => Promise<void>;\n}\n\n//Authservice.ts\nexport class AuthServiceImpl implements AuthService {\n  googleProvider: GoogleAuthProvider;\n  githubProvider: GithubAuthProvider;\n  auth: Auth;\n\n  constructor(private app: FirebaseApp) {\n    this.googleProvider = new GoogleAuthProvider();\n    this.githubProvider = new GithubAuthProvider();\n    this.auth = getAuth(this.app);\n  }\n  signIn(email: string, password: string) {\n    return signInWithEmailAndPassword(this.auth, email, password);\n  }\n\n  signUp(email: string, password: string) {\n    return createUserWithEmailAndPassword(this.auth, email, password);\n  }\n\n  OAuthSignIn(platform: OAuthType): Promise<UserCredential> {\n    const provider = this[`${platform}Provider`];\n    return signInWithPopup(this.auth, provider);\n  }\n\n  signOut() {\n    return signOut(this.auth);\n  }\n}\n\n```\n\n### SignIn과 SignUp\n\n회원가입/로그인 페이지 내 AuthService가 사용될 곳은 AuthForm 컴포넌트로 회원가입과 로그인 모두에서 동일한 UI를 사용되게 했다. 한곳에서 회원가입/로그인 두 가지 조금 다른 로직을 처리해야 했기 때문에 컴포넌트 내부가 복잡하다고 생각했다.\n\n회원가입 페이지에서 성공 시에는 login페이지로 이동하면서 이전에 있던 에러 메시지는 지워줘야 했고, 로그인 페이지는 성공시에 받은 userData를 이용해 accessToken을 받을 수 있어 우선 localStorage에 저장하고 메인 페이지로 이동해야 했다.\n\n```tsx\n//AuthForm.tsx\n...\nexport default function AuthForm({ isLogin }: AuthFormProps) {\n\t...\n  const authService = useAuth();\n  const { push } = useRouter();\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const { email, password } = userInfo;\n    if (isLogin) {\n      authService\n        .signIn(email, password)\n        .then((userData: UserCredential) => {\n          return userData.user.getIdToken();\n        })\n        .then((token) => {\n          localStorage.setItem(AccessToken, token);\n          push('/');\n        })\n        .catch((error) => setMessage(error.message));\n    } else {\n      authService\n        .signUp(email, password)\n        .then(() => {\n          push('/login');\n          setMessage('');\n        })\n        .catch((error) => setMessage(error.message));\n    }\n  };\n\n  return (\n    <Layout action=\"submit\" onSubmit={handleSubmit} isActive={!isInActive}>\n      <AuthInput\n        name={EMAIL_INPUT.name}\n        text={userInfo.email}\n        title={'이메일'}\n        placeholder={EMAIL_INPUT.placeholder}\n        dispatch={dispatch}\n      />\n      <AuthInput\n        name={PASSWORD_INPUT.name}\n        text={userInfo.password}\n        title={'비밀번호'}\n        placeholder={PASSWORD_INPUT.placeholder}\n        dispatch={dispatch}\n      />\n      {message && <ErrorMessage message={message} />}\n      <button type=\"submit\" disabled={isInActive}>\n        {name}\n      </button>\n    </Layout>\n  );\n}\n```\n\n로직이 promise chaining으로 이어지다 보니 하는 일에 비해 로직이 차지하는 코드가 많이 보여, 따로 분리하고자 했다. 정리할 때 custom Hook을 이용하려 했지만 custom Hook은 handleSubmit 내부에서 사용할 수 없기 때문에 \"함수\"로 분리해 정리했다.\n\n```tsx\n//logic.ts\nexport const login = async (\n  userInfo: UserInfoType,\n  authService: AuthService,\n  router: NextRouter,\n  setMessage: React.Dispatch<React.SetStateAction<string>>\n) => {\n  const { push } = router;\n  const { email, password } = userInfo;\n  try {\n    const userData = await authService.signIn(email, password);\n    const token = await userData.user.getIdToken();\n    localStorage.setItem(AccessToken, token);\n    push('/');\n  } catch (error) {\n    const loginError = error as { message: string };\n    setMessage(loginError?.message);\n  }\n};\n\nexport const register = async (\n  userInfo: UserInfoType,\n  authService: AuthService,\n  router: NextRouter,\n  setMessage: React.Dispatch<React.SetStateAction<string>>\n) => {\n  const { push } = router;\n  const { email, password } = userInfo;\n  try {\n    await authService.signUp(email, password);\n    push('/login');\n  } catch (error) {\n    const registerError = error as { message: string };\n    setMessage(registerError?.message);\n  }\n};\n\n//AuthForm.tsx\nexport default function AuthForm({ isLogin }: AuthFormProps) {\n  const [message, setMessage] = useState('');\n  const [userInfo, dispatch] = useReducer(authReducer, initialState);\n  const isInActive = !userInfo.emailValid || !userInfo.passwordValid;\n  const authService = useAuthService();\n  const router = useRouter();\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (isLogin) {\n      login(userInfo, authService, router, setMessage);\n    } else {\n      register(userInfo, authService, router, setMessage);\n    }\n  };\n  const name = isLogin ? '로그인' : '회원가입';\n\n  return (\n \t...\n  );\n}\n```\n\n### OAuthSignIn\n\nfirebase의 OAuth 서비스를 이용하기 위해서 해당 플랫폼의 provider을 연결하고 signInWithPopup 메소드를 이용하면 되는데, provider의 종류에 관계없이 하나의 함수를 사용하기 위해 전달받은 platform의 provider와 연결될 수 있게 로직을 구성했다. AuthService와 연결하기 위해서 button태그의 name으로 인자를 전달되게 했다.\n\n```typescript\n//AuthService.ts\nexport class AuthServiceImpl implements AuthService {\n  googleProvider: GoogleAuthProvider\n  githubProvider: GithubAuthProvider\n  auth: Auth\n\n  constructor(private app: FirebaseApp) {\n    this.googleProvider = new GoogleAuthProvider()\n    this.githubProvider = new GithubAuthProvider()\n    this.auth = getAuth(this.app)\n  }\n\n  OAuthSignIn(platform: OAuthType): Promise<UserCredential> {\n    const provider = this[`${platform}Provider`]\n    return signInWithPopup(this.auth, provider)\n  }\n}\n\n//PlatformBtns.tsx\n\nexport const OAuthLogin = async (\n  name: OAuthType,\n  authService: AuthService,\n  router: NextRouter\n) => {\n  const { push } = router\n  try {\n    const userData = await authService.OAuthSignIn(name)\n    const token = await userData.user.getIdToken()\n    localStorage.setItem(AccessToken, token)\n    push(\"/\")\n  } catch (error) {\n    console.log(error)\n  }\n}\n\nexport default function PlatformBtns() {\n  const authService = useAuthService()\n  const router = useRouter()\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    const { name } = e.currentTarget\n    if (name === PLATFORM.GOOGLE || name === PLATFORM.GITHUB) {\n      OAuthLogin(name, authService, router)\n    }\n  }\n  return (\n    <Wrapper>\n      <button name={PLATFORM.GOOGLE} onClick={handleClick}>\n        ...\n      </button>\n      <button name={PLATFORM.GITHUB} onClick={handleClick}>\n        ...\n      </button>\n    </Wrapper>\n  )\n}\n```\n\n### Logout\n\nNavbar의 로그아웃 버튼을 추가해 간단하게 처리할 수 있었다.\n\n```tsx\nexport default function Navbar() {\n  const { push } = useRouter()\n  const authService = useAuthService()\n  const onSignOut = () => {\n    authService\n      .signOut()\n      .then(() => {\n        localStorage.removeItem(AccessToken)\n        push(\"/login\")\n      })\n      .catch(error => console.log(error))\n  }\n  return (\n    <Wrapper>\n      <Layout>\n        <Link href=\"/\">모으잡</Link>\n        <Btns>\n          <button onClick={onSignOut}>로그아웃</button>\n        </Btns>\n      </Layout>\n    </Wrapper>\n  )\n}\n```\n\n아직 예외 처리, token관리, redirection을 해주어야 하지만 우선 전반적으로 완성한 후에 다시 돌아와서 수정하고자 한다. 남은 큰 기능들은 Database, 자격조건/우대사항 체크 기능, 크롤러 프로그램을 수행해 줄 서버 기능이 있다.\n"},{"excerpt":"우리가 당연하게 생각하고 있는 컴퓨터를 켜서,크롬을 누르면 브라우저 화면을 보여준다는 것은 사실 어마어마한 작업이 뒤에서 돌아가고 있다. 브라우저가 해당 url을 서버에 요청하고 필요한 정보를 서버가 응답으로 보내줬을 때, 그 결과 ( html, css, javascript )를 우리에게 그려주는 과정, Critical Rendering Path에 대해 …","fields":{"slug":"/2022-11-24-Critical-Rendering-Path/"},"frontmatter":{"date":"November 24, 2022","title":"💻 Critical Rendering Path","tags":["web","javascript","event-loop","performance"]},"rawMarkdownBody":"\n우리가 당연하게 생각하고 있는 컴퓨터를 켜서,크롬을 누르면 브라우저 화면을 보여준다는 것은 사실 어마어마한 작업이 뒤에서 돌아가고 있다. 브라우저가 해당 url을 서버에 요청하고 필요한 정보를 서버가 응답으로 보내줬을 때, 그 결과 ( html, css, javascript )를 우리에게 그려주는 과정, **Critical Rendering Path**에 대해 알아보자.\n\n## CRP의 정의\n\nCritical Rendering Path는 브라우저에서 <u>html, css, javascript를 해석해서 화면에 그려주는 과정</u>이라고 정의할 수 있다. 우리가 작성한 코드들, html, css, javascript를 받으면 그걸 그대로 보여주는 게 아니라, 먼저 브라우저가 이해할 수 있게 변환해줘야한다. 이때 html parser와 css parser를 이용해 코드를 읽어, 브라우저가 이해할 수 있는 구조로 **토큰화**를 한다. 이 토큰의 결과물들을 한번쯤 들어본 적 있는 DOM과 CSSOM이다.\n\n공부하면서 먼저 정리해둘 것은 각 파일을 읽어나가는 과정에 사용되는 엔진이 **두가지**라는 점이었다. 하나는 렌더링을 해주는 \"브라우저의 렌더링 엔진\", 다른 하나는 자바스크립트를 읽어주는 \"자바스크립트 엔진\"이다. 전달받은 html을 읽는 것은 렌더링 엔진, 자바스크립트를 읽고 DOM을 조작하는 등의 일을 하는 것은 자바스크립트 엔진이다.\n\n## CRP 세부과정\n\n세부과정은 다음과 같은 과정으로 나타낼 수 있다. 각각의 과정에 대해 알아보자.\n\n![CRP](geekforgeeks.png)\n\n### DOM 트리\n\nDOM은 Document Object Model로 HTML parser를 이용해 브라우저가 이해할 수 있는 <u>Tree</u> 구조로 변환해 만든 구조다. 내가 작성하는 html 태그들은 DOM 트리의 Node로 변환되게 된다. 브라우저는 tree구조를 통해 태그들의 부모관계를 이해할 수 있다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <link href=\"style.css\" rel=\"stylesheet\" />\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"awesome-photo.jpg\" /></div>\n  </body>\n</html>\n```\n\n![dom](dom.png)\n\n그러면 이렇게 만들어진 DOM tree는 <u>어떻게 스타일링이 되는 걸까?</u>\n\n### CSSOM 트리\n\ncss파일은 보통 html의 head에 넣어주는데 자바스크립트 엔진이 html을 읽다가 link:css를 만나면 html 파싱을 멈추고 css 파일을 불러온다. 불러온 css파일은 css parser에 의해 브라우저가 이해할 수 있는 트리구조인 CSSOM (CSS Object Model)을 만들게 되고, 브라우저는 만든 tree구조를 통해서 CSS의 기본 원리인 Cascading rule (아래로 내려올 수록, 해당 태그에 구체적인 styling요소일수록 우선순위가 높다)를 적용할 수 있다. CSSOM을 만든 이후에 다시 html파싱이 멈춰진 곳으로 돌아가 다시 html을 파싱한다.\n\n```css\nbody {\n  font-size: 16px;\n}\np {\n  font-weight: bold;\n}\nspan {\n  color: red;\n}\np span {\n  display: none;\n}\nimg {\n  float: right;\n}\n```\n\n![cssom.png](cssom.png)\n\n이렇게 만든 각각의 Tree들은 <u>어떻게 합칠까?</u>\n\n### Render Tree\n\nRender Tree는 앞서 정리한 DOM tree와 CSSOM Tree를 합쳐서, DOM Tree의 Node에 CSSOM에서 결정된 스타일링을 적용한 구조다. Render Tree에서 특징적인 것은 실제로 브라우저에 그려주지 않을 부분 (html의 head나 display:none으로 스타일링된 node)을 제외하고 보여줄 부분만 담는다는 것이다.\n\n![render tree](renderTree.png)\n\n그러면 우리가 작성한 <u>Javascript</u>는 어떻게 작동하는 걸까?\n\n### Javascript\n\n자바스크립트도 css파일과 동일하게 html의 파싱하는 과정에서 렌더링 엔진이 script를 태그를 만나면 DOM생성을 중지하고 자바스크립트 엔진의 파싱과 실행을 진행한다. 자바스크립트 엔진은 자바스크립트를 읽어 AST(abstract syntax tree)를 생성한 후에 실행한다. 이때 DOM이나 CSSOM을 변경한다면 렌더트리가 변경되게 되고, 변경된 렌더트리를 기준으로 브라우저 화면을 다시 그리는 리플로우(layout 계산을 다시 실행)와 리페인트(다시 paint과정을 다시 진행)를 한다.\n\n이렇게 자바스크립트로 변경까지 한 후에 렌더트리를 만들었지만, <u>어디에 요소를 그릴지</u> 정해지지 않았다.\n\n### Layout\n\nLayout과정은 Render Tree로 어떤요소로 어떻게 그릴지를 결정한 후에 어디에 그릴지를 결정하는 과정이다. 해당요소의 부모자식관계, css에서 정의된 크기와 위치를 이용해 고정된 값으로 변환한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <title>Critial Path: Hello world!</title>\n  </head>\n  <body>\n    <div style=\"width: 50%\">\n      <div style=\"width: 50%\">Hello world!</div>\n    </div>\n  </body>\n</html>\n```\n\n![layout](layout.png)\n\n이제 위치까지 계산이 끝났다. 다음으로는 드디어 <u>실제로 그리는 과정</u>이다.\n\n### Paint와 composite\n\n<u>Paint</u>는 브라우저 요소를 실제 픽셀단위로 그리는 과정이다. 여기서 중요한 것은 요소를 그릴 때 한 층에 다 그리는 것이 아니라 여러개의 층으로 나눠서 그린다는 점이다. 하나의 층에 그리지 않고 여러개의 층로 나눠서 그리는 이유는, 하나 surface에 그릴 경우, 내부 요소에 변화가 생기면 전체를 다시 그려야하는 단점이 생기기 때문이다. 그렇기 때문에 위치나 스타일링 요소가 바뀔 수 있는 부분은 다른 층으로 그려진다. 변화될 부분을 따로 층을 만드는 방법으로 css의 will-change와 같은 방법이 있다.\n\n이렇게 여러 층으로 그려놓은 요소들을 하나의 층으로 합치는 과정을 <u>composite</u>이라고 한다.\n\n<img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--QKe-oE4M--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/layers.jpg\" width=\"800\"/>\n\n## CRP와 성능\n\n위의 세부과정들을 통해서 어떻게 브라우저를 통해 우리가 요청한 화면이 그려지는 지를 알아보았다. 이제 중요한 점은 이러한 과정을 알기 때문에 **성능**을 고려해서 코딩할 수 있어야한다. 각 과정에서 성능을 고려해서 작업한다면, 훨씬 빠르게 화면이 그려질 수 있다. 여기서 고려해야할 중요한 점은 **과정의 앞부분의 변화가 생기면 이후 과정도 다시 새로 일어난다는 점**이다.\n\n만약 아래 그림과 같이 layout이 새로 일어나야한다면 layout이 변경된 이후 과정인 paint와 composite도 다시 실행되어야 하기 때문에, 성능에 영향을 줄 수 있는 변화가 된다. 그렇기 때문에 요소를 이동시킬 때 position을 변화시키는 것(layout) 보다 transform을 이용해 (transform) 요소를 이동시키는 게 더 성능이 좋은 이유가 된다.\n\n<img src=\"https://pollen-port-115.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F88026078-c255-4c6e-82eb-e014bbaf250f%2FUntitled.png?table=block&id=15ed16ee-d0e1-4d60-bee5-8ec27d84fc4d&spaceId=75afd7aa-b6ab-4cc8-9a59-9695618bc541&width=2000&userId=&cache=v2\" width=\"800\"/>\n\n이러한 비교를 위해서는 https://csstriggers.com/와 같은 사이트를 참조해 브라우저별로 적절한 styling의 선택이 가능하다.\n\n## 리액트와 CRP\n\n리액트를 사용하면서 DOM요소를 컴포넌트로 만들고 추가하고 제거하는 작업들을 많이 해왔다. CRP를 이해하고 나면 여태까지 작업했던 과정에 대해 의문이 생긴다. DOM을 직접건드리면 이후에 layout, paint, composite도 다 다시 일어나야하고 **화면이 깜빡일 것 같은데 왜 일어나지 않았을까?**\n\n이유를 찾아보니 피상적으로만 알고 있던 리액트의 <u>V-DOM</u>과 <u>Reconcilation</u> 덕분이었다.\n\n### V-DOM\n\n리액트는 가상 DOM, V-DOM(Virtual DOM)을 가지고 있다. 리액트를 이용하면 상태에 따라 UI의 변화가 발생한다. 하지만 이러한 변화에 항상 즉각적으로 DOM을 바꾸는 것이 아니라, V-DOM을 업데이트 하고 실제 DOM에 반영할 타이밍을 관리하는 \"스케줄러\"가 있어, 변화들을 모아서 <u>한번에 처리한다</u>. 그렇기 때문에 state를 바꾸었을 때 즉각적으로 바뀌지 않을 때가 있고, \"setState가 비동기로 처리된다\"는 의미가 여기에 있다. V-DOM 덕분에 정말 필요한 부분에만 업데이트가 일어나기 때문에, 효율적으로 렌더링이 가능하고 이러한 업데이트를 **Reconcilation**이라고 부른다.\n\n![post-thumbnail](https://velog.velcdn.com/images/ye-ji/post/887cbb0d-44aa-46d5-b66b-319baf2f0b12/1_CqdIWZy0NMPQhYx2rKzo9g.png)\n\n그러면 Reconcilation에서 V-DOM과 실제 DOM은 어떻게 비교될까?\n\n### Reconcilation\n\nreact에서 리랜더링이 필요한 경우는 props나 상태가 변화한 경우다. 상태변화에 따라 V-DOM을 업데이트하고 실제 DOM과 비교해, 필요한 부분을 업데이트하는 과정을 **Reconcilation**라고 한다. Reconcilation을 하기 위해 변화에 따라 어떤 요소가 바뀌었는지 일일히 비교한다면 리액트 공식홈페이지에서는 O(n^3)의 시간복잡도(n은 tree 요소 수) 를 갖는다고 한다. 일일히 다 비교하지 않기 위해서 리액트는 두가지 전제를 이용한다.\n\n첫번째는 element type이 달라지면 다른 tree를 만든다는 점이다. a태그에서 img태그로 바뀐다면 아예 다른 트리를 만든다는 의미이다. 부모 node가 달라지면 일일히 자식까지 비교하는 것이 아니라 새로운 tree로 바꾸는 것으로 이해했다. <u>상태의 불변성</u>을 전제한 동작이다. 상태를 변화시킬 때 항상 새로운 상태로 변화시켜줘야한다는 원칙이 여기서 기인한다. Object의 참조값을 이용한 **얕은 비교**를 통해 같은 상태인지 다른 상태인지 비교하기 때문에 상태를 업데이트 시켜줄 때는 새로운 값을 할당해 주어야한다.\n\n두번째로 개발과정에서 key를 이용해 달라져야할 부분을 알려줄 수 있다는 점이다. react를 개발하면서 map으로 반복되는 컴포넌트를 넣을 때 자주 마주하는 에러였는데 왜 리액트가 에러로 던져주는지 알 수 있는 부분이다. key를 이용해서 바뀌어야하는 요소를 알려줌으로써 불필요한 업데이트를 막을 수 있기 때문이다.\n\n<img src=\"https://i0.wp.com/blog.knoldus.com/wp-content/uploads/2020/10/virtual-dom.png?resize=810%2C339&ssl=1\" width=\"800\"/>\n\n위 두가지 전제를 이용해 V-DOM과 실제 DOM을 비교하기 때문에 O(n)의 시간복잡도를 가지고 처리할 수 있다. 그렇기 때문에 보다 빠르게 DOM에서 변화되야할 부분을 찾을 수 있고, 찾은 부분은 적절한 타이밍에 한번에 업데이트하기 때문에, 성능을 보장할 수 있어, 깜빡임없이 렌더링이 가능했다.\n\n## 마치며\n\n스코프, 실행컨텍스트,클로저를 공부할 때도 느꼈지만 우리가 당연하게 쓰고 있는 것 뒤에서 돌아가고 있는 작업들을 알게 되면 깜짝 놀라게 된다. 이렇게 많은 작업이 되고 있다니... \"누군가 하는 모습이 쉬워보인다면 그사람은 그분야의 고수다\"라는 말이 있듯이 그만큼의 추상화가 잘 되어있어 사용자는 그런 부분들을 알지 못해도 사용할 수 있다는 게 놀랍다. CRP를 이전에 알고는 있었지만 리액트에서는 어떻게 연결되는지에 대해 비어있는 부분이었는데, 이번기회에 연결이 되면서 채울 수 있는 좋은 기회였다. 리액트를 쓰는 이유로 단순히 시장에서 많이 쓰여서라고 대답하기 보다는, SPA에서 자바스크립트로 다양한 interaction을 하면서 DOM요소들을 건드리게 되는데, 이때 V-dom과 reconcilation과 같은 내부 동작으로 **최적화가 된 렌더링을 보장해주기 때문에**라고 대답하면 더 좋은 대답이 될 것 같다.\n\n### 참조\n\n- [dom](https://poiemaweb.com/js-dom)\n- [constructing the object model](https://web.dev/critical-rendering-path-constructing-the-object-model/)\n- [critical rendering path (web performance)](https://dev.to/coderedjack/critical-rendering-path-web-performance-23ij)\n- [성능 최적화](https://reactjs-kr.firebaseapp.com/docs/optimizing-performance.html)\n- [reconciliation](https://reactjs.org/docs/reconciliation.html#gatsby-focus-wrapper)\n"},{"excerpt":"⚒ 모으잡 프로젝트 수정하기 프리온보딩 코스가 끝나고 이력서를 수정하며, 모으잡 프로젝트를 프로토타입으로 먼저 제작하기로 결정했다. 기존의 한계점은 schema를 짜고, 서버를 만들어두었지만, 별도의 CRUD 처리를 하기보다 단순히 크롤링 결과만 json으로 전달해주는 역할만 했다. 서버가 간단한 역할만 한다면 Next js의 서버를 이용해 api로 전달…","fields":{"slug":"/2022-11-23-모으잡-Next-migration/"},"frontmatter":{"date":"November 23, 2022","title":"모으잡-Next js로 migration, 디자인 수정","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# ⚒ 모으잡 프로젝트 수정하기\n\n프리온보딩 코스가 끝나고 이력서를 수정하며, 모으잡 프로젝트를 프로토타입으로 먼저 제작하기로 결정했다. 기존의 한계점은 schema를 짜고, 서버를 만들어두었지만, 별도의 CRUD 처리를 하기보다 단순히 크롤링 결과만 json으로 전달해주는 역할만 했다.\n\n서버가 간단한 역할만 한다면 **Next js의 서버를 이용해** api로 전달해주고, 데이터베이스와 인증/인가는 **firebase**를 이용하면 프론트엔드 레포 내에서 충분히 모든 기능을 다 구현할 수 있겠다는 생각이 들었다. 필요하다면 이후에 백엔드를 공부하면서 백엔드 서버와 데이터베이스를 분리하고, 현재는 프로토타입으로 next js를 이용하면 충분할 것 같다는 생각이 들었다.\n\n## ▶ Next js로 migration하기\n\n기존의 CRA로 제작하던 프로젝트에서 Next js 바꾸기 위해 migration에 대해 알아보았고, 공식 홈페이지의 도움을 받았다.\n\n(공식홈페이지 설명: [Migrating from Create React App ](https://nextjs.org/docs/migrating/from-create-react-app))\n\n### 1. 리액트네이티브.json과 dependencies 정리하기\n\nCRA에서는 당연했던 react-scripts와 react-router-dom은 next js를 사용하면서 제거해야했다. react-scripts 대신에 next를 이용하고, next 자체적으로 pages폴더내 파일을 routing해주기 때문이었다.\n\n```json\n{\n  \"name\": \"moejob-client\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"next\": \"^13.0.4\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-icons\": \"^4.6.0\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.0\"\n  },\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"start\": \"next start\",\n    \"build\": \"next build\"\n  }\n}\n```\n\n### 2. static assets과 index.html\n\nCRA에서 static assets와 index.html은 함께 public폴더에 있었지만 next를 사용하면서 index.html은 필요가 없기 때문에 static assets만 남겨두고 index.html 내부요소는 \\_document.js나 \\_app.js로 옮겨주면 되지만 비어있어서 그냥 제거했다.\n\n### 3. src 파일 정리\n\nCRA에서는 app.jsx를 기준으로 모든게 이루어졌지만, 이제 src 폴더가 불필요하고 app.jsx를 pages/index.js로 바꿔주면 기존대로 사용할 수 있었다.\n\n페이지도 하나였고 구현사항이 적어서 생각보다 너무 간단하게 migration이 가능했다.\n\n## 🚩 Typescript 적용하기\n\n기존의 프로젝트는 javascript를 이용해서 개발했었기 때문에 안전하게 개발하기 위해 typescript를 추가했다.예전에는 typescript가 싫었는데 그새 안 쓰는 게 예상이 되지 않아서 더 불편해졌다. typescript도 간단하게 next js에서 알려주는 방식대로 진행했다. (https://nextjs.org/docs/basic-features/typescript)\n\n먼저 `touch tsconfig.json`파일을 만든 후에 next를 실행하면 원래는 next가 자동으로 필요한 dependency들을 설치할지 물어본다고 한다.\n\n```\nnpm run dev\n\n# You'll see instructions like these:\n#\n# Please install TypeScript, @types/react, and @types/node by running:\n#\n#         yarn add --dev typescript @types/react @types/node\n#\n# ...\n```\n\n하지만 실행해도 설치할지 물어 보지 않아서 수동으로 관련 dependency들을 다운 받았다. 그리고 주의할 점은 `next-env.d.ts`파일이 생기는데 `.gitignore` 파일에 추가해 버전 관리에 포함되지 않게 해야 한다.\n\n## 🎨 Styled-Components 적용하기\n\n기존에는 tailwind로 진행했지만 간단하게 프로토 타입만 만들고 끝나는 게 아니라 계속해서 수정해나갈 프로젝트로 만들고 있기 때문에, UI 컴포넌트를 이용해 이해하기 쉽게 프로젝트를 진행하기 위해 styled components를 이용하기로 했다.\n\nstyled-components는 css-in-js이기 때문에 CSR과 달리 SSR에서는 설정을 추가해 주어야한다. next는 초기에 html을 그릴 때에는 SSR을 이용하고 이후에 CSR을 이용하기 때문에 styled-components를 그대로 사용하면 js가 다운 받고 스타일링이 되기 때문에 깜빡이는 문제가 발생한다.\n\n이를 막기 위해서 \\_document.tsx를 다음과 같이 설정함으로써 html파일에 스타일 요소를 넣어서 해결할 수 있다. 아직 정확히 코드 내용을 이해하지는 못했지만 우선 왜 해야하는지에 대한 이유만 알고 넘어갔다.\n\n```tsx\nimport Document, {\n  DocumentContext,\n  DocumentInitialProps,\n  Main,\n  NextScript,\n  Head,\n  Html,\n} from \"next/document\"\nimport { ServerStyleSheet } from \"styled-components\"\n\nexport default class MyDocument extends Document {\n  static async getInitialProps(\n    ctx: DocumentContext\n  ): Promise<DocumentInitialProps> {\n    const sheet = new ServerStyleSheet()\n    const originalRenderPage = ctx.renderPage\n\n    try {\n      ctx.renderPage = () =>\n        originalRenderPage({\n          enhanceApp: App => props => sheet.collectStyles(<App {...props} />),\n        })\n\n      const initialProps = await Document.getInitialProps(ctx)\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            {initialProps.styles}\n            {sheet.getStyleElement()}\n          </>\n        ),\n      }\n    } finally {\n      sheet.seal()\n    }\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head>\n          <link\n            href=\"https://fonts.googleapis.com/css2?family=Cabin&display=optional\"\n            rel=\"stylesheet\"\n          />\n          <link\n            href=\"https://fonts.googleapis.com/css2?family=Raleway&display=optional\"\n            rel=\"stylesheet\"\n          />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    )\n  }\n}\n```\n\n이후에는 SSR에서 CSR로 넘어갈 때 class 해쉬값의 차이로 에러가 날 수 있어서 babel에 설정이 필요한데 설정을 위해 `babel-plugin-styled-components`를 다운받고 .babelrc 파일에 다음과 같이 추가한다.\n\n```json\n{\n  \"presets\": [\"next/babel\"],\n  \"plugins\": [\n    [\n      \"styled-components\",\n      {\n        \"ssr\": true,\n        \"displayName\": true,\n        \"preprocess\": false\n      }\n    ]\n  ]\n}\n```\n\n이렇게 Next로 migration이 끝났다. 이제 기획을 다시 수정할 차례다.\n\n# 🔭기획 수정\n\n한달동안 프리온보딩 코스를 공부하면서 배웠던 부분들을 적용할 만한 부분들과 기존 기획에서 부족했던 부분들을 먼저 돌아봤다.\n\n기존 기획)\n\n1. 프론트 페이지에 채용공고의 url을 입력한다.\n\n2. 프론트 페이지에서 전달된 url을 node 서버에서 크롤링을 한 후 주요업무/자격조건/우대사항에 대해 json파일에 넣어서 전달한다.\n\n3. 프론트 페이지에서 전달받은 json을 프론트페이지에서 firebase를 이용해 데이터를 저장한다.\n\n4. 프론트 페이지에서 데이터의 CRUD를 진행한다.\n\n5. 재접속시 firebase에 저장해둔 데이터를 다시 받아서 보여준다.\n\n기존 기획은 서버가 하는 역할이 크지 않았다. 우선 공부하는 목적으로 node서버를 express로 만들었었기 때문에 서버 자체의 기능이 너무 한정적이었다. 프론트에서 기존 기획은 거의 다 일을 처리할 수 있기 때문에 Next로 migration을 했고 Next서버를 이용해서 모든 기능을 구현하면 더 간단하고 좀 더 빠르게 개발이 가능할 것으로 예상되었다.\n\n추가할 기능은 오늘 원티드에서 제공해준 이력서 강의를 들으면서, 자격 조건과 우대 사항에 대해서 해당여 부를 표시할 수 있는 **체크**기능을 만들고, 그에 따른 **우선순위 기능**을 추가하면 좋겠다는 생각이 들었다. 그리고 사용자별 데이터를 저장하기 위해서 **firebase기능을 이용해 인증/인가기능**을 추가할 예정이다.\n\n프론트 페이지의 디자인은 wanted와 op.gg를 참고해 메인 페이지에는 전체 공고들을 보여주는데 필터링이 가능하게 만들려고 한다. 공고를 클릭시에는 디테일 페이지로 넘어가 해당 공고의 내용을 보여주고 동일하게 아래에 저장해둔 공고들을 보여 주는 형식으로 진행하면 어떨까라는 생각이 들었다.\n\n# Home 페이지 스타일링\n\n기획한 대로 우선 간단하게 Home페이지 디자인을 완성했다. 모바일 페이지도 고려해 max-width를 1000px로 고정해두었다. url form을 이전처럼 navbar에 두지 않고 이번에는 main 컨텐츠에 넣어두었다. 그냥 form만 두기엔 너무 허전해서 op.gg를 참고해 검색 주변에 캐릭터를 추가했다.\n\n[op.gg 검색창]\n\n![op.gg](./opgg.png)\n\nurlForm 아래에는 크롤링한 전체 채용공고들을 보여주고 플랫폼별로 필터링이 가능하게 버튼을 추가해두었다. 이후에 query string을 이용해 필터링을 추가할 예정이다.\n\n레이아웃은 원티드 홈페이지를 참고했다. 원티드의 경우 4개에서 화면크기가 작아지면 2개로 줄이는데 반응형으로 적용하기 좋을 것 같아 참고해서 만들었다. 우선순위를 표시하는 부분은 공고의 뱃지처럼 붙여주는 것으로 해두었다. 이후에 별점으로 평가해서 반영해도 좋을 것 같다.\n\n[원티드 게시물]\n\n![원티드커리어인사이트](./원티드커리어인사이트.png)\n\n스타일링을 하면서 styled-components가 tailwind로 작업하던 것보다 훨씬 편하다고 많이 느꼈는데, 특히 next/image를 다루는 것에 있어서 좀 더 편하게 스타일링이 가능해서 좋았다. 이미지를 remote에서 받아올 때는 해당 주소를 next.config.js에 추가해줘야 한다는 점도 새롭게 알게 되었다.\n\n```tsx\nconst Img = styled(Image)`\n  width: 100%;\n`\n\n//next.config.js\n\nmodule.exports = {\n  images: {\n    domains: [\"image.wanted.co.kr\"],\n  },\n}\n```\n\n완성한 모습은 아래 사진과 같다. 개인적으로는 굉장히 만족했고 기능을 내일부터 붙여나가 토요일까지 prototype을 완성해보는 것이 이번 주의 목표다.\n\n![개선 UI](./모으잡개선.png)\n"},{"excerpt":"스코프는 식별자 (변수, 함수, 클래스)가 참조될 수 있는 범위, 식별자를 검색하는 규칙을 의미한다. 이 범위는 코드 블록으로 구분되어져, {}로 감싸지는 함수, if나 switch 조건문, for 문 등으로 내부에 선언된 변수는 외부에서는 접근할 수 없는 특징을 가진다. 마치 썬팅된 자동차의 운전자는 외부를 볼 수 있지만 자동차 외부에서는 안을 볼 수 …","fields":{"slug":"/2022-11-20-스코프-실행컨테스트-클로저/"},"frontmatter":{"date":"November 20, 2022","title":"스코프,실행컨텍스트,클로저","tags":["javascript","문법"]},"rawMarkdownBody":"\n스코프는 식별자 (변수, 함수, 클래스)가 참조될 수 있는 범위, **식별자를 검색하는 규칙**을 의미한다. 이 범위는 코드 블록으로 구분되어져, {}로 감싸지는 함수, if나 switch 조건문, for 문 등으로 내부에 선언된 변수는 외부에서는 접근할 수 없는 특징을 가진다. **마치 썬팅된 자동차의 운전자는 외부를 볼 수 있지만 자동차 외부에서는 안을 볼 수 없는 것과 같다.**\n\n<img width=\"500\" src=\"https://t1.daumcdn.net/cfile/tistory/2155063B527737B20C\"/>\n\n스코프 내의 변수는 유일해야하지만, 다른 스코프라면 같은 이름의 변수를 가질 수 있어, **이름 충돌을 막을 수 있고**, 블록 내부의 사용하지 않는 변수는 이후 GC(Garbage Collecotr) 에 의해 메모리에서 제거되어 **메모리를 절약할 수 있는** 장점을 갖는다.\n\n스코프는 크게 전역 스코프과 지역 스코프로 나눌 수 있으며, 전역 스코프에 선언된 변수는 어디서든 접근이 가능하고, 앱이 종료될 때까지 GC가 제거하지 않는 특징을 가진다. 지역 스코프는 앞서 설명했던 블록 내부를 의미하며 지역 스코프에서 선언된 변수는 지역스코프 내부와, 하위 스코프에서만 참조가 가능하다. (안에서 밖은 가능, 밖에서 안은 불가능)\n\n```javascript\nconst text = \"global\" //전역 변수, 전역 스코프\n{\n  const text = \"inside block1\" //로컬 변수, 로컬 스코프\n  {\n    const text = \"inside block2\"\n    console.log(text) //inside block2\n  }\n}\n```\n\n그럼 어떻게 javascript는 scope들의 관계를 알 수 있을까?\n\n## ⛓ Scope 체인\n\n스코프들의 **계층적인 연결**을 스코프 체인이라고 부른다. 변수를 참조할 때 스코프 체인을 이용해 변수를 참조하는 코드에서 시작해서, 변수를 찾을 수 없으면 상위 스코프로 이동해서 변수를 찾는다. 이런 스코프 체인이 가능한 것은 연결리스트와 같이 실제 자료구조인 **Lexical 환경**로 연결되어 있기 때문이고 이러한 lexical 환경을 이용해 scope들의 관계를 알 수 있다.\n\n**Lexical 환경**에서 **전역 lexical 환경**은 코드가 로드되면 바로 생성되며, 함수의 경우 함수가 호출되면 생성된다. 스코프의 변수들을 key에 저장하고, 상위 스코프 정보를 저장한다. (자세한 내용은 이후 실행 컨텍스트를 정리하면서 더 자세히 정리하고자 한다)\n\n아래의 예제에서 inner내부의 x,y,z를 찾는 과정을 보면 먼저 x는 inner 내부에 존재하기 때문에 바로 찾아 탐색을 정지한다. y는 inner 내부에 없기 때문에 상위 스코프인 outer를 확인하지만 outer에도 없기 때문에 가장 상위인 전역 스코프에서 y를 찾고 탐색을 정지한다.\n\n```javascript\nconst x = \"global x\"\nconst y = \"global y\"\n\nfunction outer() {\n  function inner() {\n    const x = \"inner's local x\"\n    console.log(x)\n    console.log(y)\n  }\n  inner()\n}\n\nouter()\n```\n\n## 📚 lexical scope\n\n함수가 실행될 때 스코프를 어떻게 정의하느냐에 따라 결과가 함수의 결과가 달라질 수 있다. 두가지 방식이 있을 수 있는데, 첫 번째는 동적 스코프로 **함수를 어디에 호출하느냐**에 따라 스코프가 결정되는 방식이다. 두 번째로는 lexical 스코프, 정적 스코프로 **함수를 어디에 정의했느냐**에 따라 스코프가 결정된다.\n\n자바스크립트는 lexical scope을 기반으로 작동하기 때문에 어디에 함수를 호출하느냐가 중요한 게 아니라 함수를 정의한 곳이 기준이 되어 스코프가 정해진다.\n\n```javascript\nconst x = 1\n\nfunction foo() {\n  const x = 10\n  bar()\n}\n\nfunction bar() {\n  console.log(x)\n}\n\nfoo()\nbar()\n```\n\n위 예시를 보면서 처음에 foo()에는 x=10이 나오지 않을까라는 생각을 했지만, foo와 bar 모두 동일하게 1로 콘솔에 찍혔다. 역시 그 이유는 함수가 호출되는 곳이 기준이 아니라 **함수가 정의되는 곳**이 기준으로 스코프가 결정되기 때문이다. bar는 foo내부에서 호출되었지만 전역에 선언된 함수이기 때문에 전역 스코프를 가진다. 그렇기 때문에 x=1이 탐색되어 호출된다.\n\n스코프는 식별자를 탐색하는 규칙이라는 점과 scope들은 scope chain으로 연결되어 있어, chain을 통해 식별자를 찾을 수 있다. 함수의 경우 스코프가 함수가 정의된 위치를 기준으로 스코프가 결정된다는 점을 알아보았다. 이제는 이러한 스코프가 정의되어있는 실행 컨텍스트에 대해 알아보자.\n\n# 📦 실행 컨텍스트\n\n실행 컨텍스트는 **코드가 실행되기 위한 환경**이라고 정리할 수 있다. 자바스크립트 코드는 다음과 같은 두 가지 과정을 거친다. 먼저 실행 컨택스트를 생성한 후에 변수와 함수 선언문을 등록하는 \"소스코드의 평가\" 과정이 실행된다. 다음으로 변수에 값을 할당하는 등의 일을 하는 \"소스코드 실행\" 과정이 실행한다.\n\n예로` const x=3`에서 `const x`만을 이용해 x를 key로, undefined을 값으로 실행 컨텍스트에 먼저 등록한 후에 평가과정이 끝나고, 실행과정에서 `x=3`으로 값을 변경한다. 이렇게 과정이 나눠져 있기 때문에 실행 컨텍스트에 존재하지 않는 값이라면 reference error를 던져줄 수 있다. 항상 실행 중인 컨텍스트를 기준으로 탐색을 시작한 후에 상위 스코프로 이어나가는 과정, 스코프 체인을 따라 탐색한다.\n\n코드를 보며 내부 동작을 이해하면서 먼저 정리해야 할 부분이 있었다. 먼저 var와 const/let은 실행 컨텍스트에서 다르게 취급되어진다는 점이다. var로 선언된 변수는 **lexical 환경의 객체 환경 레코드**에 등록되어지는 반면, const/let은 **lexical 환경의 선언적 환경 레코드**에 등록되어진다. 함수 선언문의 경우는 변수들과는 다르게 undefined으로 할당하지 않고 함수 객체를 바로 할당하는 특징을 가진다.\n\n소스코드의 \"평가\"와 \"실행\"과정은 **모든 스코프에서 동일하게 진행된다**. 여기서 중요한 점은 실행하다가 함수나 다른 스코프를 만났을 때 스코프 내부로 들어가서 다시 평가와 실행을 진행한 후에, 원래 읽던 부분부터 소스코드를 읽어나간다. 그렇기 때문에 실행과정을 기억하고 있어야 하고 자바스크립트는 **실행컨텍스트 스택**을 통해서 기억하고 있다. 실행컨텍스트 스택은 실행 컨텍스트가 생성되는 평가 과정에 해당 실행 컨텍스트를 추가하고, 실행이 다 끝나면 제거한다.\n\n다음 예시 코드로 과정을 정리하면 다음과 같다.\n\n```javascript\nvar x = \"xxx\"\n\nfunction foo() {\n  var y = \"yyy\"\n\n  function bar() {\n    var z = \"zzz\"\n    console.log(x + y + z)\n  }\n  bar()\n}\nfoo()\n```\n\n1. 전역 코드:\n\n   1.1 평가: 전역 실행컨텍스트를 생성하고 스택에 넣는다. var x, function foo() 를 전역컨텍스트의 전역스코프에 동록하는데 이때, **전역 객체의 프로퍼티와 메소드**로 등록한다.\n\n   1.2 실행: x=\"xxx\"값을 할당하고 함수를 호출하면서 foo() 함수 내부로 들어간다.\n\n2. foo 호출:\n\n   2.1 평가: foo 함수 실행컨텍스트를 생성하고 스택에 넣는다. var y, function bar()를 지역 컨텍스트의 지역스코프에 등록한다. 그리고 함수는 **arguments** 객체가 생성되고 this 바인딩과 함께 지역 스코프에 등록한다.\n\n   2.2 실행: y=\"yyy\" 값을 할당하고 함수를 호출하면서 bar() 함수 내부로 들어간다.\n\n3. bar 호출:\n\n   3.1 평가: bar 함수 실행컨텍스트를 생성하고 스택에 넣는다. var z를 지역 컨텍스트의 지역스코프에 등록한다.\n\n   3.2 실행: z=\"zzz\"값을 할당하고, console, x, y, z 값을 탐색 후에 실행한다.\n\n4. foo 복귀:\n\n   bar()가 다 실행된 후에 실행컨텍스트 스택에서 제거되면 foo로 돌아온다.\n\n5. 전역으로 복귀:\n\n   foo()가 다 실행된 후에 실행컨텍스트 스택에서 제거되면 전역으로 돌아온다. 전역이 제거되면서 완료된다.\n\n![img](https://poiemaweb.com/img/ec_1.png)\n\n## lexical 환경\n\nlexical 환경은 객체 형태의 스코프를 만들어 키값으로 식별자로 등록하고 값을 관리한다. 스코프와 함께 정리했던 lexical 스코프는 lexical 환경과 동일하다고 이해가 되었다. lexical 환경은 두 가지의 컴포넌트로 구성되는데 하나는 **환경레코드**, 다른 하나는 **외부 렉시컬환경에 대한 참조**이다. 환경레코드는 스코프에 등록된 식별자를 등록하는 곳이고, 외부 lexical 환경에 대한 참조는 상위 스코프를 가리킨다.\n\nlexical 환경이 실행되는 과정을 더 세부적으로 나눠서 보면 실행 컨텍스트를 생성한 후에 lexical 환경을 생성한다.이후에 환경 레코드에 변수들을 등록한 후에, this binding이 이뤄지고 마지막에 외부 렉시컬 환경에 대한 참조가 결정된다. 이 과정들 또한 **모든 실행 컨텍스트에서 동일하게 일어난다.**\n\n위의 같은 예시를 좀 더 디테일하게 lexical 환경까지 고려해서 정리하면 다음과 같다.\n\n```javascript\nvar x = \"xxx\"\n\nfunction foo() {\n  var y = \"yyy\"\n\n  function bar() {\n    var z = \"zzz\"\n    console.log(x + y + z)\n  }\n  bar()\n}\nfoo()\n```\n\n### 1. 전역코드 평가와 실행\n\n1. 평가: 전역 실행컨텍스트를 생성하고 스택에 넣는다.\n2. 전역 lexical 환경 생성: 전역 lexical 환경 생성하고 전역 실행컨텍스트와 바인딩한다.\n3. 변수 등록: **객체환경레코드**에는 var로 선언된 변수와 함수선언문이 등록되어지는데, 전역 lexical환경의 경우 **BindingObject**를 통해 전역객체에 되어진다. const/let으로 선언된 변수들은 **선언적 환경레코드**에 등록된다.\n4. this binding: [[GlobalThisValue]]를 통해 this가 바인딩 되는데 전역이기 때문에 전역 this가 바인딩된다.\n5. 외부 lexical 환경에 대한 참조: 전역컨텍스트의 상위 스코프는 없기 때문에 null이 할당된다.\n6. 실행: x=\"xxx\"값을 할당하고 foo를 실행한다.\n\n### 2. foo 함수 평가와 실행\n\n1. 평가: foo 함수 실행컨텍스트를 생성하고 스택에 넣는다.\n2. lexical 환경 생성:foo 함수 lexical 환경 생성하고 foo 함수 실행 컨텍스트와 바인딩한다.\n3. 변수 등록: 함수에서는 **함수환경레코드**에 모든 변수가 같이 등록되어지며, 매개변수를 담은 **arguments**객체를 등록한다.\n4. this binding: [[ThisValue]]에 일반함수이기 때문에 전역객체를 가리킨다. (this는 함수 호출 방식에 따라 결정)\n5. 외부 lexical 환경에 대한 참조: foo의 **함수 정의가 이루어진 실행컨텍스트의 lexical환경**을 참조하기 때문에 전역 lexical환경 참조가 할당된다. 이때 내부슬롯인 [[Environment]]에 저장되어 항상 상위를 기억하고 있다.\n6. 실행: 스코프 체인을 이용해 y와 bar를 탐색하고 y=\"yyy\" 값을 할당하고 bar를 실행한다.\n\n### 3. bar 함수 평가와 실행\n\n1. 평가: bar 함수 실행컨텍스트를 생성하고 스택에 넣는다.\n2. lexical 환경 생성:bar 함수 lexical 환경 생성하고 bar 함수 실행 컨텍스트와 바인딩한다.\n3. 변수 등록: 함수에서는 **함수환경레코드**에 모든 변수가 같이 등록되어지며, 매개변수를 담은 arguments객체를 등록한다.\n4. this binding: [[ThisValue]]에 일반함수이기 때문에 전역객체를 가리킨다. (this는 함수 호출 방식에 따라 결정)\n5. 외부 lexical 환경에 대한 참조: bar의 함수 정의가 이루어진 실행 컨텍스트의 lexical환경을 참조하기 때문에 내부슬롯인 [[Environment]]에 foo를 참조한다.\n6. 실행: 스코프 체인을 이용해 z,x,y, console를 탐색하고 할당, 호출한다.\n\n### 4. bar 함수 종료\n\n함수종료후 실행컨텍스트 스택에서 제거되어 실행 중인 실행 컨텍스트는 foo가 된다. 이때 중요한 것은 **실행컨텍스트 스택에서 bar가 사라진다고 해서 bar의 lexical 환경까지 제거되지는 않는다.** 제거되는 것은 아무도 참조하고 있지 않을 때 GC에 의해 제거되어진다.\n\n### 5. foo 함수 종료\n\n함수종료후 실행컨텍스트 스택에서 제거되어 실행 중인 실행 컨텍스트는 전역컨텍스트가 된다.\n\n### 6. 전역 코드 종료\n\n실행할 코드가 더 이상 없으면 전역 코드도 종료되면서 실행컨택스트 스택에서 제거된다.\n\n## 블록레벨 스코프\n\nif문이나 for문과 같은 블록레벨의 스코프가 있게 되면 새롭게 렉시컬 환경을 생성한 후에, 기존의 전역 lexical 환경과 교체하고, 블록 lexical 환경은 외부 렉시컬 환경참조를 기존 lexical환경으로 하는 구조가 된다.\n\n![img](https://velog.velcdn.com/images/93minki/post/a00bae7a-2b02-4855-8d22-34df83782503/image.png)\n\n# 💊 Closure\n\n클로저는 **함수와 함수가 선언된 렉시컬 환경과의 조합**이라고 MDN에 정의되어있다. 함수가 선언된 렉시컬 환경이란 말은 앞서 설명한 실행컨텍스트에서 함수의 lexical 환경의 외부 lexical환경에 대한 참조가 **함수가 정의된 곳(실행 컨택스트)을 기준으로 상위 스코프**로 되어있기 때문에 항상 함수는 상위 스코프를 기억하고 있다.\n\n```javascript\nconst x=1;\nfunction Outer(){\n    const x=10;\n    inner()\n}\nfunction inner{\n    console.log(x)//1\n}\n\nouter()\n```\n\n얼핏보면 outer내부에 x=10이 있어 콘솔에 10이 찍힐 것 같지만, inner는 전역에서 선언된 함수이기 때문에 전역 실행 컨텍스트에서 먼저 탐색해 lexical 환경 레코드에 있는 x=1에 접근한다. 이렇게 외부 lexical 환경에 대한 참조를 이용해 상위 lexical 환경과 연결되어있는 것을 앞서 정리했던 \"스코프 체인\"이라고 부른다\n\n이렇게 참조한 상위 스코프는 함수의 실행컨텍스트를 만들기 전에 [[Environment]]에 참조되어있고, 참조한 상위 스코프는 실행 중인 실행 컨텍스트의 lexical 환경\"이라고 할 수 있다. 전역 코드를 평가하면서 함수가 정의 되었다면 실행중이었던 실행 컨텍스트는 전역 컨텍스트고, 그렇기 때문에 당연히 함수의 상위 스코프는 전역 컨텍스트가 된다. 이렇게 저장된 참조값이 있기 때문에, 이후에 함수 실행 컨텍스트가 생성되고 lexical 환경이 생성될 때 먼저 저장해둔 [[Environment]]의 참조 값을 외부 lexical환경에 대한 참조에 할당한다.\n\n이렇게 상위 스코프를 참조하고 있기 때문에 외부 함수가 종료되고 해당 실행 컨텍스트이 스택에서 제거가 되어도, 내부 함수의 상위 스코프에 해당하는 lexical 환경을 GC가 제거하지 않고, 제거된 외부 함수의 변수를 내부 함수가 참조할 수 있는 것을 **클로저**라고 부른다.\n\n그렇다면 모든 함수가 다 상위 스코프를 기억하고 있는데, 전부 클로저라고 할 수 있겠다라는 생각이 들었지만, 클로저에는 두가지 포인트가 존재한다.\n\n첫 번째는 **내부함수가 외부함수의 식별자를 참조**하고 있어야하고, 두 번째는 **외부 함수가 내부 함수보다 먼저 실행 컨텍스트 스택에서 제거**되어야 한다.\n\n그렇다면 왜 클로저를 사용할까?\n\n## 클로저의 활용\n\n클로저는 자바스크립트에서 **상태를 안전하게 관리하기 위해서** 사용되어진다. 상태를 안전하게 보관하기 위해서는 상태를 외부에서 직접 접근하지 못해야 하며, 상태를 변화시킬 수 있는 함수를 이용해서 상태를 변화시키는 방식이 사용 되어야 한다. 이를 **캡슐화**, 또는 **정보은닉**이라고도 부른다.\n\n클로저는 외부 함수에 상태가 존재하고 이를 변경할 수 있는 함수를 내부 함수에 전달해, 외부에서 전달된 함수를 통해서만 상태를 변화시키는 방식이다.\n\n```javascript\nconst Counter=(function(){\n    let num=0\n    return {\n        increase(){\n            return ++num;\n        }\n        decrease(){\n            return --num;\n        }\n    }\n})\n```\n\ntypescript에는 class를 이용해 private, protected, public로 상태를 관리할 수 있지만, javascript에서는 없기 때문에 클로저를 이용해서 사용했다.\n\n이러한 클로저를 보다보면 사용 목적이 리액트의 useState hook과 너무나 닮아있다는 것을 알 수 있다. 상태를 안전하게 관리하기 위해, 상태를 관리하는 함수, setState로만 상태를 변화시킬 수 있다는 점이 너무나 닮아있다. 실제로 usestate hook의 내부 구조를 보면 다음과 같이 되어 있다.\n\n```javascript\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null,\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current\n  return dispatcher\n}\n\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher()\n  return dispatcher.useState(initialState)\n}\n```\n\n생각보다 너무 단순하게 구성되어있는 내부 로직을 볼 수 있다. current값으로 받아와 useState값에 받은 값을 객체 안에 보관하고 있는 모습이다. 이것을 조금 더 구체적으로 구현하면 다음과 같다.\n\n```javascript\nfunction useState(initialValue) {\n  var _val = initialValue\n  function state() {\n    return _val\n  }\n  function setState(newVal) {\n    _val = newVal\n  }\n  return [state, setState]\n}\n```\n\nstate로 상태를 전달해주고, setState로 전달받은 새로운 값으로 상태를 변경한다. 클로저를 이용한 간단한 로직이지만, 이것으로 인해 리액트의 함수형 컴포넌트가 주를 이루게 되었다. 왜 hook이 나오기 이전 버전에서는 클래스 컴포넌트만 상태 관리가 가능했는지가 이해되었다.\n\n[참고]\n\n- [모던 자바스크립트 딥다이브](http://www.yes24.com/Product/Goods/92742567)\n\n- [poiemaweb](https://poiemaweb.com/js-execution-context)\n\n- [Deep dive: How do React hooks really work?](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)\n"},{"excerpt":"드디어 프리온보딩 코스의 마지막 과제가 되었다. 정리했던 NEXT JS를 공부한 내용과 과제를 하면서 해결해나간 에러들, 멘토님의 피드백을 받았던 부분들을 작성해 보고자 한다. 📜 과제 설명 마지막 과제는 일주일 동안 핀테크 기업의 관리자 서비스 페이지를 제작하는 것이었다. 회원가입/로그인 페이지와 메인 보드 페이지 두 가지 페이지를 제작해야 했다. 기술…","fields":{"slug":"/2022-11-19-원티드-프리온보딩-마지막 과제회고/"},"frontmatter":{"date":"November 19, 2022","title":"원티드 프리온보딩 마지막 과제회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n드디어 프리온보딩 코스의 마지막 과제가 되었다. 정리했던 NEXT JS를 공부한 내용과 과제를 하면서 해결해나간 에러들, 멘토님의 피드백을 받았던 부분들을 작성해 보고자 한다.\n\n# 📜 과제 설명\n\n마지막 과제는 일주일 동안 핀테크 기업의 관리자 서비스 페이지를 제작하는 것이었다. 회원가입/로그인 페이지와 메인 보드 페이지 두 가지 페이지를 제작해야 했다. 기술 스택은 typescript와 멘토님의 적극적인 권유로 처음으로 Next js를 이용했고, data fetching으로는 react query를 이용해 서버 데이터를 관리해, client 상태와 분리해서 관리했다.\n\n세부 부분은 총 5가지로 다음과 같이 정리할 수 있다.\n\n1. Next JS를 이용한 페이지 세팅\n2. 회원가입과 로그인 페이지와 에러핸들링\n3. react query를 이용한 CRUD\n4. Query string을 이용한 필터링 구현\n5. Pagination\n\n# 👓 Next JS\n\n<img width=\"800px\" src=\"https://velog.velcdn.com/images/jay/post/3a497590-d1b6-414c-9f3f-7b6c7eb18f6d/img.png\"/>\n\nNEXT JS를 처음 사용하면서 느낀 점은 CRA을 이용해서 react를 사용할 때와 \"너무 다르다\" 였다. 이 점은 프레임워크와 라이브러리의 차이에서 나온다고 생각되었다.\n\n## 📖 프레임워크와 라이브러리\n\n프레임워크와 라이브러리는 내가 작성하는 **코드가 어떻게 작동하냐**가 가장 큰 차이점이라 생각된다.\n\n라이브러리는 내가 사용한 코드에 따라 어떤 것을, 어떻게 사용할 지를 정하는 커스텀이 자유롭지만, 프레임워크는 반대로 프레임워크에서 정한 방식에 맞춰서 코드를 작성해야한다.\n\n예로 CRA에서는 자유롭게 어떻게 router 파일을 만들어서 관리할 지 app.tsx에 포함해서 관리할 지 등을 정할 수 있지만, Next js에서는 반드시 pages폴더 내부에서 사용해야하는 특징을 가진다.\n\n<img width=\"800px\" src=\"https://t1.daumcdn.net/cfile/tistory/2344774D577B359522\"/>\n\n그렇기 때문에 Next js를 사용할 때는 **Next js에서 정해놓은 방식을 잘 배워나가는 게 중요하다**.\n\n## 🥊 Next js 이용하기\n\n처음 사용해봐서 아직 너무 미숙하지만, 우선 프로젝트를 하면서 필요했던 부분들을 먼저 찾아보고 공부했다.\n\n### Routing\n\n항상 먼저 프로젝트를 할 때 어떻게 웹페이지를 구성하면 될지를 고민하고 Routing과 기본적인 파일들을 만드는 습관이 있어, Routing에 대해 가장 먼저 공부했다. 앞서 프레임워크와 라이브러리를 정리하면서 작성했듯이 **Pages 폴더 내의 파일**로 routing을 설정할 수 있다.\n\n이번 프로젝트를 하면서 필요했던 url에 따른 Next js 폴더 구조를 다음과 같이 표현할 수 있다.\n\n|     url      |         Next js         |\n| :----------: | :---------------------: |\n|      /       |     pages/index.tsx     |\n|    /login    |     pages/login.tsx     |\n|     /:id     |     pages/[id].tsx      |\n|  /register   |   pages/register.tsx    |\n|   /account   | pages/account/index.tsx |\n| /account/:id | pages/account/[id].tsx  |\n\n동적라우팅의 경우도 간단하게 [id].tsx파일을 만들어서 설정할 수 있어서 편리했다.\n\n### \\_app.tsx\n\n\\_app파일은 서버에 요청이 들어왔을 때 가장 먼저 실행되는 컴포넌트로 공통로직이나, 글로벌 스타일링을 정의할 수 있다.\n\n프로젝트에 필요한 context API의 provider와 react Query의 provider component를 감싸주었다.\n\n```tsx\n//_app.tsx\n\nfunction App({ Component, pageProps }: AppProps) {\n\t...\n\n  return (\n    <AuthProvider authService={authService}>\n      <InfoProvider infoService={infoService}>\n        <QueryClientProvider client={queryClient}>\n          <Hydrate state={pageProps.dehydratedState}>\n            <ReactQueryDevtools initialIsOpen={false} />\n            <Component {...pageProps} />\n          </Hydrate>\n        </QueryClientProvider>\n      </InfoProvider>\n    </AuthProvider>\n  );\n}\n\nexport default App;\n```\n\n### Next에서 localhost 서버와 client의 API 통신\n\n로컬의 서버와 client 통신을 하면서 에러를 만났다. 프론트서버는 localhost:3000으로, 백엔드서버는 localhost:4000으로 동작하는 상황에서 다른 port를 사용하다보니 api요청에 대해 cors 에러가 발생했다.\n\n<img width=\"800px\" src=\"https://user-images.githubusercontent.com/80830981/201516131-d6b06d3f-afd1-40ad-80cb-16b72fd95f47.PNG\"/>\n\npost man으로 localhost:4000으로 요청했을 때는 아무 문제가 없었는데...\n\n문제를 해결하기 위해 구글링을 했을 때 next.config.js의 rewrite를 해 3000 port로 요청을 보내지만, 4000 port으로 우회하는 방식으로 해결할 수 있었다.\n\n```ts\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n  async rewrites() {\n    return [\n      {\n        source: \"/:path*\",\n        destination: \"http://localhost:4000/:path*\",\n      },\n    ]\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n문제는 cors 에러는 해결했지만 나에게 잘 받아드려지지 않았다. 왜냐하면 client의 모든 요청이 4000 포트로 요청을 보내는 것으로 바뀌어버렸기 때문이다. 미리 설정해둔 url중에 로그인 페이지 주소인 `/login` 과 로그인을 위한 요청의 `https://localhost:4000/login`이 연결되어버려, login을 위한 post요청이 아닌 login 페이지의 html을 응답으로 전달받게 되었다. 매번 서버의 api주소와 페이지 url을 다르게 설정하고 프로젝트를 해야할 지 고민되는 중에, 같이 수강하시는 분께서 이슈로 올려놓은 내 질문에 답변을 감사히 달아주셨다..\n\n<img width=\"800px\" src=\"/assets/img/2022-11-13-원티드 프리온보딩 마지막 과제회고/image-20221120015748757.png\"/>\n\n간단히 source의 url을 `/api/:path`로 설정하면 됬다... 조금 간단하게 해결할 수 있는 부분이라 머쓱..하기도 했지만 검색을 3시간 하다가 해결한 거라 너무 감사했다.\n\n## 🖱 SEO\n\nSEO를 위해서 간단하게 NEXT의 Head컴포넌트를 이용해 Meta데이터를 넣을 수 있었다. 이전 과제에서 했던 방식보다 너무나도 간단했던 SEO처리였다...\n\n왜 SEO를 위해 NEXT를 써야하는지 조금 더 느꼈다.\n\n```tsx\nimport Head from \"next/head\"\nimport React from \"react\"\n\nexport default function SEO({ text }: { text: string }) {\n  return (\n    <Head>\n      <title>{text}</title>\n      <meta name=\"description\" content=\"마지막 과제입니다.\" />\n      <link rel=\"icon\" href=\"/favicon.ico\" />\n    </Head>\n  )\n}\n```\n\n### Next와 브라우저 API\n\n브라우저 API는 Next에서 CSR로 받은 이후에 사용할 수 있다. 몰랐던 나는 local storage를 당연히 그냥 이전처럼 사용했는데 에러를 만나게 되었다.\n\n<img width=\"800px\" src=\"./localstorage error.PNG\"/>\n\n이렇게 브라우저 요소를 사용하기 위해서는 window가 존재하는지 체크하는 로직으로 감싸주거나 useEffect를 이용해서 렌더링이 된 이후에 사용하게 할 수 있다. 토큰 관련 로직을 처리할때 useEffect내에서 localStorage에 접근하는 로직을 추가했다.\n\n```tsx\n//_app.tsx\n\nfunction App({ Component, pageProps }: AppProps) {\n\n    ...\n\n  useEffect(() => {\n    const token = localStorage.getItem('accessToken');\n    if (!token) {\n      router.push('/login');\n    }\n  }, []);\n\n  return (\n    ...\n  );\n}\n\nexport default App;\n```\n\n<br/>\n\n# ❗ 인증/인가 에러핸들링\n\n회원가입과 로그인 로직은 맨 처음과제할 때 처럼 동일한 Layout을 이용해 만들어서 UI를 구성하고 각각의 api 요청에 대해서 어떻게 응답이 주어지는 지를 먼저 정리했다.\n\n| 컴포넌트 | Status code     | 내용                                          |\n| :------: | --------------- | --------------------------------------------- |\n| 회원가입 | 400 Bad Request | 동일한 이메일이 이미 존재합니다.              |\n| 회원가입 | 400 Bad Request | incorrect Passoword                           |\n|  로그인  | 400 Bad Request | Email already exists                          |\n|  로그인  | 400 Bad Request | Password is too short (세글자이상)            |\n|  로그인  | 400 Bad Request | email format is invalid (적어도 @포함 세글자) |\n\n위의 정리된 내용에 적절한 에러 메시지를 전달하고 싶어서 우선 기존 사용해왔던 httpError 클래스의 getter를 두가지로 나눠서 설정했다.\n\n```tsx\nexport default class HTTPError extends Error {\n  constructor(\n    private statusCode: number,\n    public message: string,\n    private data?: string\n  ) {\n    super(message)\n  }\n  get signUpMessage() {\n    if (this.statusCode === 400) {\n      switch (this.data) {\n        case SIGN_UP_MESSAGE.email:\n          this.message = \"이메일 형식이 올바르지 않습니다\"\n          break\n        case SIGN_UP_MESSAGE.password:\n          this.message = \"4자이상의 비밀번호를 입력해주세요\"\n          break\n        case SIGN_UP_MESSAGE.duplicate:\n          this.message = \"이미 존재하는 계정입니다\"\n          break\n        default:\n          throw new Error(\"Unknown Error\")\n      }\n      return this.message\n    }\n    throw new Error(\"unknown Error\")\n  }\n\n  get signInMessage() {\n    switch (this.statusCode) {\n      case 400:\n        if (this.data === SIGN_IN_MESSAGE.password) {\n          this.message = \"비밀번호를 확인해주세요\"\n        } else if (this.data === SIGN_IN_MESSAGE.email) {\n          this.message = \"존재하지 않는 계정입니다\"\n        }\n        break\n      case 404:\n        this.message = \"잘못된 요청입니다. url을 확인해주세요\"\n        break\n      default:\n        throw new Error(\"Unknown Error\")\n    }\n    return this.message\n  }\n}\n```\n\n## AxiosInterceptor를 이용한 코드 중복 제거\n\n커스텀 에러클래스를 만든 후에 사용할 때 같은 에러처리하는 로직이 반복되는 문제를 발견했다.\n\n이후에 CRUD를 이용할 때도 많이 반복될 것 같아, 어떻게 처리할 지 고민하다가 axiosInterceptor를 이용한다면 클래스에서 에러를 처리하지 않고 한 곳에서 에러 처리를 한번에 정리할 수 있겠다는 생각이 들었다.\n\nhttpClient 클래스에서 axiosClient를 만들 때 constructor로 기본적인 error를 한 곳에서 처리하고 httpError클래스에서 세부 사항을 정리하면 더 좋은 코드가 될 것 같다는 생각으로 수정했다.\n\n```typescript\n//변경전\nexport default class AuthServiceImpl implements AuthService {\n  constructor(private httpClient: AxiosInstance) {}\n\n  async signUp({ email, password }: UserInfoType) {\n    try {\n      ...\n    } catch (error) {\n      if (error instanceof AxiosError) {\n        const { response } = error;\n        if (response) {\n          throw new HTTPError(\n            response?.status,\n            response?.statusText,\n            response.data\n          );\n        }\n      }\n    }\n\n    throw new Error('Server Error');\n  }\n\n  async signIn(userInfo: UserInfoType) {\n    try {\n      ...\n    } catch (error) {\n      if (error instanceof AxiosError) {\n        const { response } = error;\n        if (response) {\n          throw new HTTPError(\n            response?.status,\n            response.statusText,\n            response.data\n          );\n        }\n      }\n    }\n\n    throw new Error('Server Error');\n  }\n}\n\n//변경 후\n\nexport default class AuthServiceImpl implements AuthService {\n  constructor(private httpClient: AxiosInstance) {}\n\n  async signUp({ email, password }: UserInfoType) {\n    const response = await this.httpClient.post<AuthResponse>(\n      'api/users/signup',\n      { email, password }\n    );\n    const { data } = response;\n    return data;\n  }\n\n  async signIn(userInfo: UserInfoType) {\n    const response = await this.httpClient.post<AuthResponse>(\n      'api/login',\n      userInfo\n    );\n    const { data } = response;\n    return data;\n  }\n}\n\n//httpClient\n\nexport default class HttpClient {\n  httpClient: AxiosInstance;\n\n  constructor(private baseUrl: string) {\n    this.httpClient = axios.create({\n      baseURL: this.baseUrl,\n    });\n    this.httpClient.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        if (error instanceof AxiosError) {\n          const { response } = error;\n          if (response) {\n            const { status } = response;\n            throw new HTTPError(\n                response?.status,\n                response?.statusText,\n                response.data\n              );\n            }\n          }\n        }\n        throw new Error('Server Error');\n      }\n    );\n  }\n\t...\n}\n\n```\n\n## 🔑 JWT Token으로 다루기\n\n다음으로 문제가 된 부분은 로그인으로 받은 user의 JWT token을 어디에 보관하고 어떻게 관리할 지였다. 필요한 기능중에 로그인을 한 후에 새로고침시 로그인 상태가 유지되어야하기 때문에 access token을 local storage에 보관했다.\n\nlocalstorage를 이용해서 보관시에 XSS공격에 취약한 약점이 있다는 점을 알게 되어 좀 더 안전한 방식으로 하고 싶어서 여러가지를 검색하는 와중에 access token은 local Storage에 refresh token은 쿠키에 htmlOnly로 설정해서 사용하는 것을 알게되었다.\n\n하지만 json server 백엔드 서버로 진행하다 보니 access token만 존재하고 refresh token이 없고, 쿠키를 위해서 별도의 라이브러리들을 다운받아야해서 우선은 localstorage에 보관하는 방향으로 진행했다.\n\n### axiosInterceptor를 이용해 헤더에 토큰추가\n\n받은 토큰을 data Fetching 로직에 자동으로 header에 넣어주기 위해서 axiosInterceptor에서 넣어주었다. token은 로그인/회원가입에는 필요하지 않기 때문에 httpClient에서 토큰을 헤더에 넣는 withToken메소드를 추가해 필요한 부분에만 토큰을 포함하게 로직을 구성했다.\n\n```typescript\n//HttpClient.ts\n\nexport default class HttpClient {\n  httpClient: AxiosInstance;\n\n  constructor(private baseUrl: string) {\n    this.httpClient = axios.create({\n      baseURL: this.baseUrl,\n    });\n    this.httpClient.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        if (error instanceof AxiosError) {\n          const { response } = error;\n          if (response) {\n            const { status } = response;\n            if (status === 401) {\n              localStorage.removeItem(ACCESS_TOKEN);\n              localStorage.removeItem(USER_ID);\n              window.location.replace('/login');\n            } else {\n             ...\n            }\n          }\n        }\n        throw new Error('Server Error');\n      }\n    );\n  }\n\n  withToken() {\n    this.httpClient.interceptors.request.use((config) => {\n      const token = localStorage.getItem(ACCESS_TOKEN);\n      if (config.headers && token) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    });\n\n    return this.httpClient;\n  }\n}\n\n//_app.tsx\n\nfunction App({ Component, pageProps }: AppProps) {\n  const client = new HttpClient(process.env.NEXT_PUBLIC_BASE_URL || '');\n  const authService = new AuthServiceImpl(client.httpClient);\n  const infoService = new InfoServiceImpl(client.withToken());\n\t...\n}\n\nexport default App;\n\n\n```\n\n### 페이지 redirection\n\ntoken이 없을 때 자동으로 로그인으로 이동하게 하기위해 \\_app.tsx에 useEffect로 토큰의 유무를 확인하는 로직을 추가했다.\n\n그리고 토큰이 없는 상태에서 data fetching api를 호출시에 401에러가 발생했다. 이때 자동으로 로그인페이지로 이동 될 수 있게 에러핸들링 부분에 해당 에러처리를 추가했다.\n\n원래는 react-query의 data Fetching 로직에 토큰이 만료되고 호출시에 login으로 이동할 수있게 onError 옵션에 hook을 추가하려 했지만, 팀원분의 아이디어로 좀 더 빠른 시점에 에러처리가 될 수 있게 axiosInterceptor를 이용해 에러핸들링을 해주었다.\n\nhook으로 했을 때는 토큰이 없는 채로 호출시에 여러번의 에러메시지가 떴지만, axiosInterceptor를 통해 시점을 당겼더니 에러메시지가 한번만 보이고 좀 더 빠르게 페이지 이동이 가능했다.\n\n```tsx\n//_app.tsx\n\nfunction App({ Component, pageProps }: AppProps) {\n\n    ...\n\n  useEffect(() => {\n    const token = localStorage.getItem('accessToken');\n    if (!token) {\n      router.push('/login');\n    }\n  }, []);\n\n  return (\n    ...\n  );\n}\n\nexport default App;\n\n//httpClinet.ts\n\nconst ACCESS_TOKEN = 'accessToken';\nconst USER_ID = 'userId';\nexport default class HttpClient {\n  httpClient: AxiosInstance;\n\n  constructor(private baseUrl: string) {\n   \t...\n\n    this.httpClient.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        if (error instanceof AxiosError) {\n          const { response } = error;\n          if (response) {\n            const { status } = response;\n            if (status === 401) {\n              localStorage.removeItem(ACCESS_TOKEN);\n              localStorage.removeItem(USER_ID);\n              window.location.replace('/login');\n            } else {\n           \t\t...\n              );\n            }\n          }\n        }\n        throw new Error('Server Error');\n      }\n    );\n  }\n\n \t...\n}\n```\n\n<br/>\n\n# 🔍React-query를 이용한 CRUD 로직\n\n이전에 react-query를 이용할 때는 간단하게 해당 데이터를 받아오는 부분만 했다면 이번에는 **Patch, Delete, Create** CRUD에 필요한 모든 부분을 react-query로 함께 처리했다. 이러한 처리를 위해 react-query에는 `useMutation`이라는 api가 있고, 이러한 서버데이터의 변화가 생기면 현재 보고있는 데이터는 stale해지기 때문에 이전 데이터 대신 새로운 데이터를 받아와야한다. 이를 위해서 useMutaion에 onSuccess에 `invalidataeQueries`를 전달해 기존의 데이터 대신 새로운 데이터를 받아올 수 있게 설정했다.\n\nuseMutation을 사용할 때는 **어떤 함수를 실행할지**를 전달하고 인자는 useMutation 내부 메소드인 **mutate로 전달**해서 사용할 수 있었다.\n\n```typescript\n//useModifyUser.ts\n\nconst userDeleteMutation = useMutation(\n  async (userId: string) => {\n    return infoService?.deleteUser(userId)\n  },\n  {\n    onSuccess: () => {\n      queryClient.invalidateQueries([\"users\", page])\n    },\n  }\n)\nconst settingDeleteMutation = useMutation(\n  async (userId: string) => {\n    return infoService?.deleteUserSetting(userId)\n  },\n  {\n    onSuccess: () => {\n      queryClient.invalidateQueries([\"userSetting\", \"all\"])\n    },\n  }\n)\nconst nameMutation = useMutation(\n  async (info: { name: string; id: string }) => {\n    return infoService?.patchUserName(info)\n  },\n  {\n    onSuccess: () => {\n      queryClient.invalidateQueries([\"users\", page])\n    },\n  }\n)\n\n//userTableItem.tsx\n\nconst handleEdit = () => {\n  nameMutation.mutate({ id: item.id.toString(), name: userName })\n  toggleIsModifying()\n}\n\nconst handleDelete = () => {\n  userDeleteMutation.mutate(item.id.toString())\n  settingDeleteMutation.mutate(userSetting?.id.toString() || \"\")\n}\n```\n\n## ❗ 캐쉬 데이터가 사라지는 이슈 발생\n\nreact query를 잘 사용했다고 생각했지만 뜻밖에 에러를 만났다. useMutation으로 api 호출은 되고 서버에서도 데이터가 삭제, 수정, 생성이 되지만 UI로는 새롭게 fetching을 해오지 않는 문제였다. 왜그런지 확인하기 위해 직접 queryClient를 확인했을 때 기존에 queryMap에 존재하던 querykey들이 새로고침이나 같은 url을 바로 다시 접속했을 때 cache된 데이터가 모두 사라져버린 것을 확인할 수 있었다.\n\n[devtool에서 사라진 cache 데이터]\n\n<img width=\"800px\" src=\"https://user-images.githubusercontent.com/93697790/202516281-aee75db4-172e-4450-8833-2298902a8d5a.PNG\"/>\n\n<br/>\n<br/>\n 여러가지 방법을 고민하고 시도했다. 가장 먼저 시도한 방법은 React Query의 `keeppreviousdata`를 true로 설정하는 방법이었다. 이전 데이터를 새로운 데이터를 받아오기 전까지 보관하는 옵션이라 시도했지만 여전히 에러가 남아있었다.\n\n두번째로 시도한 방법은 react query의 기능 중 persistQueryClient를 이용해 localstorage에 데이터들을 저장하는 방법을 생각했다. 하지만 많은 데이터를 매번 localStorage에 저장하는 방법은 비효율적이라는 생각에 다른 방법을 찾아보기로 했다.\n\n블로그나 stackOverflow에서는 유사한 이슈를 찾을 수 없어, React Query github의 issue 페이지를 직접 검색해, 유사한 문제 상황을 담은 이슈를 6시간의 구글링 끝에, 포기직전에... 찾을 수 있었다.\n\n<img width=\"800px\" src=\"./image-20221120032953149.png\"/>\n\ncache된 데이터가 사라진 에러는 서버사이드 렌더링으로 같은 path로 이동 시에, react query가 페이지 이동을 인식하지 못해 생긴 문제였다. 이에 대한 해결방법으로 react query를 만든 Tk Dodo님이 올리신 codeSandBox 코드를 참고해 queryClient를 컴포넌트 밖에 선언해 전달하게 했더니 사라졌던 cache들이 모두 나오는 것을 확인할 수 있었다.\n\n <img width=\"800px\" src=\"./image-20221120033230974.png\"/>\n\n사실 혼자 에러를 해결하려했으면 포기했을지도 모르지만 팀원분들이 다같이 도와주셔서 오래걸렸지만 다행히 해결할 수 있었다. 한달동안 마주했던 에러를 해결한 여러순간들 중에서 가장 뿌듯하고 공식 레포에서 방법을 찾으려는 \"개발자스러운 해결방법\"을 시도한 게 너무 좋았다.\n\n## 멘토님의 피드백\n\nReact query로 받은 데이터를 정제하는 과정에서 select라는 옵션이 있다는 것을 멘토님께서 알려주셨다. 훨씬 응집도있는 코드가 되고 불필요한 변수선언이 없어 이후 프로젝트에 적용해 보려한다. 또한 key값의 경우 재사용할 때 일치시켜줘야하기 때문에 상수로 관리하는게 안전하다는 부분을 놓쳤다는 것도 알 수 있었다.\n\n<br/>\n\n```tsx\n//변경전\n\nconst { data: allUsers } = useQuery([\"users\", \"all\"], () => {\n  return infoService?.getAllUsers()\n})\nconst { data: allAccounts } = useQuery([\"accounts\", \"all\"], () => {\n  return infoService?.getAllAccounts()\n})\nconst user = allUsers?.find(item => item.id.toString() === id)\nconst accounts = allAccounts?.filter(item => item.user_id.toString() === id)\n\n//변경 후\nconst { data: user } = useQuery(USERS.ALL, infoService.getAllUsers, {\n  select: data => data?.find(item => item.id.toString() === id),\n})\nconst { data: accounts } = useQuery(ACCOUNTS.ALL, infoService.getAllAccounts, {\n  select: data => data?.filter(item => item.user_id.toString() === id),\n})\n```\n\n<br/>\n그리고 사용자의 전체 계좌를 세기 위해 빈 객체에 object의 key로 id를 주고 count하는 방법을 사용했는데 object의 불변성을 깨고 동적으로 key값을 할당하다보니 위험할 수 있는 로직이라는 피드백을 받았다. 코딩테스트를 자바스크립트로 할 때 문제만 풀면 된다는 생각으로 전혀 고려하지 못했던 부분이었다. 부족한 부분을 알게되어서 더 감사했고, reduce를 객체에서 사용하는 법을 새롭게 알게되었다.\n\n<br/>\n<br/>\n\n```typescript\n//변경전\n\nconst accountCount: AccountCountType = {}\naccountData.forEach(item => {\n  const id = item.user_id\n  if (!accountCount[id]) {\n    accountCount[id] = 1\n  }\n  accountCount[id] += 1\n})\n\n//변경 후\nconst accountCount: AccountCountType = accountData.reduce(\n  (allAcount: AccountCountType, account) => {\n    if (account.user_id in allAcount) {\n      allAcount[account.user_id]++\n    } else {\n      allAcount[account.user_id] = 1\n    }\n    return allAcount\n  },\n  {}\n)\n```\n\n<br/>\n\n# Query String을 이용한 상태관리\n\nselector를 이용해 필터링을 하는 부분은 이번 과제에서 또다른 메인 주제라고 생각이 되었다. 과제에서 새로고침을 해도 같은 페이지를 보여주어야 한다는 부분을 보면서 가장 먼저 떠올렸던 부분이었다. Query string은 Next의 API인 useRouter를 이용해서 간단하게 접근이 가능했다.\n\nuseRouter에는 다양한 요소가 담겨져 있는데 param을 담고 있는 route와 query를 담고 있는 query, useNavigation과 같이 페이지 이동을 할 수 있는 push가 method로 있기 때문에 간단하게 적용할 수 있었다.\n\n내가 특히 고민되었던 부분은 해당 상태를 url에 반영할 때 **이전 query값은 유지하면서 원하는 query만 수정할 수 있을까**였다. 그러기 위해서 먼저는 문자열을 수정하는 방식을 고민했지만 너무 복잡해지기 때문에 다른 방법을 고민하다가 urlSearchParams와 같이 router.push에 object로 query를 줄 수 있다는 것을 알게 되었다. 이를 활용해서 이전 query를 spread문법으로 받고, 수정할 부분만 overWriting하는 방식으로 해결할 수 있었다.\n\n<br/>\n\n<img width=\"800px\" src=\"./routing으로 select관리.PNG\"/>\n\nquery string을 상태로 생각해서 처리하다보니 전역상태가 크게 줄고, query와 UI가 동기화 되어있어, 항상 같은 url에 같은 UI를 가지는 장점이 너무 좋았다.\n\n# Pagination\n\nPagination을 만들어본 적이 없어서 많이 고민이 되었지만 다음과 같은 계산으로 진행했다.\n\n1. 전체 페이지수= Math.ceil(전체 아이템 갯수/ 페이지당 보여줄 갯수)\n2. 전체 index=Math.floor(totalPage / 페이지에 내가 보여줄 페이네이션 수)\n3. index에 따른 보여질 페이지 번호=[1, 2, 3, 4, 5].map((_item_) => index \\* 5+ item)\n\nindex 상태를 클릭에 따라 올려주고 내려줌으로써 페이지 번호를 관리하고 해당 page를 queryString로 관리했다.\n\n```tsx\nexport default function Pagination({ totalItems }: PaginationProps) {\n  const router = useRouter();\n  const { page } = router.query;\n  const [index, setIndex] = useState(0);\n  const pages = [1, 2, 3, 4, 5].map((item) => index * PAGENATION + item);\n  const totalPage = Math.ceil(totalItems / USER_NUM);\n  const isFirstIndex = index === 0;\n  const isLastIndex = index === Math.floor(totalPage / PAGENATION);\n  const currPage = page || '1';\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    const { name } = e.currentTarget;\n    if (name === PREV) {\n      setIndex((prev) => prev - 1);\n    } else if (name === NEXT) {\n      setIndex((prev) => prev + 1);\n    }\n  };\n\n  return (\n    <nav className=\"flex justify-center py-5\">\n      <ul className=\"inline-flex items-center -space-x-px\">\n        {!isFirstIndex && (\n          <button\n            className=\"px-3\"\n            name={PREV}\n            type=\"button\"\n            onClick={handleClick}\n          >\n            <AiOutlineArrowLeft />\n          </button>\n        )}\n\n        {pages.map((item) => {\n          if (item <= totalPage) {\n            return (\n              <li key={item}>\n                <Link\n                  href={% raw %}{{\n                    pathname: router.route,\n                    query: {\n                      ...router.query,\n                      page: item,\n                    },\n                  }}{% endraw %}\n                >\n                  {item}\n                </Link>\n              </li>\n            );\n          }\n        })}\n        {!isLastIndex && (\n          <button\n            name={NEXT}\n            type=\"button\"\n            onClick={handleClick}\n          >\n            <AiOutlineArrowRight />\n          </button>\n        )}\n      </ul>\n    </nav>\n  );\n}\n\n```\n\n<br/>\n\n# 😊 마치며\n\n드디어 길었던 한달의 프리온보딩 코스가 끝났다. 추상화와 관심사분리와 같은 깊이 있는 내용들과 typescript, react Query, Next js까지 새로운 뉴노멀이 되어가는 스택들도 경험할 수 있었다. 정말 참여하기 잘했다고 느꼈고, 이전에 혼자 하던 `실력있는 개발자란 뭘까?`, `좋은 코드란 뭘까?`라는 고민에 기준이 생기게 되었고, 팀원들의 코드를 보면서 다른 사람의 코드를 보는 눈, 다양한 공식문서를 읽을 수 있는 힘도 기르게 되었다.\n\n이제 남은 기간은 내가 얼마나 적용하고 더 성장하는냐에 달려있다. 많은 실패를 마주하고 새로운 것을 배우겠지만, 본질을 놓치지 않고 멘토님들처럼 배운 내용들을 이제 내가 누군가에게 전달하고 가르쳐 줄수 있는 날을 목표로 나아가고자 한다.\n"},{"excerpt":"👓 Next JS \nNext js는 typescript와 함께 프론트엔드의 뉴노멀이라고도 불리는 프레임워크로, 내가 관심이 갔던 대부분의 기업들에서 사용하고 있는 기술이다. 기술을 이해하기 위해서 먼저 웹의 역사를 먼저 정리해 보고, CSR과 SSR의 각각의 장단점과 둘의 방식을 합친 Universal Rendering을 정리해보고자 한다. 💿MPA(Mu…","fields":{"slug":"/2022-11-18-CSR과-SSR/"},"frontmatter":{"date":"November 18, 2022","title":"CSR과 SSR 그리고 Universal Rendering","tags":["NextJS","React","web","CSR","SSR","UniversalRendering"]},"rawMarkdownBody":"\n# 👓 Next JS\n\n![next](nextjs.png)\nNext js는 typescript와 함께 프론트엔드의 뉴노멀이라고도 불리는 프레임워크로, 내가 관심이 갔던 대부분의 기업들에서 사용하고 있는 기술이다. 기술을 이해하기 위해서 먼저 웹의 역사를 먼저 정리해 보고, CSR과 SSR의 각각의 장단점과 둘의 방식을 합친 Universal Rendering을 정리해보고자 한다.\n\n# 💿MPA(Multi Page Application)\n\nSSR (server-side-rendering)은 사실 CSR(Client Side Rendering) 보다 훨씬 오래된 렌더링 방식이다.\n\nMPA (Multi Page Application) 시절에는 서버로 우리가 원하는 url을 보내면 서버는 해당 url에 해당하는 html을 보내주고 브라우저는 렌더링 해주는 방식으로 사용되었다. Web의 발전과 Javascript의 발전으로 비동기 처리가 가능해 지면서, 기존의 MPA에서 가진, 업데이트 된 화면을 보여주기 위해 **새로운 HTML 전체를 받아 와야 하는 문제점**을 해결할 수 있었다. 여러 개의 페이지를 다 받아오지 않고 발전된 Javascript를 이용해 단 하나의 html만 받아 와서, Javascript로 동적으로 Dom 요소들을 변형하는 SPA (Single Page Application)방식이 시작되었다.\n\n![mpa](mpa.jpeg)\n\n# 📀CSR과 SSR\n\nSPA 의 큰 특징은 html을 하나만 받아오기 때문에, 새로고침을 하지 않고도 새롭게 반영된 화면을 받을 수 있다는 점으로, 사용자 경험이 향상될 수 있고, 전체를 받아오는 게 아니라 **바뀐 부분만** 수정하는 효율적인 렌더링 방식이다. 이렇게 서버와 분리되어 브라우저에서 javascript를 이용해 어떻게 웹페이지를 렌더링 할지 정하는 방식을 CSR (Client Side Rendering)이라고 하고, SPA를 이용한 CSR의 방법으로 React가 대표적인 라이브러리로 사용되고 있다.\n\nCSR을 이용하게 되면 서버는 하나의 html을 응답으로 주면 되기 때문에 **서버 부하가 적은 장점**과 javascript를 다 받아뒀기 때문에 이후 페이지 로드 시간이 짧은 장점을 가진다.\n\n이렇게 좋아 보이는 CSR은 2가지 큰 단점을 가지는데, 바로 SEO (Search Engine Optimization)와 첫 화면을 보여주기 까지 오랜 시간이 걸린다는 점이다.\n\n### SEO\n\nSEO는 구글이나 네이버의 검색에서 검색을 했을 때, 노출되는 것을 의미한다. 우리는 googling이란 단어가 생길 정도로 많은 정보를 검색 사이트를 통해서 얻는다. 그렇기 때문에 서비스를 검색엔진에게 잘 보여주고 사용자에게 자주 보여 줄 수 있는 것 자체가 너무나 중요하다. 검색엔진의 봇이 우리 서비스를 잘 크롤링할 수 있게 만드는 과정을 SEO라고 하고, 여기서 CSR이 큰 단점을 가진다.\n![seo](seo.png)\n\n앞선 과제에서 CSR에서 react-helmet과 react-snap을 이용해서 CSR에서 route에 맞는 html을 만들어 head부분에 넣을 부분들을 넣어주었지만 이렇게 해야 했던 근본적인 문제는 CSR이 하려 했던 효율적인 전략, **단 하나의 HTML을 이용해 Javascript로 동적으로 페이지를 만들려 하기** 때문이다. 단 하나의 HTML은 비어있어 우리가 동적으로 Javascript로 DOM요소를 넣어주기 때문에 검색엔진이 크롤링할 때는 아무것도 볼 수 없는 상태가 된다. 아무 정보를 주지 않으면 당연히 검색엔진은 아무것도 가져가지 못한다...\n\n### CSR의 렌더링 과정의 단점\n\nCSR은 FCP (First Contentful Paint) 와 TTI (Time To Interactive) 요소에서 큰 단점을 가진다. 왜냐하면 반복적으로 언급한 하나의 html에 Javascript로 페이지를 동적으로 만들기 때문이다. server에 먼저 Html을 요청 후 첫 번째 contents를 받아오는 시간 TTFB (Time To First Byte)는 비어있는 HTML이기 때문에 빠르지만, 이후 Javascript를 받아 오고 javascript를 실행하고, react를 실행해 Rendering이 시작되어 동적으로 DOM을 구성한다.\n\n그로 인해 FCP, 실제 화면을 보여 주는 데 시간이 오래 걸리고, 그로 인해 TTI, user의 이벤트에 반응하기까지 오랜 시간이 걸린다. 그렇기 때문에 javascript 번들 크기에 따라 사용자가 빈 화면을 오랜 시간 봐야 할 수 있는 큰 단점을 지닌다.\n![csr](csr.png)\n\n### CSR의 단점을 해결해 줄 수 있는 SSR?\n\n위의 언급한 단점들 SEO와 느린 FCP를 해결하기 위해 SSR을 사용할 수 있다. SSR은 SEO를 위해 각각 route에 해당하는 html을 가지고 있어, 해당 html을 서버가 응답해주기 때문에 검색엔진이 크롤링할 수 있는 장점을 가진다. 서버가 미리 만들어놓은 html을 먼저 제공하기 때문에 사용자가 빈 페이지에서 기다리는 게 아니라, 자바스크립트를 다운 실행 전 **먼저 그려진 페이지를 볼 수 있어** 빠른 FCP를 가지는 장점을 가지며, 서버에서 페이지 로직과 렌더링을 실행해 TTI도 빠르다.\n![ssr](ssr.png)\n\n하지만 역시 무조건 좋은 점만 가지는 것이 아니라 SSR도 단점이 존재한다. 내용이 차있는 html 페이지를 보내줘야 하기 때문에 CSR과 달리 TTFB가 느린 단점을 가지며, 서버에서 요청에 따라 주어야 하는 내용이 많아져 부하가 심해지는 단점도 가진다. 초기 html에 담아줘야 할 양이 많다면 오히려 페이지 로드에 단점을 가질 수 있다.\n\n역시 무조건 좋은 것과 무조건 안 좋은 것은 없다. 그렇다면 이 두 가지 중 \"어떤 걸 이용해야 할까?\" 라는 고민이 들 때, 각각의 장점을 이용하자는 방식인 **universal Rendering**이라는 방식이 있고 이 방법이 바로 NEXT js가 지원하는 방식이라는 것을 알게 되었다.\n\n# 😁Universal Rendering\n\n**Universal Rendering**은 Next JS가 지원하는 방식으로 SSR을 이용해 먼저 경로에 맞는 페이지를 만들어 전달한 후에 client에서 rehydration을 해 다시 렌더링하는 CSR의 방식을 이용하는, SSR과 CSR을 모두 사용하는 방식이다. CSR의 단점인 느린 FCP를 해결할 수 있는 장점이 있다.그럼 어떻게 두가지 방식을 사용하는 걸까?\n\n먼저 서버에서 렌더링할 내용을 만든 후에 해당 페이지를 문자열로 클라이언트에 넘겨준다. **(serialization)** 클라이언트는 넘겨받은 페이지에 자바스크립트 이벤트 요소를 연결하는 과정을 진행한다. **(hydration)**\n\n이러한 과정은 우리가 서버와 통신하는 과정과 유사한다. JSON을 이용해 통신할 때 JSON.stringfy로 된 내용을 전달한 후에 전달 받아서 client에서 사용할 때는 JSON.parse를 이용해 파싱해준다. 이때 함수는 전달할 수 없는 특징을 가진다,\n\nuniversal rendering에서도 이와 동일하게 서버에서는 해당 페이지 내용을 html 페이지를 문자열로 전달해주고, client에서는 전달받은 html 문자열을 이용해 페이지를 만들고, 적절한 함수와 이벤트를 붙여준다. 이렇게 두가지 일이 분리되어 있기 때문에 javascript번들 크기가 클 경우에는 화면은 SSR처럼 먼저보이지만 TTI는 늦어지는 단점을 가질 수 있다.\n\n![universal](universal.webp)\n\n# 마치며\n\n역시 완벽한 기술은 없다. 항상 상황에 맞는 알맞은 기술이 존재할 뿐이다는 걸 느낀다. 그리고 개발자는 그 상황에 맞는 기술을 사용할 줄 아는 게 중요하다고 생각된다. 서버와 클라이언트를 이 과정을 이해하는 중요성을 너무 느낀 시간이었다. 이제 직접 과제에 NEXT js를 써보려 한다.\n\n- [mpa와 spa](https://lvivity.com/single-page-app-vs-multi-page-app_)\n- [csr과 ssr](https://rockcontent.com/blog/client-side-rendering-vs-server-side-rendering/)\n- [web vital과 csr,ssr](https://velog.io/@yrnana/%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EB%A9%94%ED%8A%B8%EB%A6%AD#csr-client-side-rendering)\n- [csr,ssr,ssg](https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg)\n"},{"excerpt":"📜 과제 설명 이번 과제는 간단하게 하나의 페이지로 되어있고 검색창과 검색어 추천 기능을 구현하는 과제였다. 검색창을 UI로 구현한 후에 검색창에 입력에 따라 관련된 추천 검색어를 api를 이용해 받아와 보여주면 되는 간단해 보였던... 하지만 하나하나 공부할 게 많았던 유익한 과제였다. 세부 부분은 총 4가지로 다음과 같이 정리할 수 있다. 추천 검색어…","fields":{"slug":"/2022-11-11-원티드 프리온보딩-3-1-과제-회고/"},"frontmatter":{"date":"November 11, 2022","title":"원티드 프리온보딩 3-1 과제회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n# 📜 과제 설명\n\n이번 과제는 간단하게 하나의 페이지로 되어있고 **검색창과 검색어 추천 기능**을 구현하는 과제였다. 검색창을 UI로 구현한 후에 검색창에 입력에 따라 관련된 추천 검색어를 api를 이용해 받아와 보여주면 되는 간단해 보였던... 하지만 하나하나 공부할 게 많았던 유익한 과제였다.\n\n세부 부분은 총 4가지로 다음과 같이 정리할 수 있다.\n\n1. 추천 검색어에서 키워드 볼드처리\n2. API호출한 결과를 로컬 캐싱\n3. 입력마다 api호출을 하지 않게 api 호출 횟수를 줄이기\n4. 키보드 만으로 추천 검색어로 이동하게 하기\n\n저번과 달리 React Query를 사용하지 않았는데, 이유는 React Query를 사용하면 자동으로 서버 데이터를 로컬 캐싱할 수 있기 때문에 제한되었고, Typescript를 기반으로 진행했다.\n\n# 🎈 전역상태에 대한 고민\n\n특별히 이번과제를 하면서 신경썼던 부분은 **전역상태**였다. 당연히 고민해야할 부분이지만 저번 과제를 피드백을 받으면서 전역상태를 어떻게 관리해야 하는지 디테일하게 알게 되었다. 저번 과제에서 마지막에 react query를 이용해 리팩토링을 하면서 서버의 데이터를 받은 후에 다시 context API를 이용해 전역상태로 넘겨주는 방식으로 사용했다. 멘토님께서 **Server State를 다시 Client State로 다룰 이유가 없다**고 말씀해주셨다.\n\n**Server State와 Client State**, 처음 생각해본 주제였다. 당연히 server에서 받아온 데이터를 사용하려면 client의 전역상태로 받아서 사용해야한다고 생각했었다. server State와 client State는 어떻게 다른걸까?\n\n## Server state와 Client state\n\n둘의 차이에 대해서 찾아보면서 [React Query와 상태관리 :: 2월 우아한테크세미나](https://www.nashu.dev/content-a-day/20220222/react-query) 글을 읽으면서 이해하게 되었다.\n\n**Client State**\n\n- client에서 관리하는 상태\n- 다른 사람과 공유하지 않고 client 화면에서 사용자와 interaction으로 변화가능\n- client 에서 최신으로 관리됨\n\n**Server State**\n\n- server에서 관리하는 상태\n- fetch와 같이 네트워크 api가 필요함\n- 다른 사람과 공유하는 데이터로 변경된 데이터를 사용자가 알 수 없을 수 있음\n\n둘의 가장 큰 차이점은 **데이터를 관리하는 주체가 누구냐**에 있다. 그렇기 때문에 이전 방식처럼 api를 호출한 후에 결과를 로컬의 전역상태로 관리한다면 사실은 서버의 데이터가 바뀌었을 때 반영하기 어려운 문제가 존재했다. 그리고 이런 부분을 해결하기 위한 라이브러리들 만의 방법이 있지만 **react Query**를 이용하면 stale time와 같은 option들을 이용해 시간을 정해 새로 받아올 수 있고, 자동 로컬 cahche기능도 제공하기에 **Server state와 Client state** 를 구분해서 관리할 수 있다는 큰 장점을 갖게된다. 이제야 react query의 필요성을 제대로 이해할 수 있게 되었고, 다음 step으로 그럼 어떤걸 client의 전역상태로 관리해야할까?\n\n## **어떤 기준**으로 전역상태를 선택할까?\n\n**Server state와 Client state** 를 구분하고 나니 내가 생각해왔던 전역 상태의 기준이 흔들렸다. 어떤 기준으로 전역상태를 선택하면 될지가 다음 고민으로 이어졌다. 해답은 context API를 이용하는 이유와 동일했다, Prop-drilling을 막기 위해. 반복적으로 상태를 전달해주는 경우 내 기준은 2번 이상의 component를 거쳐서 전달해줘야한다면 하나의 client 전역상태로 관리하면 좋겠다는 기준이 생겼다. 그러면 전역상태를 관리하는 방법은 contextAPI, redux, recoil과 같은 라이브러리가 다일까?\n\n## Query String: 잊혀진 전역상태\n\n상태관리라 하면 contextAPI나 redux와 같은 라이브러리만을 떠올렸지만, 이번 수업시간에 하나의 전역상태 관리방법으로 **Query String**에 대해 멘토님께서 알려주셨다. 가장 기본적인 요소이지만 고민하지 못했던 부분이었다. 우리가 쇼핑몰 사이트에서 여러가지 필터(키, 옷 종류 등)를 적용한 후에 친구에게 공유한다고 했을 때 화면과 url이 동기화 되어있지 않다면 친구가 보는 화면은 내가 보여주고 싶어했던 페이지와는 다른 페이지 될 것이다.\n\n이렇게 query String을 하나의 전역상태로 생각해 query String에 따라 화면을 렌더링할 수 있고, 이러한 방법은 세부적인 필터나, 입력값을 관리할 때 유용하다는 것을 알게 되었다.\n\n(실제 구글 검색창에 내용을 입력한 후에 구글의 url을 보면 반영되어 있는 것을 볼 수 있다)\n\n<img width=\"1000\" src=\"./그림1.png\"/>\n\n이번 과제를 하면서 원래는 keyword라는 전역상태를 만들고 input의 값이 변화할 때마다 keyword상태를 변화시켜 api를 호출하려 했지만, **query String을 바꿈으로써 query에 따라 api를 호출하는 방식으로 상태관리를 해보면 어떨까**라는 생각으로 프로젝트를 진행했다.\n\n처음에 useParams를 이용하면 query String을 받아올 수 있을까 했지만 useParms로 받아올 수 있는 것은 말그대로 paramter, /:id라면 id값만 받아올 수 있었다. query string을 받아오기 위해서는 **window.location**을 이용하거나 react-router-dom의 **useLocation**을 이용해서 path를 받고 별도의 qs 라이브러리를 이용해 object로 만든 후에 받아오는 방법도 있었다. 하지만 추가적인 라이브러리없이, 간결하게 사용하고 싶어 **useSearchParam**이라는 react-router-dom의 메소드를 이용했다.\n\nuseSearchParam은 useState처럼 배열의 첫 요소는 현재 url의 파람이 담겨있고, 두번째 요소는 param을 변경할 수 있는 setState와 같은 함수가 담겨있다. 값만 받아오면 되기 때문에 첫요소의 메소드인 get으로 해당 query string을 받아 하나의 상태로 관리했다.\n\n```tsx\nimport { useSearchParams } from \"react-router-dom\"\n\nconst useQueryString = () => {\n  const [params] = useSearchParams()\n  const query = params.get(\"q\") || \"\"\n  return query\n}\n\nexport { useQueryString }\n```\n\n<br/>\n\n# 💾 로컬 캐싱\n\n이번 과제의 핵심적인 부분중 하나였던 로컬 캐싱을 할 수 있는 방법으로 **HTTP cache-control**, **local Storage**, **Session Storage** 세가지에 대해서 고려했고, **Session Storage**를 이용하기로 결정했다.\n\n## HTTP cache-control\n\nHTTP cache-control은 api호출 후에 받아온 데이터를 저장한 후에 이후 같은 데이터를 요청했을 때 새로 api를 호출하는 것이 아니라, cache되어 있는 데이터를 가져올 수 있는 방법으로, 서버 state의 변화를 확인하고 가져올 수 있어 가장 좋은 방법이라 생각되었다. 네트워크 상에서는 cache data의 경우 데이터 크기가 작고, 서버의 응답이 200과 304로 구분되어 표시되었지만, client에서의 서버 응답이 모두 동일하게 200 OK로 들어와 cache된 데이터인지 확인하기 어려운 문제가 있었다.\n\n[서버의 응답]\n\n<img width=\"1000\" src=\"https://user-images.githubusercontent.com/109899564/200900602-0eae83d9-859b-4dc9-90e6-fcbb22c60bc0.png\"/>\n\n[client가 받은 서버의 응답]\n\n<img width=\"1000\" src=\"https://user-images.githubusercontent.com/109899564/200901207-d39c5867-eb02-4366-a291-713536dbf30f.png\"/>\n\n## Browser Storage\n\n다음으로 브라우저 내의 storage를 이용하는 방식을 고려했다. 서버의 데이터를 브라우저로 가져와서 client에서 저장하다보니 **서버의 데이터 변화를 알 수 없는 단점**이 존재한다. 그렇기 때문에 브라우저에 닫아도 계속해서 저장하는 local storage가 아니라 브라우저를 닫으면 저장된 데이터를 초기화하고, 새로운 api 호출을 하는 **session storage**를 이용하는 게 더 적절한 선택이라 생각되었다.\n\nsession storage를 처음 써봤지만 local Stoarge와 동일한 method라 사용법은 간단했고, 저장할 때는 JSON.Stringfy를 받아올 때는 JSON.parse를 이용해 변화해줘야했기 때문에 CacheService class를 만들어 사용했다.\n\n```typescript\nexport default class CacheService {\n  static setData = (query: string, words: SearchType[]) => {\n    const stringifyWord = JSON.stringify(words)\n    sessionStorage.setItem(query, stringifyWord)\n  }\n\n  static getData = (query: string) => {\n    const data = sessionStorage.getItem(query)\n    const parsedData: SearchType[] = JSON.parse(data || JSON.stringify([]))\n    return parsedData\n  }\n}\n```\n\n다른 팀의 코드에서 map을 이용해 로컬 캐싱을 구현한 부분을 보면서 이렇게 구현할 수도 있었겠구나 느끼기도 했다.\n\n```typescript\nconst myCache = new Map()\n\nexport const setMyCacheData = <T>(key: string, data: T) => {\n  const value = { data, expired: new Date().getTime() + 5000 }\n  myCache.set(key, value)\n}\n\nexport const getMyCacheData = (key: string) => {\n  if (myCache.has(key)) {\n    if (myCache.get(key).expired > new Date().getTime()) {\n      return myCache.get(key).data\n    } else {\n      myCache.delete(key)\n    }\n  }\n\n  return null\n}\n```\n\n<br/>\n# 🎨키워드 Bold 처리\n\n키워드는 queryString을 이용해서 간단하게 가져올 수 있었지만 api 데이터에서 해당 query를 bold처리하기 위해서는 별도의 방법을 고민해야했다. string을 tag로 바꿔줘야했기 때문에 관련 내용을 찾아보았더니 가장 먼저 나온건 `dangerouslySetInnerHTML`이었다. 이름부터 쓰지말라는 것 같아 왜 사용하면 안되는지 먼저 찾아보니, 문자열을 태그로 바꿀 수 있다는 것은 사용자가 임의로 script를 삽입할 수 있다는 보안문제가 존재했다.\n\n이를 보완하기 위해 우선 문자열 내의 query부분을 기준으로 split으로 array를 만들어 키워드가 있는 index에만 `<b></b>`로 감싸주는 방식으로 해결했다. 키워드를 기준으로 자르기 때문에 항상 키워드는 두번쨰에 존재해 쉽게 처리할 수 있었다.\n\n```tsx\n//splitByKeyword.ts\nconst splitByKeyword = (query: string, text: string) => {\n  if (text.toUpperCase().includes(query.trim().toUpperCase())) {\n    return text.split(new RegExp(`(${query})`, 'gi'));\n  }\n};\n\nexport { splitByKeyword };\n\n//searchItem.tsx\n\nconst KEYWORD_INDEX = 1;\n\nconst SearchItem = ({\n ...\n}: SearchItemProps) => {\n\n  const query = useQueryString();\n  const textArray = splitByKeyword(query, text);\n\n  return (\n    <Link to={`/search?q=${text}`}>\n      <S.Wrapper ref={itemRef} active={active} onMouseEnter={handleMouseEnter}>\n        <BsSearch />\n        <span>\n          {textArray?.map((item, idx) => {\n            if (idx === KEYWORD_INDEX) {\n              return <b key={item}>{item}</b>;\n            }\n            return item;\n          })}\n        </span>\n      </S.Wrapper>\n    </Link>\n  );\n};\n\nexport default SearchItem;\n```\n\n<br/>\n\n# ✨Debouncing과 Throttling\n\n입력마다 API호출하지 않도록 호출 횟수를 줄이는 방법을 찾아보다가 Debouncing과 Throttling에 대해 알게 되었다. 사실 이전 무한 스크롤을 구현하는 과제에서 scroll event를 이용해 구현했을 때 생기는 문제를 해결하는 방법으로 Debouncing과 Throttling있다는 점을 본 적이 있었다. 하지만 그때는 Intersection Observer API를 이용했어서 크게 공부를 안했지만 이번기회에 제대로 공부해보고자 했다.\n\n## Debouncing\n\nDebouncing은 자주 발생하는 이벤트를 원하는 시점의 이벤트를 기준으로 일을 처리하는 방식이다. 이번과제에서는 input의 onChange로 인해 생기는 이벤트에 따라 api를 호출해서 추천 검색어를 받아와야했다. 만약에 모든 event에 대해서 api를 불러온다면 불필요한 API 호출이 생기기 때문에 onChange의 event 중 사용자가 입력을 마쳤을 때의 input value를 api로 호출하는게 더 효율적인 방법이 되었다. 이를 구현하기 위해서 마지막으로 입력된 값을 api로 전달하는 debounce방식을 이용했다.\n\n```typescript\nuseEffect(() => {\n  if (query) {\n    if (NO_SESSION_ITEM) {\n      dispatch({ type: \"SET_DATA\", data: cachedItem })\n    } else {\n      const debounce = setTimeout(() => {\n        getResponse()\n      }, DELAY_TIME)\n      return () => clearTimeout(debounce)\n    }\n  }\n}, [query])\n```\n\nsetTimeout을 이용해 delay time 뒤에 전달해준 callback 함수를 실행하게 하는데, 이때 input의 입력으로 query가 바뀌면 이전 실행대기중이던 debounce 함수는 clearTimemout으로 인해 사라지게 되고 마지막으로 전달해준 값만 실행시키는 방식으로 debouncing을 구현했다.\n\n## Throttling\n\nThrottling은 일정 시간을 두고 시간 안의 하나의 이벤트만을 처리하는 방식이다. debouncing과 다른 점으로 정해진 시간내에 다른 입력이 들어와도 무시하고 정해진 시간이 지난 이후에 다시 이벤트를 받아 실행시킨다는 점이다. 둘을 정리하면 주기적으로 이벤트를 발생시키는 것이 Throttling, 처음이나 끝에 들어온 이벤트만을 처리하는 방식이 Debouncing으로 이해할 수 있다.\n\ndebouncing은 검색과 같이 시점의 결과가 중요할 때 사용하고, throttling은 무한 스크롤과 같은 과제에서 성능개선을 위해 사용할 수 있다. 이번기회에 제대로 이해할 수 있어 좋은 기회가 되었다.\n\n<br/>\n\n# ⌨ 키보드만으로 추천검색어로 이동가능하도록 구현\n\n키보드만으로 추천검색어들로 이동하기 위해, 추천 검색어 **리스트 배열의 index와 keydown, keyup event**를 이용했다.\n\nwindow의 keydown, keyup Event를 사용해 화면에서 방향키를 눌러 바로 추천검색어 리스트로 이동이 가능하게 해, 변화된 index와 searchItem의 index가 같을때 해당 searchItem 컴포넌트의 배경색을 변화시켜 현재 위치를 UI로 알 수 있게 했다.\n\n추천 검색어 리스트 배열의 자료 양이 많아지면 scroll이 생기고 container 크기 밖의 item이 보이지 않는 문제점이 있었다. 이를 해결하기 위해서 scrollIntoView 메소드를 이용해 해당 아이템의 위치로 자동으로 스크롤이 될 수 있게 했다.\n\n마우스이동과 키보드이동이 호환이 가능할 수 있게 하기 위해서 mouse Event에 따라서도 index가 변할 수 있게 했는데, 처음에 mouseMove 이벤트를 이용했더니 너무 많은 이벤트가 발생해 당황하기도 했다. 마우스가 해당 item에 올라왔을 때만 index를 바꿔주면 되니까 mouseEnter로 해결할 수 있었다.\n\n적절한 이벤트 선택이 중요하다는 것도 배울 수 있는 기회였다.\n\n```tsx\n//useKeyboard\nimport { useState, useEffect } from 'react';\n\ntype KeyType = 'ArrowDown' | 'ArrowUp' | 'Enter';\n\nconst useKeyPress = (targetKey: KeyType) => {\n\nconst [keyPressed, setKeyPressed] = useState(false);\n\nconst downHandler = (event: KeyboardEvent) => {\n  const { key } = event;\n  if (key === targetKey) {\n    setKeyPressed(true);\n    }\n  };\n\nconst upHandler = (event: KeyboardEvent) => {\n  const { key } = event;\n  if (key === targetKey) {\n    setKeyPressed(false);\n    }\n  };\n\nuseEffect(() => {\n  window.addEventListener('keydown', downHandler);\n  window.addEventListener('keyup', upHandler);\n\n  return () => {\n    window.removeEventListener('keydown', downHandler);\n    window.removeEventListener('keyup', upHandler);\n   };\n });\n\nreturn keyPressed;\n};\n\nexport { useKeyPress };\n\n//SearchItem.tsx\nconst KEYWORD_INDEX = 1;\n\nconst SearchItem = ({\n active\n ...\n}: SearchItemProps) => {\n  const itemRef = useRef<HTMLLIElement>(null);\n\n  const handleMouseEnter = () => {\n    setIsMovingMouse(true);\n    setCursor(index);\n  };\n  useEffect(() => {\n    if (active && !isMovingMouse) {\n      itemRef.current?.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n      });\n    }\n  });\n  return (\n    <Link to={`/search?q=${text}`}>\n      <S.Wrapper ref={itemRef} active={active} onMouseEnter={handleMouseEnter}>\n        <BsSearch />\n        <span>\n          {textArray?.map((item, idx) => {\n            if (idx === KEYWORD_INDEX) {\n              return <b key={item}>{item}</b>;\n            }\n            return item;\n          })}\n        </span>\n      </S.Wrapper>\n    </Link>\n  );\n};\n\nexport default SearchItem;\n\n```\n\n<br/>\n\n# 😀 마치며\n\n이제 마지막 과제만을 앞에 두고 있다. 다음주면 한달간의 과정이 끝나고 진짜 지원을 하게되는데 걱정되고 두렵기도 하다. 하지만 배운 내용을 통해 넓혀진 시야와 다른 사람들의 코드를 보면서 배운 더 좋은 코드들을 내가 해왔던 프로젝트들에 적용해 간다면 분명 더 큰 경쟁력과 힘이 될 것 같다는 자신감도 생긴다. 공부할 건 많지만, 조급한 마음보다 기쁜 마음으로 배워가는 태도를 유지해가자.\n"},{"excerpt":"📜 과제 설명 이번 과제는 이번 기간에 참가한 기업의 과제는 아니지만 이전 기수에서 주어졌던 과제로, 멘토님께서 좋은 과제라 생각하셔서 넣으셨다고 했다. 기업은 광고 회사로 광고와 마케팅과 관련된 데이터들을 보여 주는 대시보드와 관리 페이지를 만드는 과제였다. 난생 처음 보는 용어들과 너무 디테일 하게 구성되어있는 피그마 페이지 때문에 여태 까지 과제들 …","fields":{"slug":"/2022-11-07-원티드 프리온보딩-2-2-과제-회고/"},"frontmatter":{"date":"November 07, 2022","title":"원티드 프리온보딩 2-2 과제회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n# 📜 과제 설명\n\n이번 과제는 이번 기간에 참가한 기업의 과제는 아니지만 이전 기수에서 주어졌던 과제로, 멘토님께서 좋은 과제라 생각하셔서 넣으셨다고 했다. 기업은 광고 회사로 광고와 마케팅과 관련된 데이터들을 보여 주는 **대시보드와 관리 페이지**를 만드는 과제였다. 난생 처음 보는 용어들과 너무 디테일 하게 구성되어있는 피그마 페이지 때문에 여태 까지 과제들 중에서 가장 힘든 과제가 되었다...\n\n저번과 동일하게 **Typescript**와 **Context API, useReducer**를 활용해 상태 관리를 했다. 그래프를 위해서는 APEXCHART 라이브러리, 날짜 변경을 위해서는 reat-picker 라이브러리를 이용해 진행했다. 이번에 과제를 하면서 시도해보고 싶었던 것은 두 가지로, 수업을 통해 배웠던 **관심사 분리**와 **redux**를 이용한 전역 상태 관리였다. 하지만 기능 구현에도 너무 많은 시간이 들어, redux를 시도할 시간이 없이 빠르게 ContextAPI를 이용해 전역 상태를 관리했다.\n\n## 🎈 관심사 분리\n\n관심사 분리는 좋은 코드를 작성하기 위한 기준이 되어 준다. **KISS (Keep it simple stupid)**라고 불리는 원칙은 하나의 모듈이 하나의 기능만을 하게하라는 뜻이다. 처음에 생각했을 때 하나의 모듈이 여러가지 기능을 하게 되면 더 좋지 않을까 라는 생각을 했지만, 문제가 생겼을 때 여러 기능이 엉켜 있다면 해당 문제를 해결하려다 다른 기능이 영향을 받는 일이 생기게 된다. 이러한 상태를 흔히 \"스파게티 코드\"라고 불린다.\n\n사실 함수를 배우면서 하나의 기능만 하게 해야 한다는 원칙은 너무 많이 들어왔지만, 나중에 내가 했던 프로젝트의 코드를 돌아보면 도저히 손댈 수 없이 엉켜있는 것을 보게 된다. 이러한 하나의 모듈이 하나의 기능만 하기 위해서는 서로 다른 관심사를 하나에 두지 않는 **관심사 분리**가 필요하다. 내가 좋아하는 자바스크립트는 멀티 패러다임 언어이기 때문에, 함수형 프로그래밍과 객체지향 프로그래밍 두 가지 모두 가능해, **class**로 모듈을 나누고, 필요한 곳에 사용할 수 있게 전달 **(Dependency Injection)**하면 사용하는 곳에서는 어떻게 구성되어있는지 자세히 알지 못해도 사용할 수 있는 **추상화**가 된 모듈들로 연결해 나갈 수 있다.\n\n이전에 class를 사용할 때 하나의 기능을 하는 관련된 것들을 모아두자는 기준으로 index.tsx에서 instance를 만들어 전달하는 방식을 알고는 있었지만 사용하는 곳까지 계속해서 prop으로 전달하는 방식을 이용했다. 이러한 방식은 똑같이 prop-drilling이 발생하게 되고 오히려 더 복잡하게 되는데, 이때 사용할 수 있는 게 이전에 배웠던 context API였다.\n\n그리고 Typescript는 자바스크립트보다 강력한 객체지향 프로그래밍의 기능들을 담고 있다. Typescript의 **interface**는 우리가 만들고자 하는 모듈의 명세서로 어떠한 상태와 행동들을 하는 모듈인지 정하고, 그것을 implements하는 class를 만들 수 있다.\n\n### 📖 Interface\n\n이번 과제에서 만들었던 class는 두가지 광고 데이터를 api로 불러오는 모듈이 필요했다. 그래서 interface는 다음과 같은 두 가지 함수를 가지고 있다.\n\n```typescript\ntype GetAdListResponse = {\n  ads: AdType[]\n  counts: number\n}\n\ntype GetTrendResponse = {\n  report: {\n    daily: TrendType[]\n  }\n}\n\ninterface AdService {\n  getAdList: () => Promise<GetAdListResponse>\n  getTrend: () => Promise<GetTrendResponse>\n}\n```\n\nAPI 통신을 위한 class이므로 각 메소드는 통신결과인 promise를 반환하고 promise 내부의 데이터 타입을 정해주면 interface를 작성할 수 있다.\n\n### 📁 Class\n\n우리가 정의한 interface를 구현하는 class인 AdserviceImpl를 다음과 같이 만들 수 있다.\n\n```typescript\nimport { AxiosError, AxiosInstance } from \"axios\"\nimport {\n  AdService,\n  GetAdListResponse,\n  GetTrendResponse,\n} from \"models/interface\"\nimport HTTPError from \"../network/httpError\"\n\nconst AD_LIST_URL = \"/ad-list-data-set.json\"\nconst AD_TREND_URL = \"/trend-data-set.json\"\n\nclass AdServiceImpl implements AdService {\n  constructor(private axiosInstance: AxiosInstance) {}\n\n  getAdList = async () => {\n    try {\n      const { data } = await this.axiosInstance.get<GetAdListResponse>(\n        AD_LIST_URL\n      )\n      return data\n    } catch (error) {\n      const { response } = error as unknown as AxiosError\n      if (response) {\n        throw new HTTPError(response?.status, response?.statusText)\n      }\n      throw new Error(\"Unknown Error\")\n    }\n  }\n\n  getTrend = async () => {\n    try {\n      const { data } = await this.axiosInstance.get<GetTrendResponse>(\n        AD_TREND_URL\n      )\n      return data\n    } catch (error) {\n      const { response } = error as unknown as AxiosError\n      if (response) {\n        throw new HTTPError(response?.status, response?.statusText)\n      }\n      throw new Error(\"Unknown Error\")\n    }\n  }\n}\n\nexport default AdServiceImpl\n```\n\n이전부터 항상 사용해오던 HTTPError class는 원하는 에러메시지를 커스텀할 수 있게 하는 정도로 사용했지만 에러가 다양해지고 복잡해지면 class에 내용만 추가하면 되니까 훨씬 유지 보수에 유용할 것이란 예상을 할 수 있다.\n\n```typescript\nexport default class HTTPError extends Error {\n  constructor(private statusCode: number, public message: string) {\n    super(message)\n  }\n\n  get errorMessage() {\n    switch (this.statusCode) {\n      case 404:\n        this.message = \"잘못된 요청입니다. url을 확인해주세요\"\n        break\n      default:\n        throw new Error(\"Unknown Error\")\n    }\n    return this.message\n  }\n}\n```\n\n### 💊 Dependency Injection\n\n위의 만든 AdService를 사용하기 위해서는 instance를 만들고 instance를 context API로 전달해주면 필요한 곳에서 편하게 사용할 수 있다. typescript로 contextAPI로 instance를 전달할 때 어떻게 type을 전달해야 할 지 해결하는 와중에, 우리가 **정의한 interface**를 그대로 전달해주면 type을 간단하게 정해줄 수 있다는 점을 알게 되었다. interface를 기준으로 class를 만드는 **의존성 역전 원칙**을 이해하는 경험이었다.\n\n[adService의 type을 interface로 전달해주기 전의 에러]\n\n<img width=\"800\" src=\"./context에 class instance를 넣으려하니 생긴에러.PNG\"/>\n\n여기서 조금 주의할 부분은 전달하면서 instance가 this를 잃어버린다는 점이다. 그래서 bind로 adService를 binding을 해주거나, method 자체를 **arrow function**으로 바꾸게 되면, this binding 문제를 해결할 수 있다.\n\n```tsx\n//index.tsx\nconst BASE_URL = process.env.REACT_APP_BASE_URL || \"\"\nconst axiosInstance = createAxiosClient(BASE_URL)\nconst adService = new AdService(axiosInstance)\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement)\n\nroot.render(\n  <React.StrictMode>\n    <AdServiceProvider adService={adService}>..</AdServiceProvider>\n  </React.StrictMode>\n)\n\n//AdServiceContext.tsx\nimport { AdService } from \"models/interface\"\nimport { createContext, useMemo, useContext } from \"react\"\n\nconst AdServiceContext = createContext<AdService | null>(null)\nexport const useAds = () => useContext(AdServiceContext)\n\nexport const AdServiceProvider = ({\n  children,\n  adService,\n}: {\n  children: React.ReactNode\n  adService: AdService //interface로 바로 type정해줄 수 있어\n}) => {\n  const { getAdList, getTrend } = adService\n  const value = useMemo(() => {\n    return { getAdList, getTrend }\n  }, [getAdList, getTrend])\n  return (\n    <AdServiceContext.Provider value={value}>\n      {children}\n    </AdServiceContext.Provider>\n  )\n}\n```\n\n## 🛠React Query를 이용한 Refactoring\n\n기능을 우선으로 코드를 작성하다 보니 너무 비슷한 코드가 두 번이나 사용되었는데, 코드 양이 너무 많아 가독성이 떨어지는 문제를 가지고 있었다.\n\n```tsx\nconst getAdList = useCallback(async () => {\n    listDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: true });\n     try {\n      const response = _await_ adService?.getAdList();\n      listDispatch({\n        type: DataActionEnum.SET_DATA,\n        data: response?.ads || [],\n      });\n    } catch (e) {\n      console.error(e);\n    } finally {\n      listDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: false });\n    }\n  }, [adService, listDispatch]);\n\nconst getAdTrend = useCallback(async () => {\n    trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: true });\n    try {\n      const response = _await_ adService?.getTrend();\n      trendDispatch({\n        type: DataActionEnum.SET_DATA,\n        data: response?.report.daily || [],\n      });\n    } catch (e) {\n      console.error(e);\n    } finally {\n      trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: false });\n    }\n  }, [adService, trendDispatch]);\n```\n\ndispatch함수와 action내용만 바뀌는 두 가지 함수 내용을 보면서 하나의 함수로 만들어서 전달할 까도 생각했지만 Type과 관련해서 너무 복잡해지는 문제를 가지고 있었다. 코드의 간결화와 두 가지 분리된 함수를 가지는 게 더 좋을 것 같아 React Query를 사용했다.\n\n## React Query\n\n<img width=\"1000\" src=\"https://velog.velcdn.com/images/woohobi/post/0233c2ea-03ab-439f-b735-7bb125f091f0/image.svg\"/>\n\nReact Query는 서버에서 데이터를 받아오고, 받아온 데이터를 caching, retry 등 비동기에 필요한 다양한 기능을 제공해 주는 라이브러리다. React Query는 이후에 상태 관리 라이브러리와 연동한다면 상태는 상태를 보관하고 변경하는 역할만, React Query로는 서버에서 받아온 데이터만을 관리하는 역할만 분리해서 사용할 수 있을 것 같아 공부하고 적용해보았다.\n\n위 상황은 두 가지 API 함수로 호출을 하는 상황이고 각각의 데이터를 상태로 전달해줘야 하는 상황이었다. (React query가 나서기 딱 좋은 상황이다)\n\n이를 받아온 결과들만 뽑아서 상태를 전달하니, 훨씬 코드가 간단해지고 구분이 잘된 것을 볼 수 있다.\n\n```tsx\nconst { isLoading, data: trendData } = useQuery(\n  [\"trend\"],\n  () => adService?.getTrend(),\n  {\n    staleTime: 1000 * 60 * 60,\n    cacheTime: 1000 * 60 * 60,\n  }\n)\nconst { data: listData } = useQuery([\"adList\"], () => adService?.getAdList(), {\n  staleTime: 1000 * 60 * 60,\n  cacheTime: 1000 * 60 * 60,\n})\n\nuseEffect(() => {\n  trendDispatch({\n    type: DataActionEnum.SET_DATA,\n    data: trendData?.report.daily || [],\n  })\n  trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading })\n}, [trendData, isLoading])\n\nuseEffect(() => {\n  listDispatch({\n    type: DataActionEnum.SET_DATA,\n    data: listData?.ads || [],\n  })\n}, [listData])\n```\n\n## 😅Typescript Error\n\n역시 Typescript는 아직 어렵다... 마주했던 에러들을 기록해 이후에 까먹을 내가 참고하려한다.\n\n### Object Key Type\n\n저번 과제에서 Detail 페이지를 구성할때 api로 받은 데이터 중에서 param값과 같은 id를 갖는 데이터를 찾아서 가져왔다. 이렇게 할 때 만약에 데이터가 커진다면 찾는데 훨씬 오랜 시간이 걸리는 문제가 발생한다 (배열에서 찾기는 O(n)). 그래서 Object로 자료구조를 바꾸려 했었는데 Type을 어떻게 설정할지 몰라 포기했던 경험이 있다.\n\n이번에는 데이터를 계산하면서 Object.keys() 메소드를 이용했는데, 나열하려면 index의 type을 결정해줘야 했다.\n\n```typescript\nexport type ResultType = {\n  [index: string]: number\n}\n\nconst calculateData = (data: TrendType[]) => {\n  const result: ResultType = {\n    imp: 0,\n    click: 0,\n    cost: 0,\n    conv: 0,\n    convValue: 0,\n    ctr: 0,\n    cvr: 0,\n    cpc: 0,\n    cpa: 0,\n    roas: 0,\n  }\n\n  data.forEach(item => {\n    Object.keys(item).forEach(key => {\n      if (key in result) {\n        result[key] += Number(item[key])\n      }\n    })\n  })\n  return result\n}\n\nexport default calculateData\n```\n\n만약 저번 과제에서 해결 못했던 Object의 key로 데이터의 id를 사용하고 데이터를 value로 한 자료구조의 type 경우는 다음과 같이 적용할 수 있다.\n\n```typescript\ntype Type = {\n  [index: string]: { data: string }\n}\n\nconst obj: Type = {\n  \"123123\": { data: \"hi\" },\n}\n```\n\n# 😥아쉬웠던 점\n\n이번 과제는 너무 디테일한 UI들과 selector를 이용해 받은 데이터들을 필터 해야 하는 부분들이 많아, 완전히 구현하지 못했다. 필터링 로직을 많이 구현하다 시간이 없어 그래프의 형식들도 신경 쓰지 못했고, adList 데이터로 수정하기 부분도 구현하지 못했다. 아직 너무 많이 부족하다는 것을 많이 느낀다. 코딩을 하면서 저번에 했던 코드를 복사해 수정해서 사용하다 보니, \"정말 내가 이 코드들을 제대로 이해하고 있는 걸까\"라는 생각도 들고, 부족함에 좌절하기도 많이 했다.\n\n그래도 매번 과제를 하면서 내가 가진 장점은, 프로젝트 내의 **문제점을 잘 찾는다**는 점과 **배운 것을 적용할 수 있는 능력**이라고 생각한다. 내 프로젝트에서 부족한 점들을 기록해서 최대한 채웠고, 멘토님이 말씀해 주셨던 부분들을 담아서 코딩하다 보니 이전과는 다른 시야와 다른 수준으로 코딩하고 있다는 생각을 한다.\n\n좌절하고 힘들었지만 거기서 멈추지 말고 이번 부족한 부분들을 밑거름으로 다음으로 나아가야겠다.\n"},{"excerpt":"📜 과제 설명 이번 과제는 기업과제로 주어진 피그마의 디자인과 api를 이용해 2가지 페이지를 구현해야했다. 페이지는 차량리스트를 보여주는 Home페이지, 해당 차량의 정보를 보여주는 detail페이지로 구성되어 있으며, 추가 구현사항으로 페이스북과 카카오톡에 공유시 해당 이미지와 차량정보들을 보여줄 수 있어야하는 SEO가 있었다. 과제 자체는 저번 과제…","fields":{"slug":"/2022-11-04-원티드 프리온보딩-2-1-과제-회고/"},"frontmatter":{"date":"November 04, 2022","title":"원티드 프리온보딩 2-1 과제회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n# 📜 과제 설명\n\n이번 과제는 기업과제로 주어진 피그마의 디자인과 api를 이용해 2가지 페이지를 구현해야했다. 페이지는 차량리스트를 보여주는 Home페이지, 해당 차량의 정보를 보여주는 detail페이지로 구성되어 있으며, 추가 구현사항으로 페이스북과 카카오톡에 공유시 해당 이미지와 차량정보들을 보여줄 수 있어야하는 **SEO**가 있었다. 과제 자체는 저번 과제와 크게 다른 점이 없어서 수월하게 할 수 있을 것 같아, 이번 기회에 모두 다같이 **typescript**를 도입해보기로 했다.\n\n## UseReducer와 Context API\n\n처음 과제부터 계속해서 사용해와서 조금은 익숙해진 context API와 useReducer를 이번에 함께 사용해보았다. 다른 팀의 저번과제의 코드들과 [Velopert님의 글](https://react.vlpt.us/)을 참고해서 코드를 구성했다.\n\n### UseReducer\n\nuseReducer는 중첩된 상태나 여러가지 상태를 하나의 오브젝트로 묶어서 관리할 때 등, 복잡한 상태관리 로직을 간단하게 처리할 수 있는 react hook이다. useReducer의 로직은 useState와 유사하게, 우리가 관리해야 할 **상태**가 있고, 상태를 어떻게 처리할지를 담고 있는 **action**과 전달받은 action에 따라 처리해주는 **dispatch**가 있다.\n\n```jsx\nconst reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ActionType.SET_IS_LOADING:\n      return {\n        ...state,\n        isLoading: action.isLoading,\n      };\n    ...\n};\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n// const [state,setState]=useState()와 유사해\n```\n\n이번 프로젝트에서 reducer를 사용해본 부분은 API호출에 따른 error, isLoading, data를 하나로 관리하기 위해, 저번 usefetch로 분리했던 customHook을 useReducer로 대체했다.\n\n```typescript\ntype State = {\n  isLoading: boolean;\n  data: CarType[];\n  error: string;\n};\n\ntype Action =\n  | { type: ActionType.SET_DATA; data: CarType[] }\n  | { type: ActionType.SET_IS_LOADING; isLoading: boolean }\n  | { type: ActionType.SET_ERROR; error: string };\n\nconst reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ActionType.SET_IS_LOADING:\n      return {\n        ...state,\n        isLoading: action.isLoading,\n      };\n    case ActionType.SET_DATA:\n      return {\n        ...state,\n        data: action.data,\n      };\n    case ActionType.SET_ERROR:\n      return {\n        ...state,\n        error: action.error,\n      };\n    default:\n      throw new Error('Unknown Action');\n  }\n};\n\nexport const CarsProvider = ({ children }: { children: React.ReactNode }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\t\t...\n};\n```\n\n### contextAPI\n\ncontextAPI를 기존에서 사용할 때는 value에 상태와 함수를 같이 보내주었지만 이번에 reducer를 사용하면서 상태와 dispatch 둘 중 하나만 필요할 때가 있어, stateContext와 dispatchContext 두 가지로 나누어서 구성했다.\n\n```tsx\ntype State = {\n  isLoading: boolean;\n  data: CarType[];\n  error: string;\n};\n\ntype Action =\n  | { type: ActionType.SET_DATA; data: CarType[] }\n  | { type: ActionType.SET_IS_LOADING; isLoading: boolean }\n  | { type: ActionType.SET_ERROR; error: string };\n\ntype CarsDistpatch = Dispatch<Action>;\n\nexport const CarsStateContext = createContext<State | null>(initialState);\nexport const CarsDispatchContext = createContext<CarsDistpatch | null>(null);\n\nexport const CarsProvider = ({ children }: { children: React.ReactNode }) => {\n\t\t...\n    return (\n    <CarsStateContext.Provider value={state}>\n      <CarsDispatchContext.Provider value={dispatch}>\n        {children}\n      </CarsDispatchContext.Provider>\n    </CarsStateContext.Provider>\n  );\n};\n```\n\nuseReducer와 contextAPI를 이용해서 보다 깔끔하게 상태관리를 할 수 있었고, reducer에서만 상태관리 로직을 추가하면 되어서 확장성도 좋은 장점을 갖게 되었다.\n\n```tsx\nenum ActionEnum {\n  SET_IS_LOADING = \"SET_IS_LOADING\",\n  SET_DATA = \"SET_DATA\",\n  SET_ERROR = \"SET_ERROR\",\n}\n\nconst App = () => {\n  const dispatch = useCarsDispatch()\n  const getList = useCallback(async () => {\n    dispatch({ type: ActionType.SET_IS_LOADING, isLoading: true })\n    try {\n      const response = await carsAPI.getCars()\n      if (response) {\n        dispatch({ type: ActionType.SET_DATA, data: response?.payload })\n      }\n    } catch (e) {\n      if (e instanceof HTTPError) {\n        dispatch({ type: ActionType.SET_ERROR, error: e.errorMessage })\n      }\n      console.error(e)\n    } finally {\n      dispatch({ type: ActionType.SET_IS_LOADING, isLoading: false })\n    }\n  }, [dispatch])\n  useEffect(() => {\n    getList()\n  }, [getList])\n\n  return (\n    <>\n      <Header />\n      <Outlet />\n    </>\n  )\n}\n\nexport default App\n```\n\n### contextAPI를 이용한 Filtering\n\n이번 과제에서 전체 차량중에서 category를 누르면 해당 차량의 종류만 보여줘야했기 때문에 filtering 로직도 필요했다. filtering을 하기 위해서는 기존의 상태를 가지고 있으면서 filter하고 싶은 차량들만 보여줘야 했기 때문에 기존 Reducer로직에 추가하지 않고 따로 caterogryContext를 만들어 관리했다.\n\n```tsx\n//categoryContext.tsx\nimport { createContext, useState, useMemo } from \"react\"\nimport { CategoryType } from \"types/CarsInterface\"\n\nconst initialState = {\n  category: \"전체\",\n  setCategory: (category: CategoryType) => {},\n}\n\nexport const CategoryContext = createContext(initialState)\n\nexport const CategoryProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  const [category, setCategory] = useState<CategoryType>(\"전체\")\n  const value = useMemo(() => ({ category, setCategory }), [category])\n  return (\n    <CategoryContext.Provider value={value}>\n      {children}\n    </CategoryContext.Provider>\n  )\n}\n```\n\n각각의 context API의 provider는 필요한 곳에서 감싸 주려했다. 차량 목록이 있다면 useParam으로 해당 차량 정보도 얻을 수 있기 때문에 따로 api를 호출하지 않고 한번만 호출하게 하기 위해 Router.jsx에서 carsProvider를 감싸주었다. categoryProvider는 category를 update하고 category를 이용해 filtering된 결과를 받아오기 위해 categories와 carsList가 있는 home.tsx에서 감싸주었다.\n\n```tsx\n//router.tsx\nconst Router = () => {\n  return (\n    <CarsProvider>\n      <RouterProvider router={router} />\n    </CarsProvider>\n  )\n}\n\n//\n\nconst Home = () => {\n  return (\n    <CategoryProvider>\n      <S.Section>\n        <Categories />\n        <CarList />\n      </S.Section>\n    </CategoryProvider>\n  )\n}\n\nexport default Home\n```\n\n## Custom Hook\n\n이번 과제를 하면서 가장 신경썼던 포인트중 하나는 **컴포넌트의 단순화**였다. 멘토님께서 강의 해주신 컴포넌트의 추상화에 대해 많이 생각하면서 되도록이면 Component가 로직과 관련된 코드를 많이 가지고 있지 않고, UI 렌더링 로직만을 가지고 있게 노력했다. 그렇게 하기 위해서는 중복되거나 사용되는 로직을 다른 파일로 보관해야 했고, **custom hook**을 적극적으로 사용했다.\n\n특히 home page의 carsList 컴포넌트는 api로 받아온 차량리스트를 카테고리에 맞게 보여줘야했다. 내부에 carsContext로부터 받아온 데이터를 filtering을 할 수도 있지만 **로직을 컴포넌트 내부에 남기고 싶지 않아** customHook으로 만들어 list만 받아올 수 있게 했다. useCarsValue 내부에서 필터링하기 때문에 컴포넌트는 엄청 간소화된 구조를 가질 수 있었다.\n\n```tsx\n//useCars.tsx\n\nexport const useCarsState = () => {\n  const state = useContext(CarsStateContext)\n  if (!state) throw new Error(\"Can't find State Provider\")\n  return state\n}\n\nexport const useCarsDispatch = () => {\n  const dispatch = useContext(CarsDispatchContext)\n  if (!dispatch) throw new Error(\"Can't find Dispatch Provider\")\n  return dispatch\n}\n\nexport const useCarsValue = () => {\n  const state = useCarsState()\n  const { category } = useContext(CategoryContext)\n\n  if (!state) throw new Error(\"Can't find StateProvider\")\n  if (!category) throw new Error(\"Can't find CategoryProvider\")\n  if (category === \"전체\") return state.data\n\n  const filterd = state?.data.filter(\n    car => SegmentEnum[car.attribute.segment] === category\n  )\n  return filterd\n}\n\n//carsList.tsx\nimport S from \"./styles\"\nimport CarItem from \"../carItem/CarItem\"\nimport { useCarsState, useCarsValue } from \"../../hooks/useCars\"\n\nconst CarList = () => {\n  const { isLoading, error } = useCarsState()\n  const data = useCarsValue()\n  if (isLoading) {\n    return (\n      <S.Layout>\n        <h3>불러오는 중</h3>\n      </S.Layout>\n    )\n  }\n\n  if (error) {\n    return (\n      <S.Layout>\n        <h3>{error}</h3>\n      </S.Layout>\n    )\n  }\n\n  if (data.length === 0) {\n    return (\n      <S.Layout>\n        <h3>차량이 없습니다.</h3>\n      </S.Layout>\n    )\n  }\n  return (\n    <ul>\n      {data.map(car => (\n        <CarItem key={car.id} {...car} />\n      ))}\n    </ul>\n  )\n}\n\nexport default CarList\n```\n\n## Typescript\n\ntypescript는 공부를 해도 잘 쓰는 법이 무엇인지 고민이 많이 되었기 때문에 빠른 개발을 위해서 react로 한 후에 천천히 typescript로 바꿔야지라고 생각했지만, 계속 미뤄왔왔다. 이제부터는 계속해서 사용하면서 부딪히면서 배워나가기로 마음먹었다. 이번 과제는 너무 친절하게 과제의 api문서에 데이터마다 type까지 자세히 알려주기 때문에 꼭 적용해보고 싶어 적극적으로 팀에 제안했다.\n\n### enum\n\nenum은 비슷한 역할을 하는 변수들을 묶음으로 최대한 string이나, number인 상태로 의미를 알 수 없는 코드를 남기지 않으려 사용했다. enum을 사용할 때 새롭게 알게된 점은 object와 같이 사용이 가능하다는 점이었다.\n\n```typescript\nenum SegmentEnum {\n  C = \"소형\",\n  D = \"중형\",\n  E = \"대형\",\n  SUV = \"SUV\",\n}\n\ntype AttributeType = {\n  segment: keyof typeof SegmentEnum\n}\n```\n\nsegment의 type을 전달할 때 segmentEnum중의 하나라고 알려줄 때 **keyof typeof**를 이용할 수 있었고 이렇게 전달해준 enum의 value값을 찾을 때는 custom Hook에서 key값을 전달해서 찾을 수 있었다.\n\n```tsx\nexport const useCarsValue = () => {\n  //\t...\n  const filterd = state?.data.filter(\n    car => SegmentEnum[car.attribute.segment] === category\n  )\n  return filterd\n}\n```\n\n### null/undefined error\n\nnull/undefined Error는 아마 가장 자주 마주하는 에러가 아닐까 싶다. 조건부로 받아올 경우나 null로 받아올 경우 해당 오브젝트의 property가 없을 수도 있기 때문에 에러를 던져준다.\n\n<img width=\"800\" src=\"./object null error.PNG\"/>\n\n에러를 막기위해서는 항상 undefined이나 null일 경우에 처리할 수 있는 로직을 처리하면 간단하게 해결이 가능하다.\n\n```tsx\nconst Detail = () => {\n  const { id } = useParams()\n  const car = data.find(item => item.id === +id)\n\n  //\t...\n\n  if (!car) {\n    return (\n      <S.Layout>\n        <h3>url을 확인해주세요</h3>\n      </S.Layout>\n    )\n  }\n\n  const { amount, attribute, startDate, insurance, additionalProducts } = car\n\n  // ..\n}\n\nexport default Detail\n```\n\n## CRA에서의 SEO 문제 해결\n\n이번과제를 할 때 CRA에서 간단하게 react-helmet을 이용하면 SEO를 해결할 수 있을 것이란 생각에 CRA를 이용해서 진행했다. 하지만 마주한 문제들이 많았는데 문제해결과정을 정리해보고자 한다.\n\n### SEO 관점에서의 CSR과 SSR\n\n<img width=\"800\" src=\"https://velog.velcdn.com/images%2Fhanei100%2Fpost%2F138d8a8d-8df9-4bca-bf0f-561d01b4cc84%2Fimage.png\"/>\n\nCSR은 client에서 화면을 렌더링하는 방식으로, 서버에서 받은 **하나의 빈페이지 index.html**에 동적으로 html 요소를 만드는 javascript을 받아 한번에 보여준다. 그로인해 화면이 보임과 동시에 interactive한 페이지를 만들 수 있는 장점이 있다. 내가 자주 사용하는 CRA (create-react-app)는 간편하게 CSR (client-side-rendering)이 가능한 패키지이지만 CSR의 특성으로 SEO에는 취약한 단점을 가진다.\n\n<img width=\"800\" src=\"https://velog.velcdn.com/images%2Fhanei100%2Fpost%2F040f9b95-70a0-49fa-8b73-76272597890c%2Fimage.png\"/>\n\n그에 반해 SSR (server-side-rendering) 은 서버에서 정적인 페이지를 먼저 만들어 렌더링해주기 때문에 초기 렌더링 속도가 빠르고 검색엔진과 같은 봇이 보았을 때 해당 내용들을 볼 수 있기 때문에 SEO에 큰 장점을 갖고 있다. CSR에 비해 먼저 화면이 보이고 이후에 javascript가 실행되기 때문에 ux측면에서는 단점을 가질 수 있다. 이번 과제를 위해서는 SSR이 더 적합한 방식이었을 것이란 생각이 된다.\n\n### 그러면 왜 CRA로 진행했을까?\n\nReact에서 SSR을 하기 위해서는 Next.js를 사용하면 된다. 하지만 아직 사용해본 적이 없고, typescript에 좀더 초점을 맞춰서 공부하다 보니 시간이 부족해 우선 어떻게든 CRA에서 해결할 수 있는 방법을 찾아서 적용해보았다.\n\n## React-Helmet\n\nreact-helmet은 react 라이브러리로 index.html의 head 내용을 동적으로 바꿀 수 있는 라이브러리이다. 과제에 필요한 내용들을 각 detail 페이지의 정보에 맞게 head 내용을 바꾸기 위해 meta 컴포넌트를 만든 후에 정보를 담아주었다. 그결과 페이지에서 잘바뀌어있는 것을 확인할 수 있었다.\n\n<img width=\"800\" src=\"https://user-images.githubusercontent.com/104304569/199743653-4db5c757-19ed-44d5-b238-1a94bc88a255.png\"/>\n<br/>\n\n```jsx\nimport { Helmet } from \"react-helmet-async\"\n\nconst Meta = ({ attribute, amount, id }: MetaProps) => {\n  const { brand, name, imageUrl } = attribute\n  return (\n    <Helmet>\n      <title>{`${brand} ${name}`}</title>\n      <meta name=\"description\" content={`월 ${amount}원`} />\n      <meta property=\"og:type\" content=\"website\" />\n      <link href={imageUrl} />\n      <meta property=\"og:url\" content={`${process.env.PUBLIC_URL}/${id}`} />\n      <meta name=\"og:title\" content={`${brand} ${name}`} />\n      <meta name=\"og:description\" content={`월 ${amount.toLocaleString()}원`} />\n      <meta property=\"og:image\" content={imageUrl} />\n      <meta property=\"og:image:width\" content={IMAGE_SIZE.width.toString()} />\n      <meta property=\"og:image:height\" content={IMAGE_SIZE.height.toString()} />\n    </Helmet>\n  )\n}\n```\n\n하지만 공유를 할때는 여전히 초기 index.html의 head내용만 보이는 문제점이 존재했다. 이러한 문제점은 head내용이 javascript를 이용해 동적으로 바뀌지만 공유를 했을 때는 하나의 index.html의 내용이 그대로 반영되어 생긴 문제로 생각됐다.\n\n### React-snap\n\nreact-snap은 react library로 react-router로 만든 동적라우팅 페이지마다 적합한 html파일을 만들어주는 라이브러리이다. index.tsx를 hydrate를 이용해 client-side페이지를 static HTML로 바꿔준다. 바꿔준 결과 build폴더에 만들어질 페이지들의 폴더와 index.html이 생긴 걸 볼 수 있다.\n\n<img width=\"500\" src=\"https://user-images.githubusercontent.com/104304569/199749072-fc686c18-6bec-4dfc-81ce-2666386d4d2c.png\"/>\n\n```tsx\nimport { hydrate, render } from \"react-dom\"\n\nconst container = document.getElementById(\"root\") as HTMLElement\nconst root = ReactDOM.createRoot(container)\n\nif (container.hasChildNodes()) {\n  ReactDOM.hydrateRoot(\n    container,\n    <React.StrictMode>\n      <ThemeProvider theme={Theme}>\n        <GlobalStyle />\n        <Router />\n      </ThemeProvider>\n    </React.StrictMode>\n  )\n} else {\n  root.render(\n    <React.StrictMode>\n      <ThemeProvider theme={Theme}>\n        <GlobalStyle />\n        <Router />\n      </ThemeProvider>\n    </React.StrictMode>\n  )\n}\n```\n\n두가지 라이브러리를 이용한 덕분에 다행히 공유시 내용들이 담아 문제를 해결할 수 있었고, react-snap을 쓰면서 알게된 **hydration**이란 방식이 실제로 SSR을 위한 프레임워크들 Next.js와 Gatsby가 이용하는 방식임을 알게 되었다.\n\n<img width=\"300\" src=\"https://user-images.githubusercontent.com/104304569/199750059-845a9e40-679c-43cf-bff8-eac249801b9a.png\"/>\n\n<img width=\"300\" src=\"https://user-images.githubusercontent.com/104304569/199750370-7cc423bd-0972-4fba-997a-69d32788829e.png\"/>\n\n## Axios\n\n이번 프로젝트를 하면서 새롭게 시도한 것은 fetch대신 axios를 사용했다는 점이었다. fetch로 잡지 못했던 에러들을 request와 response로 나눠서 받아 에러핸들링이 더 간편했으며, 팀원분이 알려주신 axios의 interceptor를 이용하면 보내기 전에 설정들을 추가할 수도 있어 더 유용한 부분이 많은 라이브러리라 생각되었다.\n\n원래는 하나의 api만 사용할 때는 class로 사용하면 오히려 더 복잡하게 만든다고 생각해서 사용하지 않았지만 class로 분리하면 좀 더 정리가 될 수 있고 확장성이 높다는 장점이 있고, 전달시 instance를 만들어서 사용하는 점을 배울 수도 있었다.\n\n```ts\nimport axios, { AxiosError, AxiosInstance } from \"axios\"\nimport { CarType, FuelEnum, SegmentEnum } from \"types/CarsInterface\"\nimport createAxiosInstance from \"./axiosUtils\"\nimport HTTPError from \"../network/httpError\"\n\nconst BASE_URL = \"https://preonboarding.platdev.net/api/cars\"\n\ntype GetCarsResponse = {\n  payload: CarType[]\n}\n\nclass CarsAPI {\n  constructor(private axiosInstance: AxiosInstance) {}\n\n  async getCars(fuelType?: FuelEnum, segment?: SegmentEnum) {\n    try {\n      const { data } = await this.axiosInstance.get<GetCarsResponse>(BASE_URL, {\n        params: {\n          fuelType,\n          segment,\n        },\n      })\n      return data\n    } catch (error) {\n      const { response } = error as unknown as AxiosError\n      if (response) {\n        throw new HTTPError(response?.status, response?.statusText)\n      }\n      throw new Error(\"Unknown Error\")\n    }\n  }\n}\n\nconst carsAPIinstance = createAxiosInstance(BASE_URL)\n\nconst carsAPI = new CarsAPI(carsAPIinstance)\n\nexport default carsAPI\n```\n\n### 에러핸들링\n\n기존에 사용했던 에러핸들링을 위한 class를 이용해서 필요한 에러 메시지를 좀 더 이해가 잘되게 수정했고, typescript에서 제공하는 private, public을 이용해 보다 간단하게 constructor함수를 사용할 수 있었다. 에러를 상속받기 때문에 message는 public으로 사용해줘야 된다는 점을 새롭게 알 수 있었다.\n\n```ts\nexport default class HTTPError extends Error {\n  constructor(private statusCode: number, public message: string) {\n    super(message)\n  }\n\n  get errorMessage() {\n    switch (this.statusCode) {\n      case 404:\n        this.message = \"잘못된 요청입니다. url을 확인해주세요\"\n        break\n      default:\n        throw new Error(\"Unknown Error\")\n    }\n    return this.message\n  }\n}\n```\n\n### 📢 마치며\n\n이번 기회를 통해서 왜 기업이 SEO를 고려하는지, SEO를 해결하는 방식으로 SSR을 이용해야하는 이유를 체감할 수 있었다. 무조건 SSR이 좋고 유행하니까 해야된다는 생각보다 어떤 문제를 해결하기 위해 나왔고 이것을 어디에 적용해야하는 지 알게되었고, Next.js를 공부해보고 싶다는 의욕이 더 생기는 계기가 되었다. 하나를 완벽하게 하고 다음을 해야하지 않나 생각도 하지만, 이번에 next.js를 몰라서 적용을 못했다는 아쉬움이 생겨, **내가 사용할 수 있는 도구를 늘이는 과정도 필요하다**는 깨우침도 생겼다.\n"},{"excerpt":"🧨1-2 과제 회고 원티드 프리온보딩 두 번째 과제는 github API를 이용해 두 가지 페이지 (이슈 목록과 상세 페이지)를 만드는 과제였다. 세부적인 요구사항에서 가장 중요했던 부분은 리스트에서 Github API 데이터 요청, context API를 활용한 API연동, 다섯 번째 셀에 광고이미지를 넣어줄 것, 스크롤을 내리면 이슈 목록에 추가 로딩…","fields":{"slug":"/2022-10-31-원티드 프리온보딩-1-2-과제-회고/"},"frontmatter":{"date":"October 31, 2022","title":"원티드 프리온보딩 1-2 과제회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n# 🧨1-2 과제 회고\n\n원티드 프리온보딩 두 번째 과제는 github API를 이용해 두 가지 페이지 (이슈 목록과 상세 페이지)를 만드는 과제였다. 세부적인 요구사항에서 가장 중요했던 부분은 리스트에서 **Github API 데이터 요청,** **context API를 활용한 API연동**, **다섯 번째 셀에 광고이미지를 넣어줄 것**, **스크롤을 내리면 이슈 목록에 추가 로딩이 될 수 있게 infinity scroll을 구현할 것**이었다. 위 요구사항을 어떻게 해결했는지에 대해 정리하고 정리해 보고자 한다.\n\n## 1. Github Issue API\n\n첫번째 문제는 간단하게 해결할 수 있었다. 문서를 보니 list issue API에서 기본적으로 open된걸 불러오고 sort query를 이용해서 comment가 많은 순으로 받아올 수 있었다.\n\n<img width=\"1000px\" src=\"./image-20221031143703263.png\"/>\n\n문서에서 발생할 수 있는 에러는 404와 422 두 가지이기 때문에 두 가지 에러에 따라 에러메시지를 커스텀할 수 있게 이전에 만들어둔 httpError class를 이용해 알맞은 에러를 반환해 줄 수 있게 했다.\n\n```javascript\n//issueService.js\n\nimport HTTPError from '../network/httpError';\n\nconst getIssueList = async page => {\n  const response = await fetch(\n    `https://api.github.com/repos/angular/angular-cli/issues?sort=comments&per_page=30&page=${page}`,\n    {\n      method: 'GET',\n      headers: {\n        Authorization: `token ${process.env.REACT_APP_TOKEN}`,\n      },\n    }\n  );\n  if (!response.ok) {\n    throw new HTTPError(response.status, response.statusText);\n  } else {\n    const data = await response.json();\n    return data;\n  }\n};\n\nexport default getIssueList;\n\n//httpError.js\n\nexport default class HTTPError extends Error {\n  constructor(statusCode, message) {\n    super(message);\n    this.name = 'HTTPError';\n    this.statusCode = statusCode;\n  }\n\n  get errorMessage() {\n    switch (this.statusCode) {\n      case 404:\n        this.message = '해당 레포를 찾을 수 없습니다.';\n        break;\n      case 422:\n        this.message = '요청이 잘못된 endpoint로 전달되었습니다';\n        break;\n      default:\n        throw new Error('Unknown Error');\n    }\n    return this.message;\n  }\n}\n\n```\n\n## 2. context API를 활용한 API 연동\n\n### Context API\n\ncontext API는 전역상태를 관리하는 방법으로, provider내부의 컴포넌트들에게 전달시 prop으로 자식 컴포넌트에 하나하나 전달하는게 아니라, 필요한 컴포넌트에서 바로 상태에 접근할 수 있는 db와 같은 역할을 할 수 있다. 이번 과제에서 context API를 사용하려고 한다면 issue list를 불러오고 불러온 데이터를 context API에 넣어주어, list내용이 필요한 곳에서 사용이 가능하게 만들었다.\n\n<img width=\"1000\" src=\"https://velog.velcdn.com/images/devjade/post/c155b13a-e1b7-4205-9f39-875e1c284454/contextAPI.png\"></img>\n\ncontext API 자체에서 api를 이용해 값을 넣어둘까 생각을 했지만, 내부에서 계속 값이 바뀌면 받는 시점에 따라 다른 데이터가 전달될 수도 있을 것 같아 단순이 데이터만 보관하고 변경할 수 있는 함수를 context로 같이 제공하는 방식으로 코드를 구성했다.\n\n```javascript\nimport { useMemo, useState, createContext } from \"react\"\n\nexport const ListContext = createContext()\nexport const ListContextProvider = ({ children }) => {\n  const [issues, setIssues] = useState({})\n  const setNextPage = () => setPage(page + 1)\n  const value = useMemo(\n    () => ({ issues, page, setNextPage, setIssues }),\n    [issues, page]\n  )\n  return <ListContext.Provider value={value}>{children}</ListContext.Provider>\n}\n```\n\n### Custom Hook: useFetch\n\n두가지 페이지 중 어디를 먼저 접속해도, api로 데이터를 contextAPI에 저장하게 하기 위해서는 동일한 로직을 두 페이지 모두 가지고 있어야 했다. 로직의 재사용을 위해 useFetch라는 custon Hook을 만들어서 한 곳에서 관리할 수 있게 했고, 두 페이지 중 어디를 접속해도 리스트를 불러올 수 있기 때문에 성능이 더 좋게 구성할 수 있겠다는 생각이 들었다.\n\nuseEffect 내부에서는 async await으로 함수를 감싸면 promise가 반환되기 때문에 사용할 수 없어, getList를 함수를 따로 만들어서 useEffect로 실행해 주는 로직을 사용했다.\n\n```javascript\nconst useFetch = () => {\n  const { issues, setIssues, page } = useContext(ListContext)\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState(\"\")\n  const getList = async () => {\n    setIsLoading(true)\n    try {\n      const data = await getIssueList(page)\n      if (data.length === 0) {\n        setLastPage(true)\n      }\n      setIssues(prev => {\n        const updated = { ...prev }\n        data.forEach(issue => {\n          updated[issue.id] = issue\n        })\n        return updated\n      })\n    } catch (error) {\n      setError(error.errorMessage)\n    }\n    setIsLoading(false)\n  }\n  useEffect(() => {\n    getList()\n  }, [page])\n\n  return [isLoading, error, issues, lastPage]\n}\n```\n\n### issues 전역상태 자료구조\n\ncontext 내부 상태를 처음에는 배열을 이용해 api 데이터들을 담아두려고 했다. 하지만 상세페이지에 갔다가 돌아왔을 때, api가 호출되면서 같은 데이터가 두개씩 들어가는 오류가 생겼다. 이러한 오류를 해결하기 위해서 **Set**을 이용해 중복된 데이터는 제거하려 했지만, 여전히 남아있었다. 중복제거가 되지 않았던 이유는 데이터 object들이 같은 자료를 가지고 있지만 **다른 참조값**을 가지고 있어 다른 값으로 처리가 된다고 생각했다.\n\n이러한 중복을 제거하기 위해서 처음에는 받은 배열과 기존 배열을 비교하는 로직을 짜려고 했지만, **O(n^2)의 시간복잡도**를 가지기 때문에 자료양이 많아질수록 성능이 안 좋아질 것이라는 생각이 들었다.\n\n이점을 해결하기 위해서 자료구조를 **Object**로 바꾸었다. object의 key를 data의 id로, value를 데이터 자체로 한 오브젝트를 만들면, 중복을 간단하게 제거할 수 있고 이후에 배열로 바꾸어 mapping할 때 정렬만 해주면 되기 때문에 **O(nlogn)**으로 보다 나은 성능을 갖게 될 것이라 예상했다.\n\n```javascript\nconst IssueList = () => {\n  const { setNextPage } = useContext(ListContext)\n  const [isLoading, error, issues, lastPage] = useFetch()\n\n  return (\n    <>\n      <S.List>\n        {Object.values(issues)\n          .sort((a, b) => b.comments - a.comments)\n          .map((issue, idx) => {\n            return <IssueItem key={issue.id} {...issue} />\n          })}\n        {isLoading && <Loader />}\n      </S.List>\n    </>\n  )\n}\n\nexport default IssueList\n```\n\n자료구조를 object로 바꾼 덕분에 detail페이지에서 보여줄 때도 다른 api 호출없이 useParam으로 받아온 id값으로 issues에 접근해 데이터를 불러올 수 있었다.\n\n```jsx\nimport React, { memo } from \"react\"\nimport { useNavigate, useParams } from \"react-router\"\nimport S from \"./styles\"\nimport formatDate from \"../../utils/formatDate\"\n\nconst IssueItem = ({ id, number, title, user, created_at, comments }) => {\n  const navigate = useNavigate()\n  const params = useParams()\n  const date = formatDate(created_at)\n  const handleClick = () => {\n    if (!params.id) {\n      navigate(`/detail/${id}`)\n    }\n  }\n  return (\n    <S.List onClick={handleClick} params={!!params.id}>\n      <S.LeftBox>\n        <header>\n          <span>{`#${number}`}</span>\n          <S.Title>{title}</S.Title>\n        </header>\n        <div>\n          <span>{`작성자: ${user && user.login}`}</span>\n          <span>{date}</span>\n        </div>\n      </S.LeftBox>\n      <S.RightBox>\n        코멘트:\n        {comments}\n      </S.RightBox>\n    </S.List>\n  )\n}\n\nexport default memo(IssueItem)\n```\n\n## 3. 다섯번째 셀에 광고 보여주기\n\nlist의 특정부분에 추가된 것을 보여준 것을 해본 적이 없어서 고민하다, mapping을 할 때 index가 4가 되었을 때 issueItem 컴포넌트와 함께 adBox 컴포넌트를 보여주는 방식을 선택했다. 하지만 key가 계속해서 중복된다는 에러가 발생했다.\n\n```jsx\nimport React, { useContext } from \"react\"\nimport S from \"./styles\"\nimport IssueItem from \"../issueItem/IssueItem\"\nimport AdBox from \"../adBox/AdBox\"\nimport useFetch from \"../../hooks/useFetch\"\nimport useObservation from \"../../hooks/useObservation\"\nimport { ListContext } from \"../../context/ListContext\"\nimport Loader from \"../loader/Loader\"\n\nconst IssueList = () => {\n  const { setNextPage } = useContext(ListContext)\n  const [isLoading, error, issues, lastPage] = useFetch()\n\n  return (\n    <>\n      <S.List>\n        {Object.values(issues)\n          .sort((a, b) => b.comments - a.comments)\n          .map((issue, idx) => {\n            if (idx === 4) {\n              return (\n                <>\n                  <AdBox />\n                  <IssueItem key={issue.id} {...issue} />\n                </>\n              )\n            }\n            return <IssueItem key={issue.id} {...issue} />\n          })}\n        {isLoading && <Loader />}\n      </S.List>\n    </>\n  )\n}\n\nexport default IssueList\n```\n\n <br/>\n\n<img width=\"800px\" src=\"./ad에러.PNG\"/>\n \n<br/> \n어디서 계속해서 에러가 나오는지 찾는 중에 issueItem에 key값을 주었기 때문에 에러가 발생되었다는 것을 알게되었다. 해결하기 위해서 fragment가 아니라 div로 감싸주고 div에 key값을 전달해줘 에러를 해결할 수 있었다.\n\n```jsx\nimport React, { useContext } from \"react\"\nimport S from \"./styles\"\nimport IssueItem from \"../issueItem/IssueItem\"\nimport AdBox from \"../adBox/AdBox\"\nimport useFetch from \"../../hooks/useFetch\"\nimport useObservation from \"../../hooks/useObservation\"\nimport { ListContext } from \"../../context/ListContext\"\nimport Loader from \"../loader/Loader\"\n\nconst IssueList = () => {\n  const { setNextPage } = useContext(ListContext)\n  const [isLoading, error, issues, lastPage] = useFetch()\n\n  return (\n    <>\n      <S.List>\n        {Object.values(issues)\n          .sort((a, b) => b.comments - a.comments)\n          .map((issue, idx) => {\n            if (idx === 4) {\n              return (\n                <div key={issue.id}>\n                  <AdBox />\n                  <IssueItem {...issue} />\n                </div>\n              )\n            }\n            return <IssueItem key={issue.id} {...issue} />\n          })}\n        {isLoading && <Loader />}\n      </S.List>\n      {!lastPage ? (\n        <S.Target ref={targetRef} />\n      ) : (\n        <S.Banner>마지막 페이지입니다🎈</S.Banner>\n      )}\n    </>\n  )\n}\n\nexport default IssueList\n```\n\n(나중에 안 사실이지만 react.fragment에도 key값을 줄 수 있다고 한다.)\n\n## 4. Infinite Scroll\n\n이번 과제에서의 가장 큰 핵심 조건이었다. 테오님의 오픈채팅방에서도 간간히 올라오던 **infinite scroll**에 대한 질문들을 보면서 저게 왜 필요하지라는 생각을 했었는데 이번에 직접 구현해보면서 사용자 경험을 향상시킬 수 있는 기능이라는 점을 많이 느꼈다. 한번도 구현해본 적이 없던 기능이기 때문에 관련 글을 많이 찾아보고 가장 잘 정리되어 있는 [카카오 엔터프라이즈의 글](https://tech.kakaoenterprise.com/149)을 참고해 만들어보았다.\n\n만드는 방식을 scroll event를 이용하는 방식과 Intersection Observer API를 사용하는 두 가지 방식이 설명되어 있었는데, 이전에 Intersection Observer API를 사용해본 경험이 있었기 때문에 곧바로 Intersection Observer API를 이용해서 구현해 보았다.\n\n기본적인 로직은 observer가 **관찰해야 할 target**을 만들고, observer가 감지할 영역에 대한 정보를 담은 **option**과 감지되었을 때 API 호출을 해줄 **callback**을 전달해 구현하는 방식이다. callback함수는 useFetch hook에 연결해두었던 page를 증가시키는데, page 상태를 앞선 useFetch의 useEffect hook의 dependency로 전달해두었기 때문에 페이지 변화에 따라 api 호출이 자동으로 연결된다.\n\n### Custom Hook: useObservation\n\nObservation을 하는 로직을 관심사 분리를 할 수 있게 useObservation이라는 Hook으로 로직들을 정리했다. Hook은 관찰할 ref를 반환해 ref를 우리가 원하는 타겟으로 연결할 수 있다.\n\n```jsx\nimport { useCallback, useEffect, useRef } from \"react\"\n\nconst option = {\n  root: null,\n  rootMargin: \"0px\",\n  threshold: 1,\n}\n\nconst useObservation = onIntersect => {\n  const ref = useRef(null)\n  const callback = useCallback(\n    (entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) onIntersect(entry, observer)\n      })\n    },\n    [onIntersect]\n  )\n\n  useEffect(() => {\n    if (!ref.current) {\n      return\n    }\n    const observer = new IntersectionObserver(callback, option)\n    observer.observe(ref.current)\n    return () => observer.disconnect()\n  }, [ref.current, callback])\n  return ref\n}\n\nexport default useObservation\n```\n\n어려웠던 점은 **초기 렌더링 시에 전달해주었던 callback이 실행되어서 계속해서 page 2인 상태로 시작되는 점**이었다. 이것을 막기 위해서 useFetch의 isLoading상태를 이용해서 로딩이 아닐 때만 useObservation에 전달해준 callback 함수가 실행되게 했다.\n\n```jsx\nimport React, { useContext } from \"react\"\nimport S from \"./styles\"\nimport IssueItem from \"../issueItem/IssueItem\"\nimport AdBox from \"../adBox/AdBox\"\nimport useFetch from \"../../hooks/useFetch\"\nimport useObservation from \"../../hooks/useObservation\"\nimport { ListContext } from \"../../context/ListContext\"\nimport Loader from \"../loader/Loader\"\n\nconst IssueList = () => {\n  const { setNextPage } = useContext(ListContext)\n  const [isLoading, error, issues] = useFetch()\n  const onObserve = (entry, observer) => {\n    observer.unobserve(entry.target)\n    if (!isLoading) {\n      setNextPage()\n    }\n  }\n\n  const targetRef = useObservation(onObserve)\n\n  return (\n    <>\n      <S.List>\n        {Object.values(issues)\n          .sort((a, b) => b.comments - a.comments)\n          .map((issue, idx) => {\n            if (idx === 4) {\n              return (\n                <div key={issue.id}>\n                  <AdBox />\n                  <IssueItem {...issue} />\n                </div>\n              )\n            }\n            return <IssueItem key={issue.id} {...issue} />\n          })}\n        {isLoading && <Loader />}\n      </S.List>\n      <S.Target ref={targetRef} />\n    </>\n  )\n}\n\nexport default IssueList\n```\n\n### 마지막 페이지 무한 API 호출\n\n구현이 다 끝난 줄 알았지만 마지막 페이지에서 계속해서 API가 호출되는 에러가 발생했다.\n\n<img width=\"800px\" src=\"https://user-images.githubusercontent.com/83333409/198885118-10dd9434-34c2-4af1-9055-2684890dcbe6.gif\"/>\n\n에러 해결을 위해서 팀원분들의 도움을 받아 useFetch에 lastPage라는 상태를 추가했고, 더 이상 불러올 데이터가 없으면 빈 배열로 받아오는 점을 이용해 data.length가 0일 때 lastPage를 True로 바꿔 해결할 수 있었다.\n\n```jsx\n//useFetch.jsx\n\nconst useFetch = () => {\n  const { issues, setIssues, page } = useContext(ListContext);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [lastPage, setLastPage] = useState(false);\n  const getList = async () => {\n    setIsLoading(true);\n    try {\n      const data = await getIssueList(page);\n      if (data.length === 0) {\n        setLastPage(true);\n      }\n    ...\n  };\n  useEffect(() => {\n    getList();\n  }, [page]);\n\n  return [isLoading, error, issues, lastPage];\n};\n\nexport default useFetch;\n\n\n//issueList.jsx\n\nimport React, { useContext } from 'react';\nimport S from './styles';\nimport IssueItem from '../issueItem/IssueItem';\nimport AdBox from '../adBox/AdBox';\nimport useFetch from '../../hooks/useFetch';\nimport useObservation from '../../hooks/useObservation';\nimport { ListContext } from '../../context/ListContext';\nimport Loader from '../loader/Loader';\n\nconst IssueList = () => {\n  const { setNextPage } = useContext(ListContext);\n  const [isLoading, error, issues, lastPage] = useFetch();\n  const onObserve = (entry, observer) => {\n    observer.unobserve(entry.target);\n    if (!isLoading && !lastPage) {\n      setNextPage();\n    }\n  };\n\n  const targetRef = useObservation(onObserve);\n\n  return (\n    <>\n      <S.List>\n\t\t...\n      </S.List>\n      {!lastPage ? (\n        <S.Target ref={targetRef} />\n      ) : (\n        <S.Banner>마지막 페이지입니다🎈</S.Banner>\n      )}\n    </>\n  );\n};\n\n\n```\n\n<img width=\"800\" src=\"https://user-images.githubusercontent.com/83333409/198885336-38510ffe-0e24-4010-9229-ab53ea785dcc.png\"/>\n\n## 마치며\n\n혼자 공부할 때는 그냥 에러해결을 위해서 해결방법을 찾고 기록하는 게 다였는데, 팀원분들이 물어봐 주시고 도와주시는 과정이 나에게 너무 너무 소중한 경험이었다. 내가 **왜 이렇게 코드를 짰는지** 물어 봐주는 사람이 있다는 게,**피드백과 질문**을 해주시는 분이 있다는 게 내가 성장할 수 있는 기회라는 생각이 들었다. 앞으로는 더 고민하고 **왜**와 **어떻게**를 잘 설명하는 코드들을 담아내서 더 잘 준비해 나갈 수 있는 시간으로 삼아 가야겠다.\n"},{"excerpt":"초기세팅 커밋 합치기 협업을 위해 ESLint, Prettier를 처음 사용하다보니 규칙들을 추가하고 업데이트를 해갈 필요가 있었다. 그러다 보니 한줄한줄이 추가된 자잘한 커밋들이 쌓여서 보기가 안좋아 이번 프로젝트를 하면서 같이 정했던 규칙들을 추가해 하나로 합친 commit history로 합치자는 생각이 들었다. commit message 컨벤션이 …","fields":{"slug":"/2022-10-28-원티드 프리온보딩-1주차-4일/"},"frontmatter":{"date":"October 28, 2022","title":"원티드 프리온보딩 1주차 첫째주 4일차-초기세팅 커밋 합치기","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n# 초기세팅 커밋 합치기\n\n<img width=\"500\" src=\"https://miro.medium.com/max/875/1*BCZkmZR1_YzDZy22Vn4uUw.png\"/>\n\n협업을 위해 ESLint, Prettier를 처음 사용하다보니 규칙들을 추가하고 업데이트를 해갈 필요가 있었다. 그러다 보니 한줄한줄이 추가된 자잘한 커밋들이 쌓여서 보기가 안좋아 이번 프로젝트를 하면서 같이 정했던 규칙들을 추가해 **하나로 합친 commit history**로 합치자는 생각이 들었다.\n\n[commit message 컨벤션이 지켜지지 않아있는 이전모습]\n\n```\n* [2022-10-28] [d776662] | [setting] 초기세팅 업데이트   (HEAD -> main)\n* [2022-10-27] [13db846] | fix: arrow-body-style eslint 설정 수정   (origin/main, origin/HEAD)\n* [2022-10-27] [cc0652e] | fix: comma-dangle 설정 변경\n* [2022-10-27] [85db00a] | fix: function-component-definition eslint 설정 수정\n* [2022-10-27] [f283b3e] | setting: eslint airbnb style 적용\n* [2022-10-26] [b04631c] | Fix : 불필요한 코드 리코일 삭제\n* [2022-10-26] [b8a34ae] | feat: 허스키 포함 세팅 추가\n* [2022-10-26] [49cbe3e] | feat : 허스키 포함 전 초기 세팅\n```\n\n위의 코드들은 .eslintrc.js에 한 두줄의 규칙을 추가한 부분이기 때문에 하나로 묶고 레포에 어떤 규칙이 있는지, 어떻게 세팅된 것을 사용하면 되는지 적어주면 앞으로 프로젝트를 할 때 많은 도움이 될 수 있지않을까 생각이 되었다.\n\n## git rebase\n\nrebase가 merge를 할 때만 이용된다고 생각했었는데 commit들을 합칠 때도 사용할 수 있었다. 우리 프로젝트의 경우 첫 커밋부터 하나로 합치고 싶었기 때문에\n\n`git rebase -i --root`를 통해 초기 커밋을 pick으로 나머지 커밋들은 squash로 합쳐서 하나의 커밋으로 합쳤다.\n\n```\n* [2022-10-26] [3a2ab8b] | [setting] 협업툴 (ESLint, Prettier, GitHook, Husky) 초기세팅 추가\n```\n\n# 서버와 AWS\n\n<img width=\"500\" src=\"https://cdn.inflearn.com/public/courses/328088/cover/953d4d86-ca11-4a4d-a771-b0eb6fb91677/328088-eng.png\"/>\n\n이번 수업에서 배웠던 내용은 서버와 클라우드 컴퓨터로 듣기만 하고, 사용해본 적이 없던 aws에 대해서 배울 수 있었다. 서버를 프리온보딩 코스를 시작하기 전에 조금은 공부해서 \"항상 켜져 있는 서버\"의 필요성을 더 느낄 수 있었다. API를 받기 위해서는 서버가 켜져 있어야 하는데 \"moijob\" 서비스를 만들면서 서버용과 클라이언트용 서버를 둘 다 켜 놓고 확인해야 했기에 불편함이 있었다.\n\n## 서버\n\n이렇게 항상 켜놓을 수 있는 서버는 두 가지 방식이 존재한다. 한가지는 실제로 내가 사서 서버용으로 컴퓨터를 켜놓는 방식, **On-Premise** 방식이고, 다른 방식은 실제로 사지 않고 클라우드 서버를 이용해 사용하는 **클라우드 컴퓨팅** 방식이다. on-premise방식의 경우에 실제하는 컴퓨터를 사용하기 때문에 실제적인 비용과 관리비용이 따로 들지만 클라우드 서버의 경우 클라우드를 제공해주는 회사에서 관리해주고, 그에 대한 비용을 지불하는 방식이다. 클라우드 서비스를 제공하는 서버는 전세계에 서버실이 있기 때문에 미국에서의 사업을 목표로 한다면 미국의 서버를 이용해 한국서버에서 이용하는 것보다 빠른 성능을 가질 수도 있는 장점과 필요한 만큼의 성능을 사용할 수 있는 장점도 가지기 때문에 현재 주요한 사업 중 하나로 꼽힌다.\n\n## AWS\n\nAWS는 amazon web service로, 클라우드 컴퓨팅의 대표적인 서비스이다. AWS에는 용도에 맞는 다양한 서비스가 존재한다. 그중 아마 내가 가장 많이 사용할 서비스는 S3 (Simple Storage Service)일 것 같다. S3 서비스는 말하자면 dropbox와 같은 기능처럼, 이미지나 파일 등의 정적파일을 불러올 때 사용하며 정적 웹사이트 호스팅에도 사용될 수 있다.\n\n이용은 아주 간단했다. CRA로 만든 프로젝트를 build한 후에 build폴더의 내용을 그대로 올려주기 만하면 Client-side-rendering을 이용한 배포가 간단하게 이루어진다. 이때 버킷의 설정을 public access로 하고 policy를 다음과 같이 설정하면 된다.\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"PublicReadGetObject\",\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::<bucket-name>/*\"\n    }\n  ]\n}\n```\n\n![aws](./aws.png)\n"},{"excerpt":"투두 best case 프로젝트 어제 회의를 통해 정한 best case들을 프로젝트에 적용하기 위해 협업 tool 세팅과 합치면서 생긴 시행착오득을 정리해보려 한다. 🧐 협업툴 설정 협업툴인 ESLint, prettier, husky를 이용한 git hook 세가지를 설정하면서 겪었던 에러들을 정리해보았다. 1. Husky Prettier 자동화 윈도우…","fields":{"slug":"/2022-10-27-원티드 프리온보딩-1주-3일차/"},"frontmatter":{"date":"October 27, 2022","title":"원티드 프리온보딩 1주차 첫째주 과제 3일차-best case 프로젝트 회고","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n# 투두 best case 프로젝트\n\n어제 회의를 통해 정한 best case들을 프로젝트에 적용하기 위해 협업 tool 세팅과 합치면서 생긴 시행착오득을 정리해보려 한다.\n\n## 🧐 협업툴 설정\n\n협업툴인 ESLint, prettier, husky를 이용한 git hook 세가지를 설정하면서 겪었던 에러들을 정리해보았다.\n\n### 1. Husky Prettier 자동화\n\n윈도우 OS를 사용하는 내가 세팅을 끝내고 레포를 올리고 팀원 분들이 받아서 사용할 때, Prettier가 작동하지 않는 문제가 생각했다.\n\n여기서 문제점은 **윈도우에서 init 할때 리눅스에서 파일 권한과 충돌**로 터미널에 `chmod ug+x .husky/*` 을 추가해서 설정해줘야 정상적으로 작동할 수 있었다.\n\n[husky 관련 이슈](https://github.com/typicode/husky/issues/1177)\n\n### 2. ESlint Air-bnb style\n\n엄격한 기준을 가지고 있는 ESLint Air-bnb 스타일을 적용해, 필요한 부분들만 설정을 꺼주는 방식으로 ESLint 설정을 했다. 우리가 프로젝트를 하면서 느꼈던 세팅변경은 다음과 같다.\n\n- Air-bnb Eslint에서 화살표 함수를 함수 선언문으로 바꾸는 설정 off\n\n```\nreact/function-component-definition : 0 // 컴포넌트 작성 시 화살표 함수 사용 가능\n```\n\n- 화살표 함수에서 단일 파라미터 일 때 소괄호 없어지는 설정 off\n\n```\n 'arrow-body-style' : 0\n```\n\n- 함수 내에서 return을 생략하는 설정 off\n\n```\n 'Consistent-return' : 0\n```\n\n- 사용하지 않는 변수 에러로 인식하는 설정 off\n\n```\n 'no-unused-vars' : 0\n```\n\n- object 안에서 comma를 무조건 써줘야하는 설정 off\n\n이유 : prettier 설정에서 자동으로 마지막 키나 인덱스의 comma를 삭제시키기 떄문에 eslint와 충돌이 나 꺼주었다.\n\n```\n 'comma-dangle' : 0\n```\n\n팀 내의 convention으로 함수형 컴포넌트를 화살표함수로 작성하기로 해, 함수 선언문이 아니면 에러로 던지는 설정이나 prettier와 충돌해서 생기는 에러들을 꺼주었다. 처음 생각했던 설정들보다 더 많은 설정들이 필요했지만 보다 이번 프로젝트를 함께 하면서 불편한 점들을 같이 해결해나가는 과정이어서 더 의미있었다.\n\n초기 세팅을 위한 boilerplate를 만들어서 보다 깔끔한 설정으로 앞으로 프로젝트를 진행해나갈 수 있을 것 같다.\n\n## 📢 contextAPI Provider의 eslint에서 에러\n\ncontext API를 이용해서 로그인 상태를 전역상태로 관리하려 했다. 원래 개인적인 프로젝트에서는 잘 작동하던 코드가 다음과 같은 에러를 던졌다.\n\n```jsx\nexport const LoginProvider = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(\n    !!getLocalStorage({ name: TOKEN_NAME })\n  );\n\n  return (\n    <LoginContext.Provider value={% raw %}{{ isLoggedIn, setIsLoggedIn }}{% endraw %}>{children}</LoginContext.Provider>\n  );\n};\n```\n\n```\nThe object passed as the value prop to the Context provider changes every render\nThe object passed as the value prop to the Context provider\n```\n\n문제는 value로 전달되는 object가 계속해서 바뀌어서 생기는 에러로 ESLint에서 성능저하를 예상해 에러를 던져주었다. 이를 해결하기 위한 방법은 Context 데이터를 가지고 있는 컴포넌트에 useMemo hook을 이용하여 데이터를 캐싱하여 불필요한 리렌더링 방지하였다.\n\ncontextAPI의 단점인 전체적인 리렌더링을 마주할 수 있는 좋은 기회가 되었다.\n\n```jsx\nexport const LoginProvider = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(\n    !!getLocalStorage({ name: TOKEN_NAME })\n  )\n  const value = useMemo(() => ({ isLoggedIn, setIsLoggedIn }), [isLoggedIn])\n\n  return <LoginContext.Provider value={value}>{children}</LoginContext.Provider>\n}\n```\n\n## 🎈 아쉬웠던 점\n\nauth 페이지의 구조를 바꾸다 보니 디테일한 부분을 고민하지 못했다. 변수명, 함수명을 정할 때 보다 명료하게 정리하지 못했고, 불필요한 리렌더링을 막거나 내부적인 에러메시지를 좀 더 정리해서 보내는 부분이 아쉬웠다.\n\n## 💡 프로젝트 진행방식에 대한 생각\n\n팀원중 한명이 driver 나머지 팀원 7명이 navigator로 참여해 진행하다보니, 너무 오랜시간이 걸리는 단점을 발견했다. 팀원별로 기능을 담당해서 개발을 한다면 더빠르고 각자 일을 맡아서 하는 참여도가 높아지는 장점이 있지만, 개인과제들을 합치다 보니 맞춰가는 데 더 많은 시간이 필요했다.\n\n이부분을 해결하기 위해서 과제 시작전에 폴더 구조들을 정리하고 거기서 출발하게 된다면 앞으로 과제를 할때 추가된 부분만 이야기하면 되기 때문에 더 생산성이 높아질 것이라는 생각이 들었다.\n"},{"excerpt":"사전 과제 정리 팀원들의 사전 과제들을 서로 발표하고 어떤 점이 좋은지, 왜 이렇게 했는지 서로 의논하고 피드백을 하는 시간을 삼았다. 발표를 위해 먼저 내가 한 사전 과제를 정리해보고 내가 어떤 점이 부족했는지 보완해서 발표하는 시간을 가졌다. 🔨 수정사항 먼저 수정한 부분은 api들을 클래스로 주입해주는 방식이었다. 단순히 함수를 불러와서 쓰는 것이 …","fields":{"slug":"/2022-10-25-원티드프리온보딩-1주차-2일/"},"frontmatter":{"date":"October 25, 2022","title":"원티드 프리온보딩 1주차 첫째주 과제-best case찾기와 보충공부:context API","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n# 사전 과제 정리\n\n팀원들의 사전 과제들을 서로 발표하고 어떤 점이 좋은지, 왜 이렇게 했는지 서로 의논하고 피드백을 하는 시간을 삼았다. 발표를 위해 먼저 내가 한 사전 과제를 정리해보고 내가 어떤 점이 부족했는지 보완해서 발표하는 시간을 가졌다.\n\n### 🔨 수정사항\n\n먼저 수정한 부분은 api들을 클래스로 주입해주는 방식이었다. 단순히 함수를 불러와서 쓰는 것이 아니라 index.js에서 instance를 만든 후에 필요한 페이지에 주입하는 방법으로 수정했다. 원래 존재했던 함수들은 method들로 수정했다.\n\n```javascript\nexport class AuthService {\n  constructor(baseURL) {\n    this.baseURL = baseURL;\n  }\nexport async function postSignUp(email, password) {\n  try {\n    const res = await fetch(`${BASE_URL}/auth/signup`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        email,\n        password,\n      }),\n    });\n    if (!res.ok) {\n      console.log(`${res.status}에러가 발생했습니다`);\n      throw new HTTPError(res.status, res.statusText);\n    } else {\n      return await res.json();\n    }\n  } catch (e) {\n    return e.codeToErrorMessage;\n  }\n}\n\n}\n```\n\n두 번째로 수정한 부분은 httpClient 클래스를 추가했다. httpClient는 반복되는 fetch의 헤더와 바디 부분의 코드 중복을 제거하고, baseURL에 전달받은 url을 더한 url에 option에 따라 fetch를 수행 해주는 클래스다.\n\n#### httpClient\n\nhttpClient 클래스는 가지고 있는 baseURL에 전달받은 url과 option에 따라 fetch를 실행해주는 클래스입니다.\n\nfetch는 성공했다면 JWT가 담긴 객체를 반환하고 실패했다면 커스텀 에러 HTTPError를 던지고 메시지를 전달합니다.\n\n```javascript\nexport class HttpClient {\n  constructor(baseURL) {\n    this.baseURL = baseURL\n  }\n\n  async fetch(url, options) {\n    const res = await fetch(`${this.baseURL}${url}`, {\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    })\n    try {\n      if (!res.ok) {\n        console.error(`${res.status}에러가 발생했습니다`)\n        throw new HTTPError(res.status, res.statusText)\n      } else {\n        return await res.json()\n      }\n    } catch (e) {\n      return e.codeToErrorMessage\n    }\n  }\n}\n```\n\nHTTPClient class를 이용함으로써 authService와 todoService는 훨씬 간결한 코드를 가질 수 있다.\n\n```javascript\nexport class AuthService {\n  constructor(httpClient) {\n    this.httpClient = httpClient\n  }\n  async postSignUp(email, password) {\n    return this.httpClient.fetch(\"/auth/signup\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        email,\n        password,\n      }),\n    })\n  }\n\n  async postSignIn(email, password) {\n    return this.httpClient.fetch(\"/auth/signin\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        email,\n        password,\n      }),\n    })\n  }\n}\n```\n\n#### Auth의 함수\n\n함수들의 promise들의 체이닝으로 복잡하게 보여 async-await으로 보다 간결한 코드로 수정했다.\n\n```javascript\nconst handleLoginSubmit = useCallback(\n  async info => {\n    const { email, password } = info\n    const response = await authService.postSignIn(email, password)\n    if (\"access_token\" in response) {\n      navigate(\"/todo\")\n      localStorage.setItem(\"access_token\", response.access_token)\n    } else {\n      setLoginMessage(prev => {\n        return {\n          ...prev,\n          ...response,\n        }\n      })\n    }\n  },\n  [navigate]\n)\n\nconst handleRegisterSubmit = useCallback(async info => {\n  const { email, password } = info\n  const response = await authService.postSignUp(email, password)\n  let message = response\n  if (\"access_token\" in response) {\n    message = {\n      message: `회원가입에 성공했습니다`,\n      success: true,\n    }\n  }\n  setRegisterMessage(prev => {\n    return {\n      ...prev,\n      ...message,\n    }\n  })\n}, [])\n```\n\n### 투두 페이지\n\ntodo도 동일하게 함수상태로 api호출을 하는 게 아니라 todoService 클래스를 만들었고 httpClient를 이용해 api 호출 해 기존의 코드중복을 제거했다.\n\n클래스로 감싸주었기 때문에 간단하게 method이름들도 수정했다.\n\n```javascript\nexport class TodoService {\n  constructor(httpClient) {\n    this.httpClient = httpClient\n  }\n  async create(todo) {\n    return this.httpClient.fetch(\"/todos\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n      },\n      body: JSON.stringify({\n        todo,\n      }),\n    })\n  }\n\n  async get() {\n    return this.httpClient.fetch(\"/todos\", {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n      },\n    })\n  }\n\n  async update(obj) {\n    const { todo, isCompleted } = obj\n    return this.httpClient.fetch(`/todos/${obj.id}`, {\n      method: \"PUT\",\n      headers: {\n        Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n      },\n      body: JSON.stringify({\n        todo,\n        isCompleted,\n      }),\n    })\n  }\n\n  async delete(id) {\n    return this.httpClient.fetch(`/todos/${id}`, {\n      method: \"DELETE\",\n      headers: {\n        Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n      },\n    })\n  }\n}\n```\n\n## 2. 피드백\n\n피드백을 주고 받으면서 느꼈던 건 사람들마다 너무 다르게 코드를 구성하고, 그렇기 때문에 초기 설정이 많이 중요하구나라는 부분과 의존적이지 않은 컴포넌트를 만드는 것의 중요성이었다. 각자의 로직에 맞게 제작된 컴포넌트이다 보니 거기에 너무 특화되어 있어 취합하기가 어려울 것 같다는 이야기가 많이 나왔다.\n\n그중에서도 좋은 포인트들로 의논되었던 점들은 독립적으로 사용될 수 있어서 어디에나 적용될 수 있는 로직들이었다.\n\naxios의 interceptor를 이용해 httpClient 클래스 역할을 대신해서 적용하신 분도 계셨고, react 커스텀 hook을 이용해서 httpClient 클래스와 같이 옵션들만 잘 전달하면 어떤 api든 호출할 수 있게 만드신 분도 계셨다. 단순히 토큰을 추가하고 페이지이동을 시켜었던 나와 달리 context API를 이용해서 상태로 보관하고 상태에 따라 로직을 처리해주신 분도 계셨다.\n\n나보다 뛰어난 사람들, 나보다 넓은 관점들을 가지신 분들이 너무 많기 때문에 더 많이 배울 수 있겠다 생각도 들었지만, 정말 가만히 수동적으로 있다면 아무것도 안 늘고 잘해 주시는 분들에게 **묻혀갈 수도 있는 위험성도 느꼈다**. 더 적극적으로 배우고, 더 적극적으로 만들어서 **간절하게 해야 한다**는 점을 더 많이 느꼈다.\n\n발표를 하면서도 내 코드를 **왜 이렇게 짰는지** 설명하는 부분, 누군가가 이해할 수 있게 **정리되어있는 상태**가 된다는 것의 중요성도 느꼈다.\n\n## 3. 공부가 필요한 부분들\n\n피드백을 하면서 리액트를 잘한다고 느꼈던 부분들은 context API와 custom hook이었다. 내 프로젝트에서도 분명 쓸 수 있는 부분들이 있었지만 놓쳤다. 그렇기 때문에 공부가 필요하다고 느껴서 정리를 해보고자 한다.\n\n### 3.1 context API\n\n![post-thumbnail](https://velog.velcdn.com/images/devjade/post/c155b13a-e1b7-4205-9f39-875e1c284454/contextAPI.png)\n\ncontext API는 prop-drilling (상태를 전달하기 위해 여러 컴포넌트를 거쳐서 전달해주어야 하는 경우)을 막기 위한 API로 전역상태를 만들 수 있다.\n\n흔히 사용되는 경우는 로그인, 언어, 다크모드 등이 있다. 이번에 우리 과제에서 사용할 경우는 로그인으로 직접 코드를 만들어 보았다.\n\n기존 코드에서는 App.jsx에서 상태로 관리되고 있었고 signIn, signUp, todo모두에서 useEffect에서 상태에 따라 redirect하는 기능이 있었다. context API를 이용한다면 반복되는 로직을 없앨 수 있어서 더 좋은 코드가 될 수 있다고 생각되었다.\n\n```jsx\nimport { createContext } from 'react';\nimport { useState } from 'react';\n\nexport const LoginContext = createContext();\nexport function LoginProvider({ children }) {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  return (\n    <LoginContext.Provider value={% raw %}{{ isLoggedIn, setIsLoggedIn }}{% endraw %}>\n      {children}\n    </LoginContext.Provider>\n  );\n}\n\n```\n"},{"excerpt":"1주차-첫번째 섹션 협업툴: 문서화 기대하고 떨리기도 했던 프리온보딩 코스가 오늘부터 시작되었다. 세션의 주제는 \"\"협업 tool\"이었다. 채용공고에서 한번씩 보이던 esLint와 prettier, git, 그리고 처음 알게 된 git hook과 husky에서 다룬 시간이었다. 오늘 수업을 들으면서 \"왜 ESLint와 prettier를 채용공고에 넣었을까…","fields":{"slug":"/2022-10-25-원티드프리온보딩-1주차-1일/"},"frontmatter":{"date":"October 25, 2022","title":"원티드 프리온보딩 1주차 1-1 협력툴:ESLint,Prettier,Git Hook, Husky","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n# 1주차-첫번째 섹션 협업툴: 문서화\n\n기대하고 떨리기도 했던 프리온보딩 코스가 오늘부터 시작되었다. 세션의 주제는 \"\"협업 tool\"이었다. 채용공고에서 한번씩 보이던 esLint와 prettier, git, 그리고 처음 알게 된 git hook과 husky에서 다룬 시간이었다. 오늘 수업을 들으면서 \"왜 ESLint와 prettier를 채용공고에 넣었을까\"라는 의문을 깰 수 있는 시간이었다.\n\n협업 툴의 가장 기본되는 생각은 **같은 세팅에서 시작하자**이다. 이러한 세팅을 위한 기술들에 대해 정리해보고자 한다.\n\n## 1. Git\n\nGit은 분산형 버전 관리 시스템 (DVC: Distributed Version Control)이다.\n\n이전의 CVS(Centralized Version Control)는 오프라인으로 작업이 어려운 점, 서버가 죽으면 데이터가 다 날라가 버리는 단점 등을 있었다.\n\nGit은 오프라인에서도 작업을 할 수 있으며, 개발자 모두가 같은 history를 가지고 있기 때문에 서버가 죽어도 쉽게 복구 시킬 수 있는 장점을 가지고 있다.\n\n![business-org](https://www.simplilearn.com/ice9/free_resources_article_thumb/business-org.JPG)\n\n이렇게 많은 사람이 함께 사용할 수 있는 Git을 잘 사용하기 위해서는 서로 간의 약속이 필요하고\n\n이걸 **Commit Message Convention**이라고 부른다. 이러한 convention을 지킴으로써 작성자가 아닌 다른 사람이 코드를 읽을 때 어떤 목적으로 코드를 구성했는지 쉽게 알 수 있는 장점이 있다.\n\n### 1.1 Commit Message Convention\n\n코드 컨벤션은 같이 일하는 팀의 약속이기에 내부에서 조금씩 달라질 수는 있지만 모두가 같이 지켜야 하는 약속이다.\n\n대표적인 예로 **[Udacity commit message guide](https://udacity.github.io/git-styleguide/)**가 있다. 내용을 참고해서 정리해 보고자 한다.\n\n```\ntype: Subject\n\nbody\n\nfooter\n```\n\n위와 같이 커밋 메시지는 세 가지로 크게 나뉜다.\n\n#### Type\n\n타입의 경우 가장 간략히 어떤 일을 했는지 summary를 담아줘야 한다.\n\n- **feat:** A new feature\n- **fix:** A bug fix\n- **docs:** Changes to documentation\n- **style:** Formatting, missing semi colons, etc; no code change\n- **refactor:** Refactoring production code\n- **test:** Adding tests, refactoring test; no production code change\n- **chore:** Updating build tasks, package manager configs, etc; no production code change\n\n위의 내용을 보다 보니 청원사이트 서비스를 만들면서 동일한 convention으로 작업했었고 지금도 커밋 메시지를 이렇게 작성하고 있다. 처음 방법을 잘 배워두었다는 생각이 들었다.\n\n[팀원들과 함께 정한 컨벤션]\n![컨벤션](./컨벤션.png)\n\n#### Body\n\nBody는 선택 사항으로 어떤 문제를 해결했는지 왜 이렇게 수정했는지를 설명하는 부분으로 팀 프로젝트 때 PR을 보내면서 코드를 설명했던 부분과 같았다.\n\n#### Footer\n\nFooter도 동일하게 선택사항이며, 주로 이슈 번호를 담는다고 한다.\n\n### 1.2 Git history\n\ngit history는 프로젝트가 어떤 문제들을 해결해왔는지 남기는 **발자취**와 같다고 생각된다. 그렇기 때문에 history에 불필요한 commit들이 남발 되어 있다면 프로젝트가 해결하고자 한 문제점들을 한눈에 알아보기 힘들다. 이러한 부분을 막기 위해서 \"squash merge\"와 \"rebase merge\" 전략이 존재한다.\n\n### merge\n\n하나의 문제를 해결하기 위해서 브랜치를 만들고 그 브랜치에서 작업을 한 후에 커밋들을 그냥 merge를 하게 되면 브랜치를 파기 전 commit과 이어져 history에 남게 되고 복잡해진다.\n\n![merge](https://image.toast.com/aaaadh/real/2017/techblog/Screen%20Shot%2020170529%20at%2012.15.48%20PM.png)\n\n### Squash merge\n\n![squash merge](https://image.toast.com/aaaadh/real/2017/techblog/Screen%20Shot%2020170529%20at%2012.15.51%20PM.png)\n\n이것을 해결하기 위해서 사용할 수 있는 방법이 squash merge라는 방법으로 branch의 여러 개의 커밋을 하나의 커밋으로 합쳐서 기존 브랜치에 merge할 수 있다. 하나의 main branch만 남게 됨으로 history가 더 간결해지는 장점을 가진다. 하지만 a,b,c 서로 다른 내용이 하나로 합쳐지기 때문에 자세한 내용은 볼 수 없다는 단점도 가진다.\n\n### Rebase merge\n\n![rebase](https://image.toast.com/aaaadh/real/2017/techblog/Screen%20Shot%2020170529%20at%2012.15.55%20PM.png)\n\n하나하나의 내용을 담을 수 있는 방법으로는 rebase merge로 기존 branch를 만든 init 커밋에서 부모를 e로 rebase를 해 합치는 방식이다. squash merge와 달리 각각의 커밋을 볼 수 있지만 여전히 세부적인 커밋들이 많아질 수도 있다는 단점이 존재한다.\n\n용도에 따라 목적에 따라 두 가지 방법을 사용하면 될 것 같고, 이전 청원서비스를 만들 때에는 PR을 날림으로써 squash merge가 자동으로 되어서 편하게 작업했다. 개인 사이드 프로젝트를 할 때는 branch도 만들지 않고 그냥 커밋했었는데, 이제부터라도 history관리를 해야겠다는 중요성을 느꼈다.\n\n## 2. ESLint 와 Prettier\n\n<img witth=\"800px\" height=\"300ppx\" src=\"https://velog.velcdn.com/images/kyusung/post/f0ba3816-2c64-4958-9b51-675681e2a9aa/1_83PZeBAFQkP1XyOfDigxsg.png\"/>\n\n#### ESLint\n\nESLint는 자바스크립트에서 에러가 날 수 있는 버그들을 잡아 줄 수 있는 툴이다. 코드와 관련된 두 가지 일을 하는데 하나는 **code formatting,** 다른 하나는 **code quality**이다. 두 가지 일을 다 할 수 있지만 ESLint는 주로 후자인 code quality에 대한 역할을 주로 담당하고, code formatting은 prettier에 일임하는 형식으로 둘을 함께 사용한다.\n\nCode quality부분은 자바스크립트 내부에서 버그가 발생할 수 있거나 불필요한 코드 등에 대해 경고를 미리 던져 주는 역할을 한다. 코드 내에 `console.log()`가 남아있을 때 에러를 던져 주거나, ` ;`로 끝나지 않았을 때 수정 해주는 등의 일을 할 수 있다. 설정 파일은 .eslintrc.js로 원하는 확장자나 규칙들을 추가해서 사용할 수 있고, `eslint <filename>`을 이용하면 직접 실행할 수 있고 `eslint <filename> --fix`를 사용하면 ESLint에서 수정할 수 있는 에러를 수정해준다.\n\n```json\n// .eslintrc\n\n{\n  \"extends\": [\"react-app\", \"eslint:recommended\"],\n  \"rules\": {\n    \"no-var\": \"error\", // var 금지\n    \"no-multiple-empty-lines\": \"error\", // 여러 줄 공백 금지\n    \"no-console\": [\"error\", { \"allow\": [\"warn\", \"error\", \"info\"] }] // console.log() 금지\n  }\n}\n```\n\n위 **eslint:recommended**라는 플러그인을 추가해주면 자동으로 eslint 규칙들이 추가되는데 추가되는 규칙은 eslint 공식 문서의 체크표시가 되어있는 규칙들이다.\n\n![eslint](./eslint.png)\n\n#### Prettier\n\nPrettier는 ESLint와 달리 code quality에는 관심이 없고, **code formatting**에만 관심을 가지는 툴이다.\n\nprettier와 ESLint의 충돌을 막기 위해서는 간단하게 plugin을 추가하면 되는데, 우선 \"eslint-config-prettier\"와 \"eslint-plugin-prettier\" 두 가지 패키지를 설치한다. 설치 후에는 간단하게 .eslintrc.js파일에 해당 플러그인을 추가하면 된다.\n\n```javascript\nmodule.exports = {\n  extends: [\"eslint:recommended\", \"plugin:prettier/recommended\"],\n}\n```\n\n위의 설정에 따른 결과로 ESLint는 두가지 에러를 던져준다.\n\n![lint-error](./lint-error.png)\n\n```javascript\n//이전 코드\nvar foo = \"not used\" //var ESLint\nconsole.log(\n  \"...............................................................................................................\"\n)\n//prettier\n\n//수정된 코드\n\nvar foo = \"not used\"\n\nconsole.log(\n  \"...............................................................................................................\"\n)\n```\n\n앞서 얘기한 대로 vscode에는 extension이 이미 존재하기 때문에 extension을 사용할 수 있지만, 새로 vscode를 설치하거나 다른 에디터를 사용하는 경우 등 플러그인만 사용하면 자동화가 어려울 수 있다. 일일이 eslint를 돌려보고 버전 관리를 할 수는 없기 때문에 프로젝트를 받고 자동으로 실행해 줄 수 있는 자동화가 필요하다.\n\n### Git hook과 husky를 이용한 자동화\n\n위의 문제를 해결하는 방법으로 **Git hook과 husky**를 함께 사용할 수 있다. Git hook은 git 명령어 사용 전 후에 특정 동작을 실행할 수 있게 설정하는 방법이다. git hook만으로는 설정이 복잡하기 때문에 husky를 이용해서 미리 세팅해둔 git hook을 적용시킬 수 있다.\n\nhusky는 `npx husky add .husky/pre-commit \"npm run lint\"` 와 같이 간단하게 해당 git hook에 맞는 명령어를 저장할 수 있다. 실행하면 .husky라는 폴더가 생기고 해당 hook을 자동으로 실행 해주는 파일이 생성된다. 이것을 이용하면 package.json에 있는 lint라는 script를 커밋 전에 ESLint로 확인한 후에, 통과하면 커밋을 할 수 있게 자동화가 가능하다.\n\n![husky](./husky.png)\n\n실제로 커밋하면 다음과 같은 결과를 볼 수 있다.\n\n[커밋 전 상태]\n![커밋전](./커밋전.png)\n\n[커밋 후 에러]\n![커밋후](./커밋후.png)\n\ngit hook과 husky를 이용해서 세팅하는 전반적인 과정은 다음과 같이 정리할 수 있다.\n\n1. 처음 husky를 설치 `npm i husky --save-dev`\n\n2. 필요한 hook 추가하기 `npx husky add .husky/pre-push \"npm run lint\"`\n\n3. husky에 등록되어있는 git hook을 적용 `npx husky install`\n\n   - 이후에 clone하면 바로 실행 될 수 있게 package.json에 `\"postinstall\":\"husky install\"` 추가하기\n\n4. scripts에 자동화할 ESLint와 Prettier 명령어 추가하기\n\n   ```json\n   {\n     \"scripts\": {\n       \"postinstall\": \"husky install\",\n       \"format\": \"prettier --cache --write .\",\n       \"lint\": \"eslint --cache .\"\n     }\n   }\n   ```\n\n[참고자료]\n\n- NHN Cloud GitHub의 Merge, Squash and Merge, Rebase and Merge 정확히 이해하기](https://meetup.toast.com/posts/122\n- https://www.youtube.com/watch?v=Y3kjHM7d3Zo\n"},{"excerpt":"UI 수정 어제 생각했던 카드를 필터링 할 수 있는 버튼들을 추가하고, 원티드 로고를 추가했다. 서버에서 크롤링 할 때 이미지를 함께 받아올 수 있게 로직을 추가해 조금 더 디자인 적으로 채웠다. 개선 UI\n\n그리고 원티드의 포트폴리오 관련 자료를 보다가 서비스를 조금 더 발전 시킬 수 있는 포인트를 얻을 수 있었다. 원티드 포트폴리오를 부탁해  포트폴리…","fields":{"slug":"/2022-10-25-모으잡-UI-수정-크롤링-데이터-연결/"},"frontmatter":{"date":"October 25, 2022","title":"모으잡-프론트페이지 UI수정, 크롤링한 데이터 받아오기","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n## UI 수정\n\n어제 생각했던 카드를 필터링 할 수 있는 버튼들을 추가하고, 원티드 로고를 추가했다. 서버에서 크롤링 할 때 이미지를 함께 받아올 수 있게 로직을 추가해 조금 더 디자인 적으로 채웠다.\n\n[개선 UI]\n![개선 UI](./개선UI.png)\n그리고 원티드의 포트폴리오 관련 자료를 보다가 서비스를 조금 더 발전 시킬 수 있는 포인트를 얻을 수 있었다.\n\n[원티드 포트폴리오를 부탁해](https://www.wanted.co.kr/events/talk8)\n\n![포트폴리오를 부탁해](./포트폴리오를부탁해.png)\n\n포트폴리오를 작성할 때, 어떤 내용을 핵심으로 삼아서 작성해야 하는 지에 대해서 말씀해주는데, 여기서 가장 큰 포인트가 되었던 점은, 어떤 사람을 찾고 있는지는 \"Job Description(JD)\"에 담겨있다는 점이었다. JD에 담긴 회사가 바라는 능력을 아는 데서 그치지 않고, 리액트를 잘한다는 것을 어떤 건지, 타입스크립트를 잘 다룬다는 건 어떤 건지 **스스로 잘한다를 정의하고 관련 경험을** **기술한다면** **매력적인 포트폴리오가 될 수 있다**고 말해 주셨다.\n\n그러면 내 서비스도 단순히 크롤링한 걸 보여주고 정리하기만 하지 말고, 정리해온 각각의 JD에 대해 **사용자 자신의 경험과 생각을 정리할 수 있게 까지 한다면 더 좋지 않을까?** 라는 생각이 들어서 우선 페이지를 완성한 후에 기록할 수 있는 페이지를 추가 해보기로 계획했다.\n\n## 크롤링 로직\n\n서버에 만들어놓은 크롤링 로직을 프론트 페이지와 연결했다. 프론트 페이지와 연결하면서 조금 까다로웠던 부분은 입력받은 url을 어떻게 예외 처리를 할 지였다.\n\n#### url 예외처리\n\nurl을 체크할 수 있는 곳은 서버와 프론트 모두 가능하기 때문에 어느 곳에서 처리할 지 고민하다가, 안전하게 둘 다 동일한 로직으로 처리했다. 원티드 채용공고들은 \"https://www.wanted.co.kr/wd/\"로 시작하는 공통점을 발견했고 간단하게 https://www.wanted.co.kr/wd/로 시작하는지만 체크했다.\n\n서버에서는 url이 잘못되면 크롤링을 실행하지 않고 바로 에러를 던져주고, 던져진 에러를 받아서 400 Bad Request로 응답하게 로직을 구성했다.\n\n```javascript\n//서버\n\n//crawler.js\nexport default class Crawler {\n  constructor() {\n    this.wantedURL = 'https://www.wanted.co.kr/wd';\n  }\n\n  checkUrl(url) {\n    return url.startsWith(this.wantedURL);\n  }\n\n  async creatJob(url) {\n    if (!this.checkUrl(url)) {\n      throw new Error('잘못된 URL입니다.');\n    }\n    ...\n  }\n}\n\n\n //app.js\n\napp.post('/jobs', async (req, res, next) => {\n  const url = req.body.url;\n  let job;\n  try {\n    job = await crawler.creatJob(url);\n    jobs = [job, ...jobs];\n    res.status(201).json(job);\n  } catch (error) {\n    res.sendStatus(400);\n  }\n});\n\n```\n\n프론트 페이지에서는 동일한 로직으로 에러가 발생하면 placeholder와 border색을 바꿔주게 설정했다.\n\n[에러핸들링적용]\n![에러적용](./에러적용.png)\n"},{"excerpt":"채용공고서비스 UI 제작 채용공고서비스 UI를 고민하면서, 정리하는 형식들을 참고하게 되었다. 기존의 서비스를 구상했던 이유가 자동화해서 받아오는 편리함도 있지만, 공고를 쉽게 비교하고 중요내용만 간략하게 보기 위해서 였다. 그러기 위해서는 받은 내용을 보여줄 UI디자인이 중요했고, 참고한건 \"evernote\" 어플리케이션이다. Evernote  Ever…","fields":{"slug":"/2022-10-24-모으잡-프론트페이지-UI제작/"},"frontmatter":{"date":"October 24, 2022","title":"모으잡-프론트페이지 UI제작","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n## 채용공고서비스 UI 제작\n\n채용공고서비스 UI를 고민하면서, 정리하는 형식들을 참고하게 되었다.\n\n기존의 서비스를 구상했던 이유가 자동화해서 받아오는 편리함도 있지만, 공고를 쉽게 비교하고 중요내용만 간략하게\n\n보기 위해서 였다. 그러기 위해서는 받은 내용을 보여줄 UI디자인이 중요했고, 참고한건 \"evernote\" 어플리케이션이다.\n\n[Evernote]\n\n![에버노트](./에버노트.png)\n\nEvernote디자인을 보면 왼쪽의 관련된 내용을 모아두고 자세히 보고 싶은 부분은 오른쪽에 보여주는 형식으로 되어있다. 내 서비스에서도 왼쪽에 스크롤링한 공고들을 간략하게 보여주고, 오른쪽에는 자세히 보고싶은 공고를 보여주는 방식으로 디자인해보았다. UI제작을 위해서 tailwind css라이브러리를 사용해서 제작해보았다. styled-components를 좋아하긴 하지만, 새로운 프로젝트를 하면서 새로운 라이브러리들을 경험해보는 것도 좋을 것 같고, 보다 디자인이 잘되어있는 tailwind를 이용하면 쉽게 내가 원하는 UI를 만들 수 있을 것이라 예상되었다.\n\n우선 제작해본 디자인이다. evernote처럼 왼쪽에 공고들을 간략하게 두고 오른쪽에 자세한 내용을 보여줄 수 있는 공고들을 담았다. 담고보니 조금 부실(?)해보여서 디자인적으로도 계속 고민이 필요하다.\n\n![UI](./UI.png)\n\n## 로직 구상\n\n서비스가 제공할 일을 정리하면 다음과 같다.\n\n1. 공고의 url을 받아서 전달하면 서버에 url을 전달하고, 데이터를 추출받는다.\n2. 추출한 공고를 데이터베이스를 저장한 후에, 사용자가 원하는 기준에 따라 필터링된 데이터들을 보여준다.\n\n첫번째를 위해서, 서버에서는 회사의 이미지도 받아오면 좋을 것 같아, 이미지를 받아오는 부분을 추가하고, 프론트에서는 데이터를 보내고 받는 로직을 추가해야한다. 두번째를 위해서는 localstorage를 우선 이용해 데이터를 저장하고, 필터링을 할 수 있게 UI와 로직을 추가한다.\n\n처음에는 뭔가 괜찮은 아이디어다하고 시작했는데 생각보다 초라하다고 느껴져 맘이 힘들기도 했다. 그래도 **계속해서 업데이트하다보면 좀 더 괜찮아지지 않을까, 누군가가 쓸 수도 있지 않을까** 생각하면서 내일 더 발전시켜나야겠다.\n"},{"excerpt":"Puppeteer Puppeteer는 Chrome브라우저에서 사용할 수 있는 devtools API를 제공하는 Node js 라이브러리이다. 이전에 사용했던 Selenium과 같이 브라우저를 접속해서 이벤트 발생 등 다양한 api를 지원한다. 차이점이라면 Puppeteer는 크롬위에서만 동작하기 때문에 다른 브라우저에서는 사용할 수 없다. 하지만 성능이 …","fields":{"slug":"/2022-10-23-모으잡-puppeteer-크롤러제작-프론트페이지-구상/"},"frontmatter":{"date":"October 23, 2022","title":"모으잡-puppeteer을 이용한 크롤러제작, 프론트페이지 구상","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# Puppeteer\n\nPuppeteer는 Chrome브라우저에서 사용할 수 있는 devtools API를 제공하는 Node js 라이브러리이다. 이전에 사용했던 Selenium과 같이 브라우저를 접속해서 이벤트 발생 등 다양한 api를 지원한다. 차이점이라면 Puppeteer는 크롬위에서만 동작하기 때문에 다른 브라우저에서는 사용할 수 없다. 하지만 성능이 Selenium보다 좋고, 서비스가 크롬에서만 작동해도 상관이 없다 생각이 들어 우선 Puppeteer를 사용해보았다.\n\n어제까지 작업했을 때, 생긴 문제는 axios를 이용해 정적으로 페이지를 불러오면 내가 원하는 설명이 담긴 부분들이 들어오지 않는다는 점이었다. 이를 해결하기 위해서 puppeteer를 이용해 동적으로 페이지를 불러왔다.\n\n```javascript\nconst browser = await puppeteer.launch() //puppeteer로 브라우저를 실행, 옵션으로 실제로 브라우저를 켤 수 있어\nconst page = await browser.newPage() //우리가 사용할 페이지\nawait page.goto(url) //원하는 url로 연결\nconst content = await page.content() // url의 html을 받아와\n```\n\n위 코드로 불러온 html에서 어제 공부했던 cheerio를 이용해 데이터를 추출하려 시도했다. 다행히 내 예상이 맞아, 어제와는 다르게 puppeteer를 이용해 데이터를 받아올 수 있었다. 받아온 데이터중에서 span안의 값들은 처음 scheme을 짤 때 생각했던, 배열형식으로 만들기 위해 split을 이용해 배열로 저장했다.\n\n```javascript\n\t async creatJob(url) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url);\n\n    const content = await page.content();\n    const $ = cheerio.load(content);\n    const titleLists = $('h6');\n    const contentLists = $('p>span');\n    const result = {\n      name: $(titleLists[0]).text(),\n      platform: 'wanted',\n      id: Date.now(),\n      mainWork: [],\n      qualification: [],\n      preferential: [],\n      url,\n    };\n\n    contentLists.each((idx, node) => {\n      switch (idx) {\n        case 1: {\n          const mainWork = $(node)\n            .text()\n            .split('• ')\n            .filter((item) => !!item);\n          result.mainWork = mainWork;\n          break;\n        }\n        case 2: {\n          const qualification = $(node)\n            .text()\n            .split('• ')\n            .filter((item) => !!item);\n          result.qualification = qualification;\n          break;\n        }\n        case 3: {\n          const preferential = $(node)\n            .text()\n            .split('• ')\n            .filter((item) => !!item);\n          result.preferential = preferential;\n          break;\n        }\n      }\n    });\n    await browser.close();\n    return result;\n  }\n```\n\nasync-await으로 감싸진 함수이기 때문에 반환시 promise로 받게 되기에 해당 미들웨어에서도 동일하게 async-await으로 받아서 원하는 데이터를 받아오고, postman으로 정상적으로 동작하는 걸 확인했다.\n\n```javascript\napp.post(\"/jobs\", async (req, res, next) => {\n  const url = req.body.url\n  const job = await crawler.creatJob(url)\n  jobs = [job, ...jobs]\n  res.status(201).json(job)\n})\n```\n\n![결과확인](./결과확인.png)\n\n## 프론트 페이지 기획\n\n프론트 페이지를 어떻게 만들지에 대해서 고민해보니, 내가 보여주고 싶은 내용이 너무 많다는 점이 문제가 되었다. 지금의 데이터도 많은 내용을 받아오고, 거기서 내용에서 더 추출한다해도 어떤 기준으로 줄여야 할지도 문제가 되었다. 그래서 우선은 추출해온 데이터를 다보여줄 수 있는 카드 형식으로 만들어보기로 우선 구상했다. 받아온 데이터에서 필터링의 기준을 조금씩 다양화하고 형식들을 바꿔나가는 방법으로 우선 계획했고, 중요하게 내가 생각했던 전체적인 로직에서 데이터베이스부분을 조금 다르게 가져가야했다.\n\n데이터베이스를 사용할 줄 몰라, 따로 공부가 필요한데 지원했던 원티드 프리온보딩코스에 합격해서, 우선 프론트 공부를 다시 더 초점을 맞춰야하지 않을까란 생각이 들었다. 매주 몇개의 과제가 있을지 모르지만, 과제를 가장 큰 우선순위로 두고 한달을 보내야하기에, 우선은 프론트에서 **파이어베이스**를 이용해서 realtime database를 이용해서 개발을 하고, 서버는 데이터를 추출해서 전달해주기만 하는 방식으로 사용하기로 계획을 수정했다.\n"},{"excerpt":"공부를 바탕으로 서버를 만들기 전에 우선 서버의 어떤 기능이 필요할 지 먼저 정리한 후에, 직접 서버를 만들었다. SCHEMA Job data 스크롤러로 받아올 데이터 내용은 회사이름, 주요업무, 자격요건, 우대사항, 플랫폼, url 으로 정했다. GET /jobs 데이터베이스에 저장되어있는 공고들을 받아온다. GET /jobs?platform=:plat…","fields":{"slug":"/2022-10-22-모으잡-express-서버-제작-시작-cheerio/"},"frontmatter":{"date":"October 22, 2022","title":"모으잡-express 서버 제작 시작과 cheerio","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n공부를 바탕으로 서버를 만들기 전에 우선 서버의 어떤 기능이 필요할 지 먼저 정리한 후에, 직접 서버를 만들었다.\n\n## SCHEMA\n\n#### Job data\n\n스크롤러로 받아올 데이터 내용은 회사이름, 주요업무, 자격요건, 우대사항, 플랫폼, url 으로 정했다.\n\n```\n//Job\n{\n\tname:string\n\tplatform:string\n\tid:string\n\tmain_work:string[]\n\tqualification:string[]\n\tpreferential:string[]\n\turl:string\n}\n```\n\n#### GET /jobs\n\n데이터베이스에 저장되어있는 공고들을 받아온다.\n\n```\nresponse 200\n{\n\t[job,job...]\n}\n```\n\n#### GET /jobs?platform=:platform\n\n해당 플랫폼에 맞는 공고들을 받아온다.\n\n```\nresponse 200\n{\n\t[job,job...]\n}\n```\n\n#### POST /jobs\n\n전달 받은 url과 platform을 이용해서 크롤링을 한 후에 데이터베이스에 추가하고 만들어 진 job을 보여준다.\n\n```\nrequest\n{\n\turl:string\n\tplatform:string\n}\n\nreponse 201\n{\n\tname:string\n\tplatform:string\n\tid:string\n\tmain_work:string[]\n\tqualification:string[]\n\tpreferential:string[]\n\turl:string\n}\n```\n\n#### DELETE /jobs/:id\n\n전달 받은 id에 해당하는 job을 삭제한다.\n\n```\nrequest\n{\n\tid:string\n}\n\nresponse 204\n```\n\n위의 스키마를 바탕으로 서버를 만들고, postman을 이용해서 api가 정상적으로 작동하는지 확인했다. 앞서 공부했던 유용한 미들웨어 (helmet, cors)등을 적용해보았고, 아직 데이터베이스가 없기 때문에, 우선 서버의 로컬변수로 저장해서 관리했다. 데이터는 op.gg의 공고문을 참고해서 만들었다.\n\n```javascript\nimport express from \"express\"\nimport helmet from \"helmet\"\nimport cors from \"cors\"\nimport \"express-async-errors\"\nimport morgan from \"morgan\"\n\nconst app = express()\nlet jobs = [\n  {\n    name: \"오피지지(OP.GG)\",\n    platform: \"wanted\",\n    id: \"1\",\n    main_work: [\"OGT 웹사이트 최적화\", \"OGT 글로벌 플랫폼 개발 및 운영\"],\n    qualification: [\n      \"Javascript의 대한 높은 이해도를 보유하신 분\",\n      \"Next.js, React.js을 활용한 개발 경험이 있으신 분\",\n      \"HTTP, Networking에 대한 높은 이해도를 보유하신 분\",\n      \"HTML, CSS 등 마크업에 대한 충분한 이해도가 있으신 분\",\n      \"Server Side Rendering에 대한 높은 이해도를 보유하신 분\",\n      \"자신이 만드는 서비스와 기능에 대한 책임감이 높으신 분\",\n      \"다양한 직군의 사람들과 원활한 협업이 가능하신 분\",\n    ],\n    preferential: [\n      \"프로젝트를 스스로 리딩 해본 경험이 있으신 분\",\n      \"i18n을 적용한 글로벌 서비스에 대한 경험이 있으신 분\",\n      \"Next.js를 이용하여 서버 사이드 렌더링 개발 경험이 있으신 분\",\n      \"사용자를 위한 UI/UX 경험 개선을 지향하는 성향을 지니신 분\",\n      \"프로젝트 기획 단계부터 출시까지 모든 과정에 참여하신 경험이 있으신 분\",\n      \"E스포츠 게임을 즐기거나 게임 및 시장에 대한 높은 이해도를 보유하신 분\",\n      \"서비스 운영에 있어 Search Engine Optimization, User Retention, Acquisition에 대한 경험이 있으신 분\",\n    ],\n    url: \"https://www.wanted.co.kr/wd/124677\",\n  },\n  {\n    name: \"오피지지(OP.GG)\",\n    platform: \"Wanted\",\n    id: \"2\",\n    main_work: [\"OGT 웹사이트 최적화\", \"OGT 글로벌 플랫폼 개발 및 운영\"],\n    qualification: [\n      \"Javascript의 대한 높은 이해도를 보유하신 분\",\n      \"Next.js, React.js을 활용한 개발 경험이 있으신 분\",\n      \"HTTP, Networking에 대한 높은 이해도를 보유하신 분\",\n      \"HTML, CSS 등 마크업에 대한 충분한 이해도가 있으신 분\",\n      \"Server Side Rendering에 대한 높은 이해도를 보유하신 분\",\n      \"자신이 만드는 서비스와 기능에 대한 책임감이 높으신 분\",\n      \"다양한 직군의 사람들과 원활한 협업이 가능하신 분\",\n    ],\n    preferential: [\n      \"프로젝트를 스스로 리딩 해본 경험이 있으신 분\",\n      \"i18n을 적용한 글로벌 서비스에 대한 경험이 있으신 분\",\n      \"Next.js를 이용하여 서버 사이드 렌더링 개발 경험이 있으신 분\",\n      \"사용자를 위한 UI/UX 경험 개선을 지향하는 성향을 지니신 분\",\n      \"프로젝트 기획 단계부터 출시까지 모든 과정에 참여하신 경험이 있으신 분\",\n      \"E스포츠 게임을 즐기거나 게임 및 시장에 대한 높은 이해도를 보유하신 분\",\n      \"서비스 운영에 있어 Search Engine Optimization, User Retention, Acquisition에 대한 경험이 있으신 분\",\n    ],\n    url: \"https://www.wanted.co.kr/wd/124677\",\n  },\n]\n\napp.use(express.json())\napp.use(cors())\napp.use(helmet())\napp.use(morgan(\"tiny\"))\napp.get(\"/jobs\", (req, res, next) => {\n  const platform = req.query.platform\n  const data = platform ? jobs.filter(item => item.platform === platform) : jobs\n  res.status(200).json(data)\n})\n\napp.post(\"/jobs\", (req, res, next) => {\n  const { url, platform } = req.body\n  const job = jobs[0] //cheerio로 크롤링해야해, 에러 조건도 달아줘야해\n  jobs = [job, ...jobs]\n  res.status(201).json(job)\n})\n\napp.delete(\"/jobs/:id\", (req, res, next) => {\n  const id = req.body.id\n  console.log(id)\n  jobs.filter(job => job.id != id)\n  res.sendStatus(204)\n})\n\napp.use((req, res, next) => {\n  res.status(404)\n})\n\napp.use((error, req, res, next) => {\n  res.status(500).send(\"something wrong\")\n})\n\napp.listen(4000)\n```\n\npostman으로 정상적으로 다 작동하는 것을 확인할 수 있었다. 이제 중요한 건 실제로 크롤링을 한 데이터를 만드는 과정이다.\n\n![image-20221023033122214](./postman.png)\n\n# Cheerio를 이용한 크롤링\n\ncheerio는 크롤링을 위한 Node Js 라이브러리로, 파이썬의 beautifulSoup과 같은 역할을 한다.\n\n먼저 원티드 페이지를 보면 내가 원하는 정보는 h6태그에 카테고리 제목이, p안의 span의 내용들이 바로 담겨 있다. 페이지 내부의 다른 곳에서 h6태그와 p태그가 사용되고 있지 않기 때문에 간단하게 할 수 있을 것이라 생각했지만 이상하게 아무것도 크롤링이 되지 않았다.\n\n[원티드 페이지 html구조]\n\n![원티드페이지구조](./원티드-페이지구조.png)\n\n아래 코드를 보면 p태그 안에 있는 span을 받아와야 하지만 아무 것도 받아오지 못했고, 내가 잘못 코드를 친 부분이 있는지\n\n확인 차 span만 불러왔을 때는 navbar에 있는 beta만 받아왔다. 전혀 예상하지 못한 Beta가 어디서 나온 건지 확인해보니\n\n페이지 상단의 navbar의 AI 합격예측이라는 메뉴에 있는 span의 text내용이었다.\n\n[헤더 화면]\n![헤더](./헤더.png)\n\n```javascript\nimport cheerio from \"cheerio\"\nimport axios from \"axios\"\n\nconst getHTML = async () => {\n  try {\n    return await axios.get(`https://www.wanted.co.kr/wd/43745`)\n  } catch (error) {\n    console.error(error)\n  }\n}\n\nconst parsing = async () => {\n  const html = await getHTML()\n  const $ = cheerio.load(html.data)\n  const $List = $(\"span\")\n\n  $List.each((idx, node) => {\n    console.log($(node).text()) //Beta\n  })\n}\n```\n\n왜 안되는지 체크하기 위해서 네트워크 창을 보니 받아온 html을 보았을 때 **정적으로 만들어진 페이지만 cheerio가 받아와서 찾다보니 생긴 일이 아닐까** 라는 생각이 들었다. 만약 내 생각이 맞다면, 동적으로 페이지를 받아오기 위해서는 이전에 사용했던 chromium과 같은 라이브러리가 필요할 것 같다.\n\n[정적페이지만 먼저 받아오는 상황]\n![정적페이지](./정적페이지.png)\n"},{"excerpt":"CORS란 CORS는 Cross-Origin Resource Sharing의 약자로, 서버가 알고있는 클리언트의 url에서 요청시에 응답을 막을 수 있는 보안 기능이다. 같은 도메인끼리 밑의 예로 https://localhost:3000이란 주소로 서버와 클라이언트가 작동하고 있다면 둘은 아무 문제 없이 요청과 응답을 한다. 하지만 도메인이 달라질 경우에…","fields":{"slug":"/2022-10-20-모으잡-cors-에러핸들링/"},"frontmatter":{"date":"October 20, 2022","title":"모으잡-express cors 에러, 에러핸들링","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# CORS란\n\nCORS는 Cross-Origin Resource Sharing의 약자로, 서버가 알고있는 클리언트의 url에서 요청시에 응답을 막을 수 있는 보안 기능이다. 같은 도메인끼리 밑의 예로 https://localhost:3000이란 주소로 서버와 클라이언트가 작동하고 있다면 둘은 아무 문제 없이 요청과 응답을 한다. 하지만 도메인이 달라질 경우에 예로 서버는 https://localhost:5000에서 클라이언트는 https://localhost:3000에서 작동할 경우에는 다음과 같은 에러를 보여준다.\n\n![img](https://miro.medium.com/max/875/1*XxzATAY3-XDUvB2GJL2QnA.png)\n\n도메인이 같다는 의미는 scheme(https://), hostname(localhost), portNumber(:5000)이 모두 같을 때를 의미한다. 그렇기 때문에 위의 예는 포트넘버가 다르기 때문에 발생한 cors에러라고 할 수 있다.\n\n우리가 원하는 도메인의 클라이언트의 요청만 받기위해서는 서버의 헤더에 **Access-Control-Allow-Origin**과 **Access-Control-Allow-Methods**를 추가해 응답을 보내주면 에러없이 응답을 보내줄 수 있다.\n\n[출처: [medium how cors works](https://medium.com/swlh/how-cors-cross-origin-resource-sharing-works-79f959a84f0e)]\n\n<img src=\"https://miro.medium.com/max/875/0*SweGXbcps8xY31ds.png\" width=\"700px\" />\n\n## Express의 CORS 패키지\n\n저번에 알아봤던 cors 패키지는 위의 두가지 header의 내용을 간단하게 추가할 수 있게 도와준다.\n\n```javascript\napp.use(cors({\n    origin:[\"https://localhost:3000\"]\n    optionSuccessStatus:200\n}))\n```\n\norigin에 추가한 주소를 통해서 어떤 url의 요청에 추가된 헤더 내용을 담아줄 건지 정해줄 수 있다.\n\n# 에러핸들링\n\n에러핸들링은 크게 동기적인 코드내의 에러와 비동기적인 코드내의 에러로 나눌 수 있다. 기본적으로 에러처리는 발생한 미들웨어에서 최대한 적절하게 해주는 게 중요하다. 혹시 모를 에러를 위해 가장 마지막에 에러처리를 위한 미들웨어를 두어, 서버에러를 알려주는 게 기본적인 구조이다.\n\n### 1. 동기적 코드\n\n동기적 코드는 순서대로 반드시 실행이 마치고 다음으로 넘어가기 때문에 에러 발생시 어플리케이션이 아예 죽어버릴 수 있다. 이를 해결할 수 있는 방법은 try-catch문으로 에러를 잡아서 에러처리를 해준다.\n\n```javascript\napp.get(\"/sync\", (req, res, next) => {\n  try {\n    const data = fs.readFileSync(\"text.txt\") //동기적으로 파일을 읽어\n  } catch (e) {\n    res.status(404)\n  }\n})\n\napp.use((error, req, res, next) => {\n  console.error(error)\n  res.status(500).json({ message: \"Server error\" })\n})\n```\n\n### 2. 비동기적 코드\n\n비동기적 코드는 try-catch문을 사용할 수 없기 때문에 내부적으로 콜백함수를 이용하거나, catch를 통해 에러를 처리해야한다. 에러를 다음 미들웨어로 넘겨서 처리하고 싶을때는 next에 error를 담아서 보낼 수 있다.\n\n#### 콜백함수\n\n콜백함수로 에러를 처리하는 경우에 에러를 처리해주지 않으면 에러가 났지만 콜백으로 넘어가 클라이언트 페이지는 계속해서 기다리고 있고, 마지막 에러처리 미들웨어까지 전달되지 않으므로, 콜백함수 내에서 처리를 해줘야한다.\n\n```javascript\napp.get(\"/async\", (req, res, next) => {\n  fs.readFile(\"/text.txt\", (err, data) => {\n    if (err) {\n      res.status(404).send(\"File not found\")\n    }\n  })\n})\n\napp.use((error, req, res, next) => {\n  console.error(error)\n  res.status(500).json({ message: \"Server error\" })\n})\n```\n\n### Promise\n\nPromise는 catch를 이용해서 에러 핸들링을 할 수 있다. 에러처리를 해주지 않으면 위와 같이 에러가 마지막 미들웨어로 넘어가지 않는다. 그렇기 때문에 꼭 catch를 이용해서 에러 처리가 필요하다. 밑 예제는 next(error)를 이용해, 마지막 미들웨어로 에러를 전달해주었다.\n\n```javascript\napp.get(\"/async\",(req,res,next)=>{\n   return fsAsync.readFile('/text.txt').catch((e) => next(e));\n  });\n\n})\n\napp.use((error, req, res, next) => {\n  console.error(error);\n  res.status(500).json({ message: 'Server error' }); //여기서 에러처리\n});\n```\n\n### async-await\n\nasync-await은 내부에서 동기적으로 코드를 사용할 수 있어서 try-catch문을 사용할 수 있고, 함수 자체는 promise로 반환되기 때문에 동일하게 에러처리를 해주지 않으면 에러가 전달되어지지 않는다. 그렇기 때문에 동기적인 코드때 처럼 꼭 try-catch문으로 에러처리를 해주어야한다.\n\n```javascript\napp.get(\"/file3\", async (req, res) => {\n  try {\n    const data = await fsAsync.readFile(\"/text.txt\")\n  } catch (e) {\n    res.status(404).send(\"File not found\")\n  }\n})\n\napp.use((error, req, res, next) => {\n  console.error(error)\n  res.status(500).json({ message: \"Server error\" }) //여기서 에러처리\n})\n```\n\n비동기는 에러가 자동으로 넘어가지지 않는 점 때문에 해당 로직을 항상 처리를 해줘야한다.\n\n마지막으로 에러를 전달할 수 있게 도와주는 패키지로 **express-async-error**가 있어 import만 하면 비동기에서도 에러 발생시 자동으로 마지막 미들웨어까지 전달될 수 있다. 자바스크립트의 비동기 처리와 동일하게 에러처리가 필요하다는 것을 느낄 수 있었다.\n"},{"excerpt":"✨ Express express는 노드 JS의 프레임워크로 앞서 만든 Node js의 코드 복잡도를 줄여주고, 쉽게 서버를 만들 수 있게 도와준다. express의 가장 큰 특징은 middleware의 체이닝이라고 할 수 있다. 미들웨어들이 연결되어있어, 처리할 수 있는 요청에 대해서 해당 미들웨어 내에서 처리하고, 담당 미들웨어에서 처리할 수 없는 요청…","fields":{"slug":"/2022-10-19-Express-기초/"},"frontmatter":{"date":"October 19, 2022","title":"NodeJS: express","tags":["NodeJS","express"]},"rawMarkdownBody":"\n# ✨ Express\n\nexpress는 노드 JS의 프레임워크로 앞서 만든 Node js의 코드 복잡도를 줄여주고, 쉽게 서버를 만들 수 있게 도와준다. express의 가장 큰 특징은 **middleware의 체이닝**이라고 할 수 있다. 미들웨어들이 연결되어있어, 처리할 수 있는 요청에 대해서 해당 미들웨어 내에서 처리하고, 담당 미들웨어에서 처리할 수 없는 요청에 대해서는 다음으로 넘기는 과정으로 보다 이해하기 쉽고 간결한 특징을 가진다.\n\n![express](express.webp)\n\n## request\n\nrequest에서 내가 헷갈렸던 부분은 query string과 path variable의 차이이다. 리액트를 하면서 잘 이해하지 못하고 사용했던 것 같아 [Integerous DevLog 블로그](https://ryan-han.com/post/translated/pathvariable_queryparam/)의 글을 참고해 정리해보고자 한다.\n\n두가지를 구분하기 위해서는 이용목적을 이해해야한다. Path variable은 <u> resource를 구분하는 방법</u>이고, query string은 자료에서 <u>정렬이나 필터링을 할때</u> 사용되는 방법이다. 예로 /videos라는 url에서는 video 목록을 가져오는 것을 의미하고, /videos?channel=mnet라고 한다면 video목록에서 channel이 mnet인 것을 받아온다고 생각할 수 있다.\n\n```javascript\n// \"/hi\"로 접속시\napp.get(\"/:id\", (req, res, next) => {\n  console.log(req.params) //{id:\"hi\"}\n  console.log(req.query) //{}\n})\n\n// \"/hi?keyword=hello\"\napp.get(\"/:id\", (req, res, next) => {\n  console.log(req.params) //{id:\"hi\"}\n  console.log(req.query) //{keyword:\"hi\"}\n})\n```\n\n## response\n\nresponse에서는 method가 더 간결해져서 이해가 편했다.\n\n1. response.json(data) : json으로 파싱해서 데이터를 전송\n\n2. response.sendStatus(status_code): status_code만 전송\n3. response.status(status_code).send(content): status와 데이터를 함께 전송\n\n## middleware Chain\n\nmiddleware의 구성은 action에 해당하는 method에 url과 callback 함수를 전달하는 방식이다. callback 함수에는 request,response, next를 받아올 수 있는데, 현재 미들웨어에서 처리할 수 있으면 response를 이용하고, 처리할 수 없을 때는 next를 이용해서 다음 미들웨어로 넘긴다.\n\n```javascript\napp.get(\"/\", (req, res, next) => {\n  //일처리\n  next()\n})\n\napp.all(\"/users\", (req, res, next) => {\n  //일처리\n  next()\n})\n\napp.use((req, res, next) => {\n  res.status(404).send(\"not available\")\n})\n```\n\n각 method들 (GET,POST,PUT,DELETE 등)에 대한 method들 외에 **use**와 **all**이란 method가 존재한다. use는 url과 관련된 모든 경로, url을 전달하지 않은 경우에는 모든 url에서 처리해주는 미들웨어를 만들 수 있다. all은 해당 url에 한에서 모든 method를 처리하는 url이다. path variable이 추가되서 /users/1과 같은 요청은 처리할 수 없다.\n\n미들웨어는 이렇게 우리가 직접 사용할 수 있는 것 외에도 express 내장 미들웨어나 npm에 올라와있는 유용한 미들웨어도 있다. json으로 값을 파싱해서 받아올 수 있는 **express.json()**이나 cors에러를 해결해주는 **cors 미들웨어**, 나 보안에 필요한 헤더를 추가해주는 **helmet 미들웨어**가 있다. 사용할 때는 동일하게 app.use(middleware)로 전달해서 사용할 수 있다.\n"},{"excerpt":"🎈 Node JS란 노드 JS는 브라우저밖에서도 자바스크립트를 사용할 수 있는 자바스크립트 런타임 환경이다. single thread 언어인 Javascript가 브라우저 위에서 browser API를 이용한 비동기 처리로 다양한 일을 처리할 수 있었던 것 처럼, Node JS 또한, 자체 API를 이용해서 비동기 처리를 이용해 다양한 기능을 구현할 수 …","fields":{"slug":"/2022-10-18-Node-JS-기초/"},"frontmatter":{"date":"October 18, 2022","title":"Node js:NodeJS 이용한 서버 만들기","tags":["NodeJS"]},"rawMarkdownBody":"\n![nodejs](node.png)\n\n# 🎈 Node JS란\n\n노드 JS는 브라우저밖에서도 자바스크립트를 사용할 수 있는 자바스크립트 런타임 환경이다. single thread 언어인 Javascript가 브라우저 위에서 browser API를 이용한 비동기 처리로 다양한 일을 처리할 수 있었던 것 처럼, Node JS 또한, 자체 API를 이용해서 비동기 처리를 이용해 다양한 기능을 구현할 수 있고, brower처럼 Event를 통해서 콜백을 실행하는 특징을 가진다.\n\n이러한 기능중에서 나에게 현재 필요한 노드 JS의 기능은 API 서버를 만드는 것으로, 서버를 만들기 위한 기초 API들을 먼저 정리하고 서버를 만드는 과정을 정리해보려 한다.\n\n## Module system\n\n노드의 모듈시스템은 자체적인 **require(module)**이라는 함수를 통해서 받아올 수 있다. 현재는 자바스크립트 자체의 **import/export**도 이용가능한데, npm의 package.json에 \"type\":\"module\"로 추가해주어야한다.\n\n## Path\n\n말그대로 경로를 받아올 수 있는 모듈로, 다양한 디렉토리, 파일 등을 받아올 수 있는 API이다.\n\n```javascript\npath.basename(__filename) //현재 파일의 경로\npath.extname(__filename) //현재파일의 확장자\npath.join(__dirname, \"image\") //현재폴더에 image 파일의 경로\n```\n\n## File system\n\n파일 시스템 모듈은 파일, 폴더를 읽고 쓰고 이동하는 등의 일을 할 수 있는 api로 script로 작성시 자동화 프로그램도 만들 수 있다.\n\n서버를 만들고 나서 내 컴퓨터 내의 파일들을 정리하는 스크립트를 만드는 연습도 해보면 좋을 것 같다.\n\n```javascript\nfs.renameSync(oldPath,newPath) //동기적으로 파일을 이동시켜\nfs.rename(oldPath,newPath,(error,data)=>{...}) //비동기적으로 파일을 이동시켜\nfs.promises // promise를 이용해 비동기적으로 파일 시스템을 작성\n\nfs.readFile(file, option)//비동기적으로 option으로 인코딩방식 등을 정해서 파일을 읽어\nfs.writeFile(file, data) //비동기적으로 해당 파일에 데이터를 새로 작성한다\nfs.appendFile(file, data) //비동기적으로 해당 파일에 데이터를 추가 작성한다\n```\n\n## 버퍼와 스트림\n\n버퍼와 스트림은 너무나도 익숙하게 많이 들어온 개념들이다. **버퍼는 데이터 조각**으로 원본 데이터를 한번에 다 보내는 것이 아니라 데이터를 버퍼로 조금씩 잘라서 보낸다. 이렇게 **데이터 조각을 보내는 과정을 스트리밍**이라고 하고, 사용자가 받는 데이터의 속도가 보내는 데이터 속도보다 빠르다면, 화면이 보이지 않는 등의 일이 일어나는데 이런 현상을 우리가 흔히 이야기하는 **버퍼링이 걸린다**는 일이다.\n\n이렇게 버퍼와 스트림을 이용하면 한번에 다 보내서, 다 받을때까지 사용자가 볼 수 없는 문제를 해결할 수 있어서 메모리효율과 시간 효율이 좋은 장점을 가진다.\n\n[사진 출처: [카레유 티스토리](https://curryyou.tistory.com/440) ]\n\n![buffer](buffer.png)\n\n```javascript\nconst buf = Buffer.from(\"hello\") //<Buffer 68 65 6c 6c 6f>\nconst buf2 = Buffer.from(\"hello\") //<Buffer 68 65 6c 6c 6f>\nconst newBuf = Buffer.concat([buf, buf2]) //<Buffer 68 65 6c 6c 6f 68 65 6c 6c 6f> 버퍼 이어붙이기\n\nconst fs = require(\"fs\")\n\nconst data = []\n\nconst readStream = fs\n  .createReadStream(파일, option)\n  .on(\"data\", chunk => {\n    // 데이터를 받아올 때 마다 실행해\n    data.push(chunk)\n  })\n  .on(\"end\", () => {\n    console.log(data.join(\"\")) // 데이터를 다받으면 실행해\n  })\n  .on(\"error\", error => console.log(error)) // 에러 발생시 실행해\n```\n\nstream을 공부하고 느낀 가장 큰 장점은 **piping**이 가능하다는 점이다. piping은 stream들을 이어주는 것으로 stream의 결과들을 chaining이 가능하다.\n\n```javascript\nconst readStream = fs.readStream(\"./ex1.txt\")\nconst writeStream = fs.createWriteStream(\"./ex2.txt\")\nreadSream.pipe(writeStream) //ex1.txt을 읽고 ex2.txt에 쓰는 파이프\n```\n\n## 서버 제작\n\n위의 정리한 Node JS API들과 HTTP 지식들을 이용해서 간단한 서버를 만들어보았다.\n\n### 서버사이드 렌더링\n\nNode 서버는 flask를 사용했을 때와 동일하게, request로 받은 요청에 따라 response로 해당하는 html을 보여주는 서버를 먼저 제작했다. 과정은 다음과 같이 정리할 수 있다.\n\n1. http모듈을 이용해서 서버를 만든다.\n2. 서버에 받은 request의 url에 따라 html을 보낸다.\n\nfile을 읽는 방법으로 fs.readFile으로 할 수도 있지만 buffer와 stream의 효율이 더 좋기 때문에 createReadStream을 이용했다.\n\nstream으로 받아온 buffer 데이터를 pipe를 이용해서 response로 보내면, res.end()를 하지 않아도 데이터가 다 받아지면\n\npipe가 자동으로 끝내줘서 코드가 더 간단해진다.\n\n```javascript\nconst http = require(\"http\")\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\nconst server = http.createServer((req, res) => {\n  const url = req.url\n  const filePath = path.join(__dirname)\n  res.setHeader(\"content-Type\", \"text/html\") //어떤 형식으로 데이터를 보낼지를 담아\n  if (url === \"/\") {\n    fs.createReadStream(`${filePath}/template/index.html`).pipe(res) //html을 버퍼로 읽어서 읽은 데이터를 response로 흘려보내줘\n  } else if (url === \"/courses\") {\n    fs.createReadStream(`${filePath}/template/courses.html`).pipe(res)\n  } else {\n    fs.createReadStream(`${filePath}/template/not-found.html`).pipe(res)\n  }\n})\n\nserver.listen(8080)\n```\n\n### JSON을 이용한 서버\n\nJSON은 Javascript Object Notation의 약자로 네트워크통신을 위한 구조화된 데이터를 의미한다. 앞서 정리했었던 HTTP 통신으로 받은 request에 따라 해당하는 응답을 보내줄때, 요청에서 요구하는 데이터를 body에 담아서 보내줄 때, JSON으로 전달할 수 있다. 간단하게 배열을 GET이나 POST를 이용해서 JSON으로 보내주는 서버를 만들었다. 위의 서버와 다르게 request의 method별로 다른 응답을 보내주어야하고, 적절한 status_code를 함께 담아주어야한다.\n\n(GET이 성공하면 200, POST가 성공하면 201)\n\n```javascript\nconst arr = [1, 2, 3]\n\nconst server = http.createServer((req, res) => {\n  const method = req.method\n  if (method === \"GET\") {\n    res.writeHead(200, { \"Content-Type\": \"application/json\" }) //head에 status_code, content-type을 담아\n    res.end(JSON.stringify(arr)) //원하는걸 담아서 보내줘\n  } else if (method === \"POST\") {\n    const body = []\n    req.on(\"data\", chunk => {\n      body.push(chunk)\n    }) //req로 온 데이터를 받아\n    req.on(\"end\", () => {\n      const item = Buffer.concat(body).toString() //버퍼로 받아온 데이터를 이어\n      arr.push(JSON.parse(item))\n      res.writeHead(201)\n      res.end() //아무것도 담지 않아\n    })\n  }\n})\n\nserver.listen(8080)\n```\n"},{"excerpt":"Flask를 이용한 서버 제작 flask는 파이썬의 프레임워크로 아주 간단한 방법으로 서버를 구축할 수 있다. flask를 사용하는 방법은 엄청나게 쉬웠는데 route를 연결하고, route에 해당하는 페이지를 간단하게 함수를 이용해서 rendertemplate로 return해주면 해당 페이지를 만들 수 있었다. rendertemplate를 이용할 때 주…","fields":{"slug":"/2022-10-17-flask-서버만들기/"},"frontmatter":{"date":"October 17, 2022","title":"모으잡-flask이용해 SSR서버만들기","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# Flask를 이용한 서버 제작\n\nflask는 파이썬의 프레임워크로 아주 간단한 방법으로 서버를 구축할 수 있다. flask를 사용하는 방법은 엄청나게 쉬웠는데 route를 연결하고, route에 해당하는 페이지를 간단하게 함수를 이용해서 render_template로 return해주면 해당 페이지를 만들 수 있었다. render_template를 이용할 때 주의할 점은 templates라는 폴더 내에 있는 파일을 전달해주기 때문에 반드시 templates안에 파일을 만들고, 해당하는 파일의 이름을 전달해주면 된다.\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(\"JobScrapper\")\n\n@app.route(\"/\")\ndef home():\n    return render_template(\"home.html\")\n\napp.run(\"0.0.0.0\") #app을 실행할때 replit은 0.0.0.0을 사용해\n\n```\n\n제작한 스크롤러에 접속할 때 필요한 페이지는 총 세가지로 검색을 하는 \"/\", 검색한 내용을 보여주는 \"/search\", 모아온 데이터를 다운받을 수 있는 \"/extract\"이다.\n\n## home 페이지\n\n홈페이지에서는 검색한 내용을 전달 받아야한다. 전달 받기 위해서 home.html에 form과 input을 이용했다.\n\nform의 action을 이용해서 어디로 보낼지를 정할 수 있고, input의 name은 전달된 url에 query로 전달이 가능하다.\n\nhtml을 잘 알고 있었다고 생각했지만 form은 항상 event.preventDefault()로 전달을 막고 SPA를 만들다보니 태그 자체가 할 수 있는 기능을 처음 알게 되었다.\n\n```html\n<body>\n  <main class=\"container\">\n    <h1>JonScrapper</h1>\n    <h4>What job do you want?</h4>\n    <form action=\"/search\">\n      <input type=\"text\" name=\"keyword\" placeholder=\"Write keyword please\" />\n      <button>Search</button>\n    </form>\n  </main>\n</body>\n```\n\n## Search 페이지\n\nhome 페이지를 통해 전달한 내용은 \"/search/keyword=\"에 전달되기 때문에 search페이지의 함수에서 keyword를 받아온다.\n\n받아온 keyword를 앞서 만든 크롤러에 전달해 크롤링을 진행한 후에 데이터를 search페이지에 전달해 보여준다.\n\nkeyword는 flask에서 request로 url의 해당 부분을 가져올 수 있다. 이때 input에 입력하지 않고 페이지 이동하게 되지 않게\n\nredirect를 이용해 다시 홈페이지로 보내주는 로직도 추가하고, 이후 export에서도 파일을 사용할 수 있게 db라는 딕셔너리에 저장한다.\n\n```python\n#main.py\n@app.route(\"/search\")\ndef search():\n  keyword = request.args.get(\"keyword\")\n  if keyword==None:\n    return redirect(\"/\")\n  indeed = extract_indeed_jobs(keyword)\n  wwr = extract_wwwrjobs(keyword)\n  jobs = wwr + indeed\n  db[keyword] = jobs\n  return render_template(\"search.html\", keyword=keyword, jobs=jobs)\n```\n\n```html\n<main class=\"container\">\n  <h1>Searh Results for \"{{keyword}}\":</h1>\n  <a target=\"_blank\" href=\"/export?keyword={{keyword}}\">Export to file</a>\n  <!--extract 페이지로 연결-->\n  <table role=\"grid\">\n    <hhead>\n      <tr>\n        <th>Position</th>\n        <th>Company</th>\n        <th>Location</th>\n        <th>Link</th>\n      </tr>\n    </hhead>\n    <tbody>\n      {%for job in jobs%} //<!--파이썬 코드-->\n      <tr>\n        <td>{{job.position}}</td>\n        <td>{{job.company}}</td>\n        <td>{{job.location}}</td>\n        <td>\n          <a href={% raw %}\"{{job,link}}\"{% endraw %} target=\"_blank\"\n            >Apply this</a\n          >\n        </td>\n      </tr>\n      {%endfor%}\n    </tbody>\n  </table>\n</main>\n```\n\n## export페이지\n\nexport페이지는 앞서 크롤링한 데이터를 다운로드할 수 있는 페이지다. 똑같이 전달받은 keyword를 이용해서 해당 keyword를 이름으로하는 .csv파일을\n\n만든 후에 클릭시 다운로드를 받을 수 있다. 페이지에서 keyword가 없다면 homepage로 redirect한다. 딕셔너리에 해당 keyword를 키로 하는 내용이 없다면\n\n해당 키워드의 search페이지로 redirect하는 로직을 추가했다. 데이터가 있다면 데이터를 csv파일에 저장후에 flask내장 메소드은 send_file로 다운로드 받을 수\n\n있게 보내준다.\n\n```python\n@app.route(\"/export\")\ndef export():\n  keyword = request.args.get(\"keyword\")\n  if keyword==None:\n    return redirect(\"/\")\n  if keyword not in db:\n    return redirect(f\"/search?keyword={keyword}\")\n  save_to_file(keyword, db[keyword])\n  return send_file(f\"{keyword}.csv\",as_attachment=True)\n\n```\n\n이렇게 만든 페이지들은 내가 생각했던 프론트와 서버가 구분되는 게 아니라 서버에서 직접 화면을 만들어 보여주는 \"서버사이드 렌더링\"이라는 것을 공부하고 난 뒤에 깨달았다. 내가 원하는 것은 다음과 같은 과정이었다.\n\n1. API 서버를 만든다\n\n2. 프론트에서 서버에 해당 내용으로 요청을 보낸다\n3. 서버는 크롤링을 해서 결과를 json으로 프론트 서버에 응답한다\n4. 프론트서버는 받은 내용을 이용해 랜더링한다\n\n파이썬으로는 코딩테스트 공부만했다보니까 실제로 사용하기 위한 환경세팅 자체가 어색했고, flask와 react를 같이 쓰는 자료가 잘나오지 않아서, 이참에 node js를 공부해서 자바스크립트로 프론트와 백엔드를 다 연결해보자라는 생각이 들어, 조금 돌아가지만 크롤링에 대해 이해했으므로, node js를 공부해서 내일 부터 다시 node js를 공부해보기로 계획을 잡았다.\n"},{"excerpt":"파이썬을 이용해 웹크롤러 제작하기 웹크롤러는 데이터를 최신 상태로 유지하거나 웹페이지에 있는 원하는 정보를 추출하는 기술로, 일일이 사용자가 웹페이지를 돌아다니면서 정보를 수집하는 것을 대신해서 방문해 원하는 정보들을 수집해 줄 수 있어 자동화에 용이한 기술이다. 웹크롤러를 만드는 다양한 영상이 유튜브에 있지만 노마드코더(https://nomadcoder…","fields":{"slug":"/2022-10-16-파이썬을-이용한-크롤러제작/"},"frontmatter":{"date":"October 16, 2022","title":"모으잡-파이썬을 이용한 웹크롤러 제작","tags":["사이드프로젝트","모으잡"]},"rawMarkdownBody":"\n# 파이썬을 이용해 웹크롤러 제작하기\n\n웹크롤러는 데이터를 최신 상태로 유지하거나 웹페이지에 있는 원하는 정보를 추출하는 기술로, 일일이 사용자가 웹페이지를 돌아다니면서 정보를 수집하는 것을 대신해서 방문해 원하는 정보들을 수집해 줄 수 있어 자동화에 용이한 기술이다.\n\n웹크롤러를 만드는 다양한 영상이 유튜브에 있지만 노마드코더(https://nomadcoders.co/courses)의 파이썬 무료 강의를 참고해서 만들어보았다.\n\n파이썬을 이용해 우리가 원하는 website의 정보를 가져오려면 두 가지 라이브러리가 필요하다.\n\n1. requests: 우리가 원하는 데이터 url을 요청할 수 있는 라이브러리다.\n\n2. BeautifulSoup: 요청으로 받아온 response의 HTML 요소들을 가공,처리할 수 있게 도와주는 라이브러리다.\n\n## 1. Requests로 원하는 데이터 요청하기\n\nrequest을 이용하면 내가 먼저 공부했던 GET, POST, PUT, DELETE HTTP 요청을 할 수 있다.\n\n자바스크립트에서는 fetch를, 파이썬에서는 requests를 이용할 수 있구나 이해가 되었다.\n\n```python\nfrom requests import get\n\nbase_url =\"https://jsonplaceholder.typicode.com/users/1\"\nresponse = get(f\"{base_url}\")\nstatus_code=response.status_code #요청 코드\ncontent=response.content # 바이너리 원문\ntext=response.text #인코딩된 문자열\njson=response.json() #Json 데이터\n\n```\n\n우리가 요청한 게 올바른지에 따라 에러 핸들링이 필요하기 때문에 status_code로 확인 후에 성공했다면 데이터 추출을 위해 response.text로 응답의 문자열을 받아온다.\n\n## 2. BeautifulSoup\n\nBeautifulSoup은 앞서 requests로 받아온 데이터를 가공하는 데 사용되는 라이브러리이다.\n\n받아온 response.text를 이용해서 자체적인 파싱을 한 후에 우리가 원하는 부분들을 찾아갈 수 있다.\n\n이때 사용하는 메소드는 다음과 같다.\n\n1. find와 find_all ( tag , attr ): 원하는 태그를 찾고 attributes로 자세하게 설정이 가능하다.\n\n2. select( css-selector ): css-selector를 이용해서 우리가 원하는 부분을 찾을 수 있다.\n\n위 두가지 메소드가 유용한 이유는 우리가 원하는 부분을 찾고 난 후에 계속해서 검색할 수 있게 파싱된 text를 return해 준다.\n\nRequest와 BeautifulSoup 두 가지를 합쳐서 We Work Remotely라는 사이트의 데이터를 받아오는 코드는 다음과 같이 나타낼 수 있다.\n\n```python\nfrom requests import get\nfrom bs4 import BeautifulSoup\n\n\nbase_url = \"https://weworkremotely.com/remote-jobs/search?utf8=%E2%9C%93&term=\"\nresponse = get(f\"{base_url}\")\nif response.status_code != 200:\n   print(\"Can't request website\")\nelse:\n   results = []\n   soup = BeautifulSoup(response.text, \"html.parser\")\n   jobs = soup.find_all(\"section\", class_=\"jobs\")  # list로 받아\n   for job_section in jobs:\n     job_posts = job_section.find_all(\"li\")\n     job_posts.pop()  # view_all 제거\n       for post in job_posts:\n         anchors = post.find_all(\"a\")\n         anchor = anchors[1]  # 로고 anchor 제거\n         link = anchor[\"href\"]\n         company, kind, region = anchor.find_all(\"span\",class_=\"company\")\n         title = anchor.find(\"span\", class_=\"title\")\n         job_data = {\n                    \"link\": f\"https://weworkremotely.com{link}\",\n                    \"company\": company.string,\n                    \"location\": region.string,\n                    \"position\": title.string\n                }\n    results.append(job_data)\n\n```\n\n## 3. 셀레니움\n\n웹크롤링은 우리가 원하는 웹사이트의 정보를 받아오고 가공하는 기술이다. 하지만 회사에서는 우리가 원하는 정보가 중요하기 때문에, 또는 회사 서버에 과부하를 줄 수 있기 때문에 막아놓을 수 있다. 그래서 크롤링을 상업적인 목적이나, 해당 회사에게 불이익을 주면 법적 문제를 가질 수도 있기 때문에 조심해야 한다. 이를 위해서 사용하는 방법이 접속한 게 '봇인지 사람인지'를 확인하는 방식이다.\n\n셀레니움은 이때 우리가 봇으로 접속한 게 아닌 것처럼 실제로 브라우저에 접속할 수 있게 도와줄 수 있는 프로그램이다. 또한, 자바스크립트가 동적으로 만든 데이터들을 크롤링이 가능하고, 사이트의 클릭과 같은 이벤트를 줄 수 있는 장점도 가지고 있다.\n\n셀레니움을 사용하려면 추가적인 설정이 필요하다. 웹드라이버라는 기능으로 우리가 원하는 브라우저에 맞게 설정과 옵션에 따라 설정하면 된다. 나는 replit이란 웹 IDE에서 코딩하고 있었기 때문에 다음과 같은 옵션을 추가해서 진행했다.\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"--no-sandbox\")\noptions.add_argument(\"--disable-dev-shm-usage\")\nbrowser = webdriver.Chrome(options=options)\n```\n\n이렇게 만든 browser를 이용해 requests를 대신해서 사용하면 다음과 같이 코드를 바꿀 수 있다.\n\n```python\nfrom bs4 import BeautifulSoup\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"--no-sandbox\")\noptions.add_argument(\"--disable-dev-shm-usage\")\nbrowser = webdriver.Chrome(options=options)\n\n\n\nresults = []\nfor page in range(pages):\n   base_url = \"https://kr.indeed.com/jobs\"\n   browser.get(f\"{base_url}\")\n   soup = BeautifulSoup(browser.page_source, \"html.parser\")\n   job_list = soup.find(\"ul\", class_=\"jobsearch-ResultsList\")\n   jobs = job_list.find_all(\"li\", recursive=False)\n\n   for job in jobs:\n       zone = job.find(\"div\", class_=\"mosaic-zone\")\n       if zone == None:\n           anchor = job.select_one(\"h2 a\")\n           title = anchor[\"aria-label\"]\n           link = anchor[\"href\"]\n           company = job.find(\"span\", class_=\"companyName\")\n           location = job.find(\"div\", class_=\"companyLocation\")\n           job_data = {\n                \"link\": f\"https://kr.indeed.com{link}\",\n                \"company\": company.string,\n                \"location\": location.string,\n                \"position\": title\n              }\n            results.append(job_data)\n\n```\n\n이렇게 가공한 데이터를 나만 사용할 거 라면, 그냥 로컬로 엑셀로 저장되게 하면 되겠지만, 사용자들이 프론트페이지에서 요청을 보내면, 해당 요청에 맞게 받아오는 서비스를 만들고 싶기 때문에, **백엔드 서버가 필요하게 된다.** 이를 위해서 간단한 flask라는 파이썬 프레임워크를 내일 공부하고 적용해 보고자 한다.\n"},{"excerpt":"9월 말에 생각해두었던 채용공고 정리 사이트를 이번 주부터 본격적으로 만들어 보고자 한다. 급하게 한 주 안에 최대한 만드는 것을 목표로 잡았는데, 이유는 다음 주에 프리온보딩 코스 평가 결과가 나오기 때문에, 만약 합격한다면, 내 프로젝트 자체를 새롭게 기획하고 만들기 보다는, 과제를 하고, 새롭게 알게 된 걸로 프로젝트들을 수정하는 방향으로 시간을 써…","fields":{"slug":"/2022-10-15-모으잡-기획-구체화/"},"frontmatter":{"date":"October 15, 2022","title":"모으잡-기획 구체화","tags":["사이드프로젝트","모으잡","기획"]},"rawMarkdownBody":"\n9월 말에 생각해두었던 채용공고 정리 사이트를 이번 주부터 본격적으로 만들어 보고자 한다. 급하게 한 주 안에 최대한 만드는 것을 목표로 잡았는데, 이유는 다음 주에 프리온보딩 코스 평가 결과가 나오기 때문에, 만약 합격한다면, 내 프로젝트 자체를 새롭게 기획하고 만들기 보다는, 과제를 하고, 새롭게 알게 된 걸로 프로젝트들을 수정하는 방향으로 시간을 써야 맞지 않을까 생각되었다. 그래서 먼저 기획 내용을 다시 점검하고 참고하고 공부할 내용들을 정리했다.\n\n## 😁 현재까지 기획\n\n### 1. 크롤러 만들기\n\n우선 채용공고를 크롤링을 위한 언어를 정하는 게 어려웠다. 파이썬이나 node JS를 사용해야 하는 상황에서 자바스크립트를 엄청 좋아하고, node JS를 언젠가는 공부해야 한다는 마음이 있어서 많이 고민을 하다가, 우선 파이썬으로 만들기로 정했다.\n\n파이썬은 이미 여러가지 크롤러를 만드는 영상들이 많아, 보고 배울 수 있는 코드가 많기 때문에 우선 잘 만들어 진 코드를 보면서 배운 후에, Node js로 바꿔서 만들어도 늦지 않겠다는 생각이 들었다. 파이썬으로 크롤러를 이용해 최대한 빨리 만들고 간단하게 프론트 페이지랑 연결해보는 것을 목표로 한다.\n\n크롤러로 정리할 내용은 회사/ 주요업무/ 자격요건/ 우대사항 4가지로 정리해보고자 한다.\n\n## 2. 프론트 세부 페이지 만들기\n\n프론트에서 만들고 싶었던 내용은 표의 형식을 사용하지만, 좀 더 효과적으로 정리할 수 있는 양식이 있을 지 조사가 필요하다.\n\n#### 1. 부트텐트 (https://boottent.sayun.studio/camps)\n\n부트텐트는 개발자들을 위한 부트캠프들을 정리해서 보여주는 서비스로, 부트캠프별로 어떤 과정이 있는지, 접수일 등 기준으로\n\n사용자가 원하는 기준의 해당 부트캠프를 찾아볼 수 있다. 어떤 기준을 추가할 지나 기준에 따라 필터링할 때 어떻게 할 지 참고하면 좋겠다고\n\n생각했다.\n\n![부트텐트](부트텐트.png)\n\n#### 2. OP.GG (https://www.op.gg/champions)\n\nOP.GG는 게임 사용자들에게 게임에 대한 다양한 전략, 이용자 정보, 전적 등을 제공하는 서비스이다.\n\n주로 게임할 때 이용했지, 정리가 어떻게 되어있는지 고민은 안해봤는데 가독성 높게 잘 만들어져 있는 것을 느꼈다.\n\n페이지 마다 중요한 내용, 현재 순위, 티어, 승률 등을 담고 있다. 공고마다 우선순위나 중요도를 담는 부분을 참고할 수 있을 것 같다.\n\n![OP.GG](오피지지.png)\n"},{"excerpt":"새롭게 배운 내용 사전과제의 요구사항 자체는 그렇게 복잡하지 않았다. 하지만 과제를 처음 만들고 나서, 다시 돌아보면서 코드를 고쳐나가면서 배우는 게 많았다. 1. HTTP 통신에 대한 이해 사전과제를 하는 과정에서 wanted에서 제공해 준 서버의 url이 바뀐 적이 있었다. 4시간 정도 구글링도 하고, wanter에서 제공해준 로컬 서버를 클론해와서 …","fields":{"slug":"/2022-10-13-원티드 프리온보딩사전과제회고/"},"frontmatter":{"date":"October 13, 2022","title":"원티드 프리온보딩 사전과제-회고","tags":["회고","원티드프리온보딩"]},"rawMarkdownBody":"\n## 새롭게 배운 내용\n\n사전과제의 요구사항 자체는 그렇게 복잡하지 않았다. 하지만 과제를 처음 만들고 나서, 다시 돌아보면서 코드를 고쳐나가면서 배우는 게 많았다.\n\n## 1. HTTP 통신에 대한 이해\n\n사전과제를 하는 과정에서 wanted에서 제공해 준 서버의 url이 바뀐 적이 있었다. 4시간 정도 구글링도 하고, wanter에서 제공해준 로컬 서버를 클론해와서 해결하려고 시도해봤지만 접속이 되지 않았다. 다음날 보았더니 서버주소가 바뀌어있었다...\n\n그냥 포기하고 다음날 시도할 걸 후회도 했지만 **\"HTTP 통신과 에러에 대한 의미를 내가 제대로 이해하고 있지 않구나\"** 라는 생각에 http 통신에 대해서 공부하게 되었다.\n\nHTTP는 서버와 client 간의 통신 규약으로 클라이언트의 요청(request)에 서버가 해당하는 응답(response)를 보내는 과정이다.\n\nclient가 요구할 때는 요구사항에 맞는 url과 헤더, 바디에 내용을 담아서 보내게 되고, 보낸 요청에 따라 서버는 올바른 요청인지 잘못된 요청인지 statusCode와 에러메시지 등을 담아서 응답해 준다.\n\n과제를 통해서 CRUD에 해당하는 GET, POST, DELETE, PUT 모든 요청들을 다 사용해볼 수 있었다. 각 요청마다 알맞은 header와 body의 내용을 보내는 과정은 많은 도움이 되었다. 헤더의 content-type과 authorization들을 담는 법, bearer token이 뭔지, access_token을 받고 어떻게 처리 해야 할 지 등 너무 중요한 내용들을 많이 공부할 수 있었다.\n\n## 2. 리액트 폴더 구조와 styled-component 파일 분리\n\n과제는 평가를 받는 것이다 보니, 폴더 구조에도 신경이 쓰여 처음으로 리액트 폴더 구조에 대해 공부했다.\n\n공통의 기능에 따라 아니면 하나의 기능과 관련된 컴포넌트 등으로 묶는 법을 알 수 있었고, 규모가 큰 프로젝트에서 어떻게 정리하고 사용하는지 예시들도 볼 수 있었다.\n\nstyled-component는 css in js 다 보니 styling 코드가 jsx파일에 같이 존재해 파일의 내용이 길어지는 문제점과 styled-component와 기능을 위한 component의 구분이 안 가는 문제점도 있었다.\n\n이 둘을 한번에 해결하는 style.js를 만들고 내부에 S 객체를 만들어 컴포넌트들은 객체의 프로퍼티로 만들고 S 객체 하나만 export해 만드는 방법을 새롭게 알게 되었다.\n\n## 3. fetch와 에러핸들링\n\n청원사이트를 제작할 때의 로그인과 회원가입을 담당해서 제작했었지만 에러핸들링을 하는 함수 내부 코드가 너무 복잡해지는 아쉬움이 있었다.\n\n그때는 분명 이해하지 못했을 부분을 이번 과제를 통해서 직접 찾고 적용하면서 어떻게 에러 핸들링을 하면 될 지 알게 되었다.\n\nfetch 자체는 http에러에 대해서 에러를 던지지 않기 때문에 response의 ok프로퍼티를 이용해서 에러를 던져 줄 수 있고, 던져진 에러에 따라 에러 핸들링을 할 때는 에러 객체를 상속해 custom 에러 클래스를 만들어 각각의 에러에 대한 statusCode에 맞는 반환을 해 줌으로써 처리할 수 있었다.\n\n## 아쉬운 점\n\n#### 1. Axios 사용\n\nfetch로 먼저 만든 후에 axios를 이용해보려 했지만 에러핸들링에 너무 많은 시간을 쏟다 보니 axios를 공부할 시간이 없었다.\n\naxios를 왜 쓰는지, 어떤 장점이 있는지에 대해 좀 더 공부해보고 이후 프로젝트들에 적용해보아야겠다.\n\n#### 2. 놓친 에러\n\n어제 직전에 테스트를 하면서 발견한 에러로, 제출을 하고 나면 상태들이 초기화되게 했을 때, 다시 작성 시 @가 인식되지 않아서 이메일에 @가 있고, 비밀번호가 8자 이상이어도 버튼이 활성화 되지 않는 에러를 발견했다.\n\nsetState가 비동기처리이기 때문에 생긴 에러라 예상은 되지만 해결하지 못하고 제출한 게 아쉬움이 남는다.\n\n<img src=\"./image-20221013154116466.png\"/>\n\n#### 3. 시간 제한과 커밋 쪼개기\n\n10월 12일까지 제출 시 가산점 1점이 있기 때문에 저녁 11시에 에러핸들링을 이해하고 수정하고 배포하느라 11시 58분에 완료했다. 하지만 작업하면서 수정한 내용 중에서 다른 에러를 일으키는 걸 보고 다시 수정하고 커밋했더니 12시 3분에 커밋이 올라가 이미 시간을 넘겨버렸다.\n\n만약에 두 가지 일을 따로 커밋을 해두었더라면 커밋을 삭제만 했으면 시간 내에 작업을 완료했을텐데 아쉬움이 남았다.\n\n개발자로 목표를 잡고 한 첫 도전이라, 나보다 잘하는 사람들에 대한 걱정도 되고, 떨어지면 자존감이 많이 떨어질 것 같다는 생각도 들었다.\n\n하지만 언제인지는 모르지만 \"나는 목표로 한 개발자가 될 것이다\"는 생각과, 과정에서 배움이 있었기 때문에 \"이미 나에게 이득이다\"란 생각으로\n\n편하게 마무리했다. 이제는 다시 리액트와 타입스크립트 공부를 하고, 계획했던 채용공고 정리 서비스를 만들어 갈 때이다.\n\n항상 다음 목표를 생각하고 결과에 휘둘리지 않는 단단함을 키워 가는 시기로 삼아 가야겠다.\n"},{"excerpt":"최적화를 위한 todo Btn 컴포넌트 분리 TodoItem은 memo를 통해 최적화를 해두었기 때문에 투두 아이템에 클릭을 하면 다른 투두아이템들이 re-rendering되는 것은 막았다. 하지만 같은 TodoItem 내부에서 클릭되지 않은 버튼들이 다시 re-rendering이 되는 것을 보고, TodoBtn 컴포넌트로 분리하고 memo로 감싸준 다음…","fields":{"slug":"/2022-10-12-원티드프리온보딩과제-8/"},"frontmatter":{"date":"October 12, 2022","title":"원티드 프리온보딩 사전과제 8편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n## 최적화를 위한 todo Btn 컴포넌트 분리\n\nTodoItem은 memo를 통해 최적화를 해두었기 때문에 투두 아이템에 클릭을 하면 다른 투두아이템들이 re-rendering되는 것은 막았다. 하지만 같은 TodoItem 내부에서 클릭되지 않은 버튼들이 다시 re-rendering이 되는 것을 보고, TodoBtn 컴포넌트로 분리하고 memo로 감싸준 다음, 전달해주는 함수들은 useCallback을 통해 불필요한 re-rendering을 막았다.\n\n```jsx\n//TodoBtn.jsx\n\nfunction TodoBtn({ name, clicked, onClick, text }) {\n  return (\n    <S.Btn name={name} clicked={clicked} onClick={onClick}>\n      {text}\n    </S.Btn>\n  );\n}\n\nexport default memo(TodoBtn);\n\n//TodoItem.jsx\n\nfunction TodoItem({\n  todoItem: { isCompleted, id, todo },\n  todoItem,\n  onDelete,\n  onUpdate,\n}) {\n\t...\n\n  const onClick = useCallback((e) => {\n    const { name } = e.currentTarget;\n    if (name === 'cancel') {\n      inputRef.current.value = ``;\n    }\n    setOnModifyMode((prev) => !prev);\n  }, []);\n\n  const handleDelete = useCallback(() => {\n    onDelete(id);\n  }, [id, onDelete]);\n\n  const handleCompleteUpdate = useCallback((e) => {\n    const { name } = e.currentTarget;\n    if (name === 'complete') {\n      setUpdated((prev) => {\n        return { ...prev, isCompleted: true };\n      });\n    } else {\n      setUpdated((prev) => {\n        return { ...prev, isCompleted: false };\n      });\n    }\n  }, []);\n\n  const handleSubmit = useCallback(() => {\n    const todo = inputRef.current.value;\n    if (!todo) {\n      setIsBlank(true);\n      return;\n    }\n    onUpdate({ ...updated, todo });\n    inputRef.current.value = ``;\n    setOnModifyMode((prev) => !prev);\n    setIsBlank(false);\n  }, [onUpdate, updated]);\n\n  return (\n    <S.TodoLayout>\n     ...\n      <S.RightBox>\n        {onModifyMode ? (\n          <>\n            <div>\n              <TodoBtn\n                name='complete'\n                clicked={updated.isCompleted}\n                onClick={handleCompleteUpdate}\n                text='Completed🙆‍♀️'\n              ></TodoBtn>\n              <TodoBtn\n                name='not yet'\n                clicked={!updated.isCompleted}\n                onClick={handleCompleteUpdate}\n                text='Not yet 🙅‍♂️'\n              ></TodoBtn>\n            </div>\n            <TodoBtn name='cancel' onClick={onClick} text='취소하기'></TodoBtn>\n            <TodoBtn\n              name='submit'\n              onClick={handleSubmit}\n              text='제출하기'\n            ></TodoBtn>\n          </>\n        ) : (\n          <>\n            <TodoBtn\n              text={isCompleted ? 'Completed🙆‍♀️' : 'Not yet 🙅‍♂️'}\n            ></TodoBtn>\n            <TodoBtn\n              name='modify'\n              onClick={onClick}\n              text={'수정하기'}\n            ></TodoBtn>\n          </>\n        )}\n        <TodoBtn onClick={handleDelete} text={'삭제하기'}></TodoBtn>\n      </S.RightBox>\n    </S.TodoLayout>\n  );\n}\n\nexport default memo(TodoItem);\n\n```\n\n## fetch를 이용한 에러핸들링\n\n#### 문제점\n\n​ 기존 코드에서 exceptionTest라는 함수는 에러가 발생했던, 성공을 했던 data를 받아서, 성공과 실패를 함께 처리했다. 하지만 이렇게 처리하게 되면 성공과 실패가 로그인과 회원가입 각각에 맞게 엉켜있고 너무 많은 일을 하다 보니, 받아야할 변수가 많아 이해하기 어렵고 수정하기도 어려웠다.\n\n```javascript\nconst exceptionTest = useCallback(\n  (data, setMessage, process) => {\n    let result = { message: \"\", success: false }\n    if (data.statusCode >= 400) {\n      if (data.statusCode === 401) {\n        result = {\n          message: \"이메일 혹은 비밀번호를 확인해주세요.\",\n          success: false,\n        }\n      } else {\n        result = {\n          message: data.message,\n          success: false,\n        }\n      }\n    } else {\n      if (process === \"login\") {\n        navigate(\"/todo\")\n        localStorage.setItem(\"access_token\", data.access_token)\n      }\n      result = {\n        message: `${\n          process === \"login\" ? \"로그인\" : \"회원가입\"\n        }에 성공했습니다`,\n        success: true,\n      }\n    }\n\n    setMessage(prev => {\n      return {\n        ...prev,\n        ...result,\n      }\n    })\n  },\n  [navigate]\n)\n```\n\n#### 해결방법\n\n이런 문제를 해결하고 싶어서 에러핸들링에 대한 자료를 계속해서 찾고 있었지만 정확히 이해가 되지 않아서 정리하지 못하고 있었다가, 타입스크립트에서 fetch를 이용해 에러 핸들링을 하신 글을 보게 되었다. ( https://www.rinae.dev/posts/how-to-handle-errors-2)\n\n코드는 다음과 같았다.\n\n```typescript\nclass CustomError extends Error {\n  name: string\n  constructor(message?: string) {\n    super(message)\n    this.name = new.target.name\n    Object.setPrototypeOf(this, new.target.prototype)\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor) // 하는 김에 스택트레이스도 바로잡아줍시다\n  }\n}\nclass HTTPError extends CustomError {\n  constructor(\n    private statusCode: number,\n    private errorData: Record<string, any>,\n    message?: string\n  ) {\n    super(message)\n    this.name = ‘HTTPError’\n  }\n  get rawErrorData() {\n    return this.errorData\n  }\n  get codeToErrorMessage() {\n    switch (this.statusCode) {\n      case 401:\n        return `You don’t have a permission.`\n      // ...\n    }\n  }\n}\n\n```\n\nError 객체를 상속하는 CustomError 클래스를 만들고, CustomError클래스를 상속하는 HTTPError클래스를 만들어서 해당 statusCode에 따른 결과를 전달해주는 방식이었다.\n\nHTTPError클래스는 getter를 이용해 codeToErrorMessage라는 함수를 만들었는데 getter를 이용한 이유는 클래스의 statusCode값이 바뀔 때 같이 업데이트 될 수 있게 하기 위해서라고 생각되었고, 직접적인 수정을 막기위해서 getter로 읽을 수만 있게 설정했다고 이해했다.\n\n#### 적용해보기\n\n이 글을 제대로 이해하고 이렇게 한번 해보기로 마음먹었을 때 시간이 저녁 11시여서, 12시가 되기 전 제출해야했기 때문에 우선 HTTPError클래스만 Error를 상속해 만들었다.\n\nError객체를 상속할 때는 반드시 message를 전달해주어야하기에 super를 통해 상속한 Error객체에 전달하고, statusCode를 constructor함수를 이용해서 저장한다. constructor를 통해 저장한 statusCode에 따라 message상태에 전해줄 객체를 반환하게 함수를 만들었다.\n\n클래스로 분리함으로써 HTTP에러가 발생했을 때의 로직을 분리해서 관리할 수 있기 때문에 더 가독성이 좋아졌다.\n\n```javascript\n//auth.js\n\nclass HTTPError extends Error {\n  constructor(statusCode, message) {\n    super(message)\n    this.name = `HTTPError`\n    this.statusCode = statusCode\n  }\n\n  get codeToErrorMessage() {\n    let result = { message: \"\", success: false }\n    switch (this.statusCode) {\n      case 400:\n        result = {\n          message: \"동일한 이메일이 이미 존재합니다.\",\n          success: false,\n        }\n        break\n      case 401:\n        result = {\n          message: \"이메일 혹은 비밀번호를 확인해주세요.\",\n          success: false,\n        }\n        break\n      case 404:\n        result = {\n          message: \"해당 사용자가 존재하지 않습니다.\",\n          success: false,\n        }\n        break\n      default:\n        throw new Error(\"Unknown Error\")\n    }\n    return result\n  }\n}\n\nexport async function postSignUp(email, password) {\n  try {\n    const res = await fetch(`${BASE_URL}/auth/signup`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        email,\n        password,\n      }),\n    })\n    if (!res.ok) {\n      console.log(`${res.status}에러가 발생했습니다`)\n      throw new HTTPError(res.status, res.statusText)\n    } else {\n      return await res.json()\n    }\n  } catch (e) {\n    return e.codeToErrorMessage\n  }\n}\n```\n\n반환한 객체를 받았던 handleSubmit함수는 각각 login과 회원가입으로 2개의 함수로 분리했다.\n\n분리 후에 성공한 경우는 둘 다 access_token이 들어있는 객체를 전달받기 때문에 access_token이라는 프로퍼티의 유무에 따라 성공과 에러 처리를 하게 했다.\n\n```jsx\n//auth.jsx\n\nconst handleLoginSubmit = useCallback(\n  info => {\n    const { email, password } = info\n    postSignIn(email, password) //\n      .then(data => {\n        if (\"access_token\" in data) {\n          navigate(\"/todo\")\n          localStorage.setItem(\"access_token\", data.access_token)\n        } else {\n          setLoginMessage(prev => {\n            return {\n              ...prev,\n              ...data,\n            }\n          })\n        }\n      })\n  },\n  [navigate]\n)\n\nconst handleRegisterSubmit = useCallback(info => {\n  const { email, password } = info\n  postSignUp(email, password) //\n    .then(data => {\n      if (\"access_token\" in data) {\n        data = {\n          message: `회원가입에 성공했습니다`,\n          success: true,\n        }\n      }\n      setRegisterMessage(prev => {\n        return {\n          ...prev,\n          ...data,\n        }\n      })\n    })\n}, [])\n```\n\n이렇게 에러와 성공, 로그인과 회원가입을 로직을 분리하니까 더 보기 좋고 이해가 편해졌다.\n\n너무 과도하게 합치는 게 더 이해하기 어렵다는 것을 느꼈고, 에러핸들링을 할 때 customError클래스를 만들어서 처리하는 방법에 대해 배울 수 있었다.\n"},{"excerpt":"1. 최적화와 배포 에러 핸들링을 하기 전에 내일까지 배포하는 것이 목표이기 때문에 그전에 여태까지 한 작업들을 최적화하고 배포를 먼저 한 후에 readme작성을 하게 되었다. 우선 최적화는 memo와 useCallback을 이용해 auth와 todo페이지의 불필요한 re-rendering을 막았다. 1.1 auth 페이지 auth 페이지에서는 회원가입 …","fields":{"slug":"/2022-10-11-원티드프리온보딩과제-7/"},"frontmatter":{"date":"October 11, 2022","title":"원티드 프리온보딩 사전과제 7편 ","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n## 1. 최적화와 배포\n\n에러 핸들링을 하기 전에 내일까지 배포하는 것이 목표이기 때문에 그전에 여태까지 한 작업들을 최적화하고 배포를 먼저 한 후에 readme작성을 하게 되었다. 우선 최적화는 memo와 useCallback을 이용해 auth와 todo페이지의 불필요한 re-rendering을 막았다.\n\n#### 1.1 auth 페이지\n\nauth 페이지에서는 회원가입 form과 로그인 form이 같이 존재하고 상태가 변하면 authForm 내부 모두가 다시 실행되기 때문에, 모든 input들이 re-rendering되는 모습을 보였다. 이를 해결하기 위해서 input을 컴포넌트로 만들어서 각 컴포넌트에 주입되는 함수나 props가 바뀌는 게 아니면 업데이트 되지 않게 해주었다.\n\n```jsx\n//이전 코드\n\nfunction AuthForm({\n  process,\n  onSubmit,\n  onChange,\n  message,\n  setMessage,\n  info,\n  setInfo,\n}) {\n\t...\n   return (\n    <S.AuthFormLayout onSubmit={handleSubmit}>\n      <h1>{process === 'login' ? '로그인' : '회원가입'}</h1>\n      <div>\n        <label htmlFor={`${process}_email`}>Email</label>\n        <S.AuthInput\n          name='email'\n          onChange={handleChange}\n          id={`${process}_email`}\n          placeholder='아이디를 입력해주세요'\n        ></S.AuthInput>\n      </div>\n      <div>\n        <label htmlFor={`${process}_password`}>Password</label>\n        <S.AuthInput\n          name='password'\n          onChange={handleChange}\n          id={`${process}_password`}\n          placeholder='비밀번호를 입력해주세요'\n        ></S.AuthInput>\n      </div>\n      {message.message ? (\n        <S.Message success={message.success}>{message.message}</S.Message>\n      ) : null}\n      <S.SubmitBtn\n        onSubmit={handleSubmit}\n        disabled={!(info.isEmailValid && info.isPasswordValid)}\n      >\n        {process === 'login' ? '로그인' : '회원가입'}\n      </S.SubmitBtn>\n    </S.AuthFormLayout>\n  );\n}\nexport default AuthForm\n\n//수정 이후 코드\n\nfunction AuthForm({\n  process,\n  onSubmit,\n  onChange,\n  message,\n  setMessage,\n  info,\n  setInfo,\n}) {\n\n\t...\n\n  return (\n    <S.AuthFormLayout onSubmit={handleSubmit}>\n      <h1>{process === 'login' ? '로그인' : '회원가입'}</h1>\n      <AuthInput\n        onChange={handleChange}\n        process={process}\n        name={'email'}\n      ></AuthInput>\n      <AuthInput\n        onChange={handleChange}\n        process={process}\n        name={'password'}\n      ></AuthInput>\n      {message.message ? (\n        <S.Message success={message.success}>{message.message}</S.Message>\n      ) : null}\n      <S.SubmitBtn\n        onSubmit={handleSubmit}\n        disabled={!(info.isEmailValid && info.isPasswordValid)}\n      >\n        {process === 'login' ? '로그인' : '회원가입'}\n      </S.SubmitBtn>\n    </S.AuthFormLayout>\n  );\n}\n\n//AuthInput\nimport React, { memo } from 'react';\nimport S from './styles';\n\nfunction AuthInput({ onChange, process, name }) {\n  return (\n    <div>\n      <label htmlFor={`${process}_email`}>{name}</label>\n      <S.AuthInput\n        name={name}\n        onChange={onChange}\n        id={`${process}_email`}\n        placeholder='아이디를 입력해주세요'\n      ></S.AuthInput>\n    </div>\n  );\n}\n\nexport default memo(AuthInput);\n\n\n```\n\n컴포넌트로 authInput을 만들고 AuthInput을 memo로, onChange함수를 useCallback을 이용해 메모리에 저장해둠으로써 해당 input이 아닌데도 업데이트되는 부분을 막을 수 있었다. 그리고 이름을 styled-component의 convention을 정해놓으니 겹치지 않아서 더 편리하게 naming할 수 있었다.\n\n​ input들의 리랜더링은 막았지만 회원가입부분을 작성하는데 로그인 부분이 업데이트 되는 모습이 보였다. 불필요한 re-rendering이기 때문에 AuthForm도 똑같이 memo로, AuthForm에게 전달되는 함수인 onSubmit, onChange, exceptionTest을 useCallback을 이용해 메모리에 저장해 동일하게 불필요한 re-rendering을 막았다.\n\n![auth페이지개선](auth페이지개선.gif)\n\n#### 1.2 Todo 페이지\n\n​ todo페이지에서는 각 Todo를 수정하면 해당 todo를 제외한 나머지 todo들과 함께 전체적으로 re-rendering이 되기 때문에 Auth와 동일하게 관련 함수인 onUpdate와 onDelete를 useCallback으로, TodoItem은 memo를 이용해 메모리에 저장해 불필요한 re-rendering을 막았다.\n\n​ todo를 생성하는 input의 경우 Todo 전체 파일에 있게 되면 계속해서 업데이트되기 때문에 따로 컴포넌트화 시켜 memo로 저장한 후에 prop으로 전달해주는 함수들을 useCallback으로 메모리에 저장해 불필요한 re-rendering을 막았다.\n\n```jsx\nimport React, { memo, useRef } from \"react\"\nimport S from \"./styles\"\n\nfunction TodoForm({ onSubmit, isBlank }) {\n  const inputRef = useRef()\n  const handleSubmit = e => {\n    onSubmit(e, inputRef)\n  }\n  return (\n    <S.TodoForm onSubmit={handleSubmit}>\n      <input\n        ref={inputRef}\n        type=\"text\"\n        id=\"todoInput\"\n        placeholder={\n          isBlank ? \"내용이 비어있습니다.😅\" : \"오늘의 투두를 작성해주세요😀\"\n        }\n      />\n      <button>Add</button>\n    </S.TodoForm>\n  )\n}\n\nexport default memo(TodoForm)\n```\n\n![todo페이지개선](todo페이지개선.gif)\n\n## 2. Netlify를 이용한 배포\n\n​ Netlify를 이용해서 배포하는 것은 create-react-app 공식 홈페이지에 잘 안내되어있기 때문에 크게 어려움은 없었지만 Github page로 배포할 때와 동일하게 새로고침을 하게되면 에러가 발생했다. netlify를 이용한 게 github pages에서 발생했던 동일한 에러 때문이었는데.... 역시 한번 마주한 에러를 해결하지 않으면 결국엔 돌아와서 똑같이 괴롭히는 것 같다. 이번 기회에 확실히 해결하고 넘어가고자 한다.\n\n![Todo 화면에서 새로고침 후 화면](새로고침후화면.png)\n\n​ 생각보다 해결방법은 간단하게 CRA 공식홈페이지 deploy부분에 설명되어있었다.\n\n![deploy 문서내용](deploy.png)\n\n에러가 난 이유는 내가 만든 프로젝트는 Single-page-application(SPA)이다. SPA의 경우 하나의 index.html을 갖고 모든 일이 index.html에서 이루어지기 때문에 \"/\"가 아닌 \"/todo\"에서 새로고침을 하게 되면 **해당 url에서는 index.html을 불러올 수 없기 때문에** 에러 페이지를 보여주게 되었다. 이를 해결하기 위해서 netlify는 public 폴더에 \\_redierects라는 파일을 만들어 해당 코드를 그대로 적어주면 해결 할 수 있다.\n\n끝으로 github pages에 대해서도 알아보았는데 github pages는 SPA를 지원하지 않아 라우팅이 불가능한 문제점을 갖고 있다. 그래서 404.html을 만들고 CI에서 빌드시에 index.html을 404.html로 옮겨서 다시 index.html내용을 보여주는 형식으로 처리한다고 한다.\n\n[참고:heyeon.log velog ](https://velog.io/@heyoon/github-pages%EC%97%90%EC%84%9C-%EB%9D%BC%EC%9A%B0%ED%8C%85%EB%90%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8%EC%8B%9C-404%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A9%EB%8B%88%EB%8B%A4)\n\n```yml\n# CI 설정파일\n- name: Install and Build 🔧\n        run: |\n          npm install\n          npm run build\n          cp dist/index.html dist/404.html\n```\n\n위의 방식으로 기존 github pages로 만들었던 프로젝트들을 해결해봐야겠다고 생각했다.\n"},{"excerpt":"남은 리팩토링할 부분들은 axios와 api 예외사항으로 둘다 http 통신과 연관되어있다는 공통점이 있어서 함께 처리해보려 했다. 1. API 예외사항 과제에서 요구하는 부분이 많지 않아 크게 어려움은 없었지만 작성 중에 마주쳤던 에러 사항들에 대해 정리하면 다음과 같다. 컴포넌트 Status code 내용 회원가입 400 Bad Request 동일한 …","fields":{"slug":"/2022-10-10-원티드프리온보딩과제-6/"},"frontmatter":{"date":"October 10, 2022","title":"원티드 프리온보딩 사전과제 6편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n남은 리팩토링할 부분들은 axios와 api 예외사항으로 둘다 http 통신과 연관되어있다는 공통점이 있어서 함께 처리해보려 했다.\n\n## 1. API 예외사항\n\n과제에서 요구하는 부분이 많지 않아 크게 어려움은 없었지만 작성 중에 마주쳤던 에러 사항들에 대해 정리하면 다음과 같다.\n\n| 컴포넌트 | Status code      | 내용                             |\n| :------: | ---------------- | -------------------------------- |\n| 회원가입 | 400 Bad Request  | 동일한 이메일이 이미 존재합니다. |\n|  로그인  | 401 Unauthorized | Unauthorized                     |\n|  로그인  | 404 Not found    | 해당 사용자가 존재하지 않습니다. |\n|   todo   | 400 Bad Request  | todo should not be empty         |\n\n#### 1.1 회원가입\n\n400 Bad Request 에러의 경우 \"동일한 이메일이 이미 존재합니다\"라는 메세지를 함께 받아오기 때문에 그대로 메시지 상태에 받아와 UI로 보여주는 방법으로 처리했다.\n\n#### 1.2 로그인\n\n​ 401 Unauthorized 에러는 이메일은 존재하지만 비밀번호가 해당 이메일과 맞지 않을 때 주는 에러이다. 백엔드에서 받은 메시지는 \"Unauthorized\"로 오기 때문에 사용자 입장에서는 이해하기 어려울 것이라 생각해 **\"이메일 혹은 비밀번호를 확인해주세요.\"**로 바꾸어서 보여주게 설정했다.\n\n404 Not found의 경우 \"해당 사용자가 존재하지 않습니다\"로 메시지가 오기 때문에 그대로 메시지 상태로 담아 UI로 보여주었다.\n\n```jsx\nconst exceptionTest = (data, setMessage, process) => {\n  if (data.statusCode >= 400) {\n    if (data.statusCode == 401) {\n      //추가한 예외처리 부분\n      setMessage(prev => {\n        return {\n          ...prev,\n          message: \"이메일 혹은 비밀번호를 확인해주세요.\",\n          success: false,\n        }\n      })\n      return\n    }\n    setMessage(prev => {\n      return {\n        ...prev,\n        message: data.message,\n        success: false,\n      }\n    })\n    return\n  }\n  if (process == \"login\") {\n    navigate(\"/todo\")\n    localStorage.setItem(\"access_token\", data.access_token)\n  }\n  setMessage(prev => {\n    return {\n      ...prev,\n      message: `${\"login\" ? \"로그인\" : \"회원가입\"}에 성공했습니다`,\n      success: true,\n    }\n  })\n}\n```\n\n![에러메시지 맵핑](로그인개선.png)\n\n#### 1.3 Todo\n\ntodo의 경우, input에 작성된 내용으로 수정하는 기능을 추가했는데 api 연결 과정에서 빈칸으로 보내고 마주하게 된 에러였다. 에러 status코드는 400 Bad request로 message는 \"todo should not be empty\"로 반환되는 것을 확인할 수 있었다.\n\n![400에러](Todo.png)\n\n에러 처리를 위해서 고민했을 때 빈 내용을 보낼 수 없게 하기 위해서 input창이 비어있는지 확인하는 상태를 추가했고 비어 있다면 placeholder로 알려 주는 로직을 추가함으로, 에러를 처리했다.\n\n```jsx\nfunction TodoItem({\n  todoItem: { isCompleted, userId, id, todo },\n  todoItem,\n  onDelete,\n  onUpdate,\n}) {\n\n  const [isBlank, setIsBlank] = useState(false);\n\n\t...\n\n  const handleSubmit = () => {\n    const todo = inputRef.current.value;\n    if (!todo) {\n      setIsBlank(true);\n      return;\n    }\n    onUpdate({ ...updated, todo });\n    inputRef.current.value = ``;\n    setOnModifyMode((prev) => !prev);\n  };\n\n  return (\n    <S.TodoLayout>\n      <S.LeftBox>\n        {onModifyMode ? (\n          <input\n            placeholder={\n              isBlank ? '내용이 비어있습니다.😅' : '여기에 작성해주세요😀'\n            }\n            ref={inputRef}\n          ></input>\n        ) : (\n          <div>{todo}</div>\n        )}\n      </S.LeftBox>\n\n    \t...\n    </S.TodoLayout>\n  );\n}\n\nexport default TodoItem;\n\n```\n\n![배열이 비어있을 떄 안내 개선](placeholder.png)\n\nTodo 자체의 input창에서도 똑같은 에러가 나타날 수 있으니 제출을 못하게 막기보다는 isBlank상태를 추가해 사용자에게 알려 주는 방향으로 하는 게 더 좋은 방법이라 생각되어 todo에서도 같은 방법으로 수정해주었다.\n\n```jsx\nunction Todo() {\n  const inputRef = useRef();\n  const [todos, setTodos] = useState([]);\n  const [isBlank, setIsBlank] = useState(false);\n\n  const onSubmit = (e) => {\n    e.preventDefault();\n    const value = inputRef.current.value;\n    if (!value) {\n      setIsBlank(true);\n      return;\n    }\n    postCreateTodo(value).then((data) => setTodos((prev) => [...prev, data]));\n    inputRef.current.value = '';\n    setIsBlank(false);\n  };\n\n \t\t...\n\n  return (\n    <S.TodoLayout>\n      <header>TO DO</header>\n      <S.TodoContent>\n        <S.TodoForm onSubmit={onSubmit}>\n          <input\n            ref={inputRef}\n            type='text'\n            id='todoInput'\n            placeholder={\n              isBlank\n                ? '내용이 비어있습니다.😅'\n                : '오늘의 투두를 작성해주세요😀'\n            }\n          />\n          <button>Add</button>\n        </S.TodoForm>\n   \t\t\t...\n      </S.TodoContent>\n    </S.TodoLayout>\n  );\n}\n\nexport default Todo;\n\n```\n\n## 2. API 분리와 Fetch 에러처리\n\n#### 2.1 API 분리\n\n​ api.js에 회원가입과 로그인 api들과 todo의 api들 모두 담겨 있는 것보다 기능에 따라 분리할 필요가 있어 보여 api들을 분리 시켰다.\n\n```\napi/\n  auth.js\n  todo.js\n```\n\n#### 2.2 Fetch 에러처리\n\n​ Server의 API를 사용할 때 모두 fetch를 이용하고 try-catch 구문을 이용해서 에러를 잡아보려 했다. 하지만 fetch자체적으로 HTTP 오류 상태를 수신해도 cath로 에러가 잡히지 않는다는 mdn 문서 내용을 보게되었다.[참고 문서](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch)\n\n```javascript\nexport async function postSignUp(data) {\n  const { email, password } = data\n  try {\n    const res = await fetch(`${BASE_URL}/auth/signup`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        email,\n        password,\n      }),\n    })\n    return await res.json()\n  } catch (error) {\n    console.log(error)\n  }\n}\n```\n\n![fetch에러](fetch에러.png)\n\nfetch로 사용할 때는 대신 response의 ok 프로퍼티가 false로 설정되기 때문에 에러를 전달하기 위해서는 try-catch보다는 ok 프로퍼티로 먼저 수정해 줄 필요가 있었다. 바꾸고 나서 콘솔창에 에러 발생에 대해 나오는 걸 확인할 수 있었다. fetch의 이러한 특징 때문에 에러를 발생 시키고 에러에 따라 다른 작업을 해야 한다면 우선 respones.ok를 확인 후 throw error를 던진 후에 try-catch구문을 이용해서 에러를 처리해주면 좀 더 깔끔하게 에러 처리가 가능할 것 같다고 생각되었다.\n\n```javascript\nexport async function postSignUp(data) {\n  const { email, password } = data\n  const res = await fetch(`${BASE_URL}/auth/signup`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      email,\n      password,\n    }),\n  })\n  if (!res.ok) {\n    console.log(`${res.status} 에러가 발생했습니다`)\n  }\n  return await res.json()\n}\n```\n\n![에러던지기](에러던지기.png)\n\n어떻게 던진 에러를 처리할 지는 내일 좀 더 에러 핸들링에 대해 공부한 후에 적용해보기로 생각했다.\n"},{"excerpt":"리액트 폴더, 파일 구조 어제 리팩토링에 이어 폴더와 파일구조에 대해 먼저 고민해보았다. 최근에 혼자 프로젝트를 하다보니 파일 구조에 대해서는 크게 생각해본 적이 없었다. 지스트 청원 서비스 같은 경우에는 친구들과 함께 의논하면서 convention을 정해서 했지만 혼자 할 때는 크게 고민을 안했던 부분이라 이번 기회에 한 번 정리하면 좋을 것 같다는 생…","fields":{"slug":"/2022-10-09-원티드프리온보딩과제-5/"},"frontmatter":{"date":"October 09, 2022","title":"원티드 프리온보딩 사전과제 5편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n## 리액트 폴더, 파일 구조\n\n어제 리팩토링에 이어 폴더와 파일구조에 대해 먼저 고민해보았다. 최근에 혼자 프로젝트를 하다보니 파일 구조에 대해서는 크게 생각해본 적이 없었다. 지스트 청원 서비스 같은 경우에는 친구들과 함께 의논하면서 convention을 정해서 했지만 혼자 할 때는 크게 고민을 안했던 부분이라 이번 기회에 한 번 정리하면 좋을 것 같다는 생각이 들었다.\n\n### 1. 리액트 공식 홈페이지\n\n리액트 공식홈페이지에서는 **파일 기능이나 라우트에 의한 분류**와 **파일 유형에 의한 분류** 두가지로 설명하고 있다.\n\n#### 1.1 파일기능이나 라우트에 의한 분류\n\n관련된 기능들을 함께 폴더로 보관하는 방법으로 하나의 컴포넌트에 연관된 것을 묶어서 찾을 수 있다. 복잡한 어플리케이션일 수록 기능별로 다 보관하기 어려워 큰 프로젝트에 참고해서 사용하면 좋겠다는 생각이 들었다.\n\n```\ncommon/\n  Avatar.js\n  Avatar.css\n  APIUtils.js\n  APIUtils.test.js\nfeed/\n  index.js\n  Feed.js\n  Feed.css\n  FeedStory.js\n  FeedStory.test.js\n  FeedAPI.js\nprofile/\n  index.js\n  Profile.js\n  ProfileHeader.js\n  ProfileHeader.css\n  ProfileAPI.js\n```\n\n#### 1.2 파일유형에 의한 분류\n\n내가 가장 많이 사용하는 방식이라 생각된다. Api는 api끼리 component들은 componet들끼리 묶어서 정리해두는 방식으로 개인 프로젝트와 같은 소규모 프로젝트에 유용하다고 생각이 되었다.\n\n```\napi/\n  APIUtils.js\n  APIUtils.test.js\n  ProfileAPI.js\n  UserAPI.js\ncomponents/\n  Avatar.js\n  Avatar.css\n  Feed.js\n  Feed.css\n  FeedStory.js\n  FeedStory.test.js\n  Profile.js\n  ProfileHeader.js\n  ProfileHeader.css\n```\n\n## 2. Styled-components\n\n폴더 구조에 대해서는 원래 고민을 하지 않았지만 styled-components를 사용하면서 고민이 시작되었다. styled-components는 CSS-in-javascript로 자바스크립트 파일 내에서 css를 사용하기 때문에, **스타일링을 위한 코드와 기능을 위한 코드를 어떻게 분리하면 좋을 까** 고민이 되었다. 찾아본 결과는 컴포넌트 폴더를 만들고 내부에 styles.js를 만들어서 모듈 시스템으로 전달해주는 방식이었다.\n\n[사진 첨부: ghoon99님의 블로그](https://ghoon99.tistory.com/46)\n\n![사진 첨부:ghoon99님의 블로그](https://blog.kakaocdn.net/dn/bl8El0/btrigf0IB7G/luN4wBBYzm4hcNBXsWc7sK/img.png)\n\n위의 구조를 이용해 정리해 다음과 같은 폴더 구조로 수정했다. 스타일링을 위한 코드내용을 분리하니 훨씬 가독성이 좋아졌다.\n\n```\nsrc\n├── components\n│   ├── auth_form\n│   │      auth_form.jsx\n│   │      styles.js\n│   └── todo_item\n│          todo_item.jsx\n│          styles.js\n├── pages\n│   ├── auth\n│   │      auth.jsx\n│   │      styles.js\n│   └── todo\n│          todo.jsx\n│          styles.js\n├── index.js\n└── router.jsx\n```\n\n이렇게 코드를 정리하고 나니 styled-componets에서 스타일링을 위한 컴포넌트와 로직을 위한 컴포넌트들이 구분이 잘 안간다는 생각이 들었다. 구분하기 위해 styling을 위한 컴포넌트에 S라는 styling을 위한 오브젝트를 만들고 각 컴포넌트들을 property로 전달하는 방식을 도입하기로 했다. [medium Naming Styled Components](https://medium.com/inturn-eng/naming-styled-components-d7097950a245)\n\nTodo를 예로, 모든 스타일링 component들을 다 styles.js에서 받아와 복잡했던 todo.jsx의 import가 S로 간단해지고, styles.js도 간단하게 object만 export하면 되기에 효율적인 방식이라 생각되었다.\n\n```jsx\n//todo/styles.js\n\nconst S = { TodoContent, TodoForm, TodoLayout, TodoList };\n\nexport default S;\n\n\n//todo.jsx\n\nimport S from './styles';\n\nfunction Todo() {\n  return (\n    <S.TodoLayout>\n      <header>TO DO</header>\n      <S.TodoContent>\n        <S.TodoForm onSubmit={onSubmit}>\n          <input\n            ref={inputRef}\n            type='text'\n            id='todoInput'\n            placeholder='오늘의 할 일을 입력해주세요'\n          />\n          <button>Add</button>\n        </S.TodoForm>\n        <S.TodoList>\n          {todos.map((item) => (\n            <TodoItem\n              key={item.id}\n              todoItem={item}\n              onUpdate={onUpdate}\n              onDelete={onDelete}\n            ></TodoItem>\n          ))}\n        </S.TodoList>\n      </S.TodoContent>\n    </S.TodoLayout>\n  );\n}\n\nexport default Todo;\n\n\n```\n"},{"excerpt":"어제 과제에서 요구하는 전반적인 요구사항에 대한 기능은 개발했지만 리팩토링을 할 부분을 세부적으로 많이 보였다. 리팩토링 할 부분들을 정리해보면 다음과 같다. 회원가입과 로그인의 코드중복: 만들다 보니 너무 똑같은 styling과 api 사용이 반복되어서 수정이 필요하다. 폴더나 파일 구조 설계: 리액트를 개인프로젝트를 주로하다보니 폴더 설계나 어떤 곳에…","fields":{"slug":"/2022-10-08-원티드프리온보딩과제-4/"},"frontmatter":{"date":"October 08, 2022","title":"원티드 프리온보딩 사전과제 4편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n어제 과제에서 요구하는 전반적인 요구사항에 대한 기능은 개발했지만 리팩토링을 할 부분을 세부적으로 많이 보였다. 리팩토링 할 부분들을 정리해보면 다음과 같다.\n\n1. 회원가입과 로그인의 코드중복: 만들다 보니 너무 똑같은 styling과 api 사용이 반복되어서 수정이 필요하다.\n2. 폴더나 파일 구조 설계: 리액트를 개인프로젝트를 주로하다보니 폴더 설계나 어떤 곳에 어떤 파일을 두어야 좀 더 좋을지에 대한 고민이 부족했다.\n3. axios사용: fetch로 기능이 다 구현했으니 axios로 구현해보면 좋은 경험이 될 것 같다.\n4. api 예외사항 체크: 미처 발견하지 못한 에러처리에 대해 고민해보고 해결이 필요하다.\n\n## login.jsx 컴포넌트화\n\n### 1. styling 코드중복 제거\n\n기능구현을 위해 우선은 한번에 코딩을 하다보니 login.jsx에 많은 코드중복이 보였다. 우선 /경로에 로그인과 회원가입을 동시에 보여주다보니 login.jsx보다는 **auth.jsx**로 이름을 바꾸고, authForm.jsx로 컴포넌트를 추가해 로그인과 회원가입 모두 같은 구성을 갖게 만들었다.\n\n```jsx\n///이전 코드\nfunction Login(props) {\n  return (\n    <LoginLayout>\n      <LoginForm onSubmit={handleLoginSubmit}>\n        <h1>Sign In</h1>\n        <div>\n          <label htmlFor='login-email'>Email</label>\n          <LoginInput\n       \t\t...\n          ></LoginInput>\n        </div>\n        <div>\n          <label htmlFor='login-password'>Password</label>\n          <LoginInput\n\t\t\t...\n          ></LoginInput>\n        </div>\n        {message.loginMessage && (\n          <Message success={message.loginSuccess}>\n            {message.loginMessage}\n          </Message>\n        )}\n        <SubmitBtn\n        \t...\n        >\n          Login\n        </SubmitBtn>\n      </LoginForm>\n      <RegisterForm onSubmit={handleRegisterSubmit}>\n        <h1>Sign Up</h1>\n        <div>\n          <label htmlFor='register-email'>Email</label>\n          <RegisterInput\n        \t\t...\n            name='email'\n          ></RegisterInput>\n        </div>\n        <div>\n          <label htmlFor='register-password'>Password</label>\n          <RegisterInput\n            \t...\n          ></RegisterInput>\n        </div>\n        {message.registerMessage && (\n          <Message success={message.registerSuccess}>\n            {message.registerMessage}\n          </Message>\n        )}\n        <SubmitBtn\n          disabled={\n            !(registerInfo.isEmailValid && registerInfo.isPasswordValid)\n          }\n        >\n          Submit\n        </SubmitBtn>\n      </RegisterForm>\n    </LoginLayout>\n  );\n}\n\nexport default Login;\n\n//수정한 코드\n//auth.jsx\nfunction Auth() {\n \t...\n  return (\n    <AuthLayout>\n      <AuthForm\n       \t...\n      ></AuthForm>\n      <AuthForm\n       \t...\n      ></AuthForm>\n    </AuthLayout>\n  );\n}\n\nexport default Auth;\n\n//authForm.jsx\nfunction AuthForm({\n  process,\n  onSubmit,\n  onChange,\n  message,\n  setMessage,\n  info,\n  setInfo,\n}) {\n  \t...\n  return (\n    <AuthFormLayout onSubmit={handleSubmit}>\n      <h1>{process === 'login' ? '로그인' : '회원가입'}</h1>\n      <div>\n        <label htmlFor={`${process}_email`}>Email</label>\n        <AuthInput\n      \t\t...\n        ></AuthInput>\n      </div>\n      <div>\n        <label htmlFor={`${process}_password`}>Password</label>\n        <AuthInput\n         \t...\n        ></AuthInput>\n      </div>\n      {message.loginMessage && (\n        <Message success={message.loginSuccess}>{message.loginMessage}</Message>\n      )}\n      <SubmitBtn\n       \t...\n      >\n        Login\n      </SubmitBtn>\n    </AuthFormLayout>\n  );\n}\n\nexport default AuthForm;\n\n\n```\n\n### 2. 함수 코드중복 제거\n\nlogin.jsx내부의 함수들에도 코드중복이 많이 존재했다. handleLoginChange,handleRegisterChange 등 이름과 내용만 조금씩 다른 함수들이 하나의 함수로 최대한 합쳤다.\n\n#### 2.1 handleChange\n\n​ 회원가입과 로그인의 input 값들의 유효성검사를 실행하고 통과했을 때 제출버튼을 활성화하는 함수로 아예 똑같은 코드를 반복하고 있어 하나로 합쳤다. 둘의 다른 점은 다른 setState함수를 사용한다는 점이었는데, 이부분은 authForm으로 컴포넌트로 분리하면서 각각 다른 상태와 setState함수를 전달하기 때문에 컴포넌트에 handleChange를 prop으로 전달 후에, 컴포넌트 내부에서 setState를 함수로 전달해 연결했다.\n\n```jsx\n//이전 코드\nconst handleLoginChange = e => {\n  const { name, value } = e.currentTarget\n  setLoginInfo(prev => {\n    return {\n      ...prev,\n      [name]: value,\n      isEmailValid: name == \"email\" ? value.includes(\"@\") : prev.isEmailValid,\n      isPasswordValid:\n        name == \"password\" ? value.length >= 8 : prev.isPasswordValid,\n    }\n  })\n}\n\nconst handleRegisterChange = e => {\n  const { name, value } = e.target\n  setRegisterInfo(prev => {\n    return {\n      ...prev,\n      [name]: value,\n      isEmailValid: name == \"email\" ? value.includes(\"@\") : prev.isEmailValid,\n      isPasswordValid:\n        name == \"password\" ? value.length >= 8 : prev.isPasswordValid,\n    }\n  })\n}\n\n//수정 후 코드\n\nconst handleChange = (e, setInfo) => {\n  const { name, value } = e.currentTarget\n  setInfo(prev => {\n    return {\n      ...prev,\n      [name]: value,\n      isEmailValid: name == \"email\" ? value.includes(\"@\") : prev.isEmailValid,\n      isPasswordValid:\n        name == \"password\" ? value.length >= 8 : prev.isPasswordValid,\n    }\n  })\n}\n```\n\n#### 2.2 상태와 상태관리 함수\n\n​ 상태도 유사한점이 많아 하나로 합치고 싶었지만 각각 다른 데이터를 보관하기 때문에 오히려 합쳐져있던 message상태를 각각 loginMessage와 registerMessage로 분리해, 컴포넌트에 상태들과 함수를 prop으로 전달했다.\n\n```jsx\n//이전코드\nconst [loginInfo, setLoginInfo] = useState({\n  email: \"\",\n  password: \"\",\n  isEmailValid: false,\n  isPasswordValid: false,\n})\n\nconst [registerInfo, setRegisterInfo] = useState({\n  email: \"\",\n  password: \"\",\n  isEmailValid: false,\n  isPasswordValid: false,\n})\n\nconst [message, setMessage] = useState({\n  loginMessage: \"\",\n  registerMessage: \"\",\n  loginSuccess: false,\n  registerSuccess: false,\n})\n\n//수정 후 코드\nconst [loginInfo, setLoginInfo] = useState({\n  email: \"\",\n  password: \"\",\n  isEmailValid: false,\n  isPasswordValid: false,\n})\n\nconst [registerInfo, setRegisterInfo] = useState({\n  email: \"\",\n  password: \"\",\n  isEmailValid: false,\n  isPasswordValid: false,\n})\n\nconst [registerMessage, setRegisterMessage] = useState({\n  registerMessage: \"\",\n  registerSuccess: false,\n})\n\nconst [loginMessage, setLoginMessage] = useState({\n  loginMessage: \"\",\n  loginSuccess: false,\n})\n```\n\n#### 2.3 handleSubmit\n\n예외처리와 함께 각각 다른 api를 불러야 하기 때문에 가장 까다로운 부분이었다. 로그인의 경우 성공할 경우에 \"/todo\"로 연결해주고, 토큰을 저장하는 부분을 추가적으로 갖고 있지만, 그외의 예외처리는 message에 errorMessage를 저장해 UI로 에러를 보여주게 구성했기 때문에 유사했기에 하나의 함수로 수정했다.\n\n예외 검사 부분은 따로 exceptionTest란 함수로 만들었고, api.js에서는 data를 return해주는 부분까지 하는 것으로 수정해 response를 response.json으로 반환하는 부분을 제거했고, 컴포넌트에 전달한 process (\"login\" 또는 \"register\")를 이용해 process가 login일 때만 /todo로 페이지 이동하고 토큰을 저장하게 했다.\n\n수정하고 나니 좀 더 가독성이 좋고, 이후에 예외처리를 수정할 때 좀 더 편하게 할 수 있게 따로 exceptionTest 함수를 만들기 잘했다는 생각이 들었다.\n\n```jsx\n//수정 전 코드\nconst handleLoginSubmit = e => {\n  e.preventDefault()\n  const { email, password } = loginInfo\n  postSignIn({\n    email,\n    password,\n  })\n    .then(response => response.json())\n    .then(data => {\n      let loginMessage = \"\"\n      if (data.statusCode >= 400) {\n        loginMessage = data.message\n        setMessage(prev => {\n          return {\n            ...prev,\n            loginMessage,\n            loginSuccess: false,\n          }\n        })\n        return\n      }\n      navigate(\"/todo\")\n      localStorage.setItem(\"access_token\", data.access_token)\n      setMessage(prev => {\n        return {\n          ...prev,\n          loginMessage: \"로그인에 성공했습니다\",\n          loginSuccess: true,\n        }\n      })\n    })\n}\n\nconst handleRegisterSubmit = e => {\n  e.preventDefault()\n  const { email, password } = registerInfo\n  postSignUp({\n    email,\n    password,\n  })\n    .then(response => response.json())\n    .then(data => {\n      if (data.statusCode >= 400) {\n        setMessage(prev => {\n          return {\n            ...prev,\n            registerMessage: data.message,\n            registerSuccess: false,\n          }\n        })\n        return\n      }\n      setMessage(prev => {\n        return {\n          ...prev,\n          registerMessage: \"회원가입에 성공했습니다\",\n          registerSuccess: true,\n        }\n      })\n    })\n}\n\n//수정 후 코드\n\nconst exceptionTest = (data, setMessage, process) => {\n  if (data.statusCode >= 400) {\n    setMessage(prev => {\n      return {\n        ...prev,\n        message: data.message,\n        success: false,\n      }\n    })\n    return\n  }\n  if (process == \"login\") {\n    navigate(\"/todo\")\n    localStorage.setItem(\"access_token\", data.access_token)\n  }\n  setMessage(prev => {\n    return {\n      ...prev,\n      message: `${\"login\" ? \"로그인\" : \"회원가입\"}에 성공했습니다`,\n      success: true,\n    }\n  })\n}\n\nconst handleSubmit = (info, process, setMessage) => {\n  const { email, password } = info\n  const obj = { email, password }\n  if (process == \"login\") {\n    postSignIn(obj).then(data => {\n      exceptionTest(data, setMessage, process)\n    })\n  } else {\n    postSignUp(obj).then(data => {\n      exceptionTest(data, setMessage, process)\n    })\n  }\n}\n```\n"},{"excerpt":"어제에 이어서 과제를 이어서 해나갔다. 4번째와 5번째는 Todo list를 만드는 것으로 많이 해봐서 쉬울 줄 알았지만 API로 todo를 CRUD하기 때문에 조금 달라 찾아보는데 시간이 걸렸다. Assignment 4) 네 번째 과제의 내용은 다음과 같다.  과제를 스타일링과 API를 연결하는 두 가지 일로 분리해서 작업했다. 1. 스타일링 스타일링을…","fields":{"slug":"/2022-10-06-원티드-프리온보딩-과제-3편/"},"frontmatter":{"date":"October 06, 2022","title":"원티드 프리온보딩 사전과제 3편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n어제에 이어서 과제를 이어서 해나갔다. 4번째와 5번째는 Todo list를 만드는 것으로 많이 해봐서 쉬울 줄 알았지만 API로 todo를 CRUD하기 때문에 조금 달라 찾아보는데 시간이 걸렸다.\n\n## Assignment 4)\n\n네 번째 과제의 내용은 다음과 같다.\n\n![네번째과제](assignment4.png)\n\n과제를 스타일링과 API를 연결하는 두 가지 일로 분리해서 작업했다.\n\n### 1. 스타일링\n\n스타일링을 위해서 우선 의미없지만 API요청으로 받을 투두와 동일한 형식의 state를 만든 후에, TodoItem이라는 component에 prop으로 전달 해주는 형식으로 투두리스트를 구성했다. TodoItem는 다섯 번째 과제 내용 중에 수정 버튼과 제출 취소 버튼이 필요하지만 우선 간단하게 투두 내용과 완료 여부만 보여주게 구성했다.\n\n```jsx\n//Todo.jsx\nfunction Todo() {\n  const inputRef = useRef();\n  const [todos, setTodos] = useState([\n    {\n      id: 1,\n      todo: '과제하기',\n      isCompleted: false,\n      userId: 1,\n    },\n    {\n      id: 2,\n      todo: '과제하기',\n      isCompleted: false,\n      userId: 1,\n    },\n  ]);\n\n  return (\n    <TodoLayout>\n      <header>TO DO</header>\n      <TodoForm onSubmit={onSubmit}>\n        <input\n          ref={inputRef}\n          type='text'\n          id='todoInput'\n          placeholder='오늘의 할 일을 입력해주세요'\n        />\n        <button>Add</button>\n      </TodoForm>\n      <TodoList>\n        {todos.map((todo) => (\n          <TodoItem key={todo.id} {...todo}></TodoItem>\n        ))}\n      </TodoList>\n    </TodoLayout>\n  );\n}\n\nexport default Todo;\n\n//TodoItem.jsx\nfunction TodoItem({ todo, isCompleted, userId }) {\n  return (\n    <TodoLayout>\n      <span>{todo}</span>\n      <button>{isCompleted ? 'Completed🙆‍♀️' : 'Not yet 🙅‍♂️'}</button>\n    </TodoLayout>\n  );\n}\n\nexport default TodoItem;\n\n```\n\n아래 사진은 스타일링을 완료한 모습이다.\n\n![UI 제작 완료](UI제작완료.png)\n\n### 2. API 연결하기\n\nAPI는 createTodo와 getTodos 두 가지를 연결해야 했다. 두 API를 연결하기 위한 형식으로 Authorization이란 부분이 header에 포함되어야 했는데, 오늘 HTTP를 공부했지만 처음 보는 부분이라 [사이월드님의 블로그](https://cyworld.tistory.com/1163)에 올라온 코드를 참고해서 작성했다. API 문서에 Authorization: Bearer access_token이라고 되어있었는데 그냥 토큰을 전달하는 식으로 코드를 짰어서 401 unauthorized 에러가 계속해서 떴다.\n\n![post 에러](post 에러.PNG)\n\n```javascript\nexport function postCreateTodo(todo) {\n  return fetch(`${BASE_URL}/todos`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: \"Bearer \" + localStorage.getItem(\"access_token\"),\n    },\n    body: JSON.stringify({\n      todo,\n    }),\n  })\n}\n```\n\nbearer이란 부분이 생소했는데 알아보니 헤더의 Authorization에는 `<type> <cretential> `형식으로 들어가야 하는데 type에 Bearer로 쓰는게 Scheme,관례와 같다고 한다. ([참고한 블로그](www.ssemi.net/what-is-the-bearer-authentication/))\n\n그래서 Bearer를 그대로 입력한 후에 로컬스토리지에 저장되어 있는 토큰을 전달해주면 API 요청에 성공할 수 있었다.\n\n![요청 성공](요청성공.png)\n\n```javascript\nexport function postCreateTodo(todo) {\n  return fetch(`${BASE_URL}/todos`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n    },\n    body: JSON.stringify({\n      todo,\n    }),\n  })\n}\n\nexport function getTodos() {\n  return fetch(`${BASE_URL}/todos`, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${localStorage.getItem(\"access_token\")}`,\n    },\n  })\n}\n```\n\n어제 작업할 때 app.jsx 에서 token을 state로 갖고 있게 했는데 굳이 그럴 필요 없이 useEffect에서 간단하게 토큰 유무만 체크해도 redirection이 가능했다.\n\n```jsx\nfunction App() {\n  const navigate = useNavigate()\n  useEffect(() => {\n    const token = localStorage.getItem(\"access_token\")\n    if (token) {\n      navigate(\"/todo\")\n    } else {\n      navigate(\"/\")\n    }\n  }, [])\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Login></Login>}></Route>\n      <Route path=\"/todo\" element={<Todo></Todo>}></Route>\n    </Routes>\n  )\n}\n\nexport default App\n```\n\n## Assignment 5)\n\n다섯 번째 과제 내용은 다음과 같다.\n\n![다섯번째 과제](assignment5.png)\n\n네 번째와 마찬가지로 스타일링 수정과 API연결로 나눠서 일을 생각했다. 다른 점이 있었다면 이전에는 API 연결에 필요한 형식을 맞추는 데 어려움이 있었다면 이번에는 스타일링을 수정하는데 어려움이 있었다. 투두 리스트를 처음에 구성할 때 완료여부랑 투두 내용만 보여주면 되었다가, 수정버튼, 수정모드에서 제출과 취소버튼이 추가 되면서 구성을 바꾸는데에 오래걸렸다.\n\n### 1. 스타일링 수정\n\n처음 과제를 이해할 때는 완료여부를 클릭으로 상태를 바꿔주기만 하면 되는 줄 이해해서, 누르기만하면 바뀌게 했지만 다시 과제를 읽어보면서 수정모드에서 바꿀 수 있게 해야했다. 어떻게 구성을 바꿔야할까 고민하다가 수정모드에서 item 내부에 input과 함께 complete와 not yet 두가지 버튼을 모두 보여주고 선택할 수 있게 하는 형식으로 수정하게 되었다.\n\n![수정모드 전](수정모드전.png)\n\n![수정모드 후](수정모드후.png)\n\n```jsx\nfunction TodoItem({\n  todoItem: { isCompleted, userId, id, todo },\n  todoItem,\n  onDelete,\n  onUpdate,\n}) {\n  const inputRef = useRef();\n  const [onModifyMode, setOnModifyMode] = useState(false);\n  const [updated, setUpdated] = useState(todoItem);\n\n...\n\n  return (\n    <TodoLayout>\n      <LeftBox>\n        {!onModifyMode && <div>{todo}</div>}\n        {onModifyMode && (\n          <input placeholder='여기에 작성해주세요' ref={inputRef}></input>\n        )}\n      </LeftBox>\n\n      <RightBox>\n        {!onModifyMode && (\n          <>\n            <TodoBtn>{isCompleted ? 'Completed🙆‍♀️' : 'Not yet 🙅‍♂️'}</TodoBtn>\n            <TodoBtn name='modify' onClick={onClick}>\n              수정하기\n            </TodoBtn>\n          </>\n        )}\n        {onModifyMode && (\n          <div>\n            <CompleteBtn\n              name='complete'\n              clicked={updated.isCompleted}\n              onClick={handleCompleteUpdate}\n            >\n              Completed🙆‍♀️\n            </CompleteBtn>\n            <CompleteBtn\n              name='not yet'\n              clicked={!updated.isCompleted}\n              onClick={handleCompleteUpdate}\n            >\n              Not yet 🙅‍♂️\n            </CompleteBtn>\n          </div>\n        )}\n        {onModifyMode && (\n          <>\n            <TodoBtn name='cancel' onClick={onClick}>\n              취소하기\n            </TodoBtn>\n            <TodoBtn name='submit' onClick={handleSubmit}>\n              제출하기\n            </TodoBtn>\n          </>\n        )}\n        <TodoBtn onClick={handleDelete}>삭제하기</TodoBtn>\n      </RightBox>\n    </TodoLayout>\n  );\n}\n\nexport default TodoItem;\n\n```\n\ninput에 현재 이미 작성되어있던 내용을 담아줄까 고민도 했지만 디테일은 내일 한번 더 고민하면 좋지 않을까 싶어 우선은 그대로 두었다. 수정모드에서 complete여부에 따른 클릭된 모습을 보여주기 위해서 버튼의 배경색을 달리하는 효과를 넣어서 좀 더 직관적으로 이해가 잘 되게 스타일링 했다.\n\n### 2. API 연결하기\n\n​ api를 연결하면서 todo 자체의 상태도 업데이트 해야하기 때문에 둘을 app.jsx에서 같이 처리해야했다. API 연결 작업도 두가지로 나눠서 작업했다.\n\n#### 2.1 삭제 기능추가\n\n삭제와 업데이트 중에서 상대적으로 삭제하는 기능은 쉽게 구성할 수 있었다. API 요구사항이 해당하는 todo의 id만 전달하면 되었기 때문에 간단하게 삭제버튼이 눌러지면 해당 item의 id를 전달하고 todo에서는 filter로 해당 id와 같은 요소를 삭제하고, api로 동일한 id를 전달해 서버에서 삭제해주었다.\n\n![삭제기능추가 요구사항](삭제기능추가.png)\n\n```tsx\n//TodoItem.jsx\nfunction TodoItem({\n  todoItem: { isCompleted, userId, id, todo },\n  todoItem,\n  onDelete,\n  onUpdate,\n}) {\n \t...\n  const handleDelete = () => {\n    onDelete(id);\n  };\n\n\n  return (\n    <TodoLayout>\n      ...\n        {onModifyMode && (\n          <>\n            <TodoBtn name='cancel' onClick={onClick}>\n              취소하기\n            </TodoBtn>\n            <TodoBtn name='submit' onClick={handleSubmit}>\n              제출하기\n            </TodoBtn>\n          </>\n        )}\n        <TodoBtn onClick={handleDelete}>삭제하기</TodoBtn>\n      </RightBox>\n    </TodoLayout>\n  );\n}\n\n//todo.js\n\nfunction Todo() {\n  const inputRef = useRef();\n  const [todos, setTodos] = useState([]);\n\n    ...\n\n  const onDelete = (id) => {\n    setTodos((prev) => prev.filter((todo) => todo.id != id));\n    deleteTodo(id);\n  };\n\n  return (\n    <TodoLayout>\n      <header>TO DO</header>\n      <TodoContent>\n        <TodoForm onSubmit={onSubmit}>\n          <input\n            ref={inputRef}\n            type='text'\n            id='todoInput'\n            placeholder='오늘의 할 일을 입력해주세요'\n          />\n          <button>Add</button>\n        </TodoForm>\n        <TodoList>\n          {todos.map((item) => (\n            <TodoItem\n              key={item.id}\n              todoItem={item}\n              onUpdate={onUpdate}\n              onDelete={onDelete}\n            ></TodoItem>\n          ))}\n        </TodoList>\n      </TodoContent>\n    </TodoLayout>\n  );\n}\n\nexport default Todo;\n\n\n//api.js\nexport function deleteTodo(id) {\n  return fetch(`${BASE_URL}/todos/${id}`, {\n    method: 'DELETE',\n    headers: {\n      Authorization: `Bearer ${localStorage.getItem('access_token')}`,\n    },\n  });\n}\n\n```\n\n이미 네 번째 과제를 하면서 필요한 헤더나 구성을 이해하고 있어서 상대적으로 쉽게 처리해 204 No content 응답을 받았다.\n\n![삭제](삭제.PNG)\n\n#### 2.2 수정기능 추가하기\n\n수정기능을 처리할때, 한번에 complete의 수정된 부분과 input의 내용을 전달하려고 시도했다가 어려움을 겪었다. 수정모드를 on/off하는 버튼은 수정하기와 취소하기 두가지 버튼이 존재하고, 직접 수정하는데 필요한 input의 내용과, complete여부까지, 모두 다 한번에 처리하려니 복잡해지는 게 문제점이었다.\n\n그래서 하나의 함수로 다 하기보다 우선은 일을 분할해서 세가지 step으로 보기로 했고, api에서 body에 id, todo, isCompleted를 모두 전달해야 하기 때문에 수정된 todoItem의 상태를 통째로 전달하는 방식으로 TodoItem 내부에 updated 상태를 추가했다.\n\n1. 수정하기와 취소하기 버튼: onModifyMode를 true와 false로 바꿔줄 수 있게 연결하고 취소하기는 input을 비게만드는 로직을 추가한다.\n2. 완료여부 버튼: 완료여부 두가지 버튼은 버튼 클릭시 updated 상태의 isCompleted를 수정하는 로직을 추가한다.\n3. 제출 버튼: 현재 input에 있는 값을 updated상태의 todo값으로 업데이트하고, updated 전체를 전달한다.\n\nupdate를 위해서 todos에서 전달한 updated 오브젝트의 id와 같은 값의 todo만 mapping 하고 api에서는 obj를 통째로 전달해서 필요한 값만 내부에서 전달하는 형식으로 코드를 구성했다.\n\n```jsx\n//TodoItem.jsx\n\nfunction TodoItem({\n  todoItem: { isCompleted, userId, id, todo },\n  todoItem,\n  onDelete,\n  onUpdate,\n}) {\n  const inputRef = useRef();\n  const [onModifyMode, setOnModifyMode] = useState(false);\n  const [updated, setUpdated] = useState(todoItem);\n\n  const onClick = (e) => {\n    const { name } = e.currentTarget;\n    if (name === 'cancel') {\n      inputRef.current.value = ``;\n    }\n    setOnModifyMode((prev) => !prev);\n  };\n\n\t...\n\n  const handleCompleteUpdate = (e) => {\n    const { name } = e.currentTarget;\n    if (name === 'complete') {\n      setUpdated((prev) => {\n        return { ...prev, isCompleted: true };\n      });\n    } else {\n      setUpdated((prev) => {\n        return { ...prev, isCompleted: false };\n      });\n    }\n  };\n\n  const handleSubmit = () => {\n    onUpdate({ ...updated, todo: inputRef.current.value });\n    inputRef.current.value = ``;\n    setOnModifyMode((prev) => !prev);\n  };\n\n  return (\n    <TodoLayout>\n      <LeftBox>\n        {!onModifyMode && <div>{todo}</div>}\n        {onModifyMode && (\n          <input placeholder='여기에 작성해주세요' ref={inputRef}></input>\n        )}\n      </LeftBox>\n\n      <RightBox>\n        {!onModifyMode && (\n          <>\n            <TodoBtn>{isCompleted ? 'Completed🙆‍♀️' : 'Not yet 🙅‍♂️'}</TodoBtn>\n            <TodoBtn name='modify' onClick={onClick}>\n              수정하기\n            </TodoBtn>\n          </>\n        )}\n        {onModifyMode && (\n          <div>\n            <CompleteBtn\n              name='complete'\n              clicked={updated.isCompleted}\n              onClick={handleCompleteUpdate}\n            >\n              Completed🙆‍♀️\n            </CompleteBtn>\n            <CompleteBtn\n              name='not yet'\n              clicked={!updated.isCompleted}\n              onClick={handleCompleteUpdate}\n            >\n              Not yet 🙅‍♂️\n            </CompleteBtn>\n          </div>\n        )}\n        {onModifyMode && (\n          <>\n            <TodoBtn name='cancel' onClick={onClick}>\n              취소하기\n            </TodoBtn>\n            <TodoBtn name='submit' onClick={handleSubmit}>\n              제출하기\n            </TodoBtn>\n          </>\n        )}\n        <TodoBtn onClick={handleDelete}>삭제하기</TodoBtn>\n      </RightBox>\n    </TodoLayout>\n  );\n}\n\nexport default TodoItem;\n\n//Todo.jsx\n\nfunction Todo() {\n  const [todos, setTodos] = useState([]);\n\n    ...\n\n  const onSubmit = (e) => {\n    e.preventDefault();\n    const value = inputRef.current.value;\n    if (!value) {\n      return;\n    }\n    postCreateTodo(value)\n      .then((res) => res.json())\n      .then((data) => setTodos((prev) => [...prev, data]));\n    inputRef.current.value = '';\n  };\n\n    ...\n\n  const onUpdate = (todo) => {\n    setTodos((prev) =>\n      prev.map((item) => {\n        if (item.id === todo.id) {\n          return todo;\n        }\n        return item;\n      })\n    );\n    updateTodos(todo);\n  };\n\n  return (\n    <TodoLayout>\n      <header>TO DO</header>\n      <TodoContent>\n        <TodoForm onSubmit={onSubmit}>\n          <input\n            ref={inputRef}\n            type='text'\n            id='todoInput'\n            placeholder='오늘의 할 일을 입력해주세요'\n          />\n          <button>Add</button>\n        </TodoForm>\n        <TodoList>\n          {todos.map((item) => (\n            <TodoItem\n              key={item.id}\n              todoItem={item}\n              onUpdate={onUpdate}\n              onDelete={onDelete}\n            ></TodoItem>\n          ))}\n        </TodoList>\n      </TodoContent>\n    </TodoLayout>\n  );\n}\n\nexport default Todo;\n\n\n//api.js\n\nexport function updateTodos(obj) {\n  const { todo, isCompleted } = obj;\n  return fetch(`${BASE_URL}/todos/${obj.id}`, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${localStorage.getItem('access_token')}`,\n    },\n    body: JSON.stringify({\n      todo,\n      isCompleted,\n    }),\n  });\n```\n\n결과는 204 No content로 성공한 결과를 보여주었다. 그리고 userId를 따로 저장해두고 함께 전달해야하나 걱정했지만 토큰만 전달하면 서버에서 이미 알고 있기 때문에 추가적으로 저장할 필요가 없다는 점도 알게 되었다.\n\n![204 응답](204응답.png)\n\n여기까지 총 5가지 과제 내용을 모두 성공적으로 했지만 예외 처리를 할 부분과 회원가입/로그인 페이지의 코드 분리 등 아직 리팩토링이 필요하다고 생각되었다.\n"},{"excerpt":"어제 온보딩 과제를 하면서 API들 사용할 때, 각 메소드들을 이해하지 않고 사용하고 있다는 점이 많이 느껴져 캡틴판교님의 블로그 와 드림코딩의 Node.js 강의 참고해서 한번 정리해보려 한다. HTTP 프로토콜이란 HTTP 프로토콜은 HyperText Transfer Protocol의 약자로 클라이언트와 서버가 서로 통신하는데 필요한 규약/약속을 의미…","fields":{"slug":"/2022-10-06-HTTP란/"},"frontmatter":{"date":"October 06, 2022","title":"HTTP 정리","tags":["네트워크"]},"rawMarkdownBody":"\n어제 온보딩 과제를 하면서 API들 사용할 때, 각 메소드들을 이해하지 않고 사용하고 있다는 점이 많이 느껴져 [**캡틴판교**님의 블로그](https://joshua1988.github.io/web-development/http-part1/) 와 [드림코딩의 Node.js 강의](https://academy.dream-coding.com/courses/node) 참고해서 한번 정리해보려 한다.\n\n## HTTP 프로토콜이란\n\nHTTP 프로토콜은 HyperText Transfer Protocol의 약자로 클라이언트와 서버가 서로 통신하는데 필요한 규약/약속을 의미한다. request와 response의 protocol로, client가 request(요청)를 서버에 보내게 되면 서버는 요청에 맞는 response(응답)을 보내는 과정을 의미한다.\n\n![http](http.png)\n위의 그림을 조금 더 세부적으로 나누어 설명하면 다음과 같이 정리할 수 있다.\n\n1. TCP Connection: 클라이언트와 서버가 데이터를 보내기 전에 서로 연결설정을 하는 과정을 의미한다.\n2. Request: 클라이언트에서 원하는 내용(url,method,header)를 담아서 서버에 요청한다.\n3. Response: 서버에서는 받은 요청에 대해 응답(status Code, 파일들)을 담아서 클라이언트에게 보낸다.\n4. TCP Connection 해제: 모든 요청과 응답이 끝나면 TCP connection을 해제한다.\n\n## HTTP 프로토콜의 특징\n\nHTTP 프로토콜은 stateless한 프로토콜로 요청과 다음 요청과의 연관성을 가지지 않는다는 의미를 가진다. 이번에 요청을 해야 다음요청을 할 수 있는 방식이 아니라, 각각이 다른 요청으로 별개로 처리됨을 의미한다.\n\n## HTTPS와 HTTP의 역사\n\nHTTPS는 HyperText Transfer Protocol Secure의 약자로 HTTP에 암호화가 추가된 방식을 의미한다. HTTP 자체는 암호화가 되지 않기 때문에 도중에 제 3자가 개입해서 통신내용을 읽을 수 있는 보안의 문제가 있었다. 이부분을 해결하기 위해 HTTPS가 나오게 되었고 암호화가 되어 보안관계가 있는 client와 server는 내용을 읽을 수 있지만 제 3자는 읽을 수 없게 되어있다.\n\n구글에 접속한 내 브라우저 창의 주소를 옆을 보면 자물쇠모양을 볼 수 있는데, HTTPS로 접속했다는 의미를 가진다.\n\nHTTP는 현재도 계속해서 개발되고 있는 분야로, 현재 HTTP v3가 개발 진행 중에 있다고 한다.\n\n[사진 출처: 뽀블로그 티스토리](https://bbo-blog.tistory.com/87?category=1004651)\n\n![timeline](timeline.jpeg)\nHTTP v1은 text based로 사람이 읽을 수 있었고, 헤더가 압축이 되지않아 용량이 큰 문제가 있었고, 한번에 하나의 파일만 전송이 가능한 문제들이 있었다. 이를 해결한 게 HTTP v2로 binary based로 사람이 읽을 수 없어 보안이 강화되었고, header의 압축을 통해 용량을 줄일 수 있었고, 여러개의 파일을 전송할 수 있는 muliplexing이 가능하다고 한다. 현재 전세계에서 50%가 넘게 사용하고 있는 게 HTTP v2라고 한다.\n\n## Status Code\n\nStatus code는 클라이언트와 서버간에 요청과 응답을 주고 받을 때 번호로 소통하는 방식으로 각 번호마다의 의미를 가지고 있다. 프론트엔드를 공부하면서 API를 사용하고 예외처리들을 할 때 많이 사용되었던 부분이라 왜 이런 번호가 왔는지 이해가 되었다.\n\n### 1xx\n\n100번대 status 코드는 요청에 대해서 진행상태를 알려준다.\n\n1. 100 continue: 지금까지 응답이 잘 처리되었음\n2. 102 processing: 현재 요청을 처리중\n\n### 2xx\n\n200번대 status 코드는 요청에 대해서 성공했음을 알려준다.\n\n1. 200 OK: 요청이 성공했음을 의미\n2. 201 created: 요청한 데이터를 만들었음을 의미\n3. 204 no content: 요청이 성공했고 응답으로 보내줄 데이터는 없음을 의미\n\n말 자체로는 조금 모호했지만 간단한 상황을 보면, 200은 Get과 같이 요청한 내용들을 받아올 때, 201은 Post와 같이 새로운 데이터를 만들 때, 204는 Delete와 같이 데이터를 삭제할 때의 응답으로 이해할 수 있었다.\n\n### 3xx\n\n300번대 status 코드는 리다이렉션을 의미한다.\n\n1. 301 moved permanently: 요청 데이터가 영구적으로 이동했음을 의미\n2. 302 found: 요청 데이터가 임시적으로 이동했음을 의미\n3. 303 see other: get요청에 대해서 302와 같이 데이터가 임시적으로 이동했음을 의미\n\n4. 307 Temporary Redirect: 요청한 메소드에 대해서 데이터가 임시 이동했음을 의미\n5. 308 Permanent Redirect: 요청한 메소드에 대해서 데이터가 영구 이동했음을 의미\n\n300번대는 아직 한번도 받아본 적이 없어서 조금 생소했다.\n\n### 4xx\n\n1. 400 Bad Request: api나 query 등 client의 요청이 잘못된 경우를 의미\n2. 401 Unauthorized: 로그인의 비밀번호가 틀린 경우와 같이 authentication credentials이 없는 요청에 대한 에러를 의미\n3. 403 Forbidden: 로그인은 했지만 관리자 권한이 필요한 요청과 같이 권한이 없는 것에 대한 에러를 의미\n4. 404 Not found: 원하는 url의 페이지가 없음을 의미\n5. 405 Method not allowed: 해당 method를 사용할 수 없음을 의미\n6. 409 Conflict: 이미 존재하는 데이터와 충돌한 에러를 의미\n\n아마 내가 가장 자주 마주칠 status code가 아닐까, 400번대의 의미를 보고나니 단순한 에러가 아니었고 내가 어떤 부분을 잘못 요청했는지 알려주고 있었음을 알 수 있었다.\n\n### 5xx\n\n1. 500 Internal Server Error: 서버에 문제가 있어서 보낸 요청을 수행할 수 없음을 의미\n2. 502 Bad gateway: 서버와 클라이언트 사이 중간에서 어떻게 처리해야할 지 모를 때를 의미\n3. 503 Service unavailable: 서버를 이용할 수 없음을 이용\n\n## Request Method\n\nurl은 uniform resource locator의 약자로, 우리가 원하는 리소스의 위치를 의미한다. 아래 그림의 url을 분리해서 의미를 해석하면 다음과 같다.\n\n1. https:// : scheme으로 프로토콜의 종류를 의미\n\n2. www.example.com: domain 주소\n\n3. :80: 포트번호를 의미(브라우저에서 생략 가능)\n\n4. /path/to/myfile.html: 원하는 파일의 경로\n\n5. ?key1=value1&key2=value2: query로 원하는 세부 정보를 의미\n\n![full URL](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL/mdn-url-all.png)\n\nurl을 이용해서 요청을 보낼때 어떤 action을 해달라고 할지를 보내는게 바로 **Method**이다. Method에도 다양한 종류가 존재하는데 그중에서 가장 대표적인 4가지만 정리하고자한다.\n\n### 1. Get\n\nget은 **url의 자료를 받아오기 원할 때** 사용하며, 성공시 200 OK status code를, 실패시에는 401 Unauthorized, 403 Forbidden, 404 Not found와 같은 에러를 받을 수 있다.\n\n사용 예\n\n```javascript\nasync getTodos(username) {\n    const query = username ? `?username=${username}` : '';\n    const response = await fetch(`${this.baseUrl}/todos${query}`, {\n      method: 'GET',\n    });\n    const data = await response.json();\n    if (response.status !== 200) {\n      throw new Error(data.message);\n    }\n    return data;\n  }\n```\n\n### 2. POST\n\npost는 url 위치에 함께 보내는 body나 form data를 함께 전달해 **데이터를 생성할 때 사용**하며, 성공시 201 Created를 실패시에 401 Unauthorized, 403 Forbidden, 404 Not found, 409 Confilct와 같은 에러를 받을 수 있다.\n\n사용 예)\n\n```javascript\n async postTodo(text) {\n    const todo = {\n      name: 'Choi',\n      username: 'choi',\n      text,\n    };\n    const response = await fetch(`${this.baseUrl}/todos`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json', // fetch 사용시 꼭 담아주기\n      },\n      body: JSON.stringify(tweet), // body에 담을때는 꼭 JSON으로 직렬화하기\n    });\n    const data = await response.json();\n    return data;\n  }\n```\n\n### 3. PUT\n\nput은 url 위치의 **데이터를 수정할 때 사용**하며, 성공시 200 OK을, 실패시 403 Forbidden, 404 Not found, 405 Method not allowed와 같은 에러를 받을 수 있다.\n\n사용 예)\n\n```javascript\n async updateTodo(todoId, text) {\n    const response = await fetch(`${this.baseUrl}/todo/${tweetId}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ text }),\n    });\n    const data = await response.json();\n    if (response.status !== 200) {\n      throw new Error(data.message);\n    }\n    return data;\n  }\n```\n\n### 4. DELETE\n\ndelete는 url위치의 **데이터를 삭제할 때 사용**하며, 성공시 204 No content를, 실패시 403 Forbidden, 404 Not found, 405 Method not allowed와 같은 에러를 받을 수 있다.\n\n사용 예)\n\n```javascript\nasync deleteTodo(tweetId) {\n    const response = fetch(`${this.baseUrl}/todos/${tweetId}`, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (response.status !== 204) {\n      throw new Error();\n    }\n  }\n```\n\n위 4가지를 함께 CRUD(Create,Read,Update,Delete)라고도 부르는 대표적인 요청으로 꼭 기억하고 있어야할 부분이다. 이외에도 HEAD나 PATCH와 같은 Method가 있지만 나올 때마다 조금씩 정리해 나가려한다.\n\n[참조]\n\n- [캡틴판교님 블로그 HTTP 통신과정](https://joshua1988.github.io/web-development/http-part1/)\n"},{"excerpt":"Assignment 2) 어제에 이어 API 에러를 해결하기 위해 다시 시도했지만 여전히 같은 에러가 보였다. 뭐가 잘못된건지 다시 한번 확인하러 안내페이지에 다시갔더니....  API 주소가 바뀌어 있었다....ㅜㅜㅜㅜ 어제 안된건 내가 잘못 입력한 게 아니라 진짜 서버가 꺼져있었거나, 주소를 잘못 제공받았던건가 보다...  API주소가 처음부터 맞게 …","fields":{"slug":"/2022-10-05-원티드-프리온보딩-과제-2편/"},"frontmatter":{"date":"October 05, 2022","title":"원티드 프리온보딩 사전과제 2편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n## Assignment 2)\n\n어제에 이어 API 에러를 해결하기 위해 다시 시도했지만 여전히 같은 에러가 보였다. 뭐가 잘못된건지 다시 한번 확인하러 안내페이지에 다시갔더니....\n\n![바뀐 API 주소](바뀐API.png)\n\nAPI 주소가 바뀌어 있었다....ㅜㅜㅜㅜ 어제 안된건 내가 잘못 입력한 게 아니라 진짜 서버가 꺼져있었거나, 주소를 잘못 제공받았던건가 보다...\n\n![회원가입에 성공한 API결과](성공API.png)\n\nAPI주소가 처음부터 맞게 제공되었다면 좋았겠지만, 이번 경험을 통해서 내가 너무 **REST API나 HTTP통신을 잘모르구나**를 많이 느꼈다. 우선 과제를 2번과 3번을 마무리하고, HTTP서버 통신, 토큰, 쿠키, JWT등 서버 통신을 한번 정리할 필요를 느꼈다.\n\nAPI를 이제 사용할 수 있으니 각각 submit에 연결만 하면 쉽게 연결할 수 있었다. 위에 받아온 response를 이용해 로직을 작성했다. 과제 안내에 axios를 쓸 수 있다고 했지만 우선은 fetch만을 이용해서 작성한 후에 axios로 코드를 수정해보려고 계획했다.\n\n```javscript\n//api.js\nconst BASE_URL = 'https://pre-onboarding-selection-task.shop/';\n\nexport function postSignUp(data) {\n  const { email, password } = data;\n  return fetch(`${BASE_URL}auth/signup`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      email,\n      password,\n    }),\n  });\n}\n\nexport function postSignIn(data) {\n  const { email, password } = data;\n  return fetch(`${BASE_URL}auth/signin`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      email,\n      password,\n    }),\n  });\n}\n\n```\n\napi.js를 보면 url만 다르고 너무 동일한 게 보여서 코드 중복을 줄일 방법에 대해 고민하는 것도 너무 좋은 공부가 될 것 같다.\n\n```javascript\n//login.jsx\n...\n\n  const [message, setMessage] = useState({\n    loginMessage: '',\n    registerMessage: '',\n    loginSuccess: false,\n    registerSuccess: false,\n  });\n\n  const handleLoginSubmit = (e) => {\n    e.preventDefault();\n    const { email, password } = loginInfo;\n    postSignIn({\n      email,\n      password,\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        let loginMessage = '';\n        if (data.statusCode >= 400) {\n          loginMessage = data.message;\n          setMessage((prev) => {\n            return {\n              ...prev,\n              loginMessage,\n              loginSuccess: false,\n            };\n          });\n          return;\n        }\n        navigate('/todo');\n        localStorage.setItem('loginToken', data.access_token);\n        setMessage((prev) => {\n          return {\n            ...prev,\n            loginMessage: '로그인에 성공했습니다',\n            loginSuccess: true,\n          };\n        });\n      });\n  };\n\n  const handleRegisterSubmit = (e) => {\n    e.preventDefault();\n    const { email, password } = registerInfo;\n    postSignUp({\n      email,\n      password,\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (data.statusCode >= 400) {\n          setMessage((prev) => {\n            return {\n              ...prev,\n              registerMessage: data.message,\n              registerSuccess: false,\n            };\n          });\n          return;\n        }\n        setMessage((prev) => {\n          return {\n            ...prev,\n            registerMessage: '회원가입에 성공했습니다',\n            registerSuccess: true,\n          };\n        });\n      });\n  };\n\n```\n\nfetch를 이용해 코딩했기 때문에 에러처리를 catch를 사용해도 해결하지 못했다. 우선은 예외처리를 response에서 처리하려 했지만 response에서 처리할 경우에 서버에서 보내 준 에러 메시지를 이용하지 못했다. 그래서 data를 json으로 바꿔서 받아와 data에서 statusCode에 따라 400번 이상의 에러는 로그인과 회원가입 창에 해당 에러 메시지를 보여 주는 식으로 구성했다. 에러에 따라 달라지는 메시지를 담을 수 있게 message 상태를 추가했고 로그인과 회원가입이 성공했는가에 따라 메시지 보여주는 곳의 색깔을 다르게 전달해주기 위해 각각 success에 관한 내용도 message 상태에 포함시켰다.\n\n![에러핸들링](에러핸들링.png)\n\n로그인은 **이미 존재하는 이메일일 경우 400에러**를 보내줬고, 회원가입는 **존재하지 않는 이메일 경우에 404 not found에러**를, **이메일에 맞지 않는 비밀번호를 보낼 시에는 401 unauthorized 에러**를 보내주는 걸 확인했다. 로그인의 경우 401과 404에 따라 다른 메시지가 이미 서버로부터 받아오기 때문에, 바로 에러 메시지에 보여줄 수 있게 코드를 구성했다.\n\n회원가입과 로그인 모두 성공할 경우에는 하얀색으로 성공했다고 보일 수 있게 했고, 로그인은 과제안내에서 성공시 받아오는 JWT 토큰을 로컬스토리지에 저장해달라 했기 때문에 로컬스토리지에 \"loginToken\"이라는 키로 저장했다. 저장후에는 useNavigate를 이용해 \"/todo\"로 페이지이동을 추가했다.\n\n## Assignment 3)\n\n세번째 과제는 다음과 같다.\n\n![세번쨰 과제](assignment3.png)\n\n전체적인 페이지 이동을 위해서 app.jsx에서 token의 유무에 따라 이동시켜주는 게 좋을 것 같아 useEffect로 코드를 짰다. 토큰을 \"loginToken\" key로 불러온 후에 존재한다면 token 상태에 저장한 후에 존재 유무에 따라 해당 url로 이동시켜주었다.\n\n```javascript\n//App.jsx\n\nconst navigate = useNavigate()\nconst [token, setToken] = useState(\"\")\nuseEffect(() => {\n  const prevToken = localStorage.getItem(\"loginToken\")\n  prevToken && setToken(prevToken)\n  if (token) {\n    navigate(\"/todo\")\n  } else {\n    navigate(\"/\")\n  }\n}, [token])\n```\n\n생각보다 간단했지만, 회원가입과 로그인 부분에서 겹치는 부분과 분리가 필요해보여서 내일 4번과 5번 과제까지 마무리 한 후에 컴포넌트화 해볼 예정이다.\n"},{"excerpt":"기다리던 프론트엔드 원티드 프리온보딩이 열렸다. 이번주는 프리온보딩 사전과제를 수행하면서 겪은 시행착오에 대해서 정리해 보려한다. Assignment 1) 과제 첫번째는 다음과 같은 조건이다.  로그인/ 회원가입을 페이지를 만들고 유효성 검사를 진행하는데 간단하게 이메일은 @을, 비밀번호는 8자 이상이면 되는 조건이라 간단하게 할 줄 알았지만 예상치 못한…","fields":{"slug":"/2022-10-04-원티드-프리온보딩-과제-1편/"},"frontmatter":{"date":"October 04, 2022","title":"원티드 프리온보딩 사전과제 1편","tags":["원티드프리온보딩"]},"rawMarkdownBody":"\n기다리던 프론트엔드 원티드 프리온보딩이 열렸다. 이번주는 프리온보딩 사전과제를 수행하면서 겪은 시행착오에 대해서 정리해 보려한다.\n\n## Assignment 1)\n\n과제 첫번째는 다음과 같은 조건이다.\n\n![첫번째 과제](assignment1.png)\n\n로그인/ 회원가입을 페이지를 만들고 유효성 검사를 진행하는데 간단하게 이메일은 @을, 비밀번호는 8자 이상이면 되는 조건이라 간단하게 할 줄 알았지만 예상치 못한 곳에서 에러를 만났다...\n\n```javascript\nconst [loginInfo, setLoginInfo] = useState({\n  email: \"\",\n  password: \"\",\n  isEmailValid: false,\n  isPasswordValid: false,\n})\n\nconst regex = /.{8}/g\n\nconst handleLoginChange = e => {\n  const { name, value } = e.currentTarget\n  setLoginInfo(prev => {\n    return {\n      ...prev,\n      [name]: value,\n      isEmailValid: name == \"email\" ? value.includes(\"@\") : prev.isEmailValid,\n      isPasswordValid:\n        name == \"password\" ? regex.test(value) : prev.isPasswordValid,\n    }\n  })\n}\n```\n\n위와 같이 로그인과 관련된 상태를 만들어서 내부에 4가지 내용을 담았다. 여기서 이해가 안된 부분은 마지막 비밀번호 유효성 검사 부분이었다. 유효성 검사에서 8자이상이 되어도 계속해서 False가 나왔다. setState의 비동기성 때문에 생긴 문제라 하기에는 함수형으로 업데이트 해주기에 문제점으로 보이지 않았고, 자세히 보기위해서 콘솔에 입력해보았다니 다음과 같은 결과가 나왔다.\n\n![화면](화면.PNG)\n\ntrue랑 false가 동시에 나오는 이해가 안되는 상황이었다... 우선은 다음 과제를 위해서 정규표현식을 사용하지 않고 비밀번호로 받은 문자열의 길이가 8이상인지 체크하는 것으로 바꿨다.\n\n## Assignment 2)\n\n두 번째 과제는 다음과 같은 조건이다.\n\n![두번째과제](assignment2.png)\n\n원티드에서 제공하는 API를 이용해 로그인과 회원가입 로직을 연결시키는 부분이었다. 3시간 정도 검색하고 확인해도 이유를 찾을 수 없이 에러가 났다. 분명 내가 잘못된 정보를 주거나 했다면 4xx번대 에러가 나와야하는데 그것도 없이 그냥 거절당했다...\n\n찾아보니 서버 자체가 구동하지 않거나 주소가 아예 잘못된 경우 이런 에러가 나타날 수 있다고 하는데 원티드에서 잘못된 주소를 준건지... 우선은 내일 다시 시도해 보기로 했다.\n\n![error](error.png)\n"},{"excerpt":"대부분의 기능은 어제 완료했기에 전체적으로 돌아보면서 반응형 적용과 성능 최적화에 포커스를 두고 작업했다. 1) 반응형 적용 항상 반응형으로 만들 때 느끼는 점이지만 처음 기획을 할 때, 모바일 버전을 고려하지 않으면 브라우저 버전에서 생각했던 기능을 아예 빼버려야 할 때도 생긴다. 이번에 만들 때는, 처음부터 모바일 버전을 많이 생각하고 기획해서 조금 …","fields":{"slug":"/2022-10-03-포트폴리오-제작-3편/"},"frontmatter":{"date":"October 03, 2022","title":"포트폴리오 제작-반응형,배포까지","tags":["포트폴리오"]},"rawMarkdownBody":"\n대부분의 기능은 어제 완료했기에 전체적으로 돌아보면서 반응형 적용과 성능 최적화에 포커스를 두고 작업했다.\n\n## 1) 반응형 적용\n\n항상 반응형으로 만들 때 느끼는 점이지만 처음 기획을 할 때, 모바일 버전을 고려하지 않으면 브라우저 버전에서 생각했던 기능을 아예 빼버려야 할 때도 생긴다. 이번에 만들 때는, 처음부터 모바일 버전을 많이 생각하고 기획해서 조금 더 편하게 모바일 버전을 만들 수 있었다.\n\n전체적으로 모바일 기준을 788px으로 맞춰서 반응형을 주었고 좀 더 세부적으로 나눌 필요가 있을 때는 1000px을 추가적으로 기준으로 잡았다.\n\n### 1.1 Home\n\nHome 페이지는 간단하게 버튼의 크기와 폰트 사이즈만 줄여주었다.\n\n[Home 페이지 모바일 버전(좌) 데스크탑 버전(우)]\n\n![home](1.png)\n\n### 1.2 Main 페이지\n\n메인 페이지는 전체적으로 손을 봐야 할 부분이 많았다. preview 박스들의 크기들을 조정하고, navbar의 폰트사이즈도 줄였다. 특히 preview 박스들의 애니메이션을 고민했는데 원래는 아예 세로로 flex 축을 바꿀려 했지만 그렇게 하기보다 축을 유지하고, 커서를 올리면 책을 뽑듯이 해당 preview박스만 살짝 올라가게 설정했다.\n\n[main 페이지 모바일 버전(좌) 데스크탑 버전(우)]\n\n![main](./main.png)\n\n### 1.3 Section\n\n각 섹션들은 모바일 버전을 생각하고 leftBox와 rightBox을 flex박스안에 넣어두었어서, 간단하게 flex 축을 세로로 바꿔 반응형을 적용했다.\n\n[About me 모바일 버전(좌) 데스크탑 버전(우)]\n\n![about](./about.png)\n\n[Skills 모바일 버전(좌) 데스크탑 버전(우)]\n\n![skills](./skills.png)\n\n[Projects 모바일 버전(좌) 데스크탑 버전(우)]\n\n![projects](./projects.png)\n\n[Contact 모바일 버전(좌) 데스크탑 버전(우)]\n\n![contact](./contact.png)\n\n반응형을 적용하면서 어색하거나 조금 안 맞는 스타일링들은 다시 수정해나갔다.\n\n### 2) 성능 최적화\n\n성능을 위해서, 불필요하게 다시 랜더링되는 부분을 체크했다. Overlay의 취소 버튼, header와 navbar, 그리고 projects의 각 item들이 불 필요하게 re-rendering되는 것을 확인했고 memo를 이용해서 성능을 최적화했다. 정적인 페이지라 useCallback이나 특별히 더 렌더링할 부분이 없어서 간단하게 작업했다.\n\n### 3) 배포\n\n배포는 Gatsby를 공부하기 전에 우선 netlify를 이용해서 배포해두기로 했다. netlify에 배포하기 위해서 먼저 npm run build로 build 폴더를 만든 후에 netlify deploy를 이용해 간단하게 배포했다.\n\n### 마치며\n\n디자인, 추가 내용들, 사진들, 데모 영상 등 아직 수정해 나가야 할 게 많아 보이지만 그래도 기한 내에 어느 정도 구성을 마쳐서 다행이었다. 원티드 이벤트에 기다리던 원티드 프론트엔드 온보딩 코스가 떠서 내일부터는 준비해나갈 생각이다. 계속 달리자.\n"},{"excerpt":"어제에 이어 포트폴리오 Main화면을 완성했다. 4가지 섹션중에서 Projects만 남았었고, Home화면만 추가해주면 기획했던 모든 부분을 완성하기에 오늘 안에 최대한 마무리 해보려 했다. 1) Projects 페이지 제작 Projects는 슬라이더를 통해 프로젝트에 대한 설명과 사진을 보여주게 디자인했었다. 슬라이더 기능을 위해서는 총 3가지 로직이 …","fields":{"slug":"/2022-10-02-포트폴리오-제작-2편/"},"frontmatter":{"date":"September 29, 2022","title":"포트폴리오 제작-슬라이더, 페이지전환 애니메이션","tags":["포트폴리오"]},"rawMarkdownBody":"\n어제에 이어 포트폴리오 Main화면을 완성했다. 4가지 섹션중에서 Projects만 남았었고, Home화면만 추가해주면 기획했던 모든 부분을 완성하기에 오늘 안에 최대한 마무리 해보려 했다.\n\n## 1) Projects 페이지 제작\n\nProjects는 슬라이더를 통해 프로젝트에 대한 설명과 사진을 보여주게 디자인했었다. 슬라이더 기능을 위해서는 총 3가지 로직이 필요했다.\n\n1. useEffect를 통해서 local의 json의 내용들을 불러와 전체 프로젝트에 넣어주기\n2. 받아온 전체 프로젝트를 SliderItem에 mapping하기\n3. 현재 보여주고 있는 프로젝트를 상태로 저장하고 왼쪽 오른쪽 버튼에 따라 업데이트 해주기\n\n### 1.1 Local json 불러오기\n\nLocal의 json파일의 데이터를 불러오는 것은 크게 어렵지 않았다. 하지만 데이터 자체를 컴포넌트에 전달해줄 때, 이미지의 주소나 텍스트 내용들을 내가 생각한 형식에 맞게 전달하는데 시간이 오래 걸렸다.\n\n이미지 주소 문제는 어제 src파일로 img폴더를 옮겨 해결했다고 생각했었지만, 이미지의 주소 값을 json으로 불러와 prop으로 전달해주면서 import로 이미지를 전달하던 방식을 사용할 수 없었다. 그래서 **public으로 img폴더를 옮겨** 해결했다. 이 부분은 블로그( [chacha912.log](https://velog.io/@rimo09/React-Create-react-app-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-4%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95) )를 다시 보면서 수정했다.\n\n코드 중복을 줄이기 위해 **SliderItem** 컴포넌트를 만들어서 json으로 불러온 projects 배열을 mapping하는 방법으로 코드를 구성했다. prop으로 데이터만 잘 전달해주면 될 것 같았지만 **description**부분이 줄바꿈도 깨지고 원래 형식이 지켜지지 않았다.`(백틱)으로 문자열을 json에 저장하면 줄바꿈이 유지될 것 같아 시도해봤지만 json자체에 에러가 발생했고, 따옴표 밖에 사용할 수 없었다. 한줄로 description에 적절하게 **\"\\\\n\" (줄바꿈)**을 넣어서 구분해주었다.\n\n줄바꿈하고 나면 형식이 지켜져서 나올 거라 생각했지만 p태그로 감싸져 있어서 형식이 지켜지지 않아 **`<pre>`태그**로 바꾸었더니 내가 생각했던 대로 전달된 것을 볼 수 있었다.\n\n```jsx\n\n//projects.json\n{\n  \"projects\": [\n    {\n      \"id\": 0,\n      \"src\": \"/img/iphone-200521-195335.webp\",\n      \"title\": \"지스트 청원서비스\",\n      \"url\": \"https://www.gist-petition.com\",\n      \"stacks\": [\"react\", \"typescript\", \"redux\", \"javascript\"],\n      \"description\": \" 지스트 청원서비스는~\n    },\n   ...\n}\n\n//SliderItem\nfunction SliderItem({ src, title, url, stacks, description, length }) {\n  return (\n    <SliderLayout width={`${100 / length}%`}>\n      <SliderContainer>\n        <PreviewBox>\n          <img src={src} alt='project' />\n        </PreviewBox>\n        <TextBox>\n          <h1>{title}</h1>\n          <a href={url}>홈페이지: {url}</a>\n          <IconList>\n            <h3>Stack: </h3>\n            {stacks.find((item) => item == 'javascript') && (\n              <i className='fa-brands fa-square-js'></i>\n            )}\n            {stacks.find((item) => item == 'react') && (\n              <i className='fa-brands fa-react'></i>\n            )}\n            {stacks.find((item) => item == 'redux') && <SiRedux />}\n            {stacks.find((item) => item == 'typescript') && <SiTypescript />}\n            {stacks.find((item) => item == 'firebase') && <SiFirebase />}\n          </IconList>\n          <pre>{description}</pre>\n        </TextBox>\n      </SliderContainer>\n    </SliderLayout>\n  );\n}\n\nexport default SliderItem;\n```\n\n## 1.2 슬라이더 제작\n\n슬라이더를 **framer motion**을 이용하면 크게 어려움 없이 만들 수 있었지만 리액트로 만들어본 적이 없어서, 자체적으로 만들어보았다. 처음에 json으로 받아온 프로젝트 배열의 아이템 중 현재 보여주고 있는 상태, **Showing의 id** 와 같은 프로젝트만 불러와 보여주게 코드를 구성했다. 자연스럽게 버튼에 showing의 값을 올리고 내리면서 보여 줄 프로젝트를 업데이트 할 수는 있었지만 보여주고 있는 프로젝트 외에는 렌더링 트리에 없기 때문에 애니메이션을 적용할 수 없겠다는 생각이 들어 수정이 필요했다.\n\n애니메이션을 위해서는 우선 배열을 전부 mapping해준 후에 css로 안 보이게 수정해 주어야 했다. 이를 위해서 전체 컨테이너의 다음과 같은 계산이 필요했다.\n\n1. 프로젝트 배열의 길이를 n으로 두면, SliderContainer의 길이는 (`100*n%`) 으로 둔다.\n\n2. 프로젝트 컴포넌트의 길이는 sliderContainer의 길이/n (`100/n%`) 으로 둔다.\n\n3. SliderContainer을 컴포넌트 길이 만큼 프로젝트 번호에 따라 (`-100/n%*프로젝트id`) 좌우로 이동시킨다.\n\n부모 컨테이너의 크기를 이어서 받으면 좀 더 반응형에도 유리할 것 같아 %단위로 스타일링을 했다.\n\n[SliderContainer계산된 스타일링 화면]\n\n![slider1](slider1.png)\n[SliderItem의 계산된 스타일링 화면]\n\n![slider2](slider2.png)\nstyled-components는 props를 편리하게 전달할 수 있기 때문에 보여주고 있는 project의 id와 와 SliderItem의 길이를 전달해 간단하게 애니메이션이 가능했다.\n\n```jsx\nconst SliderContainer = styled.div`\n  width: ${props => props.length};\n  height: 100%;\n  transition: all 300ms ease;\n  transform: ${props => `translateX(${props.showing * -props.unit}%)`};\n  display: flex;\n`\n\nfunction Projects(props) {\n  const [projects, setProjects] = useState([])\n  const [showing, setShowing] = useState(0)\n  useEffect(() => {\n    setProjects(projectsJson.projects)\n  }, [])\n  const setNextItem = () => {\n    setShowing(prev => (prev + 1 === projects.length ? prev : prev + 1))\n  }\n  const setPrevItem = () => {\n    setShowing(prev => (prev - 1 < 0 ? 0 : prev - 1))\n  }\n  return (\n    <ProjectsLayout>\n      <Slider>\n        {showing != 0 && (\n          <LeftArr onClick={setPrevItem}>\n            <i className=\"fa-solid fa-arrow-left\"></i>\n          </LeftArr>\n        )}\n        <SliderList>\n          <SliderContainer\n            showing={showing}\n            unit={100 / projects.length}\n            length={`${projects.length * 100}%`}\n          >\n            {projects &&\n              projects.map(project => {\n                return (\n                  <SliderItem\n                    key={project.title}\n                    {...project}\n                    length={projects.length}\n                  ></SliderItem>\n                )\n              })}\n          </SliderContainer>\n        </SliderList>\n        {showing !== projects.length - 1 && (\n          <RightArr onClick={setNextItem}>\n            <i className=\"fa-solid fa-arrow-right\"></i>\n          </RightArr>\n        )}\n      </Slider>\n    </ProjectsLayout>\n  )\n}\n\nexport default Projects\n```\n\n​\n\n리액트로 슬라이더를 만들어본 적은 없지만, 자바스크립트로 투두리스트 사이트를 만들면서 해본적이 있어 보다 쉽게 만들 수 있었다. 역시 경험의 중요성...\n\n[완성된 프로젝트페이지 화면]\n\n![프로젝트](프로젝트.png)\n\n## 2) Home 페이지\n\nHome 페이지 디자인은 Typeit을 이용해 심플하게 문장을 보여주고, 버튼을 보여주고 클릭시 Main페이지로 페이지 이동하게 구성해보았다.\n\n### 2.1 Typeit 이용하기\n\n[TypeIt 공식사이트](https://www.typeitjs.com/)\n\n![typeit](typeit.png)\nTypeIt은 텍스트 애니메이션 자바스크립트 라이브러리로 이번 프로젝트를 하면서 처음 사용해보았지만 문서 정리가 잘 되어 있어서, 상당히 쉽게 사용이 가능했다. 먼저 라이브러리를 yarn을 이용해 다운을 받은 이후에 다음과 같은 컴포넌트를 만들어서 사용하면 끝이었다.\n\n```javascript\n<TypeIt\n  getBeforeInit={instance => {\n    instance\n      .options({ speed: 80 })\n      .type(`Hi, `)\n      .pause(500)\n      .type(`I'm <Strong>Youngjun Choi</strong>`)\n      .pause(1000)\n      .type(`, who is Front-end developer.`)\n      .pause(2000)\n      .delete(20, { speed: 500 })\n      .pause(500)\n      .type(`Coding the Dreams.`)\n      .pause(1000)\n      .type(`</br></br><span class=\"btn\"> Please Click the button</span>`)\n      .exec(() => {\n        setTimeout(() => {\n          setIsDone(true)\n        }, 1000)\n      })\n    // Remember to return it!\n    return instance\n  }}\n/>\n```\n\n1. type( ) : 기본적으로 span 태그 안에 어떤 문장을 적을 건지, strong, br태그와 같이 다양한 태그들에 클래스, id들을 전달해 줄 수 있다.\n\n2. pause ( ) : 현재 커서에서 몇ms동안 멈출건지 정할 수 있다.\n\n3. delete ( ) : 현재커서에서 어디까지 제거 할지 전달할 수 있다.\n\n4. exec ( ) : 콜백 함수를 전달해 수행한다.\n\n타이핑이 끝난 이후에 버튼이 보여지면 좋겠다고 생각해서 콜백함수를 전달해서 isDone의 상태를 업데이트하는 방식으로 코드를 구성했다.\n\n### 2.2 핸드폰 잠금 형식의 버튼 만들기\n\nFramer-motion을 공부하면서 핸드폰 잠금 방식의 버튼을 이용하면 재밌겠다 생각해 추가하게 되었다. 코드는 너무 간단히 motion 컴포넌트에 layout을 전달한 후에 부모 컴포넌트의 justify-content만 변경하면 간단하게 구현할 수 있었다. 클릭된 버튼으로 main페이지로 이동할 수 있게 useNavigate를 버튼에 onClick 이벤트 핸들러에 전달했다.\n\n```jsx\nconst Button = styled(motion.button)`\n  display: flex;\n  justify-content: ${props => props.on};\n  align-items: center;\n`\n\nfunction Home(props) {\n  const [isDone, setIsDone] = useState(false)\n  const [isOn, setIsOn] = useState(false)\n  const navigate = useNavigate()\n  const onClick = () => {\n    setIsOn(true)\n    setTimeout(() => {\n      navigate(\"/main\")\n    }, 1500)\n  }\n  return (\n    <HomeLayout\n      variants={pageVariant}\n      initial=\"invisible\"\n      animate=\"visible\"\n      exit=\"exit\"\n    >\n      ...\n      {isDone && (\n        <Button on={isOn ? \"flex-end\" : \"flex-start\"} onClick={onClick}>\n          <motion.div layout></motion.div>\n        </Button>\n      )}\n    </HomeLayout>\n  )\n}\n```\n\n[Home 페이지]\n\n![home](home.png)\n\n### 2.3 화면 전환 애니메이션 추가\n\n화면이 자연스럽게 넘어가는 효과를 위해서 Framer-motion을 이용해서 App.jsx에 AnimatePresence를 추가한 후, 각 페이지 전체 container Component에 variant를 전달했다.\n\n```jsx\n//app.jsx\nfunction App() {\n  return (\n    <AnimatePresence>\n      <Routes >\n        <Route path='/' element={<Home></Home>}></Route>\n        <Route path='/main' element={<Main></Main>}></Route>\n      </Routes>\n    </AnimatePresence>\n  );\n}\n\nexport default App;\n\n//home.jsx\n\nfunction Home(props) {\n\t...\n  return (\n    <HomeLayout\n      variants={pageVariant}\n      initial='invisible'\n      animate='visible'\n      exit='exit'\n    >\n    ...\n    </HomeLayout>\n  );\n}\n\nexport default Home;\n\n//main.jsx\n\nfunction Main(props) {\n\t...\n  return (\n    <MainLayout\n      variants={pageVariant}\n      initial='invisible'\n      animate='visible'\n      exit='exit'\n    >\n    ...\n    </MainLayout>\n  );\n}\n\nexport default Main;\n\n\n\n\n\n```\n\n하지만 내 생각대로 애니메이션이 적용되지 않았고, 이를 해결하기 위해 https://www.youtube.com/watch?v=pTinipkJBcs 영상을 참고했다.\n\n영상에서 설명은 페이지 이동시 AnimatePresence가 작동하려면 이동하는 페이지의 url을 전달해서 전 component와 다른 component라고 알려 주어야 한다고 한다. **uselocation**을 이용해서 key로 useloaction.pathName을, location에는 선언한 useLoaction을 그대로 전달해서 해결할 수 있었다.\n\n```jsx\nfunction App() {\n  const location = useLocation()\n  return (\n    <AnimatePresence>\n      <Routes key={location.pathname} location={location}>\n        <Route path=\"/\" element={<Home></Home>}></Route>\n        <Route path=\"/main\" element={<Main></Main>}></Route>\n      </Routes>\n    </AnimatePresence>\n  )\n}\n\nexport default App\n```\n\n### 마치며\n\n우선 기획하고 디자인했던 부분들은 다 완성했지만, 디자인에는 수정이 조금 더 필요해 보인다. 계속해서 관심을 가지고 업데이트해야 할 것 같다는 생각과 배포를 할 때 Gatsby를 공부하고 적용해보면 좋겠다는 생각이 들었다.\n"},{"excerpt":"1) Navbar & Card 와 상태 연결 어제 했던 기획에 이어 추가적으로 상태와 상태에 따른 버튼 로직을 연결해주었다. 간단하게 main에 selectedSection이란 상태를 만들고 setSelectedSection으로 클릭된 버튼이나 카드에 따라 상태를 변경 해주는 로직이다. 간단하게 추가한 로직이지만 조금 의문이 들었던 점은 Javascrip…","fields":{"slug":"/2022-10-01-포트폴리오-제작-1편/"},"frontmatter":{"date":"September 29, 2022","title":"포트폴리오 제작-메인 페이지 제작","tags":["포트폴리오"]},"rawMarkdownBody":"\n## 1) Navbar & Card 와 상태 연결\n\n어제 했던 기획에 이어 추가적으로 상태와 상태에 따른 버튼 로직을 연결해주었다. 간단하게 main에 selectedSection이란 상태를 만들고 setSelectedSection으로 클릭된 버튼이나 카드에 따라 상태를 변경 해주는 로직이다.\n\n```javascript\nfunction Main(props) {\n  const [selectedSection, setSelectedSection] = useState(null)\n  const onClick = event => {\n    const {\n      dataset: { section },\n    } = event.currentTarget\n    console.log(section)\n    setSelectedSection(section)\n  }\n  return (\n    <MainLayout>\n      <Header></Header>\n      <List>\n        <SectionBox data-section={\"About me\"} onClick={onClick}>\n          <AboutPreview></AboutPreview>\n        </SectionBox>\n        <SectionBox data-section=\"Skills\" onClick={onClick}>\n          <SkillsPreview />\n        </SectionBox>\n        <SectionBox data-section=\"Projects\" onClick={onClick}>\n          <ProjectsPreview></ProjectsPreview>\n        </SectionBox>\n        <SectionBox data-section=\"Contact\" onClick={onClick}>\n          <ContactPreview></ContactPreview>\n        </SectionBox>\n      </List>\n      <Navbar selected={selectedSection} setSelected={setSelectedSection} />\n    </MainLayout>\n  )\n}\n\nexport default Main\n```\n\n간단하게 추가한 로직이지만 조금 의문이 들었던 점은 Javascript로만 개발할 때는 **부모 component 하나에 이벤트 위임**을 해서 자식 tag에 dataset의 값을 받아오는 식으로 연결이 가능했는데, react에서는 불가능했다.\n\n그래서 우선은 일일이 SectionBox component에게 이벤트핸들러를 전달해주고, 각 component의 data-set을 받아와서 상태를 업데이트 해주었다.\n\n동일한 로직이 Navbar의 버튼들에도 적용하기 위해 prop으로 각각 전달해주었다. 이때 NavButton에도 일일이 전달해주고 싶지 않아 컴포넌트 밖에 전달해줄 정보를 담은 배열을 만들고 mapping으로 component를 만들어 코드 중복을 줄였다. 리액트 함수형 component는 렌더링 되면서 처음부터 다시 함수 내부를 실행하기 때문에 새로 업데이트가 필요없을 것 같아, 배열을 컴포넌트 밖에 만들어 두었다.\n\n```javascript\nconst buttons = [\"About me\", \"Skills\", \"Projects\", \"Contact\"]\n\nfunction Navbar({ selected, setSelected }) {\n  console.log(selected)\n  return (\n    <NavbarLayout>\n      {buttons.map(button => (\n        <NavButton\n          key={button}\n          name={button}\n          selected={button === selected}\n          setSelected={setSelected}\n        ></NavButton>\n      ))}\n    </NavbarLayout>\n  )\n}\n\nexport default Navbar\n```\n\n## 2. About me, SKills, Contact 스타일링과 애니메이션\n\n애니메이션은 react 애니메이션 라이브러리인 <b>Framer Motion</b>을 이용해서 연결해주었다. Overlay component가 click 이벤트에 따라 없어졌다가 생겼다 해야하기 때문에 AnimatePresence를 이용해서 연결했다.\n\n```javascript\nconst overlayVariant = {\n  invisible: {\n    opacity: 0,\n    transition: {\n      duration: 1,\n    },\n  },\n  visible: {\n    opacity: 1,\n  },\n  exit: {\n    opacity: 0,\n  },\n}\n\nfunction Overlay({ selected, setSelected }) {\n  const onClick = () => setSelected(null)\n  return (\n    <OverlayLayout\n      // onClick={onClick}\n      variants={overlayVariant}\n      initial=\"invisible\"\n      animate=\"visible\"\n      exit=\"exit\"\n    >\n      <ExitBtn onClick={onClick}>\n        <i className=\"fa-solid fa-xmark\"></i>\n      </ExitBtn>\n      {selected === \"About me\" && <About></About>}\n      {selected === \"Skills\" && <Skills></Skills>}\n    </OverlayLayout>\n  )\n}\n\nexport default Overlay\n```\n\nAbout me 페이지를 만들면서 이미지를 불러올 수 없어서 조금 애먹었지만 [indol.log](https://velog.io/@ingdol2/React-image-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0) 님블로그를 참고해서 해결할 수 있었다.\n\n알고보니 img폴더를 root폴더에 두고 있어서 경로 설정자체가 잘못 되어있었다. Create-React-App에서 경로를 불러올 때는 **src폴더에 있을 때는 import로**, **public 폴더는 서버에서 불러올 수 있기 때문에 import없이 주소를 직접 사용**이 가능하다고 한다. Webpack을 공부하면서 배웠었던 부분인데 다시 공부가 필요하다고 느꼈다.\n\n작업을 하면서 간단하게 스타일링을 할 수 있을 것 같았는데 생각보다 오래걸려, 리액트보다 Styled Component를 더 많이 쓴 것 같다는 아쉬움이 남는다.\n\n내일은 프로젝트를 작업하면서 직접 라이브러리를 사용하지 않고 슬라이더를 만들어보고, Home 페이지도 연결하면서 React에 대해서 더 공부해볼 예정이다.\n\n![1](1.png)\n![2](2.png)\n![3](3.png)\n"},{"excerpt":"리액트를 어느정도 공부한 걸 정리하고, 적용해볼 겸 포트폴리오 사이트를 제작해보려 했다. 내가 생각하는 포트폴리오 사이트는 보는 사람이 우와할만한 디자인도 너무 중요하지만 내가 어떤 사람인지 잘 드러내는것이 가장 중요하다고 생각되었다. 이력서로는 담을 수 없는 내 이야기, 나라는 사람에 대해 궁금한 사람들이 나를 이해할 수 있도록 기획하고 디자인하는 게 …","fields":{"slug":"/2022-09-28-포트폴리오-기획/"},"frontmatter":{"date":"September 28, 2022","title":"포트폴리오 기획","tags":["사이드프로젝트","포트폴리오","기획"]},"rawMarkdownBody":"\n리액트를 어느정도 공부한 걸 정리하고, 적용해볼 겸 포트폴리오 사이트를 제작해보려 했다. 내가 생각하는 포트폴리오 사이트는 보는 사람이 우와할만한 디자인도 너무 중요하지만 <b>내가 어떤 사람인지 잘 드러내는것</b>이 가장 중요하다고 생각되었다. <b>이력서</b>로는 담을 수 없는 내 이야기, 나라는 사람에 대해 궁금한 사람들이 **나**를 이해할 수 있도록 기획하고 디자인하는 게 가장 중요하다고 생각되었다. 이런 점들을 고려해서 담아야할 내용은 다음과 같았다\n\n# 1) 내용\n\n1. About me:\n\n   내가 어떤 걸 좋아하고, 어떤 생각을 가진 사람인지를 보여줄 수 있어야한다는 생각이 들었다. 채용과 관련된 영상들을 찾아보면서 회사에서 사람을 뽑을 때, 좀 더 보수적으로 하게 된다고 한다. 새로 뽑은 한 사람 때문에 원래 팀이 흔들릴 수도 있기 때문에, 같은 목표를 바라보는 사람인지, 회사에 적응할 수 있는 사람인지를 보고 싶어한다. 그렇기 때문에 내가 어떤 사람인지 잘 담아내는 게 중요하다고 생각했다.\n\n   - 나를 표현할 수 있는 문장\n\n   - 내가 왜 개발을 시작했고, 왜 개발을 하고 있는지\n\n   - 요즘 내가 공부하고 있는 부분\n\n   - 앞으로 내가 공부하고 싶은 부분\n\n     <br/>\n\n2. SKills:\n\n   내가 다룰 수 있는 기술스택이 어떤게 있는지, 어느정도 깊이로 사용할 수 있는지를 표현해야한다. 실무에 투입되었을 때, 필요한 기술들로 제품을 만들 수 있을 지를 보여주고, 비슷한 기술을 사용했다면 다른 기술들도 배울 수 있을 것이란 가능성도 보여줄 수 있겠다는 생각되었다. 하지만 단순히 한번 써본 걸, 나열하는 식으로 보여주는 것이 아니라, 정말 깊이 있게 공부했고 여러가지 활용도 할 수 있을 정도의 기술 스택을 담을 필요있다.\n\n- 웹페이지를 만드는데 사용되는 HTML, CSS, Javascript\n\n- 자바스크립트에 타입을 더한 Typescript\n\n- 자바스크립트 라이브러리 React와 React를 편하게 사용하게 해주는 라이브러리:\n\n  React Query, Styled Components, Redux, React Router, React Hook Form\n\n- 협업에 사용되는 git과 백엔드 서비스와 여러가지 서비스를 제공해주는 Firebase\n\n  <br/>\n\n3. Project:\n\n   프로젝트는 여태 내가 해왔던 프로젝트들을 통해 내가 어떤 공부와 어떤 깊이의 기술을 가지고 있는지, 어떤 가치를 만들 수 있을지 가장 직접적으로 보여주는 부분이라 생각되었다. 프로젝트들을 돌아보면서 클론코딩을 많이 해서 그럴듯한 프로젝트들은 많았지만, 내가 직접 기획하고 고민하고 만든 프로젝트는 얼마 되지 않다는 것을 알게 되었다. 그래서 포트폴리오에 담을 프로젝트에는 클론코딩을 한 프로젝트들을 제외하고, 내가 직접 고민한 흔적이 담긴 프로젝트들들만 담아서 보여주며, 각 프로젝트들의 시연영상들도 만들고 실제 사용자 수, 평가 등을 담아서 보여주면 가장 설득력있는 프로젝트가 되지 않을까 생각되었다.\n\n   - 지스트 청원 서비스:\n\n     2022년 나에게 가장 큰 행운이 아니었을까 생각되는 팀프로젝트였다. 처음한 팀프로젝트였고, 부족했지만 개발이 뭔지, 협업이 뭔지 깨닫게 해준 너무 너무 소중한 프로젝트였다. 9월 15일 기준, 가입자 290명, 실제 학교측에서 답변된 청원 수 6개, 총 동의 수 541개로 현재도 사용되고 있는 서비스이다.\n\n   - 투두리스트 사이트:\n\n     노마드 코더에서 공부 후 참여한 챌린지에서 제작해 본 사이트로, 처음에 자바스크립트로 제작했지만 이후 리액트로 제작해보고 싶어 같은 디자인에 그때는 어떻게 구현해야 할지 몰라 추가하지 못했던 영상들도 추가해본 투두리스트 사이트이다.\n\n   - 채용공고 스크랩 서비스:\n\n     아직 기획중에 있지만 채용공고를 스크랩해 정리할 수 있는 서비스이다. 채용플랫폼에 상관없이 url만으로 채용공고 정보를 받아와 한눈에 정리해주는 서비스로 기획중에 있다.\n\n     <br/>\n\n4. Contact\n\n관심이 생긴 분들이 연락할 수 있게 블로그, 깃헙주소, 이메일을 담아 놓을 부분이다.\n\n이렇게 총 4가지를 담는 간단한 페이지이기에, 내가 어떤 내용을 담냐가 더 중요하기에 프로젝트 각각을 완성도를 높여서 담는게 중요 포인트가 될 것 같다.\n\n# 2) 디자인\n\n담을 내용들을 정리한 뒤에 디자인을 한번 생각해보았다. 아마 자주 수정될 수 있지 않을까 생각이 되지만 일단 생각나는 대로 만들어보려고 한다. 애니메이션들은 아직 혼자 구현해내기 어려울 것 같아 우선 라이브러리들을 이용해서 만들어보고, 직접 코드들을 수정해볼 예정이다. 전반적인 CSS 작업은 styled-components를 이용해볼 예정이다.\n\n### 1. Home\n\nHome 화면에는 가장 먼저 페이지를 방문한 사용자가 볼 화면이기 때문에, **인사말**과 간단한 사용방법을 보여주는 화면을 생각했다. 그래서 가장 먼저 떠오른 방식은 인사말을 **Typing** 애니메이션을 이용해서 내가 말하고 싶은 이야기로 시작하면 좋을 것 같다는 생각이 들었다.\n\n![home](홈.gif)\n\n[출처: Velog somangoi](https://velog.io/@somangoi/%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B06-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9D%B4%ED%95%91-%ED%9A%A8%EA%B3%BC)\n\n## 2. Main\n\n#### 2022-09-28 main 디자인\n\n메인 페이지에서는 디자인은 위에 정리한 4가지 섹션들을 카드처럼 담고, 카드를 넘기는 가로 스크롤 (carousel)로 적용해보면 어떨까라고 생각했다.\n\n![main](main.jpeg)\n\n[출처:블로그 바람사이](https://2pie.tistory.com/m/entry/React-Carousel-%EC%BA%90%EB%9F%AC%EC%85%80?category=707866)\n\n여기서 메뉴를 상단에 두지 말고 아래에 버튼으로 두고, 버튼을 클릭하게 되면 해당 섹션을 보여주는 애니메이션을 구상했다. carousel 구현하는 방법으로는 우선 직접 슬라이더를 만들어보고, framer motion을 이용해서 페이지 이동을 매끄럽게 연결해주면 어떨까 생각했다.\n\n#### 2022-09-30 main 디자인\n\n![캐러셀](캐러셀.png)\ncarousel을 이용하기에 너무 내용이 적어, 가로로 펼쳐진 카드 형식으로 만든 다자인으로 수정했다. 카드에 상세한 내용이 적힌 채로 main에 있기보다. 실제로 내가 기획한 와이어 프레임의 모습대로 보여 주는 카드 형식으로 만들면 좀 더 재밌어 보이면서도 간략하게 레이아웃을 보여줄 수 있을 것 같아 디자인에 추가했다.\n\n버튼 또는 카드를 누르면 레이아웃대로 만들어 진 화면을 보여주면 될 것 같았고 카드 자체가 데스크탑 화면과 달리 세로가 길기 때문에 모바일 버전을 먼저 고려해서 만들었다.\n"},{"excerpt":"Map과 Set은 자바스크립트의 자료구조로, map은 Object와 유사한 구조를 가지고, Set은 중복을 없애주는 등에 사용된다. 유용한 자료구조이기에 정리를 한번 해보려 한다. Set Set 자료형은 위에 언급한대로 데이터의 중복을 없을 뿐 아니라 배열과 달리 순서를 가지지도 않는 특징을 가진다. 1. Set 만들기 set은 간단하게 class를 사용…","fields":{"slug":"/2022-09-24-Map과Set/"},"frontmatter":{"date":"September 24, 2022","title":"Map과 Set","tags":["javascript"]},"rawMarkdownBody":"\nMap과 Set은 자바스크립트의 자료구조로, map은 Object와 유사한 구조를 가지고, Set은 중복을 없애주는 등에 사용된다. 유용한 자료구조이기에 정리를 한번 해보려 한다.\n\n## Set\n\nSet 자료형은 위에 언급한대로 데이터의 중복을 없을 뿐 아니라 배열과 달리 순서를 가지지도 않는 특징을 가진다.\n\n### 1. Set 만들기\n\nset은 간단하게 class를 사용하듯이 new를 이용해서 만들 수 있고, 내부 값을 전해줄 수 있는데 이때 주의할 점은 iterable한 값을 전달해주어야 한다.\n\n앞서 정리했던 iterable한 값으로, array, 문자열, Object의 keys, values등을 전달해줄 수 있다.\n\n```javascript\nconst set = new Set(\"hello\")\nconsole.log(set) //Set(4) {'h', 'e', 'l','l', 'o'}\n\nconst set2 = new Set([1, 2, 3, 4])\nconsole.log(set2) //Set(4) {1, 2, 3, 4}\n```\n\n### 2. 추가,삭제\n\n추가,삭제를 위해서는, Set의 instance레벨의 함수인 **add**와 **delete**를 이용해야한다. 내부 값을 모두 삭제하고 싶을 때는 **clear**를 사용할 수 있다.\n\n```javascript\nconst set = new Set([1, 2, 3, 4])\nset.add(5) //Set(5) {1, 2, 3, 4, 5}\nset.delete(3) //Set(4) {1, 2, 4, 5}\nset.clear() //Set(0) {size: 0}\n```\n\n### 3. 길이와 포함여부\n\nSet의 길이는 배열의 length와 다르게 **size**를 이용해서 얻을 수 있으며, 특정 자료를 가지고 있는지 **has**를 통해 알 수 있다.\n\n```javascript\nconst set = new Set([1, 2, 3, 4])\nset.size //4\nset.has(5) //false\nset.has(4) //true\n```\n\n### 4. 활용\n\nset는 유일한 데이터만을 가지기 때문에 자주 쓰이는 배열내부의 중복되는 데이터를 정리하는데 사용할 수 있다.\n\n```javascript\nconst duplicatedItems = [1, 1, 2, 3, 4, 5, 5]\nconst uniqueItems = [...new Set(duplicatedItems)] //(5) [1, 2, 3, 4, 5]\n```\n\n### 주의점\n\nSet자료형이 유일한 데이터를 가지지만 주의할 점으로, set에 객체가 있다면 객체의 참조값을 가지고 있기에 주소값으로 동일한 데이터인지 확인한다. 그렇기에 객체의 내부 속성이 달라진다면 set내부의 객체의 값이 달라지고, 만약 속성이 동일한 두개의 객체가 있다면, 둘의 참조값이 다르기 때문에 모두 set에 추가된다.\n\n```javascript\nconst obj = {\n  name: \"choi\",\n}\nconst set = new Set()\nset.add(obj)\nobj.name = \"park\"\nconsole.log(set) //name이 park로 바뀌어있어\n\nconst obj2 = {\n  name: \"park\",\n}\n\nset.add(obj2) //obj와 obj2 모두 set에 포함되어 있어\n```\n\n# Map\n\nmap을 처음 배웠을 때 느꼈던 부분은 \"object\"와 너무 비슷하다는 점이었다. object와 동일하게 key와 value로 값을 저장해, 해당 key를 통해 값을 전달 받을 수 잇다. map은 앞서 정리한 set과 유사한 문법을 가지는 부분들이 있어 함께 정리했다.\n\n### 1.map 만들기\n\nset과 동일하게 new Map()을 통해서 새로 만들 수 있으며, 바로 값을 전달할 때는 배열의 형태로 [key,value]로 전달해주어야 한다.\n\n```javascript\nconst map = new Map([\n  [\"1\", 1],\n  [\"2\", 2],\n]) //Map(2) {'1' => 1, '2' => 2}\n```\n\n### 2. get,set,delete,clear\n\nmap은 추가를 위한 **set**, key를 이용해 값을 불러오는 **get**, 값을 삭제하기 위한 **delete**, 내부 값을 모두 삭제하고 싶을 때는 **clear**를 사용할 수 있다.\n\n```javascript\nconst map = new Map()\nmap.set(\"name\", \"choi\") //Map(1) {'name' => 'choi'}\nmap.get(\"name\") //choi\nmap.delete(\"name\") //Map(0) {size: 0}\n\nconst map2 = new Map([\n  [\"1\", 1],\n  [\"2\", 2],\n]) //Map(2) {'1' => 1, '2' => 2}\nmap2.clear() //Map(0) {size: 0}\n```\n\n### 3. 길이와 iterator\n\nmap의 길이는 set과 동일하게 **size**를 이용해서 얻을 수 있으며, object와 같이 **iterator**들을 이용할 수 있다.\n\n```javascript\nconst map = new Map()\nmap.set(\"name\", \"choi\") //Map(1) {'name' => 'choi'}\nmap.set(\"age\", \"26\") //Map(2) {'name' => 'choi', 'age' => '26'}\n\nmap.forEach((value, key) => console.log(value, key))\n/*\nchoi name\n26 age\n*/\n\nmap.keys() //MapIterator {'name', 'age'}\nmap.values() //MapIterator {'choi', '26'}\nmap.entries() //MapIterator {'name' => 'choi', 'age' => '26'}\n```\n\n### 4. Object와 다른점\n\n앞서 언급한 대로 Key와 value로 이루어져 Object와 매우 유사한 구조를 가지지만 Object와는 다른 방식을 이용해 값을 추가하고 삭제한다. 한마디로 둘은 **Interface**가 다르다고 할 수 있다.\n"},{"excerpt":"Iteration은 순회라는 뜻으로, 순서대로 item에 접근할 수 있을 때를 의미한다. 앞서 정리한 배열, 문자열는 순회가 가능한데 이렇게 순회가 가능하기 위해서는 iterable protocol을 따라야 한다. Protocol이란 약속이나 규약을 의미하므로 이런 규칙을 따른다는 의미로 이해할 수 있다. 먼저 iterable protocol에 대해 정리…","fields":{"slug":"/2022-09-22-iteration/"},"frontmatter":{"date":"September 22, 2022","title":"Iteration","tags":["javascript","문법"]},"rawMarkdownBody":"\nIteration은 순회라는 뜻으로, 순서대로 item에 접근할 수 있을 때를 의미한다. 앞서 정리한 **배열, 문자열**는 순회가 가능한데 이렇게 순회가 가능하기 위해서는 **iterable protocol**을 따라야 한다. Protocol이란 약속이나 규약을 의미하므로 이런 규칙을 따른다는 의미로 이해할 수 있다.\n\n먼저 iterable protocol에 대해 정리해보자.\n\n### 1. Iterable Protocol\n\niterable protocol을 따른다는 말은 \"객체가 **[Symbol.iterator]**라는 메소드가 존재하고, [Symbol.iterator]는 **iterator protocol을 따르는 객체를 반환한다\"**는 것을 의미한다. 그럼 iterator Protocol은 어떤 규칙일까?\n\n## 2. Iterator Protocol\n\nIterator Protocol을 따른다는 것은 **next()**라는 메소드를 가지고 있는 객체로, next()는 다시 값을 담고 있는 **value**와 순회가 끝난지를 담고 있는 **done**이라는 두가지 속성을 가지고 있는 객체를 반환한다.\n\n위에 헷갈리는 두가지 프로토콜을 정리하면 다음과 같이 정리할 수 있다.\n\n1. 순회가 가능하려면 Iterable Protocol을 따라야한다.\n2. Iterable Protocol은 [Symbol.iterator]메소드가 Iterator protocol을 따르는 객체를 반환한다는 뜻이다.\n3. Iterator Protocol은 next라는 메소드가 value와 done이란 두가지 속성을 가지고 있는 객체를 반환한다.\n\nIteration procol을 따르는 iterator의 예로 배열이 있고, iterator를 반환하는 Object.values()나 Object.entries()가 있다.\n\n직접 iteration이 가능한 객체를 만들어보면 다음과 같이 코드를 만들 수 있다.\n\n```javascript\nconst iterableObj = {\n  [Symbol.iterator]() {\n    let num = 0\n    const end = 5\n    return {\n      next() {\n        return { value: num++, done: num > end }\n      },\n    }\n  },\n}\n\n/*\n0\n1\n2\n3\n4\n*/\n```\n\n### 3. iteration이 가능하면 뭐가 좋을까?\n\n이렇게 Iteration이 가능하면 뭐가 좋을까? 바로 for...of 구문을 사용할 수 있다. 그냥 순회하는 코드는 다음과 같이 작성할 수 있다.\n\n```\\javascript\nconst arr=[1,2,3]\nconst iterator=arr.values() //iterator\nwhile(true){\n    const item=iterator.next()\n    if (item.done)break\n    console.log(item.value)\n}\n/*\n1\n2\n3\n*/\n```\n\nfor... of를 사용하면 보다 간단하게 사용할 수 있다. for... of 구문은 iteration이 가능한 경우에만 사용할 수 있기에 일반적인 객체는 for...of 구문은 사용하지 못하고 key값을 이용하는 for...in을 이용할 수 있다.\n\n```javascript\nconst arr = [1, 2, 3]\nfor (const item of arr) {\n  console.log(item)\n}\n/*\n1\n2\n3\n*/\n\nconst obj = {\n  1: \"1\",\n  2: \"2\",\n  3: \"3\",\n}\n\nfor (const key in obj) {\n  console.log(key)\n}\n\n/*\n\"1\"\n\"2\"\n\"3\"\n*/\n```\n\n### 4. Generator\n\nGenerator는 iteration protocl을 따르는 iterator를 간단하게 만들 수 있는 방법으로 다음과 같이 만들 수 있다.\n\n```javascript\nfunction* iteratorGenerator(start, end) {\n  for (let i = start; i < end; i++) {\n    yield i\n  }\n}\n\nconst generator = iteratorGenerator(0, 5)\nlet result = generator.next()\nwhile (!result.done) {\n  console.log(result.value)\n  result = generator.next()\n}\n\n/*\n0\n1\n2\n3\n4\n*/\n```\n\ngenerator 함수에는 return 대신 **yield**를 사용해, 그때그때 값을 무조건 반환하는 게 아니라 사용자의 요구에 따라 값을 전달 할 수 있다. generator에는 yield로 전달받은 value와 done을 담고 있는 객체를 받는 **next()**, 에러를 던질 수 있는 **throw()**와 순회를 끝낼 수 있는 **return()** 메소드가 존재한다.\n\n실제로는 generator를 직접만드는 경우는 드물지만, 조건에 맞는 객체를 만들고 호출하는 과정을 이해하는 것에 중요함을 느낄 수 있었다.\n"},{"excerpt":"1. 배경 개발자들을 위한 채용공고 정리 서비스는 요즘 다양한 채용공고 플랫폼이 존재한다. 채용 플랫폼마다 공통적으로 있는 공고도 있고, 한 플랫폼에는 있지만 다른 플랫폼에는 없는 채용공고도 있다. 취준생의 입장에서 한 회사의 하나의 채용공고만 보고 고민하는 것이 아니라, 다양한 회사들의 공고를 보았을 때, 어떤 자격 조건이 다른지, 어떤 우대사항이 있는…","fields":{"slug":"/2022-09-22-채용공고-정리사이트-기획/"},"frontmatter":{"date":"September 22, 2022","title":"채용공고 정리 서비스 기획","tags":["사이드프로젝트","기획"]},"rawMarkdownBody":"\n## 1. 배경\n\n개발자들을 위한 채용공고 정리 서비스는 요즘 다양한 채용공고 플랫폼이 존재한다. 채용 플랫폼마다 공통적으로 있는 공고도 있고, 한 플랫폼에는 있지만 다른 플랫폼에는 없는 채용공고도 있다.\n\n취준생의 입장에서 한 회사의 하나의 채용공고만 보고 고민하는 것이 아니라, 다양한 회사들의 공고를 보았을 때, 어떤 자격 조건이 다른지, 어떤 우대사항이 있는지 등을 비교할 필요가 있고, 기록해서 나중에 볼 때도 편하게 볼 수 있게 <b>키워드</b> 단위로 정리하고 싶다는 생각에서 시작했다.\n\n이미 존재하는 서비스일지도 모르지만 내가 필요해서,사용하고 싶어서 만드는 사이드 프로젝트이기에 여러가지 삽질을 시작할 예정이다.\n\n## 2. 기획\n\n채용공고들의 정보를 받기 위해서는 두 가지 방법이 떠올랐다. 하나는 <b>채용 플랫폼의 API</b>를 직접 이용하는 방법과, 다른 하나는 <b>채용 공고를 스크래핑</b>하는 방법이다.\n\n#### 2.1 채용 플랫폼 API\n\n요즘 내가 틈틈히 채용공고들을 볼 때, 많이 사용하고 있는 채용 플랫폼의 종류들을 정리하면 다음과 같다.\n\n#### 1. 원티드\n\n내가 느끼기에 가장 UI가 깔끔하고 여러 정보가 잘 담겨있어서 가장 자주 보게 되는 플랫폼으로, 취업을 위한 다양한 정보와 지원을 해주는 이벤트가 존재한다.\n\n![img](https://blog.kakaocdn.net/dn/br7AFo/btrc9d7Zpzo/a5BnKsDB3Vltlp06x3oZlK/img.png)\n\n#### 2. 로켓펀치\n\n로켓펀치는 자주 이용하지는 않지만, 다른 플랫폼에 없는 채용공고들이 있을 때가 있어 찾게 되는 플랫폼이다.\n\n![로켓펀치, 모바일 앱 출시 “더 편하게 일에 필요한 사람 찾고 메시지 보내세요.” - 로켓펀치 공식 블로그](https://blog.rocketpunch.com/wp-content/uploads/2020/03/%EB%A1%9C%EC%BC%93%ED%8E%80%EC%B9%98_%EC%95%B1%EC%B6%9C%EC%8B%9C1.jpg)\n\n#### 3. 점핏\n\n개발자들을 타겟한 채용 플랫폼으로, 개발자 시장에 특화된 정보들과 공고들이 안내되어 있어, 신입 개발자를 준비하는 나에게 유용한 플랫폼이다.\n\n![img](https://image.edaily.co.kr/images/photo/files/NP/S/2021/03/PS21030500386.jpg)\n\n#### 4.**프로그래머스**\n\n기업의 채용과정에서 코딩테스트를 지원하고, 연결해주는 서비스로 코딩테스트로 다양한 기업에 한번에 지원할 수 있는 독특한 서비스를 제공한다.\n\n![post-thumbnail](https://velog.velcdn.com/images/dev-redo/post/3eac3adc-518e-4f37-a329-9e0053080a44/image.jpg)\n\n이외에도 사람인, 잡코리아, 잡플래닛 등 채용 플랫폼이 다양하게 존재하지만, 플랫폼들 중에서 Open API를 제공하는 플랫폼에는 **Linkedin, 워크넷**, 두가지 플랫폼이 있었다. open API가 있다면 채용공고들을 보다 쉽게 가져올 수 있겠지만, 대부분의 플랫폼들은 API를 제공하지 않기도 하고, 플랫폼마다의 공고들을 받아오는 것은 사실 확장성이 떨어질 수 있기 때문에, 다양한 채용공고 정보들을 받아올 수 있는 다른 방법을 생각해야 했다.\n\n#### 2.2 채용공고 스크래핑\n\nopen soure API를 대체할 방법으로 생각해낸 방법은 채용공고 페이지에서 필요한 부분들을 가져올 수 있는 **웹크롤링** 이다. <b>웹 크롤링</b>은 브라우저를 통해 받아온 HTMl 페이지를 가져와, 파싱을 통해서 필요한 데이터를 추출하는 방식으로, 웹 크롤링을 이용한다면 api로 데이터를 받아올 수는 없지만, 공고 페이지 내부의 정보들을 받아올 수 있기 때문에 좋은 방향이 될 것이라 생각이 들었다.\n\n크롤링을 이용한 전체적인 로직은 다음과 같이 정리할 수 있다.\n\n1. **채용 공고 페이지의 url을 입력하면 url의 내용 중 내가 원하는 정보들만 추려온다**\n2. **받아온 데이터를 firebase 데이터베이스에 저장한다.**\n3. **firebase 데이터베이스의 데이터를 가져와 프론트 페이지에 보여준다.**\n"},{"excerpt":"자바스크립트에서의 배열은 객체로, index를 통해 데이터에 접근할 수 있게 정리해놓은 자료구조이다. 다른 언어들과는 다르게 메모리셀에서 변수들이 연속적으로 저장되어 있지는 않는다. 유용한 자료구조 배열에 대해 알아보자. 1. Array 만들기 배열을 만드는 방법에는 총 4가지 방법이 있다. new Array(size): size만큼의 길이를 가진 배열을…","fields":{"slug":"/2022-09-19-array/"},"frontmatter":{"date":"September 19, 2022","title":"Array","tags":["javascript","문법"]},"rawMarkdownBody":"\n자바스크립트에서의 배열은 객체로, index를 통해 데이터에 접근할 수 있게 정리해놓은 자료구조이다. 다른 언어들과는 다르게 메모리셀에서 변수들이 연속적으로 저장되어 있지는 않는다. 유용한 자료구조 배열에 대해 알아보자.\n\n### 1. Array 만들기\n\n배열을 만드는 방법에는 총 4가지 방법이 있다.\n\n1. new Array(size): size만큼의 길이를 가진 배열을 만든다.\n\n   new Array(data1,data2,...): 전달받은 데이터를 가진 배열을 만든다.\n\n2. Array.of(data1,data2,...): Array 객체의 static함수인 of 를 이용해 전달받은 데이터를 가진 배열을 만든다\n3. [data1,data2,...] : array literal로 간단하게 배열을 만들 수 있다.\n4. Array.from(array) : Array 객체의 static 함수인 from을 이용해 전달받은 배열을 복사할 수 있다.\n\n다음과 같이 정리된 배열을 이용해보면 다음과 같이 만들 수 있다.\n\n```javascript\nlet array = new Array(3) //(3) [비어 있음 × 3]\narray = new Array(1, 2, 3) //[1, 2, 3]\narray = Array.of(1, 2, 3) //[1, 2, 3]\narray = [1, 2, 3] //[1,2,3,]\narr2 = [1, 4, \"A\"]\narray = array.from(arr2) //[1,4,'A']\n```\n\n### 2. Array의 요소 추가, 삭제\n\n배열은 index를 이용해 데이터에 접근할 수 있는 자료구조로, 요소를 추가하고 삭제할 수 있는 함수들이 방법들이 존재한다.\n\n#### 2.1 add와 delete (비추)\n\nadd와 delete는 배열의 index를 이용해서 요소를 추가 삭제하는 방법이지만 index를 직접 이용하기 때문에 배열의 크기나 위치에 따른 데이터 값을 모를 경우에 문제가 될 수 있으며 delete의 경우 삭제하고 빈 공간이 남아 있는 문제가 있다.\n\n#### 2.2 push와 pop\n\n**push**와 **pop**은 배열의 끝에 요소를 추가하고 삭제하는 방법이다. **push**는 요소를 추가하고 난 다음의 배열의 길이를 반환하고, **pop**은 제거한 요소를 반환한다.\n\n맨뒤의 요소만 제거하고 추가하기 때문에 O(1)의 시간복잡도를 가진다.\n\n#### 2.3 unshift와 shift\n\n**unshift**와**shift** 는 배열의 처음에 요소를 추가하고 삭제하는 방법이다. **unshift**는 push와 같이 요소를 추가하고 난 다음의 배열의 길이를 반환하고, **shift** 는 제거한 요소를 반환한다. **unshift**와 **shift**는 **push**와 **pop**과는 다르게 배열의 맨앞의 요소를 제거하고 추가하기 때문에 전체적인 배열요소들의 이동이 있다. 그렇기 때문에 **unshift**와 **shift**의 시간 복잡도 O(n)로 더 오래걸린다.\n\n```javascript\nconst alphabets = [\"a\", \"b\", \"c\"]\nconsole.log(alphabets.push(\"d\")) //4\nconsole.log(alphabets) //['a','b','c','d']\nconsole.log(alphabets.pop()) //'d'\n\nconst alphabets = [\"a\", \"b\", \"c\"]\nconsole.log(alphabets.unshift(\"d\")) //4\nconsole.log(alphabets) //['d','a','b','c']\nconsole.log(alphabets.shift()) //'d'\n```\n\n### 3. Array의 다양한 속성과 함수\n\n배열의 매력은 다양한 내장함수를 지원한다는 점이라고 한다. 자주 사용했던 함수들을 정리해보려한다.\n\n#### 3.1 배열의 정보를 반환\n\n1. array.length: 배열의 길이를 반환\n2. Array.isArray(arr): 배열인지 아닌지 True/False\n3. array.indexof(value): value가 있는 인덱스를 반환, 없으면 -1\n4. array.includes(value): value를 배열이 포함하는지 True/False\n\n#### 3.2 배열을 수정하는 함수\n\n앞서 정리한 추가,삭제 함수들과 함께 배열 자체를 수정하는 함수를 정리하면 다음과 같다.\n\n1. array.splice(start,count,value):\n\n   splice는 배열의 중간에서 값을 삽입하거나 삭제할 때 사용할 수 있는 함수로 start 인덱스로부터 count 갯수만큼 삭제하고, value를 삽입할 수 있다.\n\n2. array.fill(value,start,end):\n\n   fill는 배열에 start부터 end-1까지 value로 바꾸거나 삽입한다.\n\n#### 3.3 새로운 배열을 반환하는 함수\n\n배열을 직접 수정하는 게 아니라, 배열을 변환해서 새로운 배열을 반환하는 함수들은 다음과 같다.\n\n1. array.concat(arr): 전달받은 배열의 요소들을 array에 추가한 새로운 배열을 반환한다.\n2. array.reverse(): 배열의 순서를 뒤집은 배열을 반환한다.\n3. array.flat(value): 배열 내 요소로 또다른 배열이 있을 때, 또다른 배열의 요소들을 요소로 가지고 있는 새로운 배열을 반환한다.\n4. arr.join(string): 새로운 배열은 아니지만 배열을 문자열로 변환해서 반환한다.\n5. arr.slice(start,end): start 인덱스부터 end-1 인덱스까지 배열을 자른 새로운 배열을 반환한다.\n\n```javascript\nconst alphabets = [\"a\", \"b\", \"c\"]\nalphabets.splice(1, 1)\nconsole.log(alphabets) //[\"a\",\"c\"]\nalphabets.splice(1, 0, \"d\")\nconsole.log(alphabets) //[\"a\",'d','c']\n\nconst alphabets1 = [\"a\", \"b\", \"c\"]\nconst alphabets2 = [\"d\", \"e\", \"f\"]\nconst alphabets3 = alphabets1.concat(alphabets2)\nconsole.log(alphabets3) // ['a', 'b', 'c', 'd', 'e', 'f']\n\nlet arr = [[1, 2, 3], 4, 5]\nconst flatArr = arr.flat(1)\nconsole.log(flatArr) //[1,2,3,4]\nconst text = arr.join(\" \") //\"1,2,3 4\"\nconsole.log(arr.slice(1, 3)) //[4,5]\n```\n\n### 4. 배열과 Shallow Copy\n\n자바스크립트에서의 복사는 항상 **shallow copy**를 통해 진행된다. **shallow copy**는 객체를 복사할 때, 새로운 객체를 만든 후에 내부의 속성, 함수들을 모두 새로 만드는 것이 아니라, 원본 객체의 내부의 값들을 가져온다. 그렇기 떄문에 아래 그림과 같이 새로운 객체를 만들었지만 같은 reference값을 가지고 있다.\n\n이에 반해 **Deep copy**는 객체뿐아니라 내부 값들 모두다 새롭게 만들어 추가한다.\n\n![Alt Text](https://res.cloudinary.com/practicaldev/image/fetch/s--CjdqwIq1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/llosmmb3rzbq5ravmfcp.jpg)\n\n이점이 중요한 이유는 원본 객체 내부의 값의 변화가 생기면 **shallow copy**로 만든 객체에도 영향을 주기 때문이다.\n\n```javascript\nconst person1 = { firstName: \"Youngjun\", lastName: \"Choi\" }\nconst person2 = { firstName: \"Youngjun\", lastName: \"Park\" }\nconst contact1 = [person1, person2]\nconst contact2 = [...contact1]\n\ncontact1.pop()\nconsole.log(contact1) //[person1]\nconsole.log(contact2) //[person1,person2]\n\nperson1.lastName = \"Son\"\nconsole.log(contact1) //[{firstName:\"Youngjun\", lastName:\"Son\"}]\nconsole.log(contact2) //[{firstName:\"Youngjun\", lastName:\"Son\"},person2]\n```\n\n위 코드를 보면 contact2는 contact1을 복사해서 만든 배열이다. contact1의 값의 변화가 있더라도 contact2는 서로 다른 배열이기 때문에 영향을 받지않는다. 하지만 person1의 속성이 바뀌면 person1을 가지고 있는 contact1과 contact2 모두 변화가 생기는 것을 볼 수 있다. 그렇기 때문에 배열이나 오브젝트 내부의 값을 바꿀 때 사이드 이펙트가 생길 수도 있다는 것을 알고 있어야 한다.\n\n### 5. Array의 고차함수\n\n자바스크립트는 일급함수를 다루기 때문에 고차함수를 이용한 함수간의 chaining, 함수형 프로그래밍이 가능하다. 배열 내부에는 좀 더 편리하게 사용할 수 있는 고차함수가 있는데 이에 대해 정리해보려한다.\n\n1.  `array.forEach( (item,index,array ) => { sth })`: array 각 요소에 전달한 callback 함수를 실행 할 수 있다.\n\n2.  `array.find( (item) => condition )` : array 요소중에서 처음으로 조건에 맞는 요소를 반환한다.\n3.  `array.findIndex( (item) => condition )` : array 요소중에서 처음으로 조건에 맞는 요소의 index를 반환한다.\n4.  `array.some( (item) => condition )` : array 요소중에서 하나라도 조건을 만족하는지 True/False\n5.  `array.every( (item) => condition )` : array 요소중에서 모두 조건을 만족하는지 True/False\n6.  `array.filter( (item) => condition )`: array 요소중에서 조건을 만족하는 요소들만을 모은 배열을 반환한다.\n7.  `array.map( (item) => sth )` : array 요소들을 다른 값으로 변환해\n8.  `array.flatMap( (item) => sth )` : array 요소들을 배열을 제거하고 다른 값으로 변환해서 반환한다.\n9.  `array.sort((a,b)=> condition)` : condition이 a-b는 내림차순, b-a는 오름차순으로 정렬한다.\n10. `array.reduce((prev,curr)=>(sth), initialVal)`: 초기값을 시작으로 curr값을 callback함수에 맞게 prev값에 더해간다.\n"},{"excerpt":"객체에는 크게 세 가지로 나뉠 수 있다. 위 그림의 사용자가 정의한 사용자 정의 객체, 브라우저나 node 객체인 Host 객체, 그리고 오늘 정리해볼 Built-in 객체 이다. 빌트인 객체는 자바스크립트 자체적인 객체로 클래스 레벨의 객체를 이용해 객체를 직접 만들지 않고, 바로 사용할 수 있다. 1) Wrapper 객체 앞서 정리해온 원시형 자료형들…","fields":{"slug":"/2022-09-17-빌트인객체/"},"frontmatter":{"date":"September 17, 2022","title":"빌트인 객체","tags":["javascript"]},"rawMarkdownBody":"\n![built-in](built.png)\n객체에는 크게 세 가지로 나뉠 수 있다. 위 그림의 사용자가 정의한 <b>사용자 정의 객체</b>, 브라우저나 node 객체인 <b>Host 객체</b>, 그리고 오늘 정리해볼 <b>Built-in 객체</b> 이다. 빌트인 객체는 자바스크립트 자체적인 객체로 클래스 레벨의 객체를 이용해 객체를 직접 만들지 않고, 바로 사용할 수 있다.\n\n## 1) Wrapper 객체\n\n앞서 정리해온 원시형 자료형들 (문자열, 숫자, 불리언 등) 을 사용할 때, 변수에 \".\"을 붙이면 자동으로 자료형이 사용할 수 있는 메소드가 뜨는걸 볼 수 있다. 원시형 자료형을 선언해도 객체처럼 불러올 수 있는 이유에는, 바로 \".\"을 사용하면 변수의 자료형에 맞는 wrapper 객체가 감싸지기 때문이다.\n\n![wrapper](wrapper.png)\n사진에서 간단하게 str이란 변수를 누르고 \".\"을 누르면 String wrapper 객체의 다양한 메소드를 사용할 수 있음을 볼 수 있다.\n\n## 2. Global 객체\n\n전역 객체라고 불리는 \"globalThis\"는 Host에 따라 달라진다. 브라우저의 경우는 window를 지칭하고 node의 경우에 module을 가리킨다. 이러한 전역객체가 가지고 있는 메소드는 변수 선언 없이 바로 함수를 사용할 수 있다.\n\n```javascript\nisFinite(Infinity) //True\nparseInt(\"12,43\") //12 (문자열을 숫자로 바꿔줘)\n```\n\n## 3. Boolean 객체\n\n```javascript\nconst Truthy = new Boolean(true)\nconsol.log(Truthy) //Boolean {true}\n```\n\n위 코드처럼 객체로 변수를 만들 수 있지만 객체는 원시형 자료형들에 비해 메모리를 많이 차지하기 때문에 그냥 사용하는 게 더 효율이 좋다.\n\n## 4. Number 객체\n\n```javascript\nconst num = 1234.5678\nconsole.log(Number.isNaN(num)) //false\nconsole.log(num.toFixed(3)) //1234.568 (소숫점아래 세자리까지 반올림 표현)\nconsole.log(num.toLocaleString(\"en-US\")) //1,234.568 (미국기준 단위 표기로 표현)\n```\n\n유용해 보였던 메소드 세가지를 정리해 보았다.\n\n1.  isNaN: 'Not a Number'가 맞는 지 확인할 수 있다.\n2.  toFixed(소숫점 아래 자릿수): 소수를 표현할 때 원하는 자릿수까지 반올림\n3.  toLocaleString: 원하는 지역의 단위 표기법으로 숫자 표기\n\n## 5. Math 객체\n\n```javascript\nMath.abs(-100) //100\nMath.ceil(3.5) //4\nMath.floor(3.5) //3\nMath.round(3.5) //4\nMath.trunc(1.543) //1\nMath.max(4, 5, 6, 7, 8) //8\nMath.min(4, 5, 6, 7, 8) //4\nMath.sqrt(25) //5\nMath.random() //0.23028324902271824\n```\n\n자바스크립트를 배우면서 가장 많이 썼던 빌트인 객체라 하면 Math 객체라고 할 것 같다. 위의 코드에 사용된 메소드를 정리하면 다음과 같다.\n\n1. Math.abs(num) : 절댓값\n2. Math.ceil(num) : 올림\n3. Math.floor(num) : 내림\n4. Math.round(num) : 반올림\n5. Math.trunc(num) : 정수만 표현\n6. Math.max(num1,num2, ...) : 전달 받은 여러 숫자 중 최댓값\n7. Math.min(num1,num2, ...) : 전달 받은 여러 숫자 중 최솟값\n8. Math.sqrt(num): 제곱근\n9. Math.random(): 0과 1사이의 랜덤한 값\n\nMath.random의 경우 0과 1사이의 랜덤한 값을 반환하기 때문에 원하는 영역의 값을 반환하고 싶다면 다음과 같이 사용 가능하다.\n\n```javascript\nfunction getRandomNum(min, max) {\n  return Math.random() * (max - min) + min\n}\n```\n\n## 6. String 객체\n\n```javascript\nconst text = \"Good night\"\nconsole.log(text.charAt(4)) //\"\"\nconsole.log(text.indexOf(\"l\")) //-1\nconsole.log(text.indexOf(\"o\")) //1\nconsole.log(text.lastIndexOf(\"o\")) //2\nconsole.log(text.includes(\"ight\")) //true\nconsole.log(text.startsWith(\"go\")) //false\nconsole.log(text.endsWith(\"ght\")) //true\nconsole.log(text.toUpperCase()) //\"GOOD NIGHT\"\nconsole.log(text.toLowerCase()) //\"good night\"\nconsole.log(text.substring(0, 3)) //\"Goo\"\nconsole.log(text.slice(2, 6)) //\"od n\"\nconsole.log(text.trim()) //undefined\nconst text2 = \"      hi     \"\nconsole.log(text2.trim()) //\"hi\"\nconsole.log(text.split(\" \")) //[\"Good\",\"night\"]\n```\n\nstring 객체의 메소드는 코딩테스트를 공부하고 정규표현식을 공부하면서 조금씩 익숙해지고 있는 것 같다. 유용한 메소드들을 정리해보면 다음과 같다.\n\n1. text.charAt(idx): index에 해당하는 문자열\n2. text.indexOf(char): 처음부터 문자열에서 원하는 문자를 찾고 인덱스 반환, 없으면 -1\n3. text.lastIndexOf(char): 마지막부터 문자열에서 원하는 문자찾고 인덱스 반환, 없으면 -1\n4. text.includes(str): 문자열에서 str을 포함하는지 True/False\n5. text.startsWith(str): 문자열이 str로 시작하는지 True/False\n6. text.endsWith(\"ght\"): 문자열이 str로 끝나는지 True/False\n7. text.toUpperCase(): 문자열을 대문자로\n8. text.toLowerCase(): 문자열을 소문자로\n9. text.substring(start,end):인덱스에 맞게 start부터 end-1까지 부분 문자열\n10. text.slice(2,6):인덱스에 맞게 start부터 end-1까지 부분 문자열을 잘라\n11. text.trim(): 문자열 내 빈 문자열을 제거하는데 문자열 사이의 \" \"는 제거하지 않아\n12. text.split(base): base를 기준으로 문자열을 잘라 배열로 반환\n\n## 7. Date 객체\n\n```javascript\nconst date = new Date() //Mon Sep 17 2022 03:04:41 GMT+0900 (한국 표준시)\nnew Date(\"Feb 5,2011\") //Sat Feb 05 2011 00:00:00 GMT+0900 (한국 표준시)\nnew Date(\"2011-2-5\") //Sat Feb 05 2011 00:00:00 GMT+0900 (한국 표준시)\nDate.now() //1663524375771\nconsole.log(date.getFullYear()) //2022\nconsole.log(date.getMonth()) //8\nconsole.log(date.getDate()) //17\nconsole.log(date.getDay()) //6\nconsole.log(date.toString()) //Sat Sep 17 2022 03:07:40 GMT+0900 (한국 표준시)\nconsole.log(date.toLocaleString(\"en-US\")) //9/17/2022, 3:07:40 AM\n```\n\nDate 객체에서 주로 사용했던 method는 Date.now()로, 컴포넌트나 객체의 값에 id로 전달할 때 자주 사용했다. Date 객체는 자체적으로 시간을 반환하고 객체에 알맞은 문자열의 시간을 넣으면, 그에 해당하는 시간을 반환한다. 유용한 메소드는 다음과 같이 정리된다.\n\n1.  Date.now(): 현재 시간을 1970년 1월 1일부터 UTC 기준으로 ms단위로 보여준다.\n\n2.  date.getFullYear: 년도\n3.  date.getMonth: 0부터 1월로, 11은 12월까지 나타내\n4.  date.getDate(): 1일부터 31일까지\n5.  date.getDay(): 0부터 일요일로, 6은 토요일\n6.  date.toString(): 날짜를 문자열로 반환\n7.  date.toLocaleString(location): 지역에 맞게 날짜를 문자열로 반환\n\ntoLocaleString같은 경우 사용자가 다른 지역에 있을 경우 유용하게 쓸 수 있을 거라 생각이 되었다.\n\n### 마치며\n\n너무 편하게 써왔지만 왜 원시형 변수에 \".\"을 찍고 함수를 사용할 수 있는지 고민을 안 했었다. 이제 왜를 알게 되어서 사용할 때 더 깊이 이해하고 사용할 수 있을 것 같다.\n"},{"excerpt":"어제 정리한 함수에 이어 이번엔 오브젝트를 정리해보고자 한다. 오브젝트는 이어질 클래스와도 많이 연결되어 있으므로 생성자함수 전까지만 정리해보고자 한다. 우선 정리하면서 자주 언급했던 오브젝트는 서로 연관있는 속성(property)과 행동(method)들을 묶어놓은 변수라고 할수있다. 다음과 같이 \"나\"라는 객체에 나에 대한 정보( property)와 내…","fields":{"slug":"/2022-09-14-객체/"},"frontmatter":{"date":"September 14, 2022","title":"객체","tags":["javascript","문법"]},"rawMarkdownBody":"\n어제 정리한 함수에 이어 이번엔 오브젝트를 정리해보고자 한다. 오브젝트는 이어질 클래스와도 많이 연결되어 있으므로 생성자함수 전까지만 정리해보고자 한다.\n\n우선 정리하면서 자주 언급했던 오브젝트는 <b>서로 연관있는 속성(property)과 행동(method)들을 묶어놓은 변수</b>라고 할수있다.\n\n```javascript\nconst Youngjun = {\n  gender: \"male\",\n  age: 26,\n  smile() {\n    console.log(\"웃음\")\n  },\n}\n```\n\n다음과 같이 \"나\"라는 객체에 나에 대한 정보( property)와 내가 할 행동(method)을 정리했다. 이러한 오브젝트에 대해 알아보자.\n\n## 1) Object 만들기\n\nObject를 만들 수 있는 방법에는 크게 3가지가 있다.\n\n1. `{ key: value}`\n2. new Object 사용하기\n3. object.create() 메소드 사용하기\n\n오브젝트는 \"key\"와 \"value\"로 이루어져 있는 자료형으로 3가지 방법으로 key와 value가 같은 오브젝트를 다음과 같이 만들 수있다.\n\n```javascript\nconst obj1 = { key: \"any value\" }\nconst obj2 = new Object()\nobj2.key = \"any value\"\n\nconst obj3 = Object.create({}, { key: \"any value\" })\n```\n\n첫번째는 전달해준 key와 value를 가지고 있는 오브젝트를 바로 만드는 방법으로 가장 많이 사용하는 방법이라 생각된다. 두번째는 새로운 빈 객체를 만든 뒤에 key와 value를 전달해준다. 세번째 방법은 Object의 메소드를 이용하는 방법으로, 첫번째 인자로 우리가 만들 객체의 프로토타입을, 두번째 인자로 우리가 원하는 key와 value를 가진 오브젝트를 전달해 만들었다. 확실히 첫번째 방법이 간단하고 이해가 잘되는 방법인 것같다.\n\n## 2) Object의 key와 value\n\n오브젝트의 key와 value는 서로 사용될 수 있는 자료형이 다르다. key가 될 수 있는 자료형은 <b>문자,숫자,문자열,심볼</b>이고, value가 될 수 있는 자료형은 <b>primitive 자료형과 객체</b>, 모든 자료형이 다 가능하다.\n\n```javascript\nconst Youngjun = {\n  gender: \"male\",\n  habits: [\"music\", \"game\", \"coding\"],\n  0: 300,\n  [\"biggest-goal-of-life\"]: \"성공하기\",\n}\n```\n\n위의 예제 오브젝트에서 key에서 문자열과 숫자로 담았고 문자열중에서도 \"-\"로 연결되어있는 경우에는 \"[]\"로 감싸서 전달해주어야 한다. 그냥 \"biggest-goal-of-life\"로 전달할 시에는 에러가 발생한다. 그렇기에 긴 단어의 경우에 camel case를 이용하는 게 더 나은 것 같다. value로는 habits key에 배열을 전달했는데 배열 또한 javascript에서 객체이기 때문에 사용가능하다.\n\nkey와 value는 자물쇠처럼 맞는 열쇠를 객체에 전달하면 해당하는 값을 얻을 수 있다. 이러한 key를 전달하는 방식에는 다음과 같은 2가지 방법이 있다.\n\n1. dot notation ( . )\n2. bracket notation ([ ])\n\n```javascript\nconst Youngjun = {\n  gender: \"male\",\n  age: 26,\n  smile() {\n    console.log(\"웃음\")\n  },\n}\nconst age = \"age\"\n\nconsole.log(Youngjun.gender) //\"male\"\nconsole.log(Youngjun[age]) //26\n```\n\n위와 같이 첫번째 방시인 dot notation을 이용하면 문자열 key로 되어있는 값에 접근할 수있고, bracket notation의 경우에는 변수로 값을 받을 수도 있어 좀 더 동적으로 사용할 수 있다.\n\n## 3. Object 추가 삭제\n\nObject의 key와 value를 추가하는 방법은 간단하게 앞서 언급한 2가지 접근 방법을 사용해 값을 지정해줄 수 있고, 제거할 때는 해당하는 key 값을 삭제하면 된다.\n\n```javascript\nconst Youngjun = {\n  gender: \"male\",\n  age: 26,\n  smile() {\n    console.log(\"웃음\")\n  },\n}\n\nYoungjun.height = 172\nYoungjun[\"homeAddress\"] = \"Gwangju\"\ndelete Youngjun.age\n```\n\n다음과 같이 사용해서 Youngjun 오브젝트에 키와 주소 값을 추가하고 나이 정보를 삭제할 수 있다.\n\nObject의 추가 삭제 방법과 bracket notation을 이용해 오브젝트에 값을 동적으로 추가하고 삭제하면 다음과 같이 사용할 수 있다.\n\n```javascript\nfunction addProperty(obj, key, value) {\n  obj[key] = value //obj.key=value 사용하면 안돼\n}\n\nconst Youngjun = {\n  gender: \"male\",\n  age: 26,\n  smile() {\n    console.log(\"웃음\")\n  },\n}\n\naddProperty(Youngjun, \"height\", 172)\n```\n\naddProperty함수에 오브젝트와 key와 value를 전달해 속성을 추가 해주었다. 이때 앞서 설명한 두가지 접근 방법 중 dot notation을 사용하면 항상 \"key\"라는 key에만 접근해 value를 바꾸기 때문에 사용해선 안된다. bracket notation을 이용하면 전달받은 인자를 이용해 추가할 수 있다.\n\n## 4) Object의 Method와 간단한 팁\n\n가장 처음 만든 오브젝트를 보면 smile이라는 함수를 가지고 있다. 이러한 오브젝트 내부의 함수를 <b>Method</b>라고 하고 property에 접근할 때와 동일하게 접근해 함수를 호출 할 수 있다. 그리고 오브젝트의 key와 value가 key만 전달해도 된다.\n\n```javascript\nconst gender = \"male\"\nconst age = 26\nconst Youngjun = {\n  gender, //gender:gender와 같아\n  age,\n  smile() {\n    console.log(\"웃음\")\n  },\n}\nYoungjun.smile() //\"웃음\"\n```\n\n예에서 gender와 age의 key와 value가 같으므로 축약해서 한번에 나타냈다. 이러한 특징을 이용해 좀 더 편하게 오브젝트에 값을 설정할 수 있다.\n"},{"excerpt":"시작하기 앞서 매일 TIL로 짤막하게 공부한 내용을 정리하려 했지만 하나의 주제의 맥락을 다 담기 힘든 부분이 있어서 작은 주제 하나씩 정하고 글을 써나가 보려 한다. 1) 함수의 정의 함수는 어떠한 하나의 일을 수행할 수 있는 관련 코드들의 모음이라고 할 수 있다. 함수를 잘 작성하면 관련 코드가 한 곳에 모여있기에 유지보수에 유리하고.\n필요할 때마다 …","fields":{"slug":"/2022-09-13-함수/"},"frontmatter":{"date":"September 13, 2022","title":"함수","tags":["javascript"]},"rawMarkdownBody":"\n### 시작하기 앞서\n\n매일 TIL로 짤막하게 공부한 내용을 정리하려 했지만 하나의 주제의 맥락을 다 담기 힘든 부분이 있어서 작은 주제 하나씩 정하고 글을 써나가 보려 한다.\n\n## 1) 함수의 정의\n\n함수는 어떠한 하나의 일을 수행할 수 있는 관련 코드들의 모음이라고 할 수 있다. 함수를 잘 작성하면 관련 코드가 한 곳에 모여있기에 유지보수에 유리하고.\n필요할 때마다 재 사용할 수 있으며, 가독성이 높은 장점을 갖는다. 함수는 다음과 같은 구조를 갖는다.\n\n```javascript\nfunction multiply(a, b) {\n  return a * b\n}\n```\n\n위 코드는 multiply라는 이름을 가진 함수를 선언하는 선언문이다. function이라는 키워드로 선언문을 시작하며 함수의 이름과 함수의 인자들을 순서대로\n작성한다. 코드 블럭 안에는 일처리를 위한 코드들을 담고 반환할 값은 return을 통해 전달한다.\n\n이러한 함수는 자바스크립트에서 오브젝트 데이터 타입을 가지고 있어 힙에 저장되며, 호이스팅을 통해 코드의 가장 위로 올라가 선언되어 코드 순서와 상관없이\n사용이 가능하다. (Hoisting은 중요한 주제이기 때문에 나중에 자세히 다루려 한다)\n\n함수는 오브젝트이기 때문에 갖는 또 다른 특징이 있는데 \"값을 갖는다\"는 점이다. 이러한 특징을 이용해 자바스크립트에서 만드는 방법에는 두 가지가 존재한다.\n<b>함수 선언문</b>과 <b>함수 표현식</b>이다.\n\n## 2) 함수 선언문과 함수 표현식\n\n함수 선언문은 이미 설명한 구조로 이루어져 있으며, 함수 표현식은 다음과 같이 정의할 수 있다.\n\n```javascript\n//함수 표현식의 첫번재 방법\nlet multiply = function (a, b) {\n  return a * b\n}\n\n//함수 표현식의 두번째 방법:arrow function\nmulitiply = (a, b) => {\n  return a * b\n}\n\nmultiply = (a, b) => a * b\n```\n\n함수는 오브젝트이기 때문에 함수를 가리키고 있는 주소 값을 가진다. 이 주소 값을 변수에 할당한 문이 \"함수표현식\"이며 구조는 할당하는 부분을 제외하고 선언문과 유사하다. 함수 표현식에는 위와 같은 방법 외에 <b>화살표 함수 (arrow function)</b>으로도 나타낼 수 있다. 화살표 함수는 함수 표현식보다 간략하게 표현할 수 있는 방법으로 인자를 먼저 작성한 후 =>와 함께 코드블럭을 작성한다. 이때 코드블럭 내 특정한 일을 하지 않고 반환 값만 존재한다면 생략하고 반환할 값만 작성할 수도 있다.\n\n## 3) 함수의 인자\n\n함수의 인자는 함수에 전달되는 요소들로 함수의 코드 블럭 내부 실행 컨텍스트 (자세한 부분은 클로저 부분에서 다시 설명하려 한다)에 등록된 변수라고 할 수 있다. 이러한 인자는 함수 내 오브젝트인 arguments로 전달된다.\n\n```javascript\nfunction multiply(a, b) {\n  console.log(arguments) //[1,2]\n  return a * b\n}\nmulitply(1, 2)\n```\n\n다음과 같이 전달된 인자들은 arguments 배열에 각 요소로 저장되어 있으며, 얼마나 많은 인자들이 들어올지 모를 때는 다음과 같이 <b>Rest parameters</b> 을 사용할 수 있다.\n\n```javascript\nfunction showRestParams(a, b, ...numbers) {\n  console.log(arguments) //[1,2,3,4]\n  console.log(numbers) //[3,4]\n}\nmulitply(1, 2, 3, 4)\n```\n\n## 4) 콜백함수 (Callback function)\n\n콜백함수는 자바스크립트를 공부하고 프로젝트를 진행하면서 너무나도 중요하다고 많이 느낀 부분이라 꼭 정리가 필요했던 부분이었다. 앞서 함수는 오브젝트이기 때문에 참조 값, 주소 값을 저장하고 있다고 했다. 이때 콜백 함수는 말 그대로 필요한 때에 \"call-back\", 참조 값을 이용해 다시 호출되는 함수이다.\n\n콜백함수가 가능한 이유는 자바스크립트가 일급함수 (1st-class function)를 가지고 있기 때문이다. 일급함수는 다음과 같이 정의될 수 있다.\n\n1. 다른 함수의 인자로 전달이 가능하다\n2. 함수가 다른 함수를 반환할 수 있다\n3. 변수에 할당할 수 있다\n4. 함수끼리 비교할 수 있다\n\n위와 같은 특징은 모두 함수가 오브젝트이고 오브젝트는 주소값을 변수에 저장하기 때문에 가능하다. 그렇기에 콜백함수는 다른 함수의 인자로 전달되어 반환되어 필요한 때에 사용 가능하다. 이때 함수를 인자로 받고 반환하는 함수는 <b>고차함수</b>라고 한다. 예로 브라우저 API인 setTImeOut과 같은 함수가 될 수 있다.\n\n```javascript\nsetTimeout(() => {\n  console.log(Date.now())\n}, 1000)\n```\n\nsetTimeOut은 정해진 시간 후에 전달 받은 함수를 실행하는 브라우저 API로 <b>고차함수</b>, 전달된 함수를 <b>콜백함수 (일급함수) </b>라 할 수 있다.\n\n## 5) 불변성\n\n함수를 사용해서 값을 바꾸고 할 때, 주의할 점 중 하나인 <b>불변성(immutability )</b>에 대해 정리해 보고자 한다.\n\n먼저 받은 인자가 원시형 타입의 값일 경우이다.\n\n```javascript\nfunction changeToRedColor(a) {\n  a = \"Red\"\n  return a\n}\nconst prevColor = \"blue\"\nchangeToRedColor(prevColor) //반환은 \"Red\"이지만 prevColor는 \"blue\"\n```\n\n원시형의 경우에는 전달 받은 인자의 값을 변경하더라도 블럭 외부의 변수에 영향을 끼치지 않는다. 문제는 전달한 인자가 오브젝트일 때 생긴다.\n\n```javascript\nfunction changeToRedColor(a) {\n  a.color = \"Red\"\n}\nconst prevColor = { color: \"blue\" }\nchangeToRedColor(color)\nconsole.log(a) //{color:\"Red\"}\n```\n\n위는 반환도 하지 않았지만 오브젝트 속성값이 바뀌어 버렸다. 이처럼 함수 내부에서 받은 인자를 바꾸는 코드는 예상하지 못할 에러를 만들 수 있으므로, 꼭 인자의 값을 수정해서 사용해야 한다면 이를 해결하기 위해 `{...obj}`와 같이 새롭게 오브젝트를 만드는 방법을 통해 사용해야 한다.\n"},{"excerpt":"이번주부터는 드림코딩의 브라우저101 강의를 통해 배운 API들과 자바스크립트 문법들을 함께 정리해나가려한다. API API는 application programming interface의 약자로 소프트웨어 내부에 존재하는 기능과 규칙의 집합이다. (출처: MDN API) API라는 단어는 너무 편하게 말하지만 사실 정확히 말하라고 했을 때 모호한 단어였…","fields":{"slug":"/2022-09-12-브라우저API/"},"frontmatter":{"date":"September 12, 2022","title":"Browser API","tags":["javascript","브라우저"]},"rawMarkdownBody":"\n이번주부터는 드림코딩의 브라우저101 강의를 통해 배운 API들과 자바스크립트 문법들을 함께 정리해나가려한다.\n\n## API\n\nAPI는 application programming interface의 약자로 소프트웨어 내부에 존재하는 기능과 규칙의 집합이다. (출처: [MDN API](https://developer.mozilla.org/ko/docs/Glossary/API))\n\nAPI라는 단어는 너무 편하게 말하지만 사실 정확히 말하라고 했을 때 모호한 단어였다. 청원 사이트 프로젝트를 할 때, 백엔드 팀에서 만들어준 여러 API들을 받아와 프론트의 UI들과 연결해 여러 일들을 처리하고, 브라우저 API들 또는 Youtube와 같은\n기업들의 API들을 이용해 개인 프로젝트들을 만들면서 자주 사용했지만 모호하게 느꼈던 API는 나에게 다음과 같이 정의할 수 있을 것 같다.\n\n\"클라이언트에서 요청하는 내용(Request)를 서버에서 요청에 맞게 제공하는 과정(response)\"\n\n이러한 과정은 내부에서 어떻게 설정되어있는지 모르지만 사용자가 편하게 사용할 수 있게 되어 있으며, 브라우저에는 정말 다양한 API들이 존재했다.\n\n이렇게 많은 브라우저의 API들은 window를 전역 객체 (global)로 다음과 같이 분류 될 수 있다.\n\n1. DOM (Document Object Model): HTML이 작성되어 렌더링 되는 영역\n\n2. BOM (Browser Object Model): 브라우저 자체의 정보 (프로퍼티와 메소드)를 담고 있는 영역\n\n![img](https://velog.velcdn.com/images%2Ftjdud0123%2Fpost%2F5fdd4197-125a-4790-b56f-5b0ef03fe7a0%2Fimage.png)\n\n자바스크립트는 이러한 DOM과 BOM API를 이용해 다양한 기능을 구현하는데 사용된다. 이렇게 다양한 API들이 있지만 그중에서 자주 사용되는 API들을 정리해보려 한다.\n\n### 브라우저의 크기\n\n화면의 크기, 브라우저의 크기는 다음과 같이 4가지로 정의된다.\n\n![img](https://blog.kakaocdn.net/dn/bZHQoM/btqT18YjBgT/VPYwdvpvjXA1fekKhFOU6k/img.png)\n\n[출처:[디자이너의 기록-[web] window size 및 좌표 관련 속성](https://designer-ej.tistory.com/entry/Web-window-size-%EB%B0%8F-%EC%A2%8C%ED%91%9C-%EA%B4%80%EB%A0%A8-%EC%86%8D%EC%84%B1)]\n\n- window.screen.width와 window.screen.height: 사용자가 보고있는 스크린 전체의 화면 크기\n- window.outerWidth와 window.outerHeight: 브라우저의 Tab과 스크롤바를 모두 포함한 크기\n\n- window.innerWidth와 window.innerHeight:브라우저의 Tab을 제외하고 스크롤바는 포함한 크기\n\n- document.documentElement.clientWidth와 document.documentElement.clientHeight: 브라우저의 Tab과 스크롤바를 포함한 크기\n\n위와 같이 총 4가지로 정리할 수 있다. window.screen.width와 window.screen.height은 사용자의 모니터 크기와 같으므로 브라우저의 크기를 작게 하거나\n\n크게 만들어도 달라지지 않는다. 앞서 언급한 window는 브라우저의 전역객체이기 때문에 생략하고 사용이 가능하며, resize 이벤트는 window에 이벤트 리스너를\n\n사용해야한다.\n\n```javascript\nwindow.addEventListener(\"resize\", () => {\n  console.log(window.screen.width)\n  console.log(screen.width)\n})\n```\n\n## 좌표\n\n브라우저의 좌표는 왼쪽 상단을 기준점 (0,0)으로 두고 다음과 같이 축을 가진다.\n\n![img](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png)\n\n[출처:[mdn Element.getBoundingClientRect()](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect)]\n\n위와 같이 아래로 갈수록 y좌표가 증가, 우측으로 갈수록 x좌표가 증가한다. 브라우저 위의 Element의 크기 정보는 Element.getBoundingClientRect()를 통해\n\n알 수 있다. CSS와 달리 right와 bottom도 동일한 기준점 (0,0)에서 측정한 값이므로 주의해야 한다.\n\n![pageY vs clientY](https://i.stack.imgur.com/4C3no.png)\n\n[출처:[stack-overflow](https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y)]\n\n브라우저에서의 위치를 표시할 때 두가지 종류의 좌표가 존재한다.\n\n1. Page X와 Page Y: 전체 페이지 크기에서의 좌표\n2. Client X와 Client Y: 사용자가 보고있는 viewport를 기준에서의 좌표\n"},{"excerpt":"추석에 휴일이라 많이 할 수 있을 것이라 생각했지만 그렇게 많은 것은 하지 못했다. 간단히 포트폴리오 강의를 다시 들으면서 intersection observation API를 사용했다. 여전히 어렵고 이해가 잘 안되는 부분이 많아, 예전 TIL을 참고해 다시 한 번 정리해 보고자 한다. 1) API의 배경 Intersection Observer API는…","fields":{"slug":"/2022-09-10-intersection-observer /"},"frontmatter":{"date":"September 10, 2022","title":"Intersection observer","tags":["javascript","브라우저","web"]},"rawMarkdownBody":"\n추석에 휴일이라 많이 할 수 있을 것이라 생각했지만 그렇게 많은 것은 하지 못했다.\n\n간단히 포트폴리오 강의를 다시 들으면서 intersection observation API를 사용했다.\n\n여전히 어렵고 이해가 잘 안되는 부분이 많아, 예전 TIL을 참고해 다시 한 번 정리해 보고자 한다.\n\n### 1) API의 배경\n\nIntersection Observer API는 브라우저 API로 이전에 사용했던 방식 (getBoundingClientRect와 스크롤과 연결)을 사용할 때\n\nscroll 이벤트의 경우에 eventListener와 연결하게 되었을 때, 자주 발생하는 event인데, 그때마다 우리가 원하는 요소의\n\n크기를 불러오기 위한 getBoundingClientRect로 layout을 계속 불러오게 된다.\n\n이로인한 성능저하를 해결하기 위한 API가 바로 <strong>Intersection Observer</strong>이다.\n\n### 2) API의구성\n\nintersectionObserver 오브젝트에는 observer가 observe하고 있는 DOM 요소에 intersection이 발생했을 때 실행할 **callback함수**와 Observer의 요소, 크기, 기준등을 어떻게 설정할지를 담고있는 **option**이다.\n\n#### Option\n\n```javascript\nconst option={\n root: document.querySelector(\"div\")\n rootMargin:\"0px\",\n threshold:0\n}\n```\n\nroot는 관찰하는 영역으로 null로 전달시 사용자의 화면, viewport를 의미한다. 위 코드와 같이 DOM요소를 전달하면 DOM요소의 영역을\n\n기준으로 관찰한다.\n\nrootMargin은 내가 전한 영역에 margin을 주어서 주어진 margin을 포함한 만큼을 기준으로 삼는다. 예시로 사용자가 봐야할 화면을 미리 준비할 때 크기를 넓혀 화면을 미리 준비 할 수 있다.\n\nthreshold는 관찰하는 영역에 어느정도 들어왔을 때, callback함수를 실행할지를 담고 있다. 0~1까지 숫자로 전달할 때 들어올 때는 값을 그대로 사용하고, 반대로 나가는 상태에서는 1-threshold값을 사용한다.\n\n#### callback function\n\n```javascript\nconst callback = (entries, observer) => {\n  entries.forEach(entry => {\n    // observer과 관찰하는 대상의 정보\n  })\n}\n```\n\ncallback 함수는 entries와 observer를 인자로 받는 함수로, entries는 관찰하고 있는 대상의 정보를 담고 있는 배열이다. 배열 내에 관찰하는 item들의 객체에는 **boundingClientRect**로 관찰하고 있는 요소의 위치,크기와 같은 정보를 주고, **intersectionRatio**로 현재 영역에 얼마만큼 들어와 있는지, **isIntersecting**으로 앞으로 들어올 대상인지 이미 보이고 있어서 사라질 지를 알려준다. 이외에도 대상의 다양한 정보들을 담고 있다.\n\nobserver를 쓰는 예제는 아직 보지 못해 사용하지 않았다.\n\n### Observer\n\n```javascript\nconst observer = new IntersectionObserver(callback, option)\nconst sections = document.querySelectorAll(\".section\")\nsections.forEach(section => {\n  observer.observe(section)\n})\n```\n\n앞서 알아본 callback과 option을 observer에 전달하면 observer.observe()의 인자로 대상을 전달해 관찰할 수 있다.\n\n위와 같은 3가지 요소를 이용해 API를 사용할 수 있다. 이때 활용할 수 있을 요소는 다양하지만 아직 부족해 다시 포트폴리오 페이지를\n\nReact를 이용해 만들 때, 더 자세히 공부해보고자 한다.\n"},{"excerpt":"Javascript 어제 공부했던 변수를 이어서 객체와 copy by value와 copy by reference에 대한 공부를 했다. 객체 객체는 key와 value로 이루어진 자료형으로 자바스크립트에서 primitive 자료형을 제외한 함수, 배열과 같은 모든 자료형이 객체로 이루어져있다고 할 수 있다. 객체는 어떠한 데이터와 관련된 상태(proper…","fields":{"slug":"/2022-09-07-자바스트립트의-두가지-복사방법/"},"frontmatter":{"date":"September 07, 2022","title":"자바스크립트의 두가지 복사 방법","tags":["javascript","문법"]},"rawMarkdownBody":"\n### Javascript\n\n어제 공부했던 변수를 이어서 객체와 copy by value와 copy by reference에 대한 공부를 했다.\n\n#### 객체\n\n객체는 key와 value로 이루어진 자료형으로 자바스크립트에서 primitive 자료형을 제외한 함수, 배열과 같은 모든 자료형이 객체로 이루어져있다고 할 수 있다.\n\n```javascript\nconst obj = { name: \"Youngjun Choi\" }\n```\n\n객체는 어떠한 데이터와 관련된 상태(property)와 행동(method) 으로 구성되어있다. 객체는 원시형 데이터들에 비해 크기가 크기 때문에 메모리 cell에 직접 저장되어있는 것이 아니라 Heap에 저장되어있고 객체를 저장한 변수에는 저장되어있는 주소가 저장되어 있다. 그렇기에 앞서 공부했던 자료형들과 다르게 작동한다.\n\n![디버깅 결과를 정리한 코드](컴파일러-인터프리터.png)\n\n[출처:https://charming-kyu.tistory.com/19]\n\n#### Copy by value\n\n```javascript\nlet a = \"a\"\nlet b = a //b=1\nb = \"b\" //b=3,a=1\n```\n\na의 값을 b가 복사한 후에 b의 값을 변경했을 때, a는 영향을 받지 않는다.\n\n그 이유는 a에는 \"a\"라는 값 자체가 메모리 셀에 저장되었고, 값이 복사되어 b에 할당되었기 때문이다.\n\n#### Copy by Reference\n\n```javascript\nlet a = { firstName: \"Youngjun\", lastName: \"Choi\" } //a는 오브젝트의 주소값을 저장\nlet b = a //b에 오브젝트의 주소값을 복사\nb.lastName = \"Park\" //b={firstName:\"Youngjun\",lastName:\"Park\"}, a={firstName:\"Youngjun\",lastName:\"Park\"}\n```\n\n위와 달리 object의 주소값을 저장하던 a의 값을 복사한 후에 b의 값을 변경했을 때, 다른 결과를 나타낸다.\n\nb의 값을 변경했지만 같은 주소의 오브젝트를 가리키고 있던 a의 값 또한 변했다.\n\n이러한 Object의 특성을 제대로 이해하고 보니 리액트에서의 useState와 같은 상태를 다룰 때 \"왜 리랜더링을 위해서 오브젝트나 배열을 새로 할당해주어야 하는지\"를 제대로 이해할 수 있었다. 상태 내의 값을 바꿀 경우, 주소값을 동일하게 저장하고 있어 브라우저입장에서는 상태가 바뀐 줄 알 수 없기 때문이었다.\n\n그냥 이렇게 해야하는게 아니라 왜 해야하는지 조금씩 납득이 되어가고 더 깊이 이해할 수 있었다.\n"},{"excerpt":"1. 자바스크립트의 타입 자바스크립트는 dynamic 프로그래밍 language로 동적으로 타입이 결정되는 언어이다. 자바스크립트는 컴파일러가 아니라 interpreter언어이기 때문이다. 위 두가지의 차이를 정리를 해보고자 한다. 컴파일러와 인터프리터 우리가 쓰는 언어 (high-level)를 컴퓨터가 이해할 수 있게 변환해주는 방식에 따라 컴파일러와 …","fields":{"slug":"/2022-09-07-자바스크립트의-타입과연산자/"},"frontmatter":{"date":"September 07, 2022","title":"자바스크립트의 타입과 연산자","tags":["javascript"]},"rawMarkdownBody":"\n### 1. 자바스크립트의 타입\n\n자바스크립트는 dynamic 프로그래밍 language로 동적으로 타입이 결정되는 언어이다. 자바스크립트는 컴파일러가 아니라 interpreter언어이기 때문이다. 위 두가지의 차이를 정리를 해보고자 한다.\n\n##### 컴파일러와 인터프리터\n\n우리가 쓰는 언어 (high-level)를 컴퓨터가 이해할 수 있게 변환해주는 방식에 따라 컴파일러와 인터프리터로 나뉘게 된다.\n\n![컴파일러-인터프리터.png](..%2F2022-09-07-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%EB%B3%B5%EC%82%AC%EB%B0%A9%EB%B2%95%2F%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0.png)\n\n출처: [difference-compiler-vs-interpreter](https://www.guru99.com/difference-compiler-vs-interpreter.html)\n\n##### 1) 컴파일러\n\n컴파일러는 우리가 작성한 언어를 실행전에 모든 코드를 검사하고 machine code로 바꾸어주는 작업을 먼저한다. 이렇게 만들어진 machine code로 인해 타입이 정적으로 정해진다.\n\n그렇기 때문에 machine code로 바꾸는 데 시간이 걸리지만 만들고 나서는 실행이 빠른 장점을 갖는다. 컴파일러 언어에는 C, Java와 같은 언어가 있다.\n\n##### 2) 인터프리터\n\n인터프리터는 우리가 작성한 언어를 한줄한줄 런타임에서 읽어 해석한다. 그렇기에 machine code로 바꾸는 작업이 없지만 실행과 함께 한줄 한줄 읽어 나가기 때문에 실행속도는 느린 단점이 있으며, 타입이 동적으로 정해진다.\n인터프리터 언어에는 Python, javascript와 같은 언어가 있다.\n\n내가 공부하고 있는 javascript는 인터프리터로 내가 쓴 코드를 javscript engine은 한 줄, 한 줄 읽으면서 해석하기 때문에\n타입이 동적으로 결정되어 내가 처음에 number로 정한 변수가 나중에는 string으로 바뀌어도 에러를 던지지 않는다.\n\n```javascript\nlet number = 3\nnumber = \"3\"\nconsole.log(number) //\"3\"\n```\n\n이렇게 유동적인 점은 빠르게 개발할 때는 좋지만, 복잡해질 수록 개발자에게는 오류를 만들 수 있는 부분이 되기 때문에 Typescript언어가 나오게 되었다.\n\n### 연산자와 형변환\n\n##### 1. 산술 연산자\n\n+, -, \\*, /, %, \\*\\* 와 같이 계산을 위한 기호를 의미한다.\n\n여기서 주의할 점은 +인데 자바스크립트는 다른 type간의 +가 가능하다.\n\n```javascript\nconst text = 1 + \"1\" //\"11\"\n```\n\n위와 같이 숫자와 string 타입간의 더하기를 통해 결과가 string으로 나오는 것을 볼 수 있다.\n\n##### 2. 단항 연산자\n\n단항연산자는 양수,음수를 표현하기 위한 +,-와 부정을 의미하는 !가 있다.\n\n여기서 유용한 점은 +와 !!를 이용해 형변환이 가능하다는 점이다.\n\n```javascript\n;+false + //0\n  null + //0\n  true + //1\n  \"text\" + //NaN\n  undefined / NaN +\n  \"3\" //3\n\n!3 //false\n!!3 //true\n!!\"\" //false\n```\n\n위와 같은 방법으로 형변환을 할 때, Truthy와 falsy값을 생각하면 좀 더 이해하기 쉬웠다.\n\nTruthy한 값을 숫자로 형변환할 때는 1로, falsy한 값을 숫자로 변환하면 0으로 변환되었다.\n\n##### 3. 할당 연산자\n\n할당연산자는 간단하게 연산식을 표현하기 위한 연산자다.\n\n```javascript\nlet a = 3\na += 2 //a=a+2;\na -= 2 //a=a-2;\na *= 2 //a=a*2;\na /= 2 //a=a/2;\na %= 2 //a=a%2;\na **= 2 //a=a**2;\n```\n\n##### 4. 증감 연산자\n\n증감 연산자는 간단하게 변수를 1 증가,1 감소를 표현하는 연산자다. 간편하지만 앞에 붙이냐 뒤에 붙이냐에 따라 달라질 수 있으니 주의하자\n\n```javascript\nlet a = 100\nconst b = a++\nconsole.log(b, a) //100,101\n\na = 100\nconst b = ++a\nconsole.log(b, a) //101,101\n```\n\n++a 경우에 1을 증가시키는 걸 먼저한 후에 필요한 계산을 하라는 의미가 되며, a++ 경우에는 필요한 계산을 먼저한 후에 1을 증가시키라는 의미가 된다. 어떤 걸 사용해도 동일할 때도 있지만 상황에 따라 달라질 수 있으니 주의할 필요가 있다.\n\n##### 5. 비교 연산자\n\n비교 연산자는 `>,<,>=,<=` 4가지로 간단하다. `=<`와 같이 쓸 때가 있는데 인식하지 못하니 주의하자\n\n##### 6. 연산자 우선순위\n\n우선순위는 항상 괄호가 높으므로 필요한 연산에는 괄호를 꼭 사용하자. 기본적으로는 \\*, / 가 + , - 보다 우선순위가 높다.\n\n##### 7. 동등 비교 연산자\n\n동등 비교연산자는 (==, !=) 와 (===,!==) 로 값이 같은 지를 비교할 수 있다. 이때 두가지의 차이점은 ==와 !=는 값만 비교하는 반면 ===와 !==는 값과 타입을 같이 비교한다. 실제 개발할 때는 타입까지 고려한 ===과 !==를 이용하는 게 좋다.\n\n```javascript\nconst num1 = 2\nconst num2 = \"2\"\nconsole.log(num1 == num2) //true\nconsole.log(num1 === num2) //false\n```\n\n- key와 value가 같은 오브젝트 비교\n\n```javascript\nconst obj1 = { firstname: \"Youngjun\" }\nconst obj2 = { firstname: \"Youngjun\" }\nconst obj3 = {}\nconst obj4 = {}\nconsole.log(obj1 == obj2) //false\nconsole.log(obj3 == obj4) //false\n```\n\n위에 키와 값이 같은 오브젝트 2가지를 비교했지만 결과는 false이다. 그이유는 어제 공부했던 오브젝트를 저장하는 변수에는 오브젝트 자체가 아닌 오브젝트를 보관하고 있는 곳의 메모리 주소가 저장되기 때문이다. 그렇기에 새롭게 만들어지는 오브젝트는 항상 서로 다르다고 할 수 있다.\n"},{"excerpt":"5 개월 간의 학원에서 강사 생활을 끝내고 이번 주부터 좀 더 집중적으로 개발 공부를 할 수 있게 되었다. 틈틈이 쪼개서 공부하다 보니 공부해 온 것들이 산발 적으로 흩어져 있다는 생각이 들었다. 우선 가장 기본이 되는 HTML, CSS, Javascript에 대한 복습을 했다. HTML과 CSS BEM (Block-Element-Modifier) HTM…","fields":{"slug":"/2022-09-06-BEM과-자료형/"},"frontmatter":{"date":"September 06, 2022","title":"BEM과 자바스크립트의 자료형","tags":["css","javascript","문법"]},"rawMarkdownBody":"\n5 개월 간의 학원에서 강사 생활을 끝내고 이번 주부터 좀 더 집중적으로 개발 공부를 할 수 있게 되었다.\n\n틈틈이 쪼개서 공부하다 보니 공부해 온 것들이 산발 적으로 흩어져 있다는 생각이 들었다.\n\n우선 가장 기본이 되는 HTML, CSS, Javascript에 대한 복습을 했다.\n\n## HTML과 CSS\n\n### BEM (Block-Element-Modifier)\n\nHTML을 사용하는 데에는 큰 무리가 없었지만 여전히 부족한 부분은 class의 이름을 naming하는 부분이었다.\n\nReact를 사용하지 않고 CSS와 연결하기 위해 BEM을 다시 공부하고 정리해 보았다.\n\nBEM은 Block-Element-Modifier를 줄인 CSS 방법론으로 React와 같이 모듈화가 가능한 경우에는 사용하지 않지만 모듈화를 할 수 없을 때에\n\nclass간의 충돌을 피하기 위해 사용한다.\n\n![Inside a card component, buttons can be a BEM element](https://scalablecss.com/static/04158e912667d940eeb914f724379072/37523/nesting-elements-within-block.png)\n\n[그림 출처, scalableCss](https://scalablecss.com/bem-blocks-within-blocks/)\n\n위와 같은 그림에서 큰 component에 해당하는 card가 block, component를 이루고 있는 image, title, description,button이 element에 해당되게 된다.\n\n그림을 이용한 코드는 다음과 같다.\n\n```html\n<div class=\"“card--dog”\">\n  <img class=\"“card__image”\" />\n  <h2 class=\"“card__title”\">I am a card</h2>\n  <p class=\"“card__description”\">I am the card paragraph</p>\n  <!-- The button is an element inside the block -->\n  <a class=\"“card__button”\">Learn more</a>\n</div>\n\n<div class=\"“card--cat”\">\n  <img class=\"“card__image”\" />\n  <h2 class=\"“card__title”\">I am a card</h2>\n  <p class=\"“card__description”\">I am the card paragraph</p>\n  <!-- The button is an element inside the block -->\n  <a class=\"“card__button”\">Learn more</a>\n</div>\n```\n\n위 코드에서 component는 \".card\"로, element들은 `.card__title` 과 같이 \\_\\_로 표현된다.\n\nmodifier는 강아지 사진을 담고 있는 카드의 경우 `.card--dog`으로 표현이 가능하고, 고양이 사진을 담고 경우 `.card--cat`과 같이 표현이 가능하다.\n\n이러한 BEM의 장점은 구분이 잘된다는 점이지만 단점으로는 점점 길어지고 component가 복잡해 질 수록 작성해야 하는 코드 양이 증가하게 된다.\n\n## Javascript\n\n자바스크립트의 문법의 기초 중 변수, 자료형에 대해 공부했다.\n\n변수를 선언하는 방법은 상수를 선언하는 'const'와 변할 수 있는 'let' 두 가지가 존재한다. (var는 문제가 많아서 제외)\n\n언급한 두 가지 방법을 통해 메모리에 우리가 원하는 데이터를 임시로 저장하게 되는데 이때 다음과 같은 일이 일어난다.\n\n1. 변수를 선언하면 (variable declaration) 메모리 cell의 특정 부분을 가리키게 된다.\n\n2. 변수를 할당하면 (variable assignment) 메모리 cell에 특정 값을 저장한다.\n\n#### Number\n\n자바스크립트는 다른 언어들과 다르게 메모리 크기를 크게 고려하지 않고 저장할 수 있는데 Number 자료형은 실수, 음수 등 모두 담을 수 있고\n\n`103/0` 이나 `23/-0` 과 같은 경우는 INFINITY로 표현한다.\n\n문자열을 숫자로 간단하게 변환할 때 `+`를 이용할 수 있다.\n\n#### String\n\n문자열을 입력할 때 `\"\"`, `''`와 함께 back tick을 이용한 template literals 세가지 방식이 존재한다.\n\n```javascript\nlet string = \"hello world!\"\nstring = \"halo world!\"\n\nconst word = \"world\"\nstring = \"hello \" + word + \"!\"\nstring = `hello ${word}`\n```\n\nBack tick (``)은 큰따옴표 (\"\")와 작은 따옴표로 표현하기 힘든 표현들을 위한 문법으로 변수를 ${}에 넣어, 일일이 조합을 고민하지 않고 원하는 문자열을 만들 수 있는 편리함을 준다.\n\n##### 이스케이프 문자\n\n이스케이프 문자는 문자열 내 특정 기호를 의미하며 백스페이스(\\\\)와 조합해 사용된다.\n\n1. `\\n`: 띄어쓰기\n2. `\\t`: 탭\n3. `\\\\`: 백스페이스\n4. `\\u`:유니코드\n\n### Boolean\n\n불리언은 간단하게 true와 false를 가진다. 이때 중요한 부분은 falshy와 truthy 값이다.\n\nboolean으로 자료형을 변환할 때는 간단하게 `!!`을 이용할 수 있다.\n\n##### Falshy\n\n1. 0,-0\n2. 빈 문자열(\"\")\n3. null\n4. undefinded\n5. NaN(not a number)\n\n##### Truthy\n\n1. 0이 아닌 숫자\n2. 빈 문자열이 아닌 문자열 (\"False\"도 가능)\n3. 객체 (비어있어도 true)\n4. Infinity\n5. 배열 (비어있어도 true)\n\n### Empty 표현\n\n자바스크립트 내 두 가지 비어있다는 표현, undefined와 null은 다음과 같은 차이점을 가지고 있다.\n\n#### undefined\n\nundefined의 경우에 말 그대로 아직 정해지지 않아 변수가 선언은 되었지만, 해당 메모리에 값이 할당되지 않은 상태를 가리킨다.\n\n#### null\n\nnull의 경우에는 변수가 선언되고 메모리에 비어있는 object가 할당되어 있는 상태를 가리킨다.\n\n- 여기서 특이한 점은 null의 type이 object라는 점이다. primitive 자료형이지만 type으로는 null을 가리키고 있는데 이러한 아이러니는 초기 자바스크립트를 개발하면서 생긴 오류라고 한다.\n\n[참조]\n[null===object에 대한 고찰](https://blog.naver.com/gofkdvjvl/222166705113)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}