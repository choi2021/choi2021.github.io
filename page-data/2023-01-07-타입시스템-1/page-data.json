{"componentChunkName":"component---src-templates-post-jsx","path":"/2023-01-07-타입시스템-1/","result":{"data":{"site":{"siteMetadata":{"title":"Troy DevLog"}},"markdownRemark":{"id":"30f66428-af72-5c78-bf83-6adedb7f226b","excerpt":"🎚 타입시스템 타입 시스템은 타입스크립트를 사용하는 큰 이유 중 하나다. 타입을 통해 안전하고 효율적으로 코드를 작성할 수 있게 도와주기 때문에 타입스크립트를 잘한다는 것의 의미가 현재 에 있다. 그렇기 때문에 최대한 구체적으로 타입을 정의하기 위해 타입시스템에 대해 알아보자 🤔 타입 추론 타입스크립트는 똑똑하기 때문에 우리가 작성한 코드에 명시적으로 전…","html":"<h1>🎚 타입시스템</h1>\n<p>타입 시스템은 타입스크립트를 사용하는 큰 이유 중 하나다. 타입을 통해 안전하고 효율적으로 코드를 작성할 수 있게 도와주기 때문에 타입스크립트를 잘한다는 것의 의미가 현재 <code class=\"language-text\">얼마나 타입을 잘 정의하냐</code>에 있다. 그렇기 때문에 최대한 구체적으로 타입을 <code class=\"language-text\">잘</code>정의하기 위해 <strong>타입시스템</strong>에 대해 알아보자</p>\n<h2>🤔 타입 추론</h2>\n<p>타입스크립트는 똑똑하기 때문에 우리가 작성한 코드에 명시적으로 전달하지 않아도 코드의 흐름을 통해 추론해준다. <code class=\"language-text\">const s=\"string\"</code>이라는 코드를 작성하면 자동으로 <code class=\"language-text\">s</code>에는 <code class=\"language-text\">string</code>타입이 할당된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// number[]</span>\n  bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">'fred'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 예제의 x는 <code class=\"language-text\">[1,2,3]</code>을 보고 <code class=\"language-text\">number[]</code>을 타입으로 추론했다. 하지만 만약에 배열의 길이가 정해져 있는 <code class=\"language-text\">Tuple</code>이었다면 위의 타입은 이후에 에러를 만들 수 있는 코드가 된다. </p>\n<p>그래서 최대한 <strong>구체적으로</strong> 타입을 정해주는 것이 중요하며 대부분의 라이브러리에는 사용하는 속성과 메소드에 대한 정보들이 <code class=\"language-text\">d.ts</code>로 끝나는 파일에 정리되어 있기 때문에 참고할 수 있다.</p>\n<p>[<code class=\"language-text\">lib.es2015.core.d.ts</code>의 Array interface]</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/ee504003e432af4eb0643108f285eaaf/46d5f/dts.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 62.94117647058823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcElEQVR42o1Si47jIAzMl1xTsAEbjCF9bCvd/3/XTbrtaqXbns5yCBlh45nJYrNLU7VarRUVTswpcc5ZMjEdQzi+j8WmN7faGxItshS0kCqyr4p9eF+/EEUmwnVYiB5XfZ4Oj/xnLMJcOUnSzCWVFEI8/ncsIFvRgNb18R0+Iz7fX8CPwy/zw+f52odLqyCp1rJKNdGmu5BNSi3VLZd8fPb/Vrzdx+V2H6cB2fvmbfou4ei1G2oAqilUDDGur+KvJsu8ju5n6zhkzb17tWFatXtruFYk55QyZ1gIcjEQBaYnhaXWLmWqurZRzWcvDueqwP7TbIYRpGCI0VUUolJJpIVegm0CtgyYY6QYmTFhykSJAwMCQkB+Hdb1gGef+fCaezndt4/778vt6qcBzn0DeSQ2bpvPC8AOCd6ofZvb+WZjtOEYEjlw2pu5NYPuuwUgDrY/FBdVTo2SpgJtYFOB7TAmg1sOsguG3zzi8y+njn8A9BR1u5PQ2OAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='d.ts' title='' src='/static/ee504003e432af4eb0643108f285eaaf/ca1dc/dts.png' srcset='/static/ee504003e432af4eb0643108f285eaaf/e7570/dts.png 170w,\n/static/ee504003e432af4eb0643108f285eaaf/f46e7/dts.png 340w,\n/static/ee504003e432af4eb0643108f285eaaf/ca1dc/dts.png 680w,\n/static/ee504003e432af4eb0643108f285eaaf/02d09/dts.png 1020w,\n/static/ee504003e432af4eb0643108f285eaaf/9d567/dts.png 1360w,\n/static/ee504003e432af4eb0643108f285eaaf/46d5f/dts.png 1364w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>d.ts</figcaption>\n  </figure></p>\n<h2>🗂타입과 집합의 관계</h2>\n<p>아래 그림을 통해 엄청나게 다양한 타입이 존재하는 것을 알 수 있다. 이러한 타입시스템을 이해하기 위해서 타입을 <code class=\"language-text\">집합</code>으로 이해해야 한다.</p>\n<p><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/08/Relationships-between-the-various-TypeScript-data-types-1024x525.png\" alt=\"img\"></p>\n<p>타입과 집합이라니... 관련이 없어 보이지만, 자바스크립트에서 프로토타입의 부모 자식 관계가 있듯이, 타입들에도 집합 관계가 있다. <code class=\"language-text\">unknown</code> type은 알 수 없기 때문에 어떤 것이든 다 될 수 있는 가장 큰 집합으로 <code class=\"language-text\">never</code>는 어떤 요소도 포함하지 않는 가장 작은 집합으로 이해할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">   <span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Type 'number' is not assignable to type 'never'.</span></code></pre></div>\n<h3>unit type</h3>\n<p>하나의 값을 가리키는 타입은 <code class=\"language-text\">unit type</code> 또는 <code class=\"language-text\">literal type</code>이라고 불리는 타입이다. 값을 직접 type에 명시한다.   </p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">  <span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Union Type</h3>\n<p>하나가 아니라 타입에 여러 값을 함께 나타내기 위해서 <code class=\"language-text\">union type</code>이 존재한다. <code class=\"language-text\">union type</code>은 여러 개의 타입을 합한 <code class=\"language-text\">합집합</code>으로 <code class=\"language-text\">|</code>으로 나타낸다.</p>\n<p><img src=\"https://python.bakyeono.net/img/img-5-7.png\" alt=\"그림 5-7 A와 B의 합집합\"></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">AB</span></span> <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ab<span class=\"token operator\">:</span> <span class=\"token constant\">AB</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span> <span class=\"token operator\">?</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> c<span class=\"token operator\">:</span><span class=\"token constant\">AB</span><span class=\"token operator\">=</span><span class=\"token string\">\"C\"</span> <span class=\"token comment\">// Type '\"C\"' is not assignable to type 'AB'</span></code></pre></div>\n<p>위 예제에서 <code class=\"language-text\">ab</code>는 <code class=\"language-text\">AB</code> 유니온 타입으로 되어 있어 <code class=\"language-text\">\"A\"</code>나 <code class=\"language-text\">\"B\"</code>가 할당될 수 있다. <code class=\"language-text\">c</code>는 <code class=\"language-text\">AB</code>타입에 정의한 <code class=\"language-text\">\"A\"</code> 또는 <code class=\"language-text\">\"B\"</code>의 부분집합이 아니기 때문에 에러가 발생한다.  즉 타입 체크를 한다는 것은 <strong>어떤 집합이 다른 집합의 부분집합이 될 수 있는지</strong> 를 확인하는 것이다.</p>\n<h3>Intersection Type</h3>\n<p>여러 개 타입을 동시에 만족하는 부분 집합, <code class=\"language-text\">교집합</code>을 <code class=\"language-text\">Intersection Type</code>이라고 하며 <code class=\"language-text\">&amp;</code>으로 나타낸다.</p>\n<p><img src=\"https://python.bakyeono.net/img/img-5-8.png\" alt=\"그림 5-8 A와 B의 교집합\"></p>\n<p>여기서 이해하기 어려웠던 부분이 \"둘 다 만족한다\"고만 생각해 <code class=\"language-text\">Union type</code>와 차이가 이해되지 않았지만 집합으로 생각해보니 이해가 쉬웠다. 동시에 만족한다는 것은 <code class=\"language-text\">두 집합의 조건을 모두 만족한다는 의미</code>를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">dogPerson</span> <span class=\"token punctuation\">{</span>\n  loveDog<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">catPerson</span> <span class=\"token punctuation\">{</span>\n  loveCat<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Both</span> <span class=\"token operator\">=</span> dogPerson <span class=\"token operator\">&amp;</span> catPerson<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> person1<span class=\"token operator\">:</span> Both <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  loveDog<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  loveCat<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 예제에서 강아지와 고양이를 모두 좋아하는 person1은 <code class=\"language-text\">loveDog</code>과 <code class=\"language-text\">loveCat</code>을 모두 true로 가지고 있어야 한다. 둘 다 만족한다는 것은 두 가지 type을 모두 만족해야 하는 것을 알 수 있다.</p>\n<p>집합 관계를  다양한 예제를 통해 좀 더 알아보자.</p>\n<h4>keyof와 함께 사용하는 union type과 intersection type</h4>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">dogPerson</span> <span class=\"token punctuation\">{</span>\n  loveDog<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">catPerson</span> <span class=\"token punctuation\">{</span>\n  loveCat<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Both</span> <span class=\"token operator\">=</span> dogPerson <span class=\"token operator\">&amp;</span> catPerson<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">K</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">keyof</span> <span class=\"token punctuation\">(</span>dogPerson <span class=\"token operator\">|</span> catPerson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//  (keyof A) &amp; (keyof B) </span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span><span class=\"token operator\">=</span> <span class=\"token keyword\">keyof</span><span class=\"token punctuation\">(</span>dogPerson <span class=\"token operator\">&amp;</span> catPerson<span class=\"token punctuation\">)</span> <span class=\"token comment\">//  (keyof A) | (keyof B)</span>\n\n<span class=\"token keyword\">const</span> a<span class=\"token operator\">:</span> <span class=\"token constant\">K</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"loveDog\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Type 'string' is not assignable to type 'never'.</span>\n<span class=\"token keyword\">const</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">=</span> <span class=\"token string\">'loveDog'</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p><code class=\"language-text\">K</code>는 합집합의 key로 교집합인 <code class=\"language-text\">never</code> type이 되고, T는 교집합의 key이기 때문에 A의 key와 B의 key의 <code class=\"language-text\">\"loveDog\"|'loveDog'</code>가 된다. 이부분은 아직 와닿지 않아서 계속해서 공부가 필요한 부분인 것 같다.</p>\n<h4>extends</h4>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">dogPerson</span> <span class=\"token punctuation\">{</span>\n  loveDog<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">catPerson</span> <span class=\"token punctuation\">{</span>\n  loveCat<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Both</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">dogPerson</span><span class=\"token punctuation\">{</span>\n    loveCat<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞서 <code class=\"language-text\">intersection type</code>으로 정의했던 관계를 extends를 이용해 상속 관계로도 이해할 수 있다. 부모의 속성을 자식이 전달 받기 때문에 자식을 subset 부모를 superset이라고 부르는 집합 관계와 상속 관계가 일치하는 것을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PointKeys</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">keyof</span> Point<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"x\"|\"y\"</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">sortBy</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>vals<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ..</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> pts<span class=\"token operator\">:</span> Point<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>pts<span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// T: Point[] K:\"x\"</span>\n<span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>pts<span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// T: Point[] K:\"y\"</span>\n<span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>pts<span class=\"token punctuation\">,</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// T: Point[] K:\"z\" // Argument of type '\"z\"' is not assignable to parameter of type 'keyof Point'.</span></code></pre></div>\n<p>위의 <code class=\"language-text\">generic</code>을 이용한 예시를 보면 T에는 <code class=\"language-text\">point[]</code>타입이 K에는 \"x\", \"y\", \"z\"가 들어간다. K는 K의 key의 부분집합이어야하므로 \"z\"는 point의 <code class=\"language-text\">\"x\"|\"y\"</code> 집합에 속하지 않기 때문에 에러가 발생하는 것을 볼 수 있다. </p>\n<h2>⁉ 값과 타입 구분하기</h2>\n<p>자바스크립트에서는 값만 신경써서 이름을 정하면 됐지만 타입스크립트를 사용하면서 type에도 네이밍이 필요해졌다. 내가 정의한 것이 <code class=\"language-text\">값</code>인지 <code class=\"language-text\">타입</code>인지를 이해할 필요가 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Cylinder</span> <span class=\"token punctuation\">{</span>\n  radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Cylinder</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> radius<span class=\"token punctuation\">,</span> height <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// Cannot redeclare block-scoped variable 'Cylinder'.</span></code></pre></div>\n<p>같은 이름으로 타입과 값 모두 정의할 수 있기 때문에 구분할 수 있는 네이밍이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Cylinder</span> <span class=\"token punctuation\">{</span>\n  radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateVolume</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shape <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Cylinder</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 'Cylinder' only refers to a type, but is being used as a value here.</span>\n    shape<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>네이밍 문제 뿐 아니라 타입을 값처럼 사용해 오류를 만들기도 한다. <code class=\"language-text\">instanceof</code>는 런타임 연산자로 값을 확인한다.  Cylinder가 타입이기 때문에 에러가 난 것을 볼 수 있다.</p>\n<p>이러한 문제를 해결할 수 있는 방법으로는 값과 타입 모두 될 수 있는 <code class=\"language-text\">class</code> 를 사용해 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Cylinder</span> <span class=\"token punctuation\">{</span>\n  radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateVolume</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shape <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Cylinder</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 'Cylinder' only refers to a type, but is being used as a value here.</span>\n    shape<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>typeof</h3>\n<p><code class=\"language-text\">typeof</code>는 class처럼 타입과 값의 의미를 모두 가진다. 타입으로 쓰일 때는 해당 값의 타입을 읽고, 값으로 쓰일 때는 해당 값의 타입을 문자열로 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> v <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> Cylinder<span class=\"token punctuation\">;</span> \n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token comment\">// function</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token operator\">=</span> InstanceType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> Cylinder<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Cylinder</span>\n\n<span class=\"token comment\">// type InstanceType&lt;T extends abstract new (...args: any) => any> =</span>\n<span class=\"token comment\">//   T extends abstract new (...args: any) => infer R ? R : any;</span></code></pre></div>\n<p>위 예제에서 typeof가 값으로 쓰여 v가 <code class=\"language-text\">\"function\"</code>문자열 값으로 반환되었고, 타입으로 쓰일 경우 Generic과 함께 쓰여 <code class=\"language-text\">C</code>의 타입이 Cylinder로 나온 것을 볼 수 있었다. 여기에 쓰인 <code class=\"language-text\">InstanceType</code>은 유틸리티 타입으로  생성자 함수 T의 instance type을 의미한다. </p>\n<h3>Branket 접근자</h3>\n<p>오브젝트의 속성 접근자인 <code class=\"language-text\">[]</code>는 타입에서도 동일하게 <code class=\"language-text\">타입의 속성의 타입정보</code>를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  first<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  last<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">PersonEl</span> <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">[</span><span class=\"token string\">'first'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'last'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Person2</span> <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Cannot access 'Person.first' because 'Person' is a type, but not a namespace.</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Tuple</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> Date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TupleEl</span> <span class=\"token operator\">=</span> Tuple<span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>구조 분해 할당</h3>\n<p>구조 분해 할당으로 자주 사용하는 경우는 react에서 전달 받은 props를 구조 할당 분해로 타입을 명시해 줄 때였다. 길어질 수 있기 때문에 type을 따로 빼서 정의하는 게 가독성에 좋았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">AdminDescriptionItemType</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  item<span class=\"token operator\">:</span> DescriptionType<span class=\"token punctuation\">;</span>\n  name<span class=\"token operator\">:</span> DescriptionNameType<span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">onDelete</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> DescriptionNameType<span class=\"token punctuation\">,</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">onChange</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> DescriptionNameType<span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">AdminDescriptionItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  item<span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">,</span>\n  onDelete<span class=\"token punctuation\">,</span>\n  onChange<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> AdminDescriptionItemType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...생략</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>😁 타입 단언 보다 타입선언</h2>\n<p>타입 단언 (type assertion)은 추론한 타입과 상관없이 개발자가 정의한 타입을 우선순위로 두기 때문에 오류가 발생할 확률이 높아진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> alice<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Alice'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> bob <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> Person<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">alice</code>의 경우 타입 선언을 이용해 타입 체크하기 때문에 명시된 값의 타입이 맞는 지를 보지만, <code class=\"language-text\">bob</code>은 내가 정의한 Person이라고 지정하게 되어 오류를 던지지 않는다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> alice<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Alice'</span><span class=\"token punctuation\">,</span>\n  occupation<span class=\"token operator\">:</span> <span class=\"token string\">'td'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Type '{ name: string; occupation: string; }' is not assignable to type 'Person'.</span>\n\n<span class=\"token keyword\">const</span> bob <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'bob'</span><span class=\"token punctuation\">,</span>\n  occupation<span class=\"token operator\">:</span> <span class=\"token string\">'js'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> Person<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이번에는 <code class=\"language-text\">Person</code>에서 정의한 속성 외의 추가 속성이 있을 때로 <code class=\"language-text\">alice</code>의 경우 기존 정의한 속성외의 다른 속성이 있음을 오류로 알려 주지만, <code class=\"language-text\">bob</code>은 Person으로 이미 타입체크를 했다고 전달하는 것과 같아 오류가 없는 것을 볼 수 있다.</p>\n<h3>타입 선언 시 주의할 점</h3>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> people <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'alice'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bob'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'jan'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {name:string}[]</span></code></pre></div>\n<p>위의 경우 타입이 <code class=\"language-text\">Person[]</code>이 되기를 기대했지만 <code class=\"language-text\">{name:string}[]</code>로 type이 정해진다. 이러한 경우는 체이닝을 이어나갈 때 type 에러를 만들기 때문에 항상 예상하는 타입과 같게 만들기 위해 <u>중간 단계의 예측한 타입을 명시함</u>으로써 오류가 발생한 곳을 빠르게 찾아나갈 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> people<span class=\"token operator\">:</span> Person<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'alice'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bob'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'jan'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Person <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>🙄 타입 단언은 언제 쓸까?</h2>\n<p>타입 단언이 필요한 경우는 <strong>내가 정의하는 타입이 추론하는 타입보다 더 정확할 때</strong>다. 당연히 타입스크립트가 더 똑똑한데 내가 맞다고 할 수 있을까 싶기도 하지만 런타임에서 결정되는 경우 타입 스크립트가 접근할 수 없고, 이미 정해져 있지만 타입이 반영되어있지 않은 경우에도 사용할 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#myButton'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  e<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> button <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>currentTarget <span class=\"token keyword\">as</span> HTMLButtonElement<span class=\"token punctuation\">;</span>\n  button<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>event의 currentTarget은 런타임에서 결정되므로 <code class=\"language-text\">null|HTMLButtonElement</code>중에서 <code class=\"language-text\">HTMLButtonElement</code>로 정해줘야 한다. </p>\n<p>최근 과제를 하면서 타입단언이 필요한 경우가 있었다. 영어로 오늘의 요일을 가져와야 할 때 <code class=\"language-text\">toLocaleDateString()</code>를 이용해서 사용하려 했지만 타입 정의가 <code class=\"language-text\">string</code>으로 되어있어 타입에러가 발생했다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/b2ae9033dee32bbc7cf3da09513d5de7/2ba58/%EB%8B%A8%EC%96%B8.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 14.117647058823529%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR42jWOCwrDMAxDc5glXewk8icdpYOuu/+lZlr2EEIYbDlBO7cQVyJiisC9UYtE4Xxpqc+cc/mzXJSlpP17vLfzOD/iBlN1tekwkcjTxcMtHAqoxLxj3HejLNn60rmrb7E0gNGqglYlQROf8YSiutBqbGB06q0+bnL+AWnrICQ1rRl7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='단언' title='' src='/static/b2ae9033dee32bbc7cf3da09513d5de7/ca1dc/%EB%8B%A8%EC%96%B8.png' srcset='/static/b2ae9033dee32bbc7cf3da09513d5de7/e7570/%EB%8B%A8%EC%96%B8.png 170w,\n/static/b2ae9033dee32bbc7cf3da09513d5de7/f46e7/%EB%8B%A8%EC%96%B8.png 340w,\n/static/b2ae9033dee32bbc7cf3da09513d5de7/ca1dc/%EB%8B%A8%EC%96%B8.png 680w,\n/static/b2ae9033dee32bbc7cf3da09513d5de7/02d09/%EB%8B%A8%EC%96%B8.png 1020w,\n/static/b2ae9033dee32bbc7cf3da09513d5de7/2ba58/%EB%8B%A8%EC%96%B8.png 1187w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>단언</figcaption>\n  </figure></p>\n<p>이점을 해결하기 위해서 고민을 하다가 정의 되어있는 타입보다 더 자세히 정해줘야 하는 상황이므로 타입단언을 사용해서 해결할 수 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> today <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> day <span class=\"token operator\">=</span> today<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleDateString</span><span class=\"token punctuation\">(</span><span class=\"token string\">'en'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  weekday<span class=\"token operator\">:</span> <span class=\"token string\">'short'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> EnKeys<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Days <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Mon<span class=\"token operator\">:</span> <span class=\"token string\">'월'</span><span class=\"token punctuation\">,</span>\n  Tue<span class=\"token operator\">:</span> <span class=\"token string\">'화'</span><span class=\"token punctuation\">,</span>\n  Wed<span class=\"token operator\">:</span> <span class=\"token string\">'수'</span><span class=\"token punctuation\">,</span>\n  Thu<span class=\"token operator\">:</span> <span class=\"token string\">'목'</span><span class=\"token punctuation\">,</span>\n  Fri<span class=\"token operator\">:</span> <span class=\"token string\">'금'</span><span class=\"token punctuation\">,</span>\n  Sat<span class=\"token operator\">:</span> <span class=\"token string\">'토'</span><span class=\"token punctuation\">,</span>\n  Sun<span class=\"token operator\">:</span> <span class=\"token string\">'일'</span><span class=\"token punctuation\">,</span>\n  Temp<span class=\"token operator\">:</span> <span class=\"token string\">'당일'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">EnKeys</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">keyof</span> <span class=\"token keyword\">typeof</span> Days<span class=\"token punctuation\">;</span></code></pre></div>\n<p>타입 단언을 항상 사용할 수 있는 것은 아니다. <code class=\"language-text\">A|B type</code>에서  A가 B의 부분 집합일 때만 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> body <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> body <span class=\"token keyword\">as</span> Person<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because neither type sufficiently overlaps with the other. // If this was intentional, convert the expression to 'unknown' first.</span>\n<span class=\"token keyword\">const</span> el <span class=\"token operator\">=</span> body <span class=\"token keyword\">as</span> unkown <span class=\"token keyword\">as</span> Person<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Person으로 타입 단언을 통해 타입을 정하려 했지만 body가 가지는 type인 <code class=\"language-text\">HTMLElement</code>와 <code class=\"language-text\">Person</code>은 서로 관계가 없기 때문에 에러가 발생한다. 하지만 <code class=\"language-text\">unknown</code>은 가장 큰 타입의 집합이므로 타입 단언이 가능한 것을 볼 수 있다.</p>\n<h1>마치며</h1>\n<p>타입 시스템을 공부하면서 타입을 <code class=\"language-text\">집합</code>이라는 시점으로 보니 좀 더 이해가 잘 되었다. 하지만 여전히 부족한 점이 많아서 여러 번 읽어야 할 부분이라 생각된다.</p>\n<p>[참조]\n<a href=\"https://search.shopping.naver.com/book/catalog/32473346832\">이펙티브 타입스크립트</a></p>","frontmatter":{"title":"TS study: 타입시스템 (1)","date":"January 07, 2023","tags":["Typescript"],"series":"Typescript"},"fields":{"slug":"/2023-01-07-타입시스템-1/","readingTime":{"minutes":15.85}}},"seriesList":{"edges":[{"node":{"id":"450c65d9-1adb-5355-86a6-38e29edf10f5","fields":{"slug":"/2023-01-02-타입스크립트란/"},"frontmatter":{"title":"TS study: 타입스크립트란"}}},{"node":{"id":"30f66428-af72-5c78-bf83-6adedb7f226b","fields":{"slug":"/2023-01-07-타입시스템-1/"},"frontmatter":{"title":"TS study: 타입시스템 (1)"}}},{"node":{"id":"8a0f9e55-e3e4-5418-a3a4-72acabfe070a","fields":{"slug":"/2023-01-10-타입시스템-2/"},"frontmatter":{"title":"TS study: 타입 시스템 (2)"}}},{"node":{"id":"34de2078-05c8-5c18-ad6f-b50da3d61695","fields":{"slug":"/2023-01-16-타입시스템-3/"},"frontmatter":{"title":"TS study: 타입 시스템 (3)"}}},{"node":{"id":"c3a5ecab-ca1d-5597-a321-d4b866d72a4c","fields":{"slug":"/2023-01-24-타입추론 (1)/"},"frontmatter":{"title":"TS study: 타입 추론(1)"}}},{"node":{"id":"526d83da-deee-5851-bd4d-6ed71de266f8","fields":{"slug":"/2023-10-16-the_Basics/"},"frontmatter":{"title":"Typescript: The Basics"}}},{"node":{"id":"b8ceb0c1-25a0-51d0-ab4e-86977a6e3643","fields":{"slug":"/2023-10-18-Narrowing/"},"frontmatter":{"title":"Typescript: Narrowing"}}},{"node":{"id":"dcf311da-09d1-555a-8978-5c8cbd09f3e4","fields":{"slug":"/2023-10-17-Everyday-Types/"},"frontmatter":{"title":"Typescript: EveryDay Types"}}},{"node":{"id":"8fe67159-cfd9-54bf-b268-55dd2267c9b3","fields":{"slug":"/2023-10-23-MoreOnFunctions/"},"frontmatter":{"title":"Typescript: More On Functions"}}},{"node":{"id":"9655a307-90e6-5c82-b302-c3a78bf59193","fields":{"slug":"/2023-10-31-Object-Types/"},"frontmatter":{"title":"Typescript: Object Types"}}},{"node":{"id":"888c4fe2-471c-5bb5-9d97-5ae433bbe9c8","fields":{"slug":"/2023-11-07-Generics/"},"frontmatter":{"title":"Typescript: Generics"}}},{"node":{"id":"afbe0b5e-070e-5dd2-9c94-200338d5851d","fields":{"slug":"/2023-11-16-keyof,typeof, indexed Access Types/"},"frontmatter":{"title":"Typescript: Keyof, TypeOf, Indexed"}}},{"node":{"id":"dab6e2de-2654-5d7c-be1b-8f852db76d25","fields":{"slug":"/2023-12-19-conditional-types/"},"frontmatter":{"title":"Typescript: Conditional Types"}}}]},"previous":{"fields":{"slug":"/2023-01-02-타입스크립트란/"},"frontmatter":{"title":"TS study: 타입스크립트란"}},"next":{"fields":{"slug":"/2023-01-10-타입시스템-2/"},"frontmatter":{"title":"TS study: 타입 시스템 (2)"}}},"pageContext":{"id":"30f66428-af72-5c78-bf83-6adedb7f226b","series":"Typescript","previousPostId":"450c65d9-1adb-5355-86a6-38e29edf10f5","nextPostId":"8a0f9e55-e3e4-5418-a3a4-72acabfe070a"}},"staticQueryHashes":[],"slicesMap":{}}